# language_name_wals:	German
# language_name_glotto:	German
# ISO_6393:	deu
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/de.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

@@image: 'figures/GNOME_desktop_Accessibility.png'; md5=76a706b0a4d4e184d7951fce04ccec59
a
ok
x
x
x
x
ok
x
x
x
x
x
x
x
@@image: 'figures/at-arch.png'; md5=e429cadb2e11d42d7437e999de175c3f
GNOME Barrierefreiheitshandbuch für Entwickler
Das GNOME Barrierefreiheitshandbuch ist für Entwickler bestimmt, die sicherstellen wollen, dass ihre Bemühungen dem größtmöglichen Anwenderkreis zu Gute kommen. Dieses Handbuch deckt auch die Erfordernisse des US-Rehabilitationsgesetzes 508 ab.
2008
Vincent Alexander
2001, 2002
Calum Benson, Brian Cameron, Bill Haneman, Padraig O'Briain, Sharon Snider
GNOME-Dokumentationsprojekt
Das vorliegende Dokument kann gemäß den Bedingungen der GNU Free Documentation License (GFDL), Version 1.1 oder jeder späteren, von der Free Software Foundation veröffentlichten Version ohne unveränderbare Abschnitte sowie ohne Texte auf dem vorderen und hinteren Buchdeckel kopiert, verteilt und/oder modifiziert werden. Eine Kopie der GFDL finden Sie unter diesem
Das vorliegende Handbuch ist Teil einer Reihe von GNOME-Handbüchern, die unter der GFDL verteilt werden. Wenn Sie dieses Handbuch separat verteilen möchten, können Sie dies tun, indem Sie dem Handbuch eine Kopie der Lizenz, wie in Abschnitt 6 der Lizenz beschrieben, hinzufügen.
Bei vielen der von Firmen zur Unterscheidung ihrer Produkte und Dienstleistungen verwendeten Namen handelt es sich um Marken. An den Stellen, an denen derartige Namen in einer GNOME-Dokumentation vorkommen und wenn die Mitglieder des GNOME-Dokumentationsprojekts über diese Marken informiert wurden, sind die Namen in Großbuchstaben oder mit großen Anfangsbuchstaben geschrieben.
DAS DOKUMENT WIRD »WIE VORLIEGEND« GELIEFERT, OHNE JEGLICHE GEWÄHRLEISTUNG, WEDER AUSDRÜCKLICH NOCH STILLSCHWEIGEND, EINSCHLIESSLICH, ABER NICHT BESCHRÄNKT AUF, GEWÄHRLEISTUNGEN, DASS DAS DOKUMENT ODER EINE MODIFIZIERTE VERSION DES DOKUMENTS FREI VON HANDELSÜBLICHEN FEHLERN UND FÜR EINEN BESTIMMTEN ZWECK GEEIGNET IST UND KEINE RECHTE DRITTER VERLETZT. JEGLICHES RISIKO IN BEZUG AUF DIE QUALITÄT, GENAUIGKEIT UND LEISTUNG DES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS TRAGEN SIE. SOLLTE SICH EIN DOKUMENT ODER EINE MODIFIZIERTE VERSION DAVON IN IRGENDEINER WEISE ALS FEHLERHAFT ERWEISEN, TRAGEN SIE (NICHT DER URSPRÜNGLICHE VERFASSER, AUTOR ODER EIN MITWIRKENDER) DIE KOSTEN FÜR JEGLICHE ERFORDERLICHE SERVICE-, REPARATUR- UND KORREKTURMASSNAHMEN: DIESE BESCHRÄNKUNG DER GEWÄHRLEISTUNG IST WESENTLICHER BESTANDTEIL DIESER LIZENZ. JEDE VERWENDUNG EINES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS UNTERLIEGT DIESER BESCHRÄNKUNG; UND
UNTER KEINEN UMSTÄNDEN UND GEMÄSS KEINER RECHTSLEHRE, WEDER AUFGRUND VON UNERLAUBTEN HANDLUNGEN (EINSCHLIESSLICH FAHRLÄSSIGKEIT), VERTRÄGEN ODER SONSTIGEM, KANN DER AUTOR, DER URSPRÜNGLICHE VERFASSER, EIN MITWIRKENDER ODER EIN VERTEILER DES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS ODER EIN LIEFERANT EINER DIESER PARTEIEN VON EINER PERSON FÜR DIREKTE, INDIREKTE, BESONDERE, ZUFÄLLIGE ODER ALS FOLGE AUFGETRETENE SCHÄDEN IRGENDEINER ART, EINSCHLIESSLICH, ABER NICHT BESCHRÄNKT AUF, SCHÄDEN DURCH GESCHÄFTSWERTVERLUSTE, ARBEITSAUSFÄLLE, COMPUTERAUSFÄLLE ODER FUNKTIONSSTÖRUNGEN ODER JEGLICHE ANDERE SCHÄDEN ODER VERLUSTE, DIE DURCH ODER IM ZUSAMMENHANG MIT DER VERWENDUNG DES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS ENTSTANDEN SIND, SELBST WENN DIESE PARTEI ÜBER MÖGLICHE SCHÄDEN INFORMIERT WORDEN SEIN SOLLTE, HAFTBAR GEMACHT WERDEN.
DAS DOKUMENT UND MODIFIZIERTE VERSIONEN DES DOKUMENTS WERDEN GEMÄSS DEN BEDINGUNGEN DER GNU FREE DOCUMENTATION LICENSE MIT DER FOLGENDEN VEREINBARUNG BEREITGESTELLT:
Vincent
Alexander
Calum
Benson
Brian
Cameron
Bill
Haneman
Padraig
O'Briain
Sharon
Snider
GNOME 2.24 Barrierefreiheitshandbuch für Entwickler V2.24.0
September 2008
Dieses Handbuch beschreibt Version 2.24 der GNOME-Arbeitsumgebung.
Rückmeldungen
Wenn Sie Fehler finden oder Vorschläge zur GNOME-Arbeitsumgebung oder diesem Handbuch haben, folgen Sie den Anweisungen auf der
Was ist Barrierefreiheit?
Barrierefreiheit bedeutet, Menschen mit Behinderungen zu helfen, an grundlegenden Lebensaktivitäten teilzunehmen. Das beinhaltet einer Arbeit nachzugehen und Dienste, Produkte und Informationen zu nutzen. GNOME enthält Bibliotheken und ein Framework, das es Menschen mit Behinderungen ermöglicht, alle Funktionen der GNOME-Benutzerumgebung zu verwenden.
Im Zusammenspiel mit gegebenenfalls notwendigen Hilfstechnologien wie Sprachausgaben, Bildschirmlesern oder alternativen Eingabegeräten wird Menschen mit vorübergehenden oder dauerhaften Behinderungen die Nutzung der GNOME-Arbeitsumgebung und deren Anwendungen ermöglicht. Hilfstechnologien können auch sinnvoll sein, wenn Rechner außerhalb von Zuhause oder Büro genutzt werden. Wenn Sie beispielsweise im Stau stehen, werden Sie vielleicht die Spracheingabe und -ausgabe für E-Mail-Nachrichten bevorzugen.
Hilfstechnologien empfangen Informationen von Anwendungen über die Schnittstelle des »Accessibility Toolkit (ATK)«, welches Sie im Modul »atk« des GNOME-Softwarebestandes finden. Da die Unterstützung für die Barrierefreiheits-Schnittstelle bereits in die GNOME-Widgets eingebaut ist, sollte Ihr GNOME-Programm Hilfstechnologien bereits grundlegend unterstützen, ohne dass Mehraufwand Ihrerseits notwendig wäre. Beispielsweise können Hilfstechnologien automatisch die Beschriftungen lesen, die Sie ohnehin in der Benutzeroberfläche festlegen(mit Hilfe von GTK-Funktionsaufrufen wie
Mit geringem Mehraufwand können Sie Ihr Programm besser auf die Zusammenarbeit mit Hilfstechnologien trimmen. Sie helfen in erster Linie bestimmten Benutzergruppen, machen Ihr Programm aber auch attraktiver für Endanwender im Verwaltungs- und Bildungssektor, wo barrierefreie Anwendungen oft gesetzlich vorgeschrieben sind.
Arten von Behinderungen
Allein in den USA leben schätzungsweise 30 Millionen Menschen, deren Fähigkeit zur Benutzung von Rechnern durch nicht barrierefreies Design eingeschränkt ist. Weltweit haben etwa 8% der Nutzer des World Wide Web irgendeine Art von Behinderung. Solche Behinderungen fallen in eine dieser Kategorien:





Wie funktioniert Barrierefreiheit in GNOME?
The Accessibility Toolkit (ATK) beschreibt eine Sammlung von Schnittstellen, die von GUI Komponenten implementiert werden müssen, um sie barrierefrei zu gestalten. Die Schnittstellen sind unabhängig vom Toolkit- - Implementierungen können für beliebige Widgets geschrieben sein, u.a. GTK, Motif und Qt.
Die Implementierungen für die GTK-Widgets befinden sich im GAIL-Modul (GNOME Accessibility Implementation Library), das man mit jeder GTK-Anwendung zur Laufzeit dynamisch laden kann. Einmal geladen, besitzen diese Programmteile, die Standard-GTK-Widgets benutzen, grundlegende Barrierefreiheit, ohne die Notwendigkeit, die Anwendung überhaupt verändern zu müssen. Wenn GAIL nicht geladen ist, werden GTK-Widgets eine standardmäßige Implementierung der Zugänglichkeit beinhalten, die im Wesentlichen keine Informationen zurück gibt, allerdings hält es sich nominell an die ATK API. Anwendungen, die Bonobo-Steuerungen benutzen, im Besonderen out-of-process, laden ebenso Code mit Unterstützung für Barrierefreiheit aus dem Modul libgail-gnome. Ob die Anwendungen in der GNOME-Arbeitsumgebung automatisch diese Barrierefreiheit-Supportbibliotheken laden, hängt vom Wert des
Die meisten Hilfstechnologien (AT), die auf anderen Arbeitsumgebungen laufen, fanden es wichtig, ein kompliziertes, vom Bildschirm losgelöstes Modell für Arbeitsflächenanwendungen zu unterhalten, das auf schnüffelnden Betriebssystem-Ereignissen aufbaute, sowie nicht unterstützte Betriebssystem- und Anwendungseigenschaften und APIs, und andere kaum portierbare Techniken. Dies führte zu einer »spröden« und höchst betriebssystem- und anwendungsspezifischen, manchmal sogar versionsspezifischen Unterstützung für Hilfstechnologien. Im Gegensatz dazu steht die GNOME-Arbeitsumgebung, auf der alle von Hilfstechnologien benötigten Informationen von den laufenden Anwendungen bereitgestellt werden. Diese laufen über das GNOME Accessibility Framework zu einem Toolkit-unabhängigen »Service Provider Interface« (SPI, etwa »Dienstleistungs-Anbieter-Schnittstelle«). Das SPI bietet Mittel für UNIX-basierte Hilfstechnologien, wie zum Beispiel Bildschirmleser und Bildschirmlupen, um Barrierefreiheitsinformationen für laufende Anwendungen über eine konsistente und stabile API zu erhalten und kann den Bedarf an vom Bildschirm losgelöste Modelle in vielen Fällen beseitigen. Unterstützung für Barrierefreihei für Anwendungen ist in Anwendungstoolkits über Toolkit-entprechende APIs »eingebaut« (z.B. ATK für die meisten nativen C-Anwendungen und die Java Accessibility API für Java Apps), und wird über die betreffenden »Brücken« in die allgemeine »AT-SPI«-Schnittstelle exportiert (siehe Diagramm).
Die GNOME Barrierefreiheits-Architektur
Diagramm der GNOME Barrierefreiheits-Architektur
Die in GNOME enthaltene Unterstützung für Barrierefreiheit drückt sich darin aus, dass Sie bei der Verwendung von GNOME-Repertoire-Widgets die Unterstützung für Hilfstechnologien praktisch »umsonst« erhalten, sofern die Widgets nicht auf unübliche Weise verwendet werden, was zu Konflikten in der eingebauten Unterstützung führen kann.
Ein GTK+/GNOME-Widget ist barrierefrei, wenn dessen Benutzung den allgemeinen Richtlinien zur Barrierefreiheit in diesem Dokument folgt, und es die verwendete ATK-Oberfläche seiner Rolle in der Benutzeroberfläche umsetzt. ATK-Umsetzungen werden für die Standard-GNOME-Toolkit-Widgets (d.h. nicht veraltete GTK+- und GNOME-Widgets) bereit gestellt, und in vielen Fällen erben neue Widgets passende Unterstützung für Barrierefreiheit, welche sich trivial von existierenden GTK+- oder GNOME-Widgets ableiten.
Wenn Ihr Programm angepasste Widgets verwendet, müssen Sie eventuell ein wenig Arbeit leisten, um diese Widget-Eigenschaften Hilfstechnologien zugänglich zu machen. Lesen Sie auch
Schnelleinstieg für Entwickler
Hier einige übliche Einstiegspunkte:
Wie kann ich überprüfen, ob meine Anwendung barrierefrei ist oder nicht?
Wo lauern die häufigsten Fallen?
Die
Wie führe ich allgemeine ATK-Angelegenheiten aus?
Eine gekürzte Liste häufiger ATK-Aufrufe finden Sie
Wie führe ich komplexere ATK Angelegenheiten aus?
Einführung in ATK, AT-SPI, GAIL und GTK+
ATK ist das Toolkit, welches GNOME einsetzt, um Barrierefreiheit für Benutzer zu schaffen, welche eine Zusatzunterstützung brauchen, um ihre Rechner vollständig nutzen zu können. ATK wird von Werkzeugen wie Bildschirmleser, Lupen und Eingabegeräte verwendet, um eine gute Interaktion mit der Arbeitsumgebung mittels alternativer Wege zu schaffen. Lesen Sie auch
Eine GNOME-Anwendung barrierefrei gestalten - Überblick
Wenn ihr Programm nur Standard-GTK-Widgets nutzt, werden Sie vermutlich wenig bis gar nichts tun müssen, um Ihr Programm (einigermaßen) barrierefrei zu gestalten. Aber Sie sollten nach Objekten in Ihrem GUI schauen, welche keine Text-Beschreibung haben, welche mit ihnen verknüpft ist, wie z.B. grafische Knöpfe oder Statusanzeigen, die keine Aufschriften oder Mini-Hilfen haben.
Sie könnten vielleicht auch die bereitgestellten Standardbeschreibungen für einige Widgets verbessern, und sie auf den Widget-spezifischen Zweck Ihres Programms zuschneiden. Sie sollten Textbeschreibungen für diese Widgets mit dem geeigneten ATK-Funktionsaufruf hinzufügen oder ändern, so dass Hilfstechnologien dem Nutzer deren Zweck oder Status beschreiben können. Lesen Sie dazu auch
Wenn Ihr Programm angepasste Widgets verwendet, sollten Sie etwas dafür tun, diese Widget-Eigenschaften den Hilfstechnologien nutzbar zu machen. Lesen Sie auch
Code-Richtlinien zur Unterstützung der Barrierefreiheit
Bereitstellung einer Accessible-Beschreibung für einen GtkButton
{
 AtkObject *obj;
 obj = gtk_widget_get_accessible(button);
 atk_object_set_description(obj,_("Closes the window"));
}
Verwenden Sie
Falls verschiedene Komponenten eine logische Gruppe bilden, versuchen Sie, diese in einem Container unterzubringen.
Beziehen eines GtkLabel auf ein GtkWidget
{
 GtkWidget *widget;
 GtkLabel *label;

 AtkObject *atk_widget, *atk_label;
 AtkRelationSet *relation_set;
 AtkRelation *relation;
 AtkObject *targets[1];

 atk_widget = gtk_widget_get_accessible(widget);
 atk_label = gtk_widget_get_accessible (GTK_WIDGET(label));

 relation_set = atk_object_ref_relation_set (atk_label);
 targets[0] = atk_widget;

 relation = atk_relation_new(targets,1, ATK_RELATION_LABEL_FOR);
 atk_relation_set_add(relation_set,relation);
 g_object_unref(G_OBJECT(relation));
}
Falls Sie ein benutzerdefiniertes Widget erstellen, sollten Sie sicherstellen, dass es barrierefrei ist. Benutzerdefinierte Komponenten, die von anderen GTK-Widgets abstammen, erben die notwendigen Barrierefreiheits-Informationen. Weitere Informationen hierzu finden Sie in
Die Barrierefreiheits-API
Nachfolgend finden Sie einige grundlegende API-Aufrufe, die Sie in Ihrer Anwendung nutzen können, um das reibungslose Zusammenwirken mit Hilfstechnologien sicher zu stellen. Die gesamte Barrierefreiheits-API ist erweiterbar, so dass Sie beispielsweise Ihre eigenen benutzerdefinierten Accessible-Widgets erstellen können.
Häufig genutzte API-Aufrufe von ATK
API
Beschreibung
AtkObject* gtk_widget_get_accessible (GtkWidget*)
Gibt das Accessible-Objekt zurück, welches das angegebene GTK-Widget für eine Hilfstechnologie beschreibt.
void atk_object_set_name (AtkObject*, const gchar*)
Legt den Namen des Accessible-Objekts fest. Wenn beispielsweise das Objekt ein grafischer Knopf ist, der beim Anklicken die Anwendung beeendet, könnte der Name »Quit« lauten.
void atk_object_set_description (AtkObject*, const gchar*)
Legt die Beschreibung in Textform für das Accessble-Objekt fest. Wenn beispielsweise das Objekt ein grafischer »Close«-Knopf ist, dann könnte die Beschreibung »Closes the window« lauten.
AtkRelation* atk_relation_new (AtkObject**, gint, AtkRelationType)
Erstellt einen neuen Bezug zwischen dem angegebenen Schlüssel und der angegebenen Liste der Zielobjekte. Eine solche Beziehung informiert normalerweise die Hilfstechnologie darüber, dass ein Widget in einem bestimmten Verhältnis zu einem anderen steht. Beispielsweise ist ein bestimmtes GtkLabel eine Beschriftung für ein GtkTreeView im gleichen Fenster.
void atk_image_set_description (AtkImage*, const gchar*)
Legt die Beschreibung in Textform für das Accessible-Bildobjekt fest. Wenn das Objekzt beispielsweise ein Vorschaubild auf eine virtuelle Arbeitsfläche in einem Panel-Applet ist, dann könnte die Beschreibung »Image showing window arrangement on desktop 1« lauten.
Beispiele für die Nutzung der Barrierefreiheits-API
Wie bereits erwähnt, sollte der Aufwand gering sein, wenn Sie Ihre Anwendung mit Hilfe der Gtk-Widgetsammlung oder jeder anderen die ATK-Schnittstelle nutzenden Widgetsammlung barrierefrei gestalten. Dies sind die zwei häufigsten Aufgaben in diesem Fall:
Bereitstellung von Beschreibungen von Bedienelementen mit
Festlegen der barrierefreien Beschreibung für einen Knopf
{
 AtkObject *obj;
 obj = gtk_widget_get_accessible(button);
 atk_object_set_description(obj,_("Opens Preferences dialog"));
}
Angeben von Beziehungen zwischen unüblichen Widget-Gruppierungen mittels
Festlegen einer barrierefreien Beziehung zwischen zwei Bedienelementen
{
 GtkWidget *widget;
 GtkLabel *label;

 AtkObject *atk_widget, *atk_label;
 AtkRelationSet *relation_set;
 AtkRelation *relation;
 AtkObject *targets[1];

 atk_widget = gtk_widget_get_accessible (widget);
 atk_label = gtk_widget_get_accessible (GTK_WIDGET(label));

 relation_set = atk_object_ref_relation_set (atk_label);
 targets[0] = atk_widget;

 relation = atk_relation_new(targets,1, ATK_RELATION_LABEL_FOR);
 atk_relation_set_add(relation_set,relation);
 g_object_unref(G_OBJECT(relation));
}
GTK-Module
setenv GTK_MODULES "libgail:libtestprops"
Alle GTK-Module haben eine
Zugänglichkeitsinformationen einer Anwendung sammeln
atk_add_focus_tracker (_my_focus_tracker);
wobei
void _my_focus_tracker (AtkObject *aobject);
Richte einen globalen Ereignislistener ein, mit atk_add_global_event_listener():
mouse_watcher_focus_id = atk_add_global_event_listener(_my_global_listener,"Gtk:GtkWidget:enter_notify_event");
AtkObject *root_obj = atk_get_root();
ATK_IS_ACTION(atkobj)
ATK_IS_COMPONENT(atkobj)
etc. (es gibt eins für jede Schnittstelle)
Einen ATK Nachrichtenhandler einrichten
table_column_inserted_id = g_signal_connect_closure_by_id(my_atk_obj, 
g_signal_lookup("column_inserted", G_OBJECT_TYPE(my_atk_obj)),0,g_cclosure_new(G_CALLBACK (_my_table_column_inserted_func),NULL,NULL), FALSE);
child_added_id = g_signal_connect_closure (my_atk_obj,"children_changed::add", g_cclosure_new (G_CALLBACK(_my_children_changed_func),NULL,NULL),FALSE);
Implementieren eines ATK-Objekts
default_registry = atk_get_default_registry();
atk_registry_set_factory_type (default_registry, GTK_TYPE_MYTYPE, MYATKIMP_TYPE_MYTYPE_FACTORY);
ATK-Implementierung für ein bestimmtes Objekt
static const GInterfaceInfo atk_text_info = 
{ 
 (GInterfaceInitFunc) atk_text_interface_init, 
 (GInterfaceFinalizeFunc) NULL, 
 NULL 
}; 

g_type_add_interface_static (type, ATK_TYPE_TEXT, 
 &atk_text_info);
void atk_text_interface_init (AtkTextIface *iface);
void 
atk_text_interface_init (AtkTextIface *iface) 
{ 
 g_return_if_fail (iface != NULL); 
 iface-gt;get_text = myatkimp_mytype_get_text; 
 iface-gt;get_character_at_offset = myatkimp_mytype_get_character_at_offset; 
 ... 
}

GType 
myatkimp_mytype_get_type (void) 
{ 
 static GType type = 0; 

 if (!type) 
 { 
 static const GTypeInfo tinfo = 
 { 
 sizeof (GailLabelClass), 
 (GBaseInitFunc) NULL, /* base init */ 
 (GBaseFinalizeFunc) NULL, /* base finalize */
 (GClassInitFunc) myatkimp_mytype_class_init, /* class init */ 
 (GClassFinalizeFunc) NULL, /* class finalize */ 
 NULL, /* class data */ 
 sizeof (GailLabel), /* instance size */ 
 0, /* nb preallocs */ 
 (GInstanceInitFunc) myatkimp_mytype_instance_init, /* instance init */ 
 NULL /* value table */ 
 }; 

 /* Set up atk_text_info structure used below */ 
 static const GInterfaceInfo atk_text_info = 
 { 
 (GInterfaceInitFunc) atk_text_interface_init, 
 (GInterfaceFinalizeFunc) NULL, 
 NULL 
 }; 

 /* Set up typename and specify parent type */ 
 type = g_type_register_static (MYATKIMP_MYPARENTTYPE, 
 "MyatkimpMytype", &tinfo, 0); 

 /* This class implements interface ATK_TYPE_TEXT */ 
 g_type_add_interface_static (type, ATK_TYPE_TEXT, 
 &atk_text_info); 
 } 
 return type; 
}
Initialisierung von Klassen und Instanzen
myatkimp_mytype_class_init (GailLabelClass *klass) 
{ 
 AtkObjectClass *class = ATK_OBJECT_CLASS (klass); 
 class-gt;get_name = myatkimp_mytype_get_name; 
}
Benötigt eine
static ParentObjectType *parent_class = NULL; 

myatkimp_mytype_class_init (GailLabelClass *klass) 
{ 
 ParentObjectType *parent_class = (ParentObjectType*)klass; 

 /* 
 * Caching the parent_class is necessary if the init, 
 * notify_gtk, or finalize functions are set up. 
 */ 
 parent_class = g_type_class_ref (MYATKIMP_TYPE_PARENT); 

 parent_class-gt;init = myatkimp_mytype_widget_init; 
 parent_class-gt;notify_gtk = myatkimp_mytype_real_notify_gtk; 
 parent_class-gt;finalize = myatkimp_mytype_finalize; 
}
parent-gt;init
Hier ein Beispiel für beides:
Eine benutzerdefinierte
void 
gail_tree_view_widget_init (MyatkimpMytype *mytype, 
 GtkWidget *gtk_widget) 
{ 
 /* Make sure to call the parent's init function */ 
 parent_class-gt;init (widget, gtk_widget); 
 
 /* Cache a value in the ATK implementation */ 
 mytype-gt;cached_value = gtk_widget_function_call(); 

 /* Listen to a signal */ 
 gtk_signal_connect (GTK_OBJECT (gtk_widget), 
 "signal-type", 
 GTK_SIGNAL_FUNC (_myatkimp_mytype_signal_type), 
 NULL); 
}
parent-gt;notify_gtk
Eine benutzerdefinierte
void 
myatkimp_mytype_real_notify_gtk (GObject *obj, 
 GParamSpec *pspec) 
{ 
 GtkWidget *widget = GTK_WIDGET (obj); 
 AtkObject* atk_obj = gtk_widget_get_accessible (widget); 

 if (strcmp (pspec-gt;name, "property-of-interest") == 0) 
 { 
 /* Handle the property change. */ 
 } 
 else 
 { 
 parent_class-gt;notify_gtk (obj, pspec); 
 } 
}
parent-gt;finalize
Eine benutzerdefinierte
void 
myatkimp_mytype_finalize (GObject *object) 
{ 
 MyAtkimpMyType *my_type = MYATKIMP_MYTYPE (object); 

 g_object_unref (my_type-gt;cached_value); 
 G_OBJECT_CLASS (parent_class)-gt;finalize (object); 
}
Benutzerdefinierte Komponenten barrierefrei gestalten
Das Hinzufügen von ATK-Unterstützung zu Ihrem benutzerdefinierten Widget stellt die Zusammenarbeit mit der Barrierefreiheits-Infrastruktur sicher. Folgende grundlegende Schritte sind hierzu erforderlich:
Richtlinien für Benutzeroberflächen zur Unterstützung der Barrierefreiheit
Allgemein
Wir alle sind frustriert, wenn wir eine Funktion in einem Programm nicht finden können, oder wenn das Programm einen Fehler macht, weshalb es eine Zeit lang braucht, um wieder zum Normalzustand zurückzukehren, wenn das überhaupt geht. Wenn Sie eine Form dieser Fehler haben, werden sowohl der Aufwand als auch die verschwendete Zeit manchmal sehr hoch sein. Diesen Grundrichtlinien zu folgen, kann helfen, diese Situationen für alle Nutzer zu vermeiden.
Stellen Sie eine Rückgängig-Funktion für jede Aktion bereit, welche die Benutzerdaten oder die Anwendugseinstellungen beeinflusst. Falls möglich, sollten für Rückgängig- und Wiederherstellungsfunktionen mehrere Ebenen ermöglichen und eine Chronikansicht anbieten, die eine Vorschau auf rückgängig zu machende Aktionen enthält.
Stellen Sie Befehle zum Wiederherstellen von Standardeinstellungen bereit. Falls eine bestimmte Einstellung eine Anwendung für einen bestimmten Benutzer unbenutzbar machen könnte, beispielsweise durch eine viel zu kleine Schrift, dann kann eine Wiederherstellungsfunktion außerhalb der Anwendung sehr nützlich sein. Das kann zum Beispiel über einen entsprechenden Schalter in der Befehlszeile geschehen.
Verhindern Sie, dass der Benutzer das Falsche tut. Das ist insbesondere für Aktionen von Bedeutung, die zufällig geschehen können (z.B. durch Mausbedienung) oder die nicht ohne Weiteres rückgängig gemacht werden können (z.B. Überschreiben von Dateien). Stellen Sie Informationsdialoge bereit oder zwingen Sie den Benutzer, gefährliche Aktionen nur in einem bestimmten Modus auszuführen.
Überstrapazieren Sie das Gedächtnis des Benutzers nicht. Lassen Sie den Benutzer beispielsweise mehrere Dokumente gleichzeitig betrachten und stellen Sie eine Online-Hilfe oder andere Hilfeanweisungen zur Verfügung, während die beschriebene Prozedur ausgeführt wird. Ermöglichen Sie das Kopieren jeglicher angezeigter Informationen und das Einfügen an beliebigen Stellen, wo Daten eingegeben werden können.
Lassen Sie den Benutzer keine Speichermedien einlegen. Abhängig von der jeweiligen Behinderung kann es schwierig sein, ein Medium physikalisch betrachtet einzulegen oder zu wechseln, oder das korrekte Medium richtig zu identifizieren. Falls Ihre Anwendung von CD-ROM installiert wird, sollten Sie dem Benutzer die Möglichkeit bieten, alle benötigten Dateien direkt auf die Festplatte zu kopieren.
Vergraben Sie häufig genutzte Funktionen nicht tief in einer Menüstruktur. Egal ob Sie eine Maus, die Tastatur oder ein anderes Eingabegerät verwenden, sollten tief ineinander verschachtelte Einträge besser vermieden werden. Da sich der Benutzer daran erinnern muss, wo diese zu finden sind, ist der Zugriff zu schwierig und erfordert zu viel Zeit.
Führen Sie den Benutzer nicht durch unnötige Schritte. Einrichtungsassistenten können zwar für Benutzer hilfreich sein, die Schwierigkeiten haben, mit vielen Optionen gleichzeitig umzugehen, aber andere wiederum möchten die Zeit oder die Anzahl der Tastenbedienungen minimieren. Solche Benutzer profitieren davon, nicht benötigte Schritte überspringen und direkt zum nächsten gewünschten Schritt gehen zu können. Stellen Sie in Ihrem Einrichtungsassistenten einen
Tastatursteuerung
Eine gut durchdachte Tastaturschnittstelle spielt eine Schlüsselrolle beim entwerfen barrierefreier Software. Blinde Benutzer können wesentlich effektiver mit der Tastatur navigieren, weil die Nutzung der Maus die visuelle Rückmeldung des Ortes des Mauszeigers erfordert. Auch Körperbehinderungen können der Grund dafür sein, dass ein Benutzer erfolgreich mit der Maus navigieren kann, da dies von der Feinmotorik abhängt.
Es ist daher wichtig, dass alle Mausaktionen auch über die Tastatur erreichbar sind, einschließlich des Zugriffs auf alle Werkzeugleisten, Menüs, Verknüpfungen und Knöpfe. Jede von Ihrer Anwendung bereitgestellte Funktion sollte auch ausschließlich mit der Tastatur erreichbar sein. Legen Sie Ihre Maus besser zur Seite, wenn Sie Ihre Anwendung testen!
Maus-Interaktion
Beispiele für Maus-Interaktionen
Beispiel eines »no-drop«-Zeigers aus CDE/Motif
Beispiel für eine »invalid drop target«-Zeigerform
Grafische Elemente
Schriften und Text
Beispiele für Schriften und Text
Einstellfeld mit Beschriftung an der linken Seite
Farbe und Kontrast
Stellen Sie sicher, dass Ihre Anwendung nicht ein bestimmtes Thema mit hohem Kontrast benötigt. Testen Sie sie mit verschiedenen Themen mit hohem Kontrast, um sicher zu stellen, dass Ihre Anwendung die Einstellungen respektiert.
Beispiele für Farbe und Kontrast
Beispiel für die redundante Farbverwendung
Beispiel für die Darstellung von Aktienkursen nur mit Farben
Diese Anzeige könnte farbenblinden Benutzern mit einer Rot-Grün-Schwäche Probleme bereiten. Diese Art der Farbenblindheit betrifft in einigen Teilen der Welt ein Siebtel der Männer. Durch den mangelnden Kontrast zwischen dem roten Text und dem schwarzen Hintergrund ist die Lesbarkeit auch für Sehbehinderte beeinträchtigt, selbst unter Zuhilfenahme einer Bildschirmlupe.
Beispiel für die Darstellung von Aktienkursen mit sowohl Farben als auch Pfeilen
Einstellungen
Vergrößerung
Viele Benutzer profitieren von der Vergrößerung von Text und Grafiken, selbst jene Benutzer ohne Sehbehinderung. Ohne Vergrößerung könnte ein sehbehinderter Benutzer möglicherweise überhaupt nicht in der Lage sein, Ihr Programm zu verwenden.
Geben Sie dem Benutzer die Möglichkeit, den Arbeitsbereich zu vergrößern.
Ermöglichen Sie, die Größe des Arbeitsbereiches Ihrer Anwendung zu verändern. Benutzer sollten den Arbeitsbereich auf 150-400% oder mehr vergrößern können. Testen sie Ihre Anwendung, um zu überprüfen, dass die Darstellung des betrachteten Objekts nicht durch die Vergrößerungseinstellung beeinträchtigt wird.
Klänge
Sowohl Leute mit eingeschränktem Hörvermögen als auch Benutzer, die Klänge auf Ihrem Rechner generell abgeschaltet haben, dürften nicht begeistert sein, wenn Ihre Anwendung Informationen allgemein über Klangausgaben bereitstellt. Stellen Sie sicher, dass der Benutzer in der Lage ist, als Klang ausgegebene Informationen auch auf anderen Wegen zu erhalten.
Nehmen Sie nicht einfach an, dass ein Benutzer Klänge hören will. Das betrifft sowohl Benutzer mit defekten Soundkarten als auch Hörgeschädigte!
Betrachten Sie Klänge nicht als den einzigen Weg, Informationen bereitzustellen. Geben Sie dem Benutzer die Möglichkeit, alle Klanginformationen auch visuell darstellen zu können. Dies beinhaltet geschlossene Beschriftungen und Textausgaben von allen wichtigen gesprochenen Soundclips.
Ermöglichen Sie dem Benutzer, die Frequenz und die Lautstärke alle Warntöne und sonstigen Klänge einzustellen. Die Klänge sollten auch vollständig abschaltbar sein.
Animation
Sparsam verwendet, können Animationen durchaus nützlich zur Darstellung wichtiger Informationen in Ihrer Anwendung sein - und sie können natürlich auch cool aussehen. Allerdings können sie für bestimmte Benutzer auch problematisch sein, daher sollten Sie eine Möglichkeit vorsehen, die Animationen abzuschalten.
Verwenden Sie keine blitzenden oder blinkenden Elemente mit einer Frequenz oberhalb von 2 Hz und unterhalb von 55 Hz. Dies betrifft sowohl Text als auch jegliche grafische Objekte. Alles innerhalb dieses Frequenzbereichs kann Benutzern mit Sehbehinderungen Probleme bereiten. Denken Sie daran, dass es keine »sichere« Frequenz gibt. Falls Blinken von essenzieller Bedeutung ist, dann sollten Sie die Blinkfrequenz des Systemzeigers verwenden (die an sich schon konfigurierbar ist) oder den Benutzern ermöglichen, eine eigene Frequenz festzulegen.
Lassen Sie keine größeren Bereiche des Bildschirms blitzen oder blinken. Kleine Bereiche verursachen weit weniger Probleme für Benutzer mit Sehbehinderungen.
Tastaturfokus
Beispiele für den Tastaturfokus
Dokumentation
Testen
Dieser Abschnitt beschreibt eine Anzahl von Tests, die Sie manuell in einer Anwendung ausführen können, um deren Barrierefreiheit zu überprüfen. Das erfolgreiche Durchlaufen dieser Tests gewährleistet zwar nicht zwangsläufig, dass die Anwendung vollständig barrierefrei ist. Aber falls Ihre Anwendung an einem dieser Tests scheitert, dann sind weitere Aktionen notwendig, um die Barrierefreiheit zu verbessern.
Die folgenden Tastaturoperationen sollten überprüft werden. Benutzen Sie in keinem Teil dieses Tests die Maus.
Bewegen Sie den Fokus durch alle Menüleisten in der Anwendung und verwenden Sie dazu nur Tastaturbefehle.
Überprüfen Sie, ob:
kontextabhängige Menüs korrekt dargestellt werden.
jegliche in der Werkzeugleiste sichtbare Funktionen auch über die Tastatur erreichbar sind.
Sie jedes Bedienelement im Client-Bereich der Anwendung und in Dialogfeldern ansprechen können.
Text und Objekte im Client-Bereich ausgewählt werden können.
alle Tastenkombinationen und Schnellzugriffe so funktionieren, wie gewünscht.
Testen Sie Ihre Anwendung mit einem Bildschrimleser und überprüfen Sie, ob:
Beschriftung und Text korrekt gelesen werden, einschließlich in Menüs und Werkzeugleisten.
Objektinformationen korrekt gelesen werden.
Indikator für den visuellen Fokus
Überprüfen Sie, ob der Indikator für den visuellen Fokus beim Bewegen durch die Objekte einfach zu erkennen ist.
Die Navigation durch die Software und deren Menüs sollte deutlich sichtbar sein, wenn sich der Fokus verändert.
Überprüfen Sie, ob der Bildschirmleser den Indikator für den visuellen Fokus verfolgt, wenn Sie eine Tastatur verwenden.
Führen Sie ein Programm zur Vergrößerung der Bildschirminhalte aus (eine Bildschirmlupe), um sicherzustellen, dass die Bildschirmlupe den Indikator für den visuellen Fokus verfolgt, wenn Sie die Tastatur oder die Maus verwenden.
Ändern Sie die Schrift in der Anwendung und überprüfen Sie, ob die Einstellungen angewendet werden.
Testen Sie die Anwendung, indem Sie die die Farben ändern und überprüfen, ob die Einstellungen wirksam werden.
Falls Vergrößerung verfügbar ist, dann überprüfen Sie die Schrift, die Farbe und die Größe der Vergrößerungsoption.
Geben Sie Bildschirmfotos auf einem einfarbigen Drucker aus und überprüfen Sie, ob alle Informationen sichtbar sind.
Testen Sie Anwendungen in einer schwarzweißen Darstellung mit hohem Kontrast und überprüfen Sie, ob alle Informationen korrekt vermittelt werden.
Testen Sie Ihre Anwendung daraufhin, ob sie mindestens drei Farbkombinationen als Thema unterstützt und dass Schemata in hohem Kontrast verfügbar sind, beispielsweise weiß auf schwarz oder gelb auf blau.
Schalten Sie im GNOME-Kontrollzentrum die Einstellungen zu hohem Kontrast ein und überprüfen Sie, ob Ihre Anwendung diese Einstellungen akzeptiert.
Testen Sie verschiedene Themen, um sicherzustellen, dass die Software mit allen verfügbaren Einstellungen funbktioniert.
Es sollte in der Anwendung eine Option geben, um akustische Benachrichtigungen visuell darstellen zu lassen.
Überprüfen Sie, ob die Ausgabe von Klängen korrekt funktioniert, indem Sie diese im GNOME-Kontrollzentrum einschalten und dann folgende Aktionen ausführen:
Führen Sie eine Aktion aus, durch die eine akustische Warnung ausgelöst wird, und überprüfen Sie, ob die Anwendung wie erwartet funktioniert.
Stellen Sie sicher, dass Ihre Anwendung korrekt reagiert, wenn Sie die Lautstärke erhöhen oder verringern.
Überprüfen Sie, ob Warnmeldungen auch in einer lauteren Umgebung korrekt verstanden werden können.
Stellen Sie sicher, dass eine Option zum Abschalten von Animationen zur Verfügung steht und diese wie erwartet funktioniert.
Schalten Sie die Animationen ab. Überprüfen Sie, ob alle Informationen immer noch korrekt vermittelt werden können.
Testen Sie alle Meldungen, um zu überprüfen, ob der Benutzer ausreichend benachrichtigt werden kann, bevor eine Meldung verschwindet, mit der Option anzugeben, dass mehr Zeit notwendig ist.
Stellen Sie sicher, dass eine Option zum Einstellen der Antwortzeit verfügbar ist und diese wie erwartet funktioniert.
Testen Sie Dokumentation im ASCII-Format mit einem Bildschirmleser, um sicherzustellen, dass diese klar und präzise von Hilfstechnologien gelesen werden kann.
Testen Sie HTML-Anwendungen mit einem Webbrowser und Bildschirmleser, um zu überprüfen, ob die Dokumentation barrierefrei ist und durch Hilfstechnologien verarbeitet werden kann.
Hinweis: Es gibt Richtlinien für Barrierefreiheit im Web auf
Überprüfen sie, ob in der Dokumentation folgende Informationen enthalten sind:
Falls eine Aktion für die Maus dokumentiert ist, stellen Sie bitte sicher, dass eine Alternative für die Tastatur bereitsteht.
Checkliste für Benutzeroberflächen
Dieser Abschnitt fasst die in den
Beim Testen einer Anwendung auf Barrierefreiheit sollten Sie alle Einträge in dieser Liste abarbeiten. Beachten Sie dabei, ob Ihre Anwendung jeden dieser Tests besteht oder scheitert, oder ob der jeweilige Test auf Ihr Programm nicht anwendbar ist.
Checkliste der allgemeinen Prinzipien
GP
Allgemeine Prinzipien
GP.1
Jede Aktion, welche die Benutzerdaten oder Anwendungseinstellungen beeinflusst, kann rückgängig gemacht werden.
GP.2
Alle Anwendungseinstellungen können auf ihre Standardwerte zurückgesetzt werden, ohne dass der Benutzer wissen muss, wie diese Einstellungen aussehen müssen.
GP.3
Nach der Installation kann die Anwendung benutzt werden, ohne dass der Benutzer eine CD oder einen sonstigen Datenträger einlegen muss.
GP.4
Die am häufigsten benutzten Funktionen befinden sich in der obersten Ebene der Menüstruktur.
Checkliste für die Tastaturnavigation
KN
KN.1
Effizienter Tastaturzugriff ist auf alle Funktionsmerkmale der Anwendung möglich.
KN.2
Alle Fenster haben einen logischen Aufbau für die Tastaturnavigation.
KN.3
Die korrekte Reiteranrodnung wird für Bedienelemente verwendet, deren Aktivierungsstatus von Ankreuzfeldern, Radioknöpfen oder Umschalttasten abhängig ist.
KN.4
Der Tastaturzugriff auf anwendungsspezifische Funktionen überschreibt keine vorhandenen Barrierefreiheits-Funktionsmerkmale des Systems.
KN.5
Die Anwendung stellt eine oder mehrere Methoden zur Ausführung von Tastaturaufgaben bereit, wo immer es möglich ist.
KN.6
Wo immer möglich, gibt es alternative Tastenkombinationen.
KN.7
Es muss nicht umständlich nach häufig benutzten Tastaturoperationen gesucht werden
KN.8
Die Anwendung erwartet keine wiederholten, gleichzeitigen Tastendrücke.
KN.9
Die Anwendung stellt für alle Mausfunktionen entsprechende Bedienungsmöglichkeiten für die Tastatur bereit.
KN.10
Jedes Objekt, das mit der Maus ausgewählt werden kann, lässt sich auch nur mit der Tastatur auswählen.
KN.11
Jedes Objekt, das mit der Maus verschoben oder dessen Größe geändert werden kann, lässt sich ebenso auch nur mit der Tastatur verschieben oder dessen Größe ändern.
KN.12
Die Anwendung nutzt keine generellen Navigationsfunktionen oder Auslöseroperationen.
KN.13
Alle tastaturbezogenen Menüs, Fenster und Minihilfen erscheinen nahe des Objekts, auf welches sie sich beziehen.
Checkliste zur Maus-Interaktion
MI
MI.1
rechten
mittleren
Keine Operation ist abhängig von der Bedienung der
MI.2
Alle Mausaktionen können abgebrochen werden, bevor sie abgeschlossen werden.
MI.3
Bei Zieh- und Ablegevorgängen wird visuelle Rückmeldung bereitgestellt
MI.4
Der Mauszeiger gerät nie unter unmittelbare Kontrolle der Anwendung und seine Bewegungsfreiheit wird nie auf den Bidschirmbereich der Anwendung beschränkt.
Checkliste für grafische Elemente
GE
GE.1
Es gibt keine fest codierten grafischen Attribute wie »line«, »border« oder »shadow thickness«.
GE.2
Alle mehrfarbigen grafischen Elemente können auch nach Möglichkeit einfarbig dargestellt werden.
GE.3
Alle interaktiven Elemente der grafischen Oberfläche sind eindeutig von statischen Elementen unterscheidbar.
GE.4
Eine Option zum Verbergen eher unwichtiger grafischer Elemente wird bereitgestellt.
Checkliste für Schriften und Text
FT
FT.1
Schriftstile und -größen sind nicht fest codiert.
FT.2
Eine Option zum Abschalten grafischer Texthintergründe steht zur Verfügung.
FT.3
Alle Bezeichnungen ergeben auch außerhalb des Kontextes einen Sinn.
FT.4
Beschriftungen werden innerhalb eines Fensters nicht mehrfach verwendet.
FT.5
Die Positionierung von Beschriftungen ist innerhalb der Anwendung konsistent.
FT.6
Alle statischen Textbschriftungen, die andere Steuerungen bezeichnen, enden mit einem Doppelpunkt.
FT.7
Statische Textbeschriftungen, die andere Steuerungen bezeichnen, stehen unmittelbar vor diesen Steuerungen in der Anordnung.
FT.8
Eine Alternative zu »WYSIWIG« steht zur Verfügung. Dies wäre zum Beispiel die Festlegung verschiedener Schriften für Bildschirm und Drucker in einem Texteditor.
Checkliste für Farben und Kontrast
CC
CC.1
Anwendungsfarben sind nicht fest kodiert, sondern werden entweder vom aktuellen Desktop-Thema oder von der Anwendungseinstellung gezeichnet.
CC.2
Farben werden lediglich als Erweiterung der Darstellung verwendet und nicht als einzige Möglichkeit für die Darstellung von Informationen oder Aktionen.
CC.3
Die Anwendung unterstützt alle Themen und Einstellungen mit hohem Kontrast.
CC.4
Die Software ist nicht von einem bestimmten Thema mit hohem Kontrast abhängig.
Checkliste zur Vergrößerung
MG
MG.1
Die Anwendung verfügt über eine Funktion zur Vergrößerung des Arbeitsbereiches.
MG.2
Die Anwendung stellt eine Option zur Skalierung des Arbeitsbereiches zur Verfügung.
MG.3
Die Funktionalität der Anwendung wird durch Vergrößerung oder Skalierung nicht beeinträchtigt.
Checkliste zu Klängen
AU
AU.1
Klänge werden nicht als einzige Möglichkeit für die Darstellung von Informationen oder Aktionen verwendet.
AU.2
Der Benutzer kann die Frequenz und die Lautstärke aller Klänge und Warntöne einstellen.
Checkliste zu Animationen
AN
AN.1
Es gibt keine blitzenden oder blinkenden Elemente mit einer Frequenz zwischen 2 Hz und 55 Hz.
AN.2
Jedes Blitzen oder Blinken ist auf kleine Bereiche des Bildschirms beschränkt.
AN.3
Falls Animation verwendet wird, dann ist eine Option zum Abschalten verfügbar, bereits bevor die Animation erstmals benutzt wird.
Checkliste für den Tastaturfokus
KF
KF.1
Wenn ein Fenster geöffnet wird, dann liegt der Fokus zunächst auf dem am häufigsten benutzten Bedienelement.
KF.2
Die aktuelle Position des Fokus wird jederzeit klar und deutlich dargestellt.
KF.3
Der Eingabefokus wird nicht in mehreren Fenstern gleichzeitig angezeigt.
KF.4
Es werden geeignete akustische oder visuelle Rückmeldungen bereitgestellt, wenn der Benutzer versucht, an das Ende oder den Anfang einer Gruppe aufeinander bezogener Elemente zu navigieren.
KF.5
Das Standardsignal für akustische oder visuelle Warnungen wird abgespielt, wenn der Benutzer eine in jeweiligen Fall nicht anwendbare Taste drückt.
KF.6
Es gibt genügend Audio-Informationen für den visuellen Fokus, über die dem Benutzer mitgeteilt werden kann, was als Nächstes zu tun ist.
KF.7
Bei der Nutzung von Hilfstechnologien, wie einem Bildschirmleser oder einer Braille-Zeile, ermittelt das Programm die Position und den Inhalt des visuellen Fokus-Indikators.
Timing-Checkliste
TM
TM.1
Es gibt keine fest codierten Zeitüberschreitungen oder sonstigen zeitbasierten Funktionsmerkmale in der Anwendung.
TM.2
Das Anzeigen oder Verbergen wichtiger Informationen wird durch die Bewegungen des Mauszeigers nicht beeinflusst.
Dokumentations-Checkliste
DC
DC.1
Jegliche Dokumentaiton liegt in einem barrierefreien Format vor, mit einer alternativen Beschreibung in Textform für alle Abbildungen und Diagramme.
DC.2
Die Dokumentation enthält einen Abschnitt, in dem die Barrierefreiheits-Funktionsmerkmale der Anwendung beschrieben werden.
GOK (GNOME-Bildschirmtastatur)
Anmelden an der GNOME-Arbeitsumgebung
Ausführen von
Starten Ihrer Anwendung
Accerciser
Accerciser und die GNOME-Barrierefreiheits-Architektur


Mario Blättermann <mariobl\@gnome\.org>, 2009
a
a
Schnelleinführung in die Optimierung von GNOME-Programmen
Dies ist eine kurze Einführung in die Optimierung und behandelt sowohl das Wie als auch das Warum. Details zu individuellen Werkzeugen verschieben wir auf spätere Artikel, eine Sammlung aus Hinweisen und Tricks ist jedoch enthalten.
Was optimieren wir?
Sie sollten bei der Optimierung für GNOME zunächst eines bedenken: Wir versuchen nicht, das Programm zu verbessern, sondern wir versuchen, die Benutzer glücklicher zu machen.
Bessere Programme machen die Benutzer glücklicher, aber es gibt Verbesserungsmöglichkeiten, die sie viel glücklicher machen werden als Andere: Ansprechzeit, Startzeit, leichter Zugriff auf Befehle. Der Rechner sollte auch nicht sofort den Auslagerungsspeicher benutzen müssen, wenn mehr als eine Anwendung geöffnet ist.
Die traditionelle Optimierung umfasst Konzepte wie Prozessorlast, Umfang des Codes, die Anzahl der Mausklicks sowie die Speichernutzung des Programms. Die folgende Auflistung sollte die erste Liste ergänzen, wobei ein grundlegender Unterschied besteht: Ein GNOME-Benutzer schenkt der zweiten Liste keine Beachtung, während der ersten Liste sehr wohl Aufmerksamkeit gewidmet wird. Beim Optimieren von GNOME-Programmen sollen die Prozessorlast, der Speicherverbrauch und all diese Dinge optimiert werden, aber das sind die Bedeutungen, nicht das Endziel. Wir optimieren für Benutzer.
Ausführung der Optimierung
Aus dem vorigen Abschnitt wurde deutlich: Um etwas optimieren zu können, muss es messbar sein. Sie können Zufriedenheit nicht messen, aber Sie können sehr wohl Startzeiten messen, um sagen zu können, dass Sie sie verbessert haben. Die Zufriedenheit wird dann - hoffentlich - folgen.
Vergessen Sie nicht das Gesamtbild.
Hinweise
Die Grundlagen
Stellen Sie sicher, dass Ihr Code korrekt und fehlerfrei ist, bevor Sie mit der Optimierung beginnen. Überprüfen Sie nach der Optimierung, ob dies dann auch noch zutrifft.
Fallen für die Unvorsichtigen
Verhindern Sie Nebeneffekte.
Vergessen Sie nicht den Ressourcenverbrauch des X-Servers. Der Speicherverbrauch Ihres Programms enthält nicht die Pixmaps, die vom X-Server verarbeitet werden, aber sie verbrauchen dennoch Speicher. Verwenden Sie
Gliedern Sie Code aus Schleifen aus. Ein etwas umfangreicheres Stück Code, das nur einmal ausgeführt wird, ist um Einiges schneller als ein simples Stück Code, was dafür tausend Schleifen durchläuft. Vermeiden Sie es, langsamen Code allzu oft aufzurufen.
Geben Sie dem Compiler so viele Hinweise wie möglich. Verwenden Sie das const-Schlüsselwort. Verwenden Sie
Verwenden Sie keine Assemblersprachen. Sie sind nicht portierbar. Während sie auf dem einen Prozessor unglaublich schnell sind, ist nicht unbedingt garantiert, dass dies auf jedem von der Architektur unterstützten Prozessor genauso ist (beispielsweise Athlon vs Pentium 4).
Schreiben Sie eine vorhandene Bibliotheksroutine nicht neu, es sei denn, Sie sind sich sicher, dass sie unakzeptabel langsam ist. Viele prozessorintensive Bibliotheksroutinen wurden bereits optimiert. Andererseits sind einige Routinen tatsächlich langsam, insbesondere diejenigen, die Systemaufrufe an das Betriebssystem absetzen.
Halten Sie die Zahl der verlinkten Bibliotheken gering. Je weniger Bibliotheken gelinkt werden müssen, umso schneller startet das Programm. Dies ist in GNOME allerdings schwierig.
Falls alles Andere scheitern sollte, informieren Sie den Benutzer mit einem Fortschrittsbalken drüber, dass es derzeit nur langsam voran geht. Das dürfte ihm lieber sein, als wenn Sie nur die Ergebnisse präsentieren würden. Er möchte zumindest wissen, dass das Programm nicht abgestürzt ist und er dann erst einmal eine Tasse Kaffee trinken gehen kann.
Verwendung von
Ihre Befehlszeile sollte daher so aussehen:
valgrind --tool=massif --depth=5 --alloc-fn=g_malloc --alloc-fn=g_realloc --alloc-fn=g_try_malloc \\
 --alloc-fn=g_malloc0 --alloc-fn=g_mem_chunk_alloc same-gnome
Das Programm
Interpretieren der Ergebnisse
Die grafische Ausgabe von
Die Textdatei ist hierarchisch in Abschnitte gegliedert. Am oberen Ende finden sich die größten Speicherverbraucher, in absteigender Ordnung nach Speicherzeit. Darunter finden sich weitere Abschnitte, die je nach dem Platz im Aufruf-Stack feiner detaillierter sind. Um dies zu verdeutlichen, verwenden wir die Ausgabe des oben stehenden Befehls.
Command: ./same-gnome 

== 0 ===========================
Heap allocation functions accounted for 90.4% of measured spacetime

Called from:
 28.8% : 0x6BF83A: gdk_pixbuf_new (in /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)

 6.1% : 0x5A32A5: g_strdup (in /usr/lib/libglib-2.0.so.0.400.6)

 5.9% : 0x510B3C: (within /usr/lib/libfreetype.so.6.3.7)

 3.5% : 0x2A4A6B: __gconv_open (in /lib/tls/libc-2.3.3.so)
== 4 ===========================
Context accounted for 28.8% of measured spacetime
 0x6BF83A: gdk_pixbuf_new (in /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)
 0x3A998998: (within /usr/lib/gtk-2.0/2.4.0/loaders/libpixbufloader-png.so)
 0x6C2760: (within /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)
 0x6C285E: gdk_pixbuf_new_from_file (in /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)

Called from:
 27.8% : 0x804C1A3: load_scenario (same-gnome.c:463)

 0.9% : 0x3E8095E: (within /usr/lib/libgnomeui-2.so.0.792.0)

 and 1 other insignificant place
Interpretieren der Ergebnisse
Command: ./same-gnome 

== 0 ===========================
Heap allocation functions accounted for 87.6% of measured spacetime

Called from:
 7.7% : 0x5A32A5: g_strdup (in /usr/lib/libglib-2.0.so.0.400.6)

 7.6% : 0x43BC9F: (within /usr/lib/libgdk-x11-2.0.so.0.400.9)

 6.9% : 0x510B3C: (within /usr/lib/libfreetype.so.6.3.7)

 5.2% : 0x2A4A6B: __gconv_open (in /lib/tls/libc-2.3.3.so)
== 1 ===========================
Context accounted for 7.7% of measured spacetime
 0x5A32A5: g_strdup (in /usr/lib/libglib-2.0.so.0.400.6)

Called from:
 1.8% : 0x8BF606: gtk_icon_source_copy (in /usr/lib/libgtk-x11-2.0.so.0.400.9)

 1.1% : 0x67AF6B: g_param_spec_internal (in /usr/lib/libgobject-2.0.so.0.400.6)

 0.9% : 0x91FCFC: (within /usr/lib/libgtk-x11-2.0.so.0.400.9)

 0.8% : 0x57EEBF: g_quark_from_string (in /usr/lib/libglib-2.0.so.0.400.6)

 and 155 other insignificant places
Optimieren von GNOME-Software
Callum McKenzie
Robert Love
McKenzie
Robert
Love
0.1
William Johnston
Erstmalige Umwandlung in das DocBook-Format.
Die Optimierung von Software kann verschiedene Ziele verfolgen: Geschwindigkeit, Programmgröße oder Speicherverbrauch. Dieser Abschnitt enthält Leitfäden und Anleitungen zum Optimieren Ihrer Software.