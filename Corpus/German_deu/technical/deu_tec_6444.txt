# language_name_wals:	German
# language_name_glotto:	German
# ISO_6393:	deu
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/de.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

Mario Blättermann <mario\.blaettermann\@gmail\.com>, 2011, 2013_
external ref='media/02_jsgrid_01.png' md5='3fdc22d361cf801f71557fdc76ae5b49'_
external ref='media/02_jsgrid_02.png' md5='07db86b0043ba5c3c24a90d7322bd81e'_
external ref='media/02_jsgrid_03.png' md5='817351e73c687d47253c56ed06b6629f'_
external ref='media/02_jsgrid_04.png' md5='eeaead27cee2851877fc3cfe66177f07'_
external ref='media/02_jsgrid_05.png' md5='a3ad12f432d5977fc1f66302ad5b7498'_
external ref='media/02_jsgrid_06.png' md5='450e48dbf6b8f5ce1c208e4812e1714b'_
external ref='media/02_jsgrid_07.png' md5='0b304d70728903fbb2601d55bf00fdb9'_
external ref='media/02_jsgrid_08.png' md5='78890beb47bd11360154b8ca4d50d1ff'
Taryn Fox
2012
Entwurf der Anwendung

Laden der Bilder
_
external ref='media/03_jssignal_01.png' md5='8d6ecab185f4af4534cc255d62b58b8e'_
external ref='media/03_jssignal_02.png' md5='ba941390fbafc4a0f653c8f70bca92c0'_
external ref='media/03_jssignal_03.png' md5='49ecf251b0bf57543c8d79a77b6f306d'_
external ref='media/03_jssignal_04.png' md5='dfc5221ca15ca9fba7d3c76a73804e2d'
Verbinden der Signale
Eine erste Anwendung
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ToggleButtonExample = new Lang.Class({
 Name: 'ToggleButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jstogglebutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 300,
 default_width: 300,
 border_width: 30,
 title: "ToggleButton Example"});

 // Create the spinner that the button stops and starts
 this._spinner = new Gtk.Spinner ({hexpand: true, vexpand: true});

 // Create the togglebutton that starts and stops the spinner
 this._toggleButton = new Gtk.ToggleButton ({label: "Start/Stop"});
 this._toggleButton.connect ('toggled', Lang.bind (this, this._onToggle));

 // Create a grid and put everything in it
 this._grid = new Gtk.Grid ({
 row_homogeneous: false,
 row_spacing: 15});
 this._grid.attach (this._spinner, 0, 0, 1, 1);
 this._grid.attach (this._toggleButton, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onToggle: function() {

 // Start or stop the spinner
 if (this._toggleButton.get_active ())
 this._spinner.start ();
 else this._spinner.stop ();

 }

});

// Run the application
let app = new ToggleButtonExample ();
app.application.run (ARGV);
_
external ref='media/aboutdialog_GMenu.png' md5='a36117a559fa98e25e2f6b3db593639f'text
Monica Kochofar
Informationen zur Anwendung anzeigen













Ryan Lortie
Tiffany Antopolski



GNOME-Dokumentationsprojekt
Musikwiedergabetext
Tutorien für Einsteiger (C)
2013
Programmieren in C
Einführungen
gcc
./
valac --pkg gtk+-3.0
Ausführen bis
Fenster
Ein mehrzeiliger Texteditor
Auswählen
Farbwähler
Bildlauf
Verschiedenes
Susanna Huhtanen
Erste Schritte
gjs
text
valac --pkg gtk+-3.0
2011
Creative Commons Share Alike 3.0
Falls Sie eine Anfrage nach einem neuen Funktionsmerkmal stellen, wählen Sie
_
external ref='media/button.png' md5='8d69efbb3a0d3e043af6139b6492171c'text
Knopf (C)
Knopf

text
Knops (JavaScript)

from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
_
external ref='media/buttonbox_calculator.png' md5='ce0de08b7ac66f517290e33e6d33d508'
JavaScript









C
Anwendungsbeispiele_
external ref='media/checkbutton.png' md5='7921a6812c87dd2b3781f4fad241e858'text
Klassen in JavaScript
Entwurf des Anwendungsfensters

from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
_
external ref='media/colorbutton.png' md5='904539d26fe367bf99f9a0961cfc9a03'
JavaScript

text
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)




external ref='media/combobox.png' md5='ab9e91bc1a58fe866cb00dd52159251d'text


JavaScript

external ref='media/combobox_multicolumn.png' md5='43f16648fb11ebc7d2f70825ed0f63b3'
ComboBox (JavaScript)
Erstellen der Benutzeroberfläche









text









C++
_
external ref='media/dialog.png' md5='c90a33386a600e892fe623d4072c8c38'text
Dialog (C)
Dialog
text
Dialog (JavaScript)
text
text




Unterstützen Sie uns bei der Entwicklung
_
external ref='media/entry.png' md5='8a828cffdcbaa4bad83342e109f28cc8'text
Eintrag (C)
Eintrag
text
Eintrag (JavaScript)

Eintrag (Python)
Sebastian Pölsterl
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
_
external ref='media/filechooserdialog_save.png' md5='3a7a3b71b9d3a36066857843b68ff27f'_
external ref='media/filechooserdialog_menu.png' md5='8a75f04127a70eba0ed68a9eb1d3bbca'text








Vala-code
Referenz-Implementierung




external ref='media/fontchooserwidget.png' md5='9161245e307b432ae1313e9a9941edae'text
Grid (JavaScript)

from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
Tiffany Antpoolski

external ref='media/gmenu.c.png' md5='f305fc3cae8d16d72b734ee53b559e33'text
_
external ref='media/gmenu.js.png' md5='16b8bee122197771ec8498dac42f196b'text
GMenu (JavaScript)
_
external ref='media/gmenu.py.png' md5='52c68b34d5d566f37e9f803dedb6353a'text
GMenu (Python)
_
external ref='media/gmenu.vala.png' md5='7a9f381fc3ed5bf8d1c50d2acb095400'text




external ref='media/grid.png' md5='27d45da115401127456a3b854dcfc5be'text
Raster
Raster

Grid (JavaScript)


external ref='media/grid_simple.png' md5='c806f2e69b30373d4d2e08b41d6cc1f6'text
Grid (Python)
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)



Grid (Vala)
Grid-Widget

external ref='media/window.png' md5='eb0cde3530978619c25bddfaeb453345'text
#include &lt;gtk/gtk.hgt;

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Hello GNOME");
 gtk_widget_show_all (window);
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}

text
text
_
external ref='media/guitar-tuner.png' md5='35e615e0f5e293671d00c5c414ac2f6b'_
@@image: 'media/guitar-tuner-glade.png'; md5=f6606525443ab2160f53a87a454364d0_
@@image: 'media/guitar-tuner-pipeline.png'; md5=5adc952909d92af5dae6954781b4ad5ftext
Gitarrenstimmgerät (C)
Johannes Schmid
Gitarrenstimmgerät
GStreamer-Weiterleitungen
Eine Beispiel-Weiterleitung in GStreamer.
Einrichten der Weiterleitung
#include &lt;gst/gst.hgt;
gst_init (amp;argc, &argv);
Die Wiedergabe stoppen
Referenz-Implementierung
Nächste Schritte
#include &lt;gtkmm.hgt;
#include &lt;iostreamgt;
Verwendung von GStreamermm
 Gst::init (argc, argv);
Der Code hat den folgenden Zweck:
Verbinden der Signale
Weitere Informationen
text
Gitarrenstimmgerät (JavaScript)
Eine Beispiel-Weiterleitung in GStreamer.
Skript zum Ausführen der Anwendung
#!/usr/bin/gjs
var Gtk = imports.gi.Gtk;
var Gst = imports.gi.Gst;

const Mainloop = imports.mainloop;
Entwurf der Anwendung
Gtk.init(null, 0);
Gst.init(null, 0);

var guitarwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL, border_width: 100});
guitarwindow.title = "Guitar Tuner";
guitarwindow.connect("destroy", function(){Gtk.main_quit()});

guitarwindow.show();
Gtk.main();
var guitar_box = new Gtk.ButtonBox ({orientation: Gtk.Orientation.VERTICAL, spacing: 10});

var E = new Gtk.Button({label: "E"});
var A = new Gtk.Button({label: "A"});
var D = new Gtk.Button({label: "D"});
var G = new Gtk.Button({label: "G"});
var B = new Gtk.Button({label: "B"});
var e = new Gtk.Button({label: "e"});

guitar_box.add(E);
guitar_box.add(A);
guitar_box.add(D);
guitar_box.add(G);
guitar_box.add(B);
guitar_box.add(e);

guitarwindow.add(guitar_box);

guitar_box.show_all();
Die Anwendung im Terminal ausführen
text
Gitarrenstimmgerät (Python)
Erste Ausführung des Codes
def on_button_clicked (self, button):
from gi.repository import Gtk, Gst, GObject
Gst.init_check(sys.argv)
LENGTH = 500
Anwendung ausführen
Gst::init (argc, argv);
Weitere Informationen
_
external ref='media/hellognomewebapp.png' md5='948efb6148ede3bc6b47b4b0bbe4a74f'
Ihre erste GNOME-Anwendung!
1. Hallo, GNOME!
#!/usr/bin/gjs
Schreiben einer Gtk-Anwendung in C++
Ihre GNOME-Anwendung ausführen

_
external ref='media/helloWorld.png' md5='4c88a27211dfd1b33e504c9f78602f2d'text
Hallo, Welt! (C)
Die verschiedenen Teile des Programms
#include &lt;gtk/gtk.hgt;
static void
activate (GtkApplication* app,
 gpointer user_data)
{
 GtkWidget *window;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Hello World");
 gtk_window_set_default_size (GTK_WINDOW (window), 200, 100);
 gtk_widget_show_all (window);
}
Schließen des Fensters
GtkWidget *label;

 label = gtk_label_new ("Hello World!");
 gtk_container_add (GTK_CONTAINER (window), label);
Schreiben einer Gtk-Anwendung in C++
int
main (int argc,
 char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new (NULL, G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}
hello-world.c
Anwendung im Terminal ausführen
gcc
Ein Programm ausführen
./
Name
Der Anwendungsname.
Kommentar
Eine kurze Beschreibung der Anwendung.
Terminal
autogen.sh
Makefile.am
configure.ac
Lies mich
text
#!/usr/bin/gjs
const Lang = imports.lang;
const Gtk = imports.gi.Gtk;
hello-world.js
text
Grid (Python)
#run the application

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
Werkzeugleiste (Vala)
hello-world.vala
valac --pkg gtk+-3.0
# The actual runnable program is set to the SCRIPTS primitive.
# # Prefix bin_ tells where to copy this
bin_PROGRAMS = hello-world
hello_world_CFLAGS = $(gtk_CFLAGS)
hello_world_LDADD = $(gtk_LIBS)
hello_world_VALAFLAGS = --pkg gtk+-3.0
hello_world_SOURCES = hello-world.vala

desktopdir = $(datadir)/applications
desktop_DATA = \\
 hello-world.desktop
_
external ref='media/image.png' md5='9416aa74d9d6a857783f7a36338e7a02'text
_Bild
Bild
#include &lt;gtk/gtk.hgt;



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *image;

 /*Create a window with a title and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Welcome to GNOME");
 gtk_window_set_default_size (GTK_WINDOW (window), 300, 300);

 image = gtk_image_new_from_file ("gnome-image.png");

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (image));

 gtk_widget_show_all (GTK_WIDGET (window));
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example",G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}
text
Bild (JavaScript)
text
Bild (Python)
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)


_
@@image: 'media/image-viewer.png'; md5=7720360611243b14283b83527be968c2text
Bildbetrachter (C)
Bildbetrachter
In diesem Tutorial lernen Sie, wie:
Schreiben einer Gtk-Anwendung in C
Erstellen der Benutzeroberfläche
Bildanzeige
Schreiben einer Gtk-Anwendung in C++
text
Bildbetrachter (JavaScript)
Jonh Wendell
print ("Hello world!");
Klassen in JavaScript
_init: function ()
Eine erste Gtk-Anwendung
Hinzufügen von Klassen
Signale

Schließen des Fensters
this.window.connect ("hide", Gtk.main_quit);
Packen: Hinzufügen von Widgets zum Container
this.window.show_all ();
const Lang = imports.lang;
text
Bildbetrachter (Python)
text
Bildbetrachter (Vala)
Philip Chimento
GNOME-Dokumentationsteam
2010, 2011
Shaun McCance
2010
Demos zur GNOME-Entwicklerplattform
Einrichten Ihrer Entwicklungsumgebung
Mithelfenlink
JavaScript
Ekaterina Gerasimova
_
external ref='media/label.png' md5='734975c18653d88379f983e4501c3fc0'text
Be_zeichnung
Beschriftung
#include &lt;gtk/gtk.hgt;



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *label;

 /*Create a window with a title and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_application (GTK_WINDOW (window), GTK_APPLICATION (app));
 gtk_window_set_title (GTK_WINDOW (window), "Welcome to GNOME");
 gtk_window_set_default_size (GTK_WINDOW (window), 200,100);
 
 /*Create a label and set its alignment. Setting the line wrap to TRUE makes 
 the label break lines if the text exceeds the widget's size. When set to 
 FALSE the text gets cut off by the edge of the widget*/
 label = gtk_label_new ("Hello GNOME!");
 gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_CENTER);
 gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (label));

 gtk_widget_show_all (GTK_WIDGET (window));
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example",G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}

JavaScript
Python
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
Rechtliche Hinweise.
Lizenz
Dieses Werk wird unter einer »CreativeCommons Attribution-Share Alike 3.0 Unported license« verbreitet.
Es ist Ihnen gestattet:

Das Werk bzw. den Inhalt zu vervielfältigen, zu verbreiten und öffentlich zugänglich zu machen.

Abwandlungen und Bearbeitungen des Werkes bzw. Inhaltes anzufertigen.
Unter den folgenden Bedingungen:

Sie dürfen das Werk nur unter gleichen Bedingungen weitergeben, wie Sie vom Autor oder Lizenzgeber festgelegt wurden (aber nicht so, dass es wie Ihr Werk aussieht).

Wenn Sie das lizenzierte Werk bzw. den lizenzierten Inhalt bearbeiten, abwandeln oder in anderer Weise erkennbar als Grundlage für eigenes Schaffen verwenden, dürfen Sie die daraufhin neu entstandenen Werke bzw. Inhalte nur unter Verwendung von Lizenzbedingungen weitergeben, die mit denen dieses Lizenzvertrages identisch, vergleichbar oder kompatibel sind.
Den vollständigen Text der Lizenz finden Sie auf der
Als besondere Ausnahme erteilen Ihnen die Urheberrechtsinhaber die Genehmigung, den in diesem Dokument enthaltenen Beispielcode ohne Einschränkung unter den Bedingungen Ihrer Wahl zu verbreiten._
external ref='media/linkbutton.png' md5='3712eae8953e87c65a6aa74503b8e32b'text

JavaScript

from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text

@@image: 'media/magic-mirror.png'; md5=8171faea6ed3b6ddac0da084c29e4e22text
Daniel G. Siegel
Schlussfolgerung
_
external ref='media/menubar.png' md5='7b642aaa1628d5e43ab85ac230ac1c78'text
Menüleiste (C)
Menüleiste
_
external ref='media/menubar_choices.png' md5='47cdfa12caf85ba20dd3e835bd7f893f'text
&lt;?xml version="1.0"? encoding="UTF-8"?gt;
&lt;?xml version="1.0" encoding="UTF-8"?gt;
&lt;interfacegt;
 &lt;menu id="menubar"gt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Filelt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Editlt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Choiceslt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Helplt;/attributegt;
 &lt;/submenugt;
 &lt;/menugt;
&lt;/interfacegt;
menubar.ui
Aktionen einrichten
Aktionen: Anwendung oder Fenster?
Tastenkürzel und Tastenkombinationen
Übersetzbare Strings


Tastenkürzel
Tastenkombinationen
_
external ref='media/linkbutton.png' md5='3712eae8953e87c65a6aa74503b8e32b'text




JavaScript
Anna Zacchi

text
_
external ref='media/message-board.ogv' md5='beb80c4538776dc2cdd26c95abea5027'text
#include &lt;webkit/webkit.hgt;




gchar *tmp, *css;
Mehr erfahren
_
external ref='media/messagedialog.png' md5='1956288274018e2386d9cba96a2101de'text
Klassen in JavaScript
Entwurf des Anwendungsmenüs
Erstellen der Benutzeroberfläche
text







Überblick
Das Modell
Referenzen




external ref='media/paned.png' md5='01e36d8a51ee18313616d63d2e15d993'
Paned
Paned

text
Bild (JavaScript)


Python
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
Fenster (Vala)

@@image: 'media/photo-wall.png'; md5=f19590d97e8ec029cda3c44b769c11cd_
@@image: 'media/photo-wall-focused.png'; md5=9f1ceecf3a28c1e468597b093a10cbaetext
Ein Clutter-Bildbetrachter
Chris Kühl
Einführung
Ersteinrichtung
Laden der Bilder
_
external ref='media/progressbar_fill.ogv' md5='287763d1d3f4a328212ea2243910f5e4'text
_
external ref='media/progressbar.ogv' md5='36deab3dd4b5be968828fa2ef416d612'text
text
text
text
Eigenschaften
link
Python
Tutorial für Einsteiger_
external ref='media/radiobutton.png' md5='d115460280d8e41493dd98054b5822a5'text
Auswahlknopf (C)
Auswahlknopf
_
external ref='media/radiobuttontravel.png' md5='0c5f01ee160bb42716ccf5dccbd080c0'
Klassen in JavaScript
Erstellen der Benutzeroberfläche
Erstellen der Benutzeroberfläche




from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
_
@@image: 'media/record-collection.png'; md5=2d645997687ed5aacd36aafafc16e072text
Erstellung einer kleinen Datenbankanwendung zum Verwalten Ihrer Musiksammlung
eine Verbindung zu einer Datenbank mittels libgda erstellt wird
Datensätze in eine Datenbanktabelle eingefügt werden oder wie die Tabelle durchsucht werden kann
Programmstruktur
Entwurf der Anwendung
Auswählen
Einfügen
enum ResponseType
ResponseType.NONE = -1
ResponseType.REJECT = -2
ResponseType.ACCEPT = -3
ResponseType.DELETE_EVENT = -4
ResponseType.OK = -5
ResponseType.CANCEL = -6
ResponseType.CLOSE = -7
ResponseType.YES = -8
ResponseType.NO = -9
ResponseType.APPLY = -10
ResponseType.HELP = -11
_
external ref='media/scale2.png' md5='ae2ba0a6675f3d9cdcd961cdf32f1a5c'text
Skalieren
Skalieren




external ref='media/scalepenguins.png' md5='2dbe6a833fec86fde71a5ddb421e2cd5'
JavaScript
Verbinden der Signale
// Die Anwendung ausführen
let app = new ScaleExample ();
app.application.run (ARGV);


external ref='media/scale.png' md5='462c52a53b773cb9e8c62c646bf88452'
Python


text




external ref='media/scrolledwindow.png' md5='697bb3205d5c4fb0b4ea8db435843157'text
#include &lt;gtk/gtk.hgt;



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 /* Declare variables */
 GtkWidget *window;
 GtkWidget *scrolled_window;
 GtkWidget *image;

 /* Create a window with a title, and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "ScrolledWindow Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 220, 200);

 /* Create the scrolled window. Usually NULL is passed for both parameters so
 * that it creates the horizontal/vertical adjustments automatically. Setting
 * the scrollbar policy to automatic allows the scrollbars to only show up
 * when needed.
 */
 scrolled_window = gtk_scrolled_window_new (NULL, NULL);
 /* Set the border width */
 gtk_container_set_border_width (GTK_CONTAINER (scrolled_window), 10);
 /* Extract our desired image from a file that we have */
 image = gtk_image_new_from_file ("gnome-image.png");
 /* And add it to the scrolled window */
 gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW (scrolled_window), image);
 /* Set the policy of the horizontal and vertical scrollbars to automatic.
 * What this means is that the scrollbars are only present if needed.
 */
 gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
 GTK_POLICY_AUTOMATIC,
 GTK_POLICY_AUTOMATIC);

 gtk_container_add (GTK_CONTAINER (window), scrolled_window);

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

Fenster (JavaScript)
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ScrolledWindowExample = new Lang.Class ({
 Name: 'ScrolledWindow Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application({ application_id: 'org.example.jscrolledwindow' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this.window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function() {
 // Create the application window
 this.window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "ScrolledWindow Example",
 default_width: 200,
 default_height: 200,
 border_width: 10 });
 // the scrolledwindow
 this.scrolledWindow = new Gtk.ScrolledWindow();
 this.scrolledWindow.set_border_width(10);
 // there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 this.scrolledWindow.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS);
 // an image - slightly larger than the window
 this.image = new Gtk.Image();
 this.image.set_from_file("gnome-image.png");

 // add the image to the scrolledwindow
 this.scrolledWindow.add_with_viewport(this.image);

 // add the scrolledwindow to the window
 this.window.add(this.scrolledWindow);
 this.window.show_all();
 }
});

// Run the application
let app = new ScrolledWindowExample();
app.application.run (ARGV);

from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)

_
external ref='media/separator.png' md5='8769b27662ce5c77f99e9ce33751a21a'text
Trennzeichen (C)
Trennzeichen
API-Referenz
text
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
Statusleiste (Vala)




external ref='media/geditview.png' md5='f1438295662d95f56fcd1d8200efaaf2'_
external ref='media/gediteditor.png' md5='50db1ee8f2c545744879ee9fba5b4b24'
text
Signale und Callbacks
_
external ref='media/spinbutton.png' md5='993cbb7d9bd271a329727a926195712a'text

external ref='media/spinbuttonkittens.png' md5='577cce8a902140aacbab73fe8a76a010'
JavaScript
Erstellen der Benutzeroberfläche
Erstellen der Benutzeroberfläche
// Run the application
let app = new SpinButtonExample ();
app.application.run (ARGV);
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const SpinButtonExample = new Lang.Class({
 Name: 'SpinButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsspinbutton'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Kitten Feeder"});

 // Create the first spinbutton using a function
 this._kittens = Gtk.SpinButton.new_with_range (1, 9001, 1);
 this._kittens.connect ("value-changed", Lang.bind (this, this._newValue));

 // Create an adjustment to use for the second spinbutton
 this._adjustment = new Gtk.Adjustment ({
 value: 1,
 lower: 0,
 upper: 9001,
 step_increment: 1,
 page_increment: 10 });

 // Create the second spinbutton
 this._tuna = new Gtk.SpinButton ({ adjustment: this._adjustment });
 this._tuna.connect ("value-changed", Lang.bind (this, this._newValue));

 // this._tuna.set_digits (1);
 // this._tuna.set_wrap (true);

 // Create the text labels to go with the spinbuttons
 this._startLabel = new Gtk.Label ({ label: "There are " });
 this._kittenLabel = new Gtk.Label ({ label: " kitten(s), and "});
 this._tunaLabel = new Gtk.Label ({ label: " can(s) of tuna."});
 this.perKitten = Math.floor((this._tuna.get_value() / this._kittens.get_value()));
 this._lastLabel = new Gtk.Label ({
 label: "That's " + this.perKitten + " can(s) of tuna per kitten." });

 // Create a grid to put the spinbuttons and their labels in
 this._spinGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_bottom: 20 });

 // Attach everything to the grid
 this._spinGrid.attach (this._startLabel, 0, 0, 1, 1);
 this._spinGrid.attach (this._kittens, 1, 0, 1, 1);
 this._spinGrid.attach (this._kittenLabel, 2, 0, 1, 1);
 this._spinGrid.attach (this._tuna, 3, 0, 1, 1);
 this._spinGrid.attach (this._tunaLabel, 4, 0, 1, 1);

 // Create a main grid to hold it and the last label
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Attach the smaller grid and the last label to the main grid
 this._mainGrid.attach (this._spinGrid, 0, 0, 1, 1);
 this._mainGrid.attach (this._lastLabel, 0, 1, 1, 1);

 // Add the main grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _newValue: function () {

 // Update the label which shows how many cans there are per kitten
 this.perKitten = Math.floor((this._tuna.get_value() / this._kittens.get_value()))
 this._lastLabel.set_label ("That's " + this.perKitten + " can(s) of tuna per kitten.");

 }

});

// Run the application
let app = new SpinButtonExample ();
app.application.run (ARGV);

from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text

external ref='media/spinner.png' md5='d04f2d81f1d72c6c2f97e8729947dfed'text
Spinner
Spinner

JavaScript

from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text



external ref='media/statusbar3.png' md5='60c71604fb44656237ee66dfb39a8689'text
Statusleiste (C)
Statusleiste

_
external ref='media/statusbar2.png' md5='ff6f7e5b270827ca98b2d5f7087aa766'
JavaScript
Erstellen der Knöpfe
Erstellen der Statusleiste
// Assemble the frames into the paned interface
 this._panes.pack1 (this._topFrame, true, false);
 this._panes.pack2 (this._barFrame, false, false);

 // Put the panes into the window
 this._window.add (this._panes);

 // Show the window and all child widgets
 this._window.show_all();
 },



external ref='media/statusbar.png' md5='eb1aca55315d6cda57b12a5f36058ba8'text
Statusleiste (Python)
from gi.repository import Gtk
from gi.repository import Gdk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="StatusBar Example", application=app)
 self.set_default_size(200, 100)

 # a label
 label = Gtk.Label(label="Press any key or ")

 # a button
 button = Gtk.Button(label="click me.")
 # connected to a callback
 button.connect("clicked", self.button_clicked_cb)

 # the statusbar
 self.statusbar = Gtk.Statusbar()
 # its context_id - not shown in the UI but needed to uniquely identify
 # the source of a message
 self.context_id = self.statusbar.get_context_id("example")
 # we push a message onto the statusbar's stack
 self.statusbar.push(self.context_id, "Waiting for you to do something...")

 # a grid to attach the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing(5)
 grid.set_column_homogeneous(True)
 grid.set_row_homogeneous(True)
 grid.attach(label, 0, 0, 1, 1)
 grid.attach_next_to(button, label, Gtk.PositionType.RIGHT, 1, 1)
 grid.attach(self.statusbar, 0, 1, 2, 1)

 # add the grid to the window
 self.add(grid)

 # callback function for the button clicked
 # if the button is clicked the event is signaled to the statusbar
 # onto which we push a new status
 def button_clicked_cb(self, button):
 self.statusbar.push(self.context_id, "You clicked the button.")

 # event handler
 def do_key_press_event(self, event):
 # any signal from the keyboard is signaled to the statusbar
 # onto which we push a new status with the symbolic name
 # of the key pressed
 self.statusbar.push(self.context_id, Gdk.keyval_name(event.keyval) +
 " key was pressed.")
 # stop the signal emission
 return True

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
Statusleiste (Vala)
text
Strings
Strings in Python 2
Strings in Python 3
Unicode in GTK+
Weitere Informationen
_
external ref='media/switch_off.png' md5='211a2962708800697ad5373dcc86ad6d'_
external ref='media/switch_on.png' md5='95e8769f758c2d95ace0fa8ecf30b29d'text
Schalter
Schalter
_
external ref='media/switchanimals.png' md5='513ae15dcf68e15eef30b76420b8c714'
JavaScript
Erstellen der Benutzeroberfläche
Erstellen der Benutzeroberfläche
_initMenus: function() {

 // Build the application's menu so we can have an "About" button
 let menu = new Gio.Menu();
 menu.append("About", 'app.about');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 // Bind the "About" button to the _showAbout() function
 let aboutAction = new Gio.SimpleAction ({ name: 'about' });
 aboutAction.connect('activate', Lang.bind(this,
 function() {
 this._showAbout();
 }));
 this.application.add_action(aboutAction);

 // Bind the "Quit" button to the function that closes the window
 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },
_showAbout: function () {

 // String arrays of the names of the people involved in the project
 var artists = ['Rob Lee http://en.wikipedia.org/wiki/File:Fuzzy_Freddy.jpg', 'Ken Funakoshi http://en.wikipedia.org/wiki/File:Pygoscelis_papua_-Nagasaki_Penguin_Aquarium_-swimming_underwater-8a.jpg', 'Shek Graham http://www.flickr.com/photos/shekgraham/127431519/in/photostream/', 'Mindaugas Urbonas http://commons.wikimedia.org/wiki/File:Mute_Swan-Mindaugas_Urbonas.jpg'];
 var authors = ["GNOME Documentation Team"];
 var documenters = ["GNOME Documentation Team"];

 // Create the About dialog
 let aboutDialog = new Gtk.AboutDialog({
 title: "AboutDialog Example",
 program_name: "Animal Creator",
 copyright: "Copyright \\xa9 2012 GNOME Documentation Team\
\
Red fox photo licensed CC-By by Rob Lee\
Gentoo penguin photo licensed CC-By-SA by Ken Funakoshi\
Fruit bat photo licensed CC-By by Shek Graham\
Mute swan photo licensed CC-By-SA by Mindaugas Urbonas\
Links to the originals are available under Credits.\
\
Have you hugged a penguin today?",
 artists: artists,
 authors: authors,
 documenters: documenters,
 website: "http://developer.gnome.org",
 website_label: "GNOME Developer Website" });

 // Attach the About dialog to the window
 aboutDialog.modal = true;
 aboutDialog.transient_for = this._window;

 // Show the About dialog
 aboutDialog.show();

 // Connect the Close button to the destroy signal for the dialog
 aboutDialog.connect('response', function() {
 aboutDialog.destroy();
 });
 }

});
// Run the application
let app = new SwitchExample ();
app.application.run (ARGV);
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const SwitchExample = new Lang.Class({
 Name: 'Switch Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsswitch'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal creates the menu and builds the UI
 _onStartup: function() {
 this._initMenus();
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Animal Creator"});

 // Create the image widget and set its default picture
 this._image = new Gtk.Image ({file: "redfox.png"});

 // Create a label for the first switch
 this._flyLabel = new Gtk.Label ({
 label: "Make it fly",
 margin_right: 30});

 // Create the first switch and set its default position
 this._flySwitch = new Gtk.Switch ({active: false});
 this._flySwitch.connect ('notify::active', Lang.bind (this, this._switchFlip));

 // Create a label for the second switch
 this._birdLabel = new Gtk.Label ({
 label: "Make it a bird",
 margin_right: 30});

 // Create the second switch
 this._birdSwitch = new Gtk.Switch ({active: false});
 this._birdSwitch.connect ('notify::active', Lang.bind (this, this._switchFlip));

 // Create a grid for the labels and switches beneath the picture
 this._UIGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_top: 20});

 // Attach the labels and switches to that grid
 this._UIGrid.attach (this._flyLabel, 0, 0, 1, 1);
 this._UIGrid.attach (this._flySwitch, 1, 0, 1, 1);
 this._UIGrid.attach (this._birdLabel, 0, 1, 1, 1);
 this._UIGrid.attach (this._birdSwitch, 1, 1, 1, 1);

 // Create a master grid to put both the UI and the picture into
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Attach the picture and the UI grid to the master grid
 this._mainGrid.attach (this._image, 0, 0, 1, 1);
 this._mainGrid.attach (this._UIGrid, 0, 1, 1, 1);

 // Add the master grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _switchFlip: function() {

 // Change the picture depending on which switches are flipped
 if (this._flySwitch.get_active()) {

 if (this._birdSwitch.get_active()) this._image.set_from_file ("muteswan.png");

 else this._image.set_from_file ("fruitbat.png");
 }

 else {

 if (this._birdSwitch.get_active()) this._image.set_from_file ("gentoopenguin.png");

 else this._image.set_from_file ("redfox.png");

 }

 },



 _initMenus: function() {

 // Build the application's menu so we can have an "About" button
 let menu = new Gio.Menu();
 menu.append("About", 'app.about');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 // Bind the "About" button to the _showAbout() function
 let aboutAction = new Gio.SimpleAction ({ name: 'about' });
 aboutAction.connect('activate', Lang.bind(this,
 function() {
 this._showAbout();
 }));
 this.application.add_action(aboutAction);

 // Bind the "Quit" button to the function that closes the window
 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },



 _showAbout: function () {

 // String arrays of the names of the people involved in the project
 var artists = ['Rob Lee http://en.wikipedia.org/wiki/File:Fuzzy_Freddy.png', 'Ken Funakoshi http://en.wikipedia.org/wiki/File:Pygoscelis_papua_-Nagasaki_Penguin_Aquarium_-swimming_underwater-8a.png', 'Shek Graham http://www.flickr.com/photos/shekgraham/127431519/in/photostream/', 'Mindaugas Urbonas http://commons.wikimedia.org/wiki/File:Mute_Swan-Mindaugas_Urbonas.png'];
 var authors = ["GNOME Documentation Team"];
 var documenters = ["GNOME Documentation Team"];

 // Create the About dialog
 let aboutDialog = new Gtk.AboutDialog({
 title: "AboutDialog Example",
 program_name: "Animal Creator",
 copyright: "Copyright \\xa9 2012 GNOME Documentation Team\
\
Red fox photo licensed CC-By by Rob Lee\
Gentoo penguin photo licensed CC-By-SA by Ken Funakoshi\
Fruit bat photo licensed CC-By by Shek Graham\
Mute swan photo licensed CC-By-SA by Mindaugas Urbonas\
Links to the originals are available under Credits.\
\
Have you hugged a penguin today?",
 artists: artists,
 authors: authors,
 documenters: documenters,
 website: "http://developer.gnome.org",
 website_label: "GNOME Developer Website" });

 // Attach the About dialog to the window
 aboutDialog.modal = true;
 aboutDialog.transient_for = this._window;

 // Show the About dialog
 aboutDialog.show();

 // Connect the Close button to the destroy signal for the dialog
 aboutDialog.connect('response', function() {
 aboutDialog.destroy();
 });
 }

});

// Run the application
let app = new SwitchExample ();
app.application.run (ARGV);


from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
class MyWindow : Gtk.ApplicationWindow {

 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Switch Example");

 this.set_default_size (300, 100);
 this.border_width = 10;

 var label = new Gtk.Label ("Title");
 var switcher = new Gtk.Switch ();

 switcher.set_active (true);

 switcher.notify["active"].connect (switcher_cb);

 var grid = new Gtk.Grid ();
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switcher, 1, 0, 1, 1);

 this.add (grid);
 }

 void switcher_cb (Object switcher, ParamSpec pspec) {
 if ((switcher as Gtk.Switch).get_active())
 this.set_title ("Switch Example");
 else
 this.set_title ("");
 }
}

class MyApplication : Gtk.Application {
 protected override void activate () {

 var window = new MyWindow (this);
 window.show_all (); //show all the things
 }

 internal MyApplication () {
 Object (application_id: "org.example.checkbutton");
 }
}

int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/textview.png' md5='049e859ed1af2d7c93d8cb5cfd9f7792'text
_
external ref='media/textviewpenguinchat.png' md5='0dd6f6aa44aaeab7901bd90162ed4c9a'
JavaScript
Ein mehrzeiliger Texteditor
Erstellen der Benutzeroberfläche
text
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 scrolled_window.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
_
external ref='media/togglebutton.png' md5='791e062613d4f9bd5936390b0aa18448'text
Klassen in JavaScript
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ToggleButtonExample = new Lang.Class({
 Name: 'ToggleButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jstogglebutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 300,
 default_width: 300,
 border_width: 30,
 title: "ToggleButton Example"});

 // Create the spinner that the button stops and starts
 this._spinner = new Gtk.Spinner ({hexpand: true, vexpand: true});

 // Create the togglebutton that starts and stops the spinner
 this._toggleButton = new Gtk.ToggleButton ({label: "Start/Stop"});
 this._toggleButton.connect ('toggled', Lang.bind (this, this._onToggle));

 // Create a grid and put everything in it
 this._grid = new Gtk.Grid ({
 row_homogeneous: false,
 row_spacing: 15});
 this._grid.attach (this._spinner, 0, 0, 1, 1);
 this._grid.attach (this._toggleButton, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onToggle: function() {

 // Start or stop the spinner
 if (this._toggleButton.get_active ())
 this._spinner.start ();
 else this._spinner.stop ();

 }

});

// Run the application
let app = new ToggleButtonExample ();
app.application.run (ARGV);
text
from gi.repository import Gtk
import sys

class MyWindow(Gtk.ApplicationWindow):
 # a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switch, 1, 0, 1, 1);

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
text
_
external ref='media/toolbar.png' md5='f0350855eedf6343952b72d6d906f738'text
Werkzeugleiste (C)
Eine Leiste mit Knöpfen
Werkzeugleiste
text
Werkzeugleiste (JavaScript)




Werkzeugleiste (Python)
text
Werkzeugleiste (Vala)
_
external ref='media/glade_ui.png' md5='baea74fe213bc12ea934f64f6977215a'_
external ref='media/glade_select_toolbar.png' md5='f7b5b224050b2e387eb04362fc99df00'_
external ref='media/glade_toolbar_general.png' md5='e31daba6e8a3e526aca89d5f1622edaa'_
external ref='media/glade_toolbar_common.png' md5='d5ec6cc0218ca98e195dbd033feb9ac5'_
external ref='media/glade_toolbar_edit.png' md5='feb1e2b7040d24a4d030f94cf07c81fd'_
external ref='media/glade_toolbar_editor.png' md5='8af65241e5ca47d5494a7b36640e6f1c'_
external ref='media/glade_visible_no.png' md5='dc6c025aa825f4d772fbd283d6330026'text
Mit Glade erstellte Werkzeugleiste (Python)
Mit Glade erstellte Werkzeugleiste
Erstellen der Werkzeugleiste mit Glade
Is important
Action name
Stock Id
open_button
Ja
app.open
Öffnen
gtk-open
undo_button
win.undo
Undo
gtk-undo
fullscreen_button
win.fullscreen
Vollbild
gtk-fullscreen
leave_fullscreen_button
Vollbild verlassen
gtk-leave-fullscreen
Schließen Sie den
Speichern Sie Ihre Arbeit und schließen Sie Glade.
text
_
external ref='media/toolbar.png' md5='f0350855eedf6343952b72d6d906f738'text
Minihilfe (C)
Minihilfe
text
Werkzeugleiste (JavaScript)



Minihilfe (Python)
text
Minihilfe (Vala)



text
_
text
from gi.repository import Gtk
from gi.repository import Pango
import sys

books = [["Tolstoy, Leo", ["War and Peace", True], ["Anna Karenina", False]],
 ["Shakespeare, William", ["Hamlet", False], ["Macbeth", True], ["Othello", False]],
 ["Tolkien, J.R.R.", ["The Lord of the Rings", False]]]

class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Library", application=app)
 self.set_default_size(250, 100)
 self.set_border_width(10)

 # the data are stored in the model
 # create a treestore with two columns
 self.store = Gtk.TreeStore(str, bool)
 # fill in the model
 for i in range(len(books)):
 # the iter piter is returned when appending the author in the first column
 # and False in the second
 piter = self.store.append(None, [books[i][0], False])
 # append the books and the associated boolean value as children of the author
 j = 1
 while j &lt; len(books[i]):
 self.store.append(piter, books[i][j])
 j += 1

 # the treeview shows the model
 # create a treeview on the model self.store
 view = Gtk.TreeView()
 view.set_model(self.store)

 # the cellrenderer for the first column - text
 renderer_books = Gtk.CellRendererText()
 # the first column is created
 column_books = Gtk.TreeViewColumn("Books", renderer_books, text=0)
 # and it is appended to the treeview
 view.append_column(column_books)

 # the cellrenderer for the second column - boolean rendered as a toggle
 renderer_in_out = Gtk.CellRendererToggle()
 # the second column is created
 column_in_out = Gtk.TreeViewColumn("Out?", renderer_in_out, active=1)
 # and it is appended to the treeview
 view.append_column(column_in_out)
 # connect the cellrenderertoggle with a callback function
 renderer_in_out.connect("toggled", self.on_toggled)

 # add the treeview to the window
 self.add(view)

 # callback function for the signal emitted by the cellrenderertoggle
 def on_toggled(self, widget, path):
 # the boolean value of the selected row
 current_value = self.store[path][1]
 # change the boolean value of the selected row in the model
 self.store[path][1] = not current_value
 # new current value!
 current_value = not current_value
 # if length of the path is 1 (that is, if we are selecting an author)
 if len(path) == 1:
 # get the iter associated with the path
 piter = self.store.get_iter(path)
 # get the iter associated with its first child
 citer = self.store.iter_children(piter)
 # while there are children, change the state of their boolean value
 # to the value of the author
 while citer is not None:
 self.store[citer][1] = current_value
 citer = self.store.iter_next(citer)
 # if the length of the path is not 1 (that is, if we are selecting a book)
 elif len(path) != 1:
 # get the first child of the parent of the book (the first book of the author)
 citer = self.store.get_iter(path)
 piter = self.store.iter_parent(citer)
 citer = self.store.iter_children(piter)
 # check if all the children are selected
 all_selected = True
 while citer is not None:
 if self.store[citer][1] == False:
 all_selected = False
 break
 citer = self.store.iter_next(citer)
 # if they do, the author as well is selected; otherwise it is not
 self.store[piter][1] = all_selected

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
_
text
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Pango = imports.gi.Pango;

// Data to go in the phonebook
 this.phonebook =
 let phonebook =
 [{ name: "Jurg", surname: "Billeter", phone: "555-0123",
 description: "A friendly person."},
 { name: "Johannes", surname: "Schmid", phone: "555-1234",
 description: "Easy phone number to remember."},
 { name: "Julita", surname: "Inca", phone: "555-2345",
 description: "Another friendly person."},
 { name: "Javier", surname: "Jardon", phone: "555-3456",
 description: "Bring fish for his penguins."},
 { name: "Jason", surname: "Clinton", phone: "555-4567",
 description: "His cake's not a lie."},
 { name: "Random J.", surname: "Hacker", phone: "555-5678",
 description: "Very random!"}];
for (i = 0; i &lt; phonebook.length; i++ ) {
 let contact = phonebook [i];
 this._listStore.set (this._listStore.append(), [0, 1, 2, 3],
 [contact.name, contact.surname, contact.phone, contact.description]);
 }
Erstellen der Benutzeroberfläche
// Create the treeview
 this._treeView = new Gtk.TreeView ({
 expand: true,
 model: this._listStore });
// Spalten für das Adressbuch erstellen
 let firstName = new Gtk.TreeViewColumn ({ title: "First Name" });
 let lastName = new Gtk.TreeViewColumn ({ title: "Last Name" });
 let phone = new Gtk.TreeViewColumn ({ title: "Phone Number" });
// Create a cell renderer for when bold text is needed
 let bold = new Gtk.CellRendererText ({
 weight: Pango.Weight.BOLD });

 // Create a cell renderer for normal text
 let normal = new Gtk.CellRendererText ();

 // Pack the cell renderers into the columns
 firstName.pack_start (bold, true);
 lastName.pack_start (normal, true);
 phone.pack_start (normal, true);
firstName.add_attribute (bold, "text", 0);
 lastName.add_attribute (normal, "text", 1);
 phone.add_attribute (normal, "text", 2);

 // Insert the columns into the treeview
 this._treeView.insert_column (firstName, 0);
 this._treeView.insert_column (lastName, 1);
 this._treeView.insert_column (phone, 2);
// Create the label that shows details for the name you select
 this._label = new Gtk.Label ({ label: "" });

 // Get which item is selected
 this.selection = this._treeView.get_selection();

 // When something new is selected, call _on_changed
 this.selection.connect ('changed', Lang.bind (this, this._onSelectionChanged));
// Create a grid to organize everything in
 this._grid = new Gtk.Grid;

 // Attach the treeview and label to the grid
 this._grid.attach (this._treeView, 0, 0, 1, 1);
 this._grid.attach (this._label, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },
_onSelectionChanged: function () {

 // Grab a treeiter pointing to the current selection
 let [ isSelected, model, iter ] = this.selection.get_selected();

 // Set the label to read off the values stored in the current selection
 this._label.set_label ("\
" +
 this._listStore.get_value (iter, 0) + " " +
 this._listStore.get_value (iter, 1) + " " +
 this._listStore.get_value (iter, 2) + "\
" +
 this._listStore.get_value (iter, 3));

 }

});
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Pango = imports.gi.Pango;

const TreeViewExample = new Lang.Class({
 Name: 'TreeView Example with Simple ListStore',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jstreeviewsimpleliststore'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 250,
 default_width: 100,
 border_width: 20,
 title: "My Phone Book"});

 // Create the underlying liststore for the phonebook
 this._listStore = new Gtk.ListStore ();
 this._listStore.set_column_types ([
 GObject.TYPE_STRING,
 GObject.TYPE_STRING,
 GObject.TYPE_STRING,
 GObject.TYPE_STRING]);

 // Data to go in the phonebook
 let phonebook =
 [{ name: "Jurg", surname: "Billeter", phone: "555-0123",
 description: "A friendly person."},
 { name: "Johannes", surname: "Schmid", phone: "555-1234",
 description: "Easy phone number to remember."},
 { name: "Julita", surname: "Inca", phone: "555-2345",
 description: "Another friendly person."},
 { name: "Javier", surname: "Jardon", phone: "555-3456",
 description: "Bring fish for his penguins."},
 { name: "Jason", surname: "Clinton", phone: "555-4567",
 description: "His cake's not a lie."},
 { name: "Random J.", surname: "Hacker", phone: "555-5678",
 description: "Very random!"}];

 // Put the data in the phonebook
 for (let i = 0; i &lt; phonebook.length; i++ ) {
 let contact = phonebook [i];
 this._listStore.set (this._listStore.append(), [0, 1, 2, 3],
 [contact.name, contact.surname, contact.phone, contact.description]);
 }

 // Create the treeview
 this._treeView = new Gtk.TreeView ({
 expand: true,
 model: this._listStore });

 // Create the columns for the address book
 let firstName = new Gtk.TreeViewColumn ({ title: "First Name" });
 let lastName = new Gtk.TreeViewColumn ({ title: "Last Name" });
 let phone = new Gtk.TreeViewColumn ({ title: "Phone Number" });

 // Create a cell renderer for when bold text is needed
 let bold = new Gtk.CellRendererText ({
 weight: Pango.Weight.BOLD });

 // Create a cell renderer for normal text
 let normal = new Gtk.CellRendererText ();

 // Pack the cell renderers into the columns
 firstName.pack_start (bold, true);
 lastName.pack_start (normal, true);
 phone.pack_start (normal, true);

 // Set each column to pull text from the TreeView's model
 firstName.add_attribute (bold, "text", 0);
 lastName.add_attribute (normal, "text", 1);
 phone.add_attribute (normal, "text", 2);

 // Insert the columns into the treeview
 this._treeView.insert_column (firstName, 0);
 this._treeView.insert_column (lastName, 1);
 this._treeView.insert_column (phone, 2);

 // Create the label that shows details for the name you select
 this._label = new Gtk.Label ({ label: "" });

 // Get which item is selected
 this.selection = this._treeView.get_selection();

 // When something new is selected, call _on_changed
 this.selection.connect ('changed', Lang.bind (this, this._onSelectionChanged));

 // Create a grid to organize everything in
 this._grid = new Gtk.Grid;

 // Attach the treeview and label to the grid
 this._grid.attach (this._treeView, 0, 0, 1, 1);
 this._grid.attach (this._label, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onSelectionChanged: function () {

 // Grab a treeiter pointing to the current selection
 let [ isSelected, model, iter ] = this.selection.get_selected();

 // Set the label to read off the values stored in the current selection
 this._label.set_label ("\
" +
 this._listStore.get_value (iter, 0) + " " +
 this._listStore.get_value (iter, 1) + " " +
 this._listStore.get_value (iter, 2) + "\
" +
 this._listStore.get_value (iter, 3));

 }

});

// Run the application
let app = new TreeViewExample ();
app.application.run (ARGV);



text
text
_
Michael Hill
Beim Übersetzen helfen
Um mit der Übersetzung zu beginnen, müssen Sie zunächst
Sie können sich mit GNOME-Übersetzern im
Alternativ können Sie das Internationalisierungsteam über dessen
Tutorial für Einsteiger (Python)
2012 2013
Jim Campbell
python
Tutorial
Einfache Fenster
Einführung
Dialoge
link
Vala
_
Klassen in JavaScript
Anwendung ausführen

Planung der grafischen Benutzeroberfläche
Asynchrone Aufrufe
Die verschiedenen Teile des Programms

var Gtk = imports.gi.Gtk;
const WeatherService = imports.geonames;
// Initialize the gtk
Gtk.init(null, 0);
//create your window, name it and connect the x to quit function. Remember that window is a taken word
var weatherwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL});
weatherwindow.title = "Todays weather";
//Window only accepts one widget and a title. Further structure with Gtk.boxes of similar
weatherwindow.connect("destroy", function(){Gtk.main_quit()});

weatherwindow.show_all();
//and run it
Gtk.main();
var grid = new Gtk.Grid();
weatherwindow.add(grid);

//We initialize the icon here, but deside the file later in geonames.js.
var weatherIcon = new Gtk.Image();

//Set some labels to your window
var label1 = new Gtk.Label({label: ""});
var label2 = new Gtk.Label({label: "Looking in the sky..."});
var label3 = new Gtk.Label({label: ""});

var entry = new Gtk.Entry();
entry.set_width_chars(4);
entry.set_max_length(4);
var label4 = new Gtk.Label({label: "Enter ICAO station for weather: "});
var button1 = new Gtk.Button({label: "search!"});

grid.attach(label4, 2, 1, 1, 1);
grid.attach_next_to(label1,label4,3,1,1);
grid.attach_next_to(label2,label1,3,1,1);
grid.attach_next_to(label3,label2,3,1,1);
grid.attach_next_to(entry,label4,1,1,1);
grid.attach_next_to(button1,entry,1,1,1);
grid.attach_next_to(weatherIcon,label2,1,1,1)
function getWeatherForStation() {
 var station = entry.get_text();

 var GeoNames = new WeatherService.GeoNames(station); //"EFHF";

 GeoNames.getWeather(function(error, weather) {
 //this here works bit like signals. This code will be run when we have weather.
 if (error) {
 label2.set_text("Suggested ICAO station does not exist Try EFHF");
 return; }
 weatherIcon.file = GeoNames.getIcon(weather);

 label1.set_text("Temperature is " + weather.weatherObservation.temperature + " degrees.");
 if (weather.weatherObservation.weatherCondition !== "n/a"){
 label2.set_text("Looks like there is " + weather.weatherObservation.weatherCondition + " in the sky.");
 }
 else {
 label2.set_text("Looks like there is " + weather.weatherObservation.clouds + " in the sky.");
 }
 label3.set_text("Windspeed is " + weather.weatherObservation.windSpeed + " m/s")
 // ...
 });
}
entry.connect("key_press_event", function(widget, event) {
 if (entry.get_text().length === 4) {
 // Enough is enough
 getWeatherForStation();
 }
 return false;
});

button1.connect("clicked", function(){
 getWeatherForStation();
});
Weatherapp.js
#!/usr/bin/gjs
//The previous line is a hash bang tells how to run the script.
// Note that the script has to be executable (run in terminal in the right folder: chmod +x scriptname)

var Gtk = imports.gi.Gtk;

const WeatherService = imports.geonames;
//Bring your own library from same folder (as set in GJS_PATH). If using autotools .desktop will take care of this

// Initialize the gtk
Gtk.init(null, 0);
//create your window, name it and connect the x to quit function. Remember that window is a taken word
var weatherwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL});
weatherwindow.title = "Todays weather";
//Window only accepts one widget and a title. Further structure with Gtk.boxes of similar
weatherwindow.connect("destroy", function(){Gtk.main_quit()});
//We initialize the icon here, but deside the file later in geonames.js.

var weatherIcon = new Gtk.Image();

//Set some labels to your window
var label1 = new Gtk.Label({label: ""});
var label2 = new Gtk.Label({label: "Looking in the sky..."});
var label3 = new Gtk.Label({label: ""});

var grid = new Gtk.Grid();
weatherwindow.add(grid);

var entry = new Gtk.Entry();
entry.set_width_chars(4);
entry.set_max_length(4);
var label4 = new Gtk.Label({label: "Enter ICAO station for weather: "});
var button1 = new Gtk.Button({label: "search!"});

//some weather

entry.connect("key_press_event", function(widget, event) {
 // FIXME: Get weather on enter (key 13)
 if (entry.get_text().length === 4) {
 // Enough is enough
 getWeatherForStation();
 }
 return false;
});

button1.connect("clicked", function(){
 getWeatherForStation();
});

function getWeatherForStation() {
 var station = entry.get_text();

 var GeoNames = new WeatherService.GeoNames(station); //"EFHF";

 GeoNames.getWeather(function(error, weather) {
 //this here works bit like signals. This code will be run when we have weather.
 if (error) {
 label2.set_text("Suggested ICAO station does not exist Try EFHF");
 return; }
 weatherIcon.file = GeoNames.getIcon(weather);

 label1.set_text("Temperature is " + weather.weatherObservation.temperature + " degrees.");
 if (weather.weatherObservation.weatherCondition !== "n/a"){
 label2.set_text("Looks like there is " + weather.weatherObservation.weatherCondition + " in the sky.");
 }
 else {
 label2.set_text("Looks like there is " + weather.weatherObservation.clouds + " in the sky.");
 }
 label3.set_text("Windspeed is " + weather.weatherObservation.windSpeed + " m/s")
 // ...
 });
}

grid.attach(label4, 2, 1, 1, 1);
grid.attach_next_to(label1,label4,3,1,1);
grid.attach_next_to(label2,label1,3,1,1);
grid.attach_next_to(label3,label2,3,1,1);
grid.attach_next_to(entry,label4,1,1,1);
grid.attach_next_to(button1,entry,1,1,1);
grid.attach_next_to(weatherIcon,label2,1,1,1)
weatherwindow.show_all();
//and run it
Gtk.main();
Autotools und Symbole

Autotools und erforderliche Dateien
weatherapp.desktop
weatherapp.sh.in
#!/bin/sh
export GJS_PATH=@bindir@
gjs @bindir@/weatherapp.js
autohen.sh
appicondir=$(datadir)/icons/hicolor/scalable/apps
appicon_DATA=weather-icon.svg
geonames.js
text
Fenster (C)
Fenster
text
Fenster (JavaScript)
Ein einfaches Fenster, welches weitere Widgets enthalten kann.
Eine minimale GtkApplication
In diesem Beispiel verwenden wir Folgendes:

Fenster (Python)
Eine minimale GTK+-Anwendung: ein Fenster mit einem Titel.
text
Fenster (Vala)
Die einfachste Gtk.Application


external ref='media/ubuntu.png' md5='40845e4a40b335b1958da1403f01c13f'_
external ref='media/fedora.png' md5='19add55f4349fd9e90f3a50b344ba626'_
external ref='media/opensuse.png' md5='a852a94199328e2f978c7f6a55bf8b54'
Manuelle Installation

Erforderliche Versionen
Anjuta - 3.0
Devhelp - 3.0
Glade - 3.10
Natürlich wird auch jede neuere Version funktionieren. Wir wünschen Ihnen nun viel Spaß mit den
external ref='media/03_jssignal_02b.png' md5='__failed__'
Automatische Installation_
external ref='media/menubutton.png' md5='1feb7b836a522c3007079d4420621d9d'
gnome-doc-list@gnome.org
shaunm@gnome.org

jhs@gnome.org
chrisk@openismus.com
"UTF-8"
NULL
shaunm
dgsiegel@gnome.org
jwendell@gnome.org
@@image: 'media/guitar-tuner.png'; md5=f0b7ed4cdc2729d2d0f4d38b829db61e

Ubuntu
Fedora
Weitere