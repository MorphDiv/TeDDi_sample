# language_name_wals:	German
# language_name_glotto:	German
# ISO_6393:	deu
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/de.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

GNOME Barrierefreiheitshandbuch für Entwickler
Das GNOME Barrierefreiheitshandbuch ist für Entwickler bestimmt, die sicherstellen wollen, dass ihre Bemühungen dem größtmöglichen Anwenderkreis zu Gute kommen. Dieses Handbuch deckt auch die Erfordernisse des US-Rehabilitationsgesetzes 508 ab.
2008
Vincent Alexander
2001, 2002
Calum Benson, Brian Cameron, Bill Haneman, Padraig O'Briain, Sharon Snider
GNOME-Dokumentationsprojekt
Das vorliegende Dokument kann gemäß den Bedingungen der GNU Free Documentation License (GFDL), Version 1.1 oder jeder späteren, von der Free Software Foundation veröffentlichten Version ohne unveränderbare Abschnitte sowie ohne Texte auf dem vorderen und hinteren Buchdeckel kopiert, verteilt und/oder modifiziert werden. Eine Kopie der GFDL finden Sie unter diesem
Das vorliegende Handbuch ist Teil einer Reihe von GNOME-Handbüchern, die unter der GFDL verteilt werden. Wenn Sie dieses Handbuch separat verteilen möchten, können Sie dies tun, indem Sie dem Handbuch eine Kopie der Lizenz, wie in Abschnitt 6 der Lizenz beschrieben, hinzufügen.
Bei vielen der von Firmen zur Unterscheidung ihrer Produkte und Dienstleistungen verwendeten Namen handelt es sich um Marken. An den Stellen, an denen derartige Namen in einer GNOME-Dokumentation vorkommen und wenn die Mitglieder des GNOME-Dokumentationsprojekts über diese Marken informiert wurden, sind die Namen in Großbuchstaben oder mit großen Anfangsbuchstaben geschrieben.
DAS DOKUMENT WIRD »WIE VORLIEGEND« GELIEFERT, OHNE JEGLICHE GEWÄHRLEISTUNG, WEDER AUSDRÜCKLICH NOCH STILLSCHWEIGEND, EINSCHLIESSLICH, ABER NICHT BESCHRÄNKT AUF, GEWÄHRLEISTUNGEN, DASS DAS DOKUMENT ODER EINE MODIFIZIERTE VERSION DES DOKUMENTS FREI VON HANDELSÜBLICHEN FEHLERN UND FÜR EINEN BESTIMMTEN ZWECK GEEIGNET IST UND KEINE RECHTE DRITTER VERLETZT. JEGLICHES RISIKO IN BEZUG AUF DIE QUALITÄT, GENAUIGKEIT UND LEISTUNG DES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS TRAGEN SIE. SOLLTE SICH EIN DOKUMENT ODER EINE MODIFIZIERTE VERSION DAVON IN IRGENDEINER WEISE ALS FEHLERHAFT ERWEISEN, TRAGEN SIE (NICHT DER URSPRÜNGLICHE VERFASSER, AUTOR ODER EIN MITWIRKENDER) DIE KOSTEN FÜR JEGLICHE ERFORDERLICHE SERVICE-, REPARATUR- UND KORREKTURMASSNAHMEN: DIESE BESCHRÄNKUNG DER GEWÄHRLEISTUNG IST WESENTLICHER BESTANDTEIL DIESER LIZENZ. JEDE VERWENDUNG EINES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS UNTERLIEGT DIESER BESCHRÄNKUNG; UND
UNTER KEINEN UMSTÄNDEN UND GEMÄSS KEINER RECHTSLEHRE, WEDER AUFGRUND VON UNERLAUBTEN HANDLUNGEN (EINSCHLIESSLICH FAHRLÄSSIGKEIT), VERTRÄGEN ODER SONSTIGEM, KANN DER AUTOR, DER URSPRÜNGLICHE VERFASSER, EIN MITWIRKENDER ODER EIN VERTEILER DES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS ODER EIN LIEFERANT EINER DIESER PARTEIEN VON EINER PERSON FÜR DIREKTE, INDIREKTE, BESONDERE, ZUFÄLLIGE ODER ALS FOLGE AUFGETRETENE SCHÄDEN IRGENDEINER ART, EINSCHLIESSLICH, ABER NICHT BESCHRÄNKT AUF, SCHÄDEN DURCH GESCHÄFTSWERTVERLUSTE, ARBEITSAUSFÄLLE, COMPUTERAUSFÄLLE ODER FUNKTIONSSTÖRUNGEN ODER JEGLICHE ANDERE SCHÄDEN ODER VERLUSTE, DIE DURCH ODER IM ZUSAMMENHANG MIT DER VERWENDUNG DES DOKUMENTS ODER EINER MODIFIZIERTEN VERSION DES DOKUMENTS ENTSTANDEN SIND, SELBST WENN DIESE PARTEI ÜBER MÖGLICHE SCHÄDEN INFORMIERT WORDEN SEIN SOLLTE, HAFTBAR GEMACHT WERDEN.
DAS DOKUMENT UND MODIFIZIERTE VERSIONEN DES DOKUMENTS WERDEN GEMÄSS DEN BEDINGUNGEN DER GNU FREE DOCUMENTATION LICENSE MIT DER FOLGENDEN VEREINBARUNG BEREITGESTELLT:
Vincent
Alexander
Calum
Benson
Brian
Cameron
Bill
Haneman
Padraig
O'Briain
Sharon
Snider
GNOME 2.24 Barrierefreiheitshandbuch für Entwickler V2.24.0
September 2008
Dieses Handbuch beschreibt Version 2.24 der GNOME-Arbeitsumgebung.
Rückmeldungen
Wenn Sie Fehler finden oder Vorschläge zur GNOME-Arbeitsumgebung oder diesem Handbuch haben, folgen Sie den Anweisungen auf der
Was ist Barrierefreiheit?
Barrierefreiheit bedeutet, Menschen mit Behinderungen zu helfen, an grundlegenden Lebensaktivitäten teilzunehmen. Das beinhaltet einer Arbeit nachzugehen und Dienste, Produkte und Informationen zu nutzen.
Im Zusammenspiel mit möglicherweise notwendigen Hilfstechnologien wie Sprachausgaben, Bildschirmlesern oder alternativen Eingabegeräten wird Menschen mit vorübergehenden oder dauernden Behinderungen die Nutzung der GNOME-Arbeitsumgebung und deren Anwendungen ermöglicht. Hilfstechnologien können auch sinnvoll sein, wenn Rechner außerhalb von Zuhause oder Büro genutzt werden. Wenn Sie beispielsweise im Stau stehen, werden Sie vielleicht die Spracheingabe und -ausgabe für E-Mail-Nachrichten bevorzugen.
Hilfstechnologien empfangen Informationen von Anwendungen über die Schnittstelle des »Accessibility Toolkit (ATK)«, welches Sie im Modul »atk« des GNOME-Softwarebestandes finden. Da die Unterstützung für die Barrierefreiheits-Schnittstelle bereits in die GNOME-Widgets eingebaut ist, sollte Ihr GNOME-Programm Hilfstechnologien bereits grundlegend unterstützen, ohne dass Mehraufwand Ihrerseits notwendig wäre. Beispielsweise können Hilfstechnologien automatisch die Beschriftungen lesen, die Sie irgendwo in der Benutzeroberfläche platzieren, mit Hilfe von GTK-Funktionsaufrufen wie
Mit geringem Mehraufwand können Sie Ihr Programm besser auf die Zusammenarbeit mit Hilfstechnologien trimmen. Sie helfen in erster Linie bestimmten Benutzergruppen, machen Ihr Programm aber auch attraktiver für Endanwender im Verwaltungs- und Bildungssektor, wo barrierefreie Anwendungen oft gesetzlich vorgeschrieben sind.
Arten von Behinderungen
Allein in den USA leben schätzungsweise 30 Millionen Menschen, deren Fähigkeit zur Benutzung von Rechnern durch nicht barrierefreies Design eingeschränkt ist. Weltweit haben etwa 8% der Nutzer des World Wide Web irgendeine Art von Behinderung. Solche Behinderungen fallen in eine dieser Kategorien:
Wie funktioniert Barrierefreiheit in GNOME?
Die GNOME Barrierefreiheits-Architektur
Diagramm der GNOME Barrierefreiheits-Architektur
Schnelleinstieg für Entwickler
Eine gekürzte Liste häufiger ATK-Aufrufe finden Sie
Einführung in ATK, AT-SPI, GAIL und GTK+
{
 AtkObject *obj;
 obj = gtk_widget_get_accessible(button);
 atk_object_set_description(obj,_("Closes the window"));
}
{
 GtkWidget *widget;
 GtkLabel *label;

 AtkObject *atk_widget, *atk_label;
 AtkRelationSet *relation_set;
 AtkRelation *relation;
 AtkObject *targets[1];

 atk_widget = gtk_widget_get_accessible(widget);
 atk_label = gtk_widget_get_accessible (GTK_WIDGET(label));

 relation_set = atk_object_ref_relation_set (atk_label);
 targets[0] = atk_widget;

 relation = atk_relation_new(targets,1, ATK_RELATION_LABEL_FOR);
 atk_relation_set_add(relation_set,relation);
 g_object_unref(G_OBJECT(relation));
}
Die Barrierefreiheits-API
API
Beschreibung
AtkObject* gtk_widget_get_accessible (GtkWidget*)
void atk_object_set_name (AtkObject*, const gchar*)
void atk_object_set_description (AtkObject*, const gchar*)
AtkRelation* atk_relation_new (AtkObject**, gint, AtkRelationType)
void atk_image_set_description (AtkImage*, const gchar*)
Beispiele für die Nutzung der Barrierefreiheits-API
{
 AtkObject *obj;
 obj = gtk_widget_get_accessible(button);
 atk_object_set_description(obj,_("Opens Preferences dialog"));
}
{
 GtkWidget *widget;
 GtkLabel *label;

 AtkObject *atk_widget, *atk_label;
 AtkRelationSet *relation_set;
 AtkRelation *relation;
 AtkObject *targets[1];

 atk_widget = gtk_widget_get_accessible (widget);
 atk_label = gtk_widget_get_accessible (GTK_WIDGET(label));

 relation_set = atk_object_ref_relation_set (atk_label);
 targets[0] = atk_widget;

 relation = atk_relation_new(targets,1, ATK_RELATION_LABEL_FOR);
 atk_relation_set_add(relation_set,relation);
 g_object_unref(G_OBJECT(relation));
}
GTK-Module
setenv GTK_MODULES "libgail:libtestprops"
atk_add_focus_tracker (_my_focus_tracker);
wobei
void _my_focus_tracker (AtkObject *aobject);
mouse_watcher_focus_id = atk_add_global_event_listener(_my_global_listener,"Gtk:GtkWidget:enter_notify_event");
AtkObject *root_obj = atk_get_root();
ATK_IS_ACTION(atkobj)
ATK_IS_COMPONENT(atkobj)
table_column_inserted_id = g_signal_connect_closure_by_id(my_atk_obj, 
g_signal_lookup("column_inserted", G_OBJECT_TYPE(my_atk_obj)),0,g_cclosure_new(G_CALLBACK (_my_table_column_inserted_func),NULL,NULL), FALSE);
child_added_id = g_signal_connect_closure (my_atk_obj,"children_changed::add", g_cclosure_new (G_CALLBACK(_my_children_changed_func),NULL,NULL),FALSE);
Implementieren eines ATK-Objekts
default_registry = atk_get_default_registry();
atk_registry_set_factory_type (default_registry, GTK_TYPE_MYTYPE, MYATKIMP_TYPE_MYTYPE_FACTORY);
static const GInterfaceInfo atk_text_info = 
{ 
 (GInterfaceInitFunc) atk_text_interface_init, 
 (GInterfaceFinalizeFunc) NULL, 
 NULL 
}; 

g_type_add_interface_static (type, ATK_TYPE_TEXT, 
 &atk_text_info);
void atk_text_interface_init (AtkTextIface *iface);
void 
atk_text_interface_init (AtkTextIface *iface) 
{ 
 g_return_if_fail (iface != NULL); 
 iface-gt;get_text = myatkimp_mytype_get_text; 
 iface-gt;get_character_at_offset = myatkimp_mytype_get_character_at_offset; 
 ... 
}

GType 
myatkimp_mytype_get_type (void) 
{ 
 static GType type = 0; 

 if (!type) 
 { 
 static const GTypeInfo tinfo = 
 { 
 sizeof (GailLabelClass), 
 (GBaseInitFunc) NULL, /* base init */ 
 (GBaseFinalizeFunc) NULL, /* base finalize */
 (GClassInitFunc) myatkimp_mytype_class_init, /* class init */ 
 (GClassFinalizeFunc) NULL, /* class finalize */ 
 NULL, /* class data */ 
 sizeof (GailLabel), /* instance size */ 
 0, /* nb preallocs */ 
 (GInstanceInitFunc) myatkimp_mytype_instance_init, /* instance init */ 
 NULL /* value table */ 
 }; 

 /* Set up atk_text_info structure used below */ 
 static const GInterfaceInfo atk_text_info = 
 { 
 (GInterfaceInitFunc) atk_text_interface_init, 
 (GInterfaceFinalizeFunc) NULL, 
 NULL 
 }; 

 /* Set up typename and specify parent type */ 
 type = g_type_register_static (MYATKIMP_MYPARENTTYPE, 
 "MyatkimpMytype", &tinfo, 0); 

 /* This class implements interface ATK_TYPE_TEXT */ 
 g_type_add_interface_static (type, ATK_TYPE_TEXT, 
 &atk_text_info); 
 } 
 return type; 
}
myatkimp_mytype_class_init (GailLabelClass *klass) 
{ 
 AtkObjectClass *class = ATK_OBJECT_CLASS (klass); 
 class-gt;get_name = myatkimp_mytype_get_name; 
}
static ParentObjectType *parent_class = NULL; 

myatkimp_mytype_class_init (GailLabelClass *klass) 
{ 
 ParentObjectType *parent_class = (ParentObjectType*)klass; 

 /* 
 * Caching the parent_class is necessary if the init, 
 * notify_gtk, or finalize functions are set up. 
 */ 
 parent_class = g_type_class_ref (MYATKIMP_TYPE_PARENT); 

 parent_class-gt;init = myatkimp_mytype_widget_init; 
 parent_class-gt;notify_gtk = myatkimp_mytype_real_notify_gtk; 
 parent_class-gt;finalize = myatkimp_mytype_finalize; 
}
parent-gt;init
void 
gail_tree_view_widget_init (MyatkimpMytype *mytype, 
 GtkWidget *gtk_widget) 
{ 
 /* Make sure to call the parent's init function */ 
 parent_class-gt;init (widget, gtk_widget); 
 
 /* Cache a value in the ATK implementation */ 
 mytype-gt;cached_value = gtk_widget_function_call(); 

 /* Listen to a signal */ 
 gtk_signal_connect (GTK_OBJECT (gtk_widget), 
 "signal-type", 
 GTK_SIGNAL_FUNC (_myatkimp_mytype_signal_type), 
 NULL); 
}
parent-gt;notify_gtk
void 
myatkimp_mytype_real_notify_gtk (GObject *obj, 
 GParamSpec *pspec) 
{ 
 GtkWidget *widget = GTK_WIDGET (obj); 
 AtkObject* atk_obj = gtk_widget_get_accessible (widget); 

 if (strcmp (pspec-gt;name, "property-of-interest") == 0) 
 { 
 /* Handle the property change. */ 
 } 
 else 
 { 
 parent_class-gt;notify_gtk (obj, pspec); 
 } 
}
parent-gt;finalize
void 
myatkimp_mytype_finalize (GObject *object) 
{ 
 MyAtkimpMyType *my_type = MYATKIMP_MYTYPE (object); 

 g_object_unref (my_type-gt;cached_value); 
 G_OBJECT_CLASS (parent_class)-gt;finalize (object); 
}
Richtlinien für Benutzeroberflächen zur Unterstützung der Barrierefreiheit
Allgemein
Tastatursteuerung
Maus-Interaktion
Grafische Elemente
Schriften und Text
Beispiele für Schriften und Text
Farbe und Kontrast
Beispiele für Farbe und Kontrast
Einstellungen
Vergrößerung
Klänge
Tastaturfokus
Beispiele für den Tastaturfokus
Dokumentation
Dokumentations-Checkliste
Accerciser
Accerciser und die GNOME-Barrierefreiheits-Architektur

Mario Blättermann <mariobl\@gnome\.org>, 2009
Schnelleinführung in die Optimierung von GNOME-Programmen
Dies ist eine kurze Einführung in die Optimierung und behandelt sowohl das Wie als auch das Warum. Details zu individuellen Werkzeugen verschieben wir auf spätere Artikel, eine Sammlung aus Hinweisen und Tricks ist jedoch enthalten.
Was optimieren wir?
Sie sollten bei der Optimierung für GNOME zunächst eines bedenken: Wir versuchen nicht, das Programm zu verbessern, sondern wir versuchen, die Benutzer glücklicher zu machen.
Bessere Programme machen die Benutzer glücklicher, aber es gibt Verbesserungsmöglichkeiten, die sie viel glücklicher machen werden als Andere: Ansprechzeit, Startzeit, leichter Zugriff auf Befehle. Der Rechner sollte auch nicht sofort den Auslagerungsspeicher benutzen müssen, wenn mehr als eine Anwendung geöffnet ist.
Die traditionelle Optimierung umfasst Konzepte wie Prozessorlast, Umfang des Codes, die Anzahl der Mausklicks sowie die Speichernutzung des Programms. Die folgende Auflistung sollte die erste Liste ergänzen, wobei ein grundlegender Unterschied besteht: Ein GNOME-Benutzer schenkt der zweiten Liste keine Beachtung, während der ersten Liste sehr wohl Aufmerksamkeit gewidmet wird. Beim Optimieren von GNOME-Programmen sollen die Prozessorlast, der Speicherverbrauch und all diese Dinge optimiert werden, aber das sind die Bedeutungen, nicht das Endziel. Wir optimieren für Benutzer.
Ausführung der Optimierung
Aus dem vorigen Abschnitt wurde deutlich: Um etwas optimieren zu können, muss es messbar sein. Sie können Zufriedenheit nicht messen, aber Sie können sehr wohl Startzeiten messen, um sagen zu können, dass Sie sie verbessert haben. Die Zufriedenheit wird dann - hoffentlich - folgen.
Vergessen Sie nicht das Gesamtbild.
Hinweise
Die Grundlagen
Stellen Sie sicher, dass Ihr Code korrekt und fehlerfrei ist, bevor Sie mit der Optimierung beginnen. Überprüfen Sie nach der Optimierung, ob dies dann auch noch zutrifft.
Fallen für die Unvorsichtigen
Verhindern Sie Nebeneffekte.
Vergessen Sie nicht den Ressourcenverbrauch des X-Servers. Der Speicherverbrauch Ihres Programms enthält nicht die Pixmaps, die vom X-Server verarbeitet werden, aber sie verbrauchen dennoch Speicher. Verwenden Sie
Gliedern Sie Code aus Schleifen aus. Ein etwas umfangreicheres Stück Code, das nur einmal ausgeführt wird, ist um Einiges schneller als ein simples Stück Code, was dafür tausend Schleifen durchläuft. Vermeiden Sie es, langsamen Code allzu oft aufzurufen.
Geben Sie dem Compiler so viele Hinweise wie möglich. Verwenden Sie das const-Schlüsselwort. Verwenden Sie
Verwenden Sie keine Assemblersprachen. Sie sind nicht portierbar. Während sie auf dem einen Prozessor unglaublich schnell sind, ist nicht unbedingt garantiert, dass dies auf jedem von der Architektur unterstützten Prozessor genauso ist (beispielsweise Athlon vs Pentium 4).
Schreiben Sie eine vorhandene Bibliotheksroutine nicht neu, es sei denn, Sie sind sich sicher, dass sie unakzeptabel langsam ist. Viele prozessorintensive Bibliotheksroutinen wurden bereits optimiert. Andererseits sind einige Routinen tatsächlich langsam, insbesondere diejenigen, die Systemaufrufe an das Betriebssystem absetzen.
Halten Sie die Zahl der verlinkten Bibliotheken gering. Je weniger Bibliotheken gelinkt werden müssen, umso schneller startet das Programm. Dies ist in GNOME allerdings schwierig.
Falls alles Andere scheitern sollte, informieren Sie den Benutzer mit einem Fortschrittsbalken drüber, dass es derzeit nur langsam voran geht. Das dürfte ihm lieber sein, als wenn Sie nur die Ergebnisse präsentieren würden. Er möchte zumindest wissen, dass das Programm nicht abgestürzt ist und er dann erst einmal eine Tasse Kaffee trinken gehen kann.
Verwendung von
Ihre Befehlszeile sollte daher so aussehen:
valgrind --tool=massif --depth=5 --alloc-fn=g_malloc --alloc-fn=g_realloc --alloc-fn=g_try_malloc \\
 --alloc-fn=g_malloc0 --alloc-fn=g_mem_chunk_alloc same-gnome
Das Programm
Interpretieren der Ergebnisse
Die grafische Ausgabe von
Die Textdatei ist hierarchisch in Abschnitte gegliedert. Am oberen Ende finden sich die größten Speicherverbraucher, in absteigender Ordnung nach Speicherzeit. Darunter finden sich weitere Abschnitte, die je nach dem Platz im Aufruf-Stack feiner detaillierter sind. Um dies zu verdeutlichen, verwenden wir die Ausgabe des oben stehenden Befehls.
Command: ./same-gnome 

== 0 ===========================
Heap allocation functions accounted for 90.4% of measured spacetime

Called from:
 28.8% : 0x6BF83A: gdk_pixbuf_new (in /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)

 6.1% : 0x5A32A5: g_strdup (in /usr/lib/libglib-2.0.so.0.400.6)

 5.9% : 0x510B3C: (within /usr/lib/libfreetype.so.6.3.7)

 3.5% : 0x2A4A6B: __gconv_open (in /lib/tls/libc-2.3.3.so)
== 4 ===========================
Context accounted for 28.8% of measured spacetime
 0x6BF83A: gdk_pixbuf_new (in /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)
 0x3A998998: (within /usr/lib/gtk-2.0/2.4.0/loaders/libpixbufloader-png.so)
 0x6C2760: (within /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)
 0x6C285E: gdk_pixbuf_new_from_file (in /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)

Called from:
 27.8% : 0x804C1A3: load_scenario (same-gnome.c:463)

 0.9% : 0x3E8095E: (within /usr/lib/libgnomeui-2.so.0.792.0)

 and 1 other insignificant place
Interpretieren der Ergebnisse
Command: ./same-gnome 

== 0 ===========================
Heap allocation functions accounted for 87.6% of measured spacetime

Called from:
 7.7% : 0x5A32A5: g_strdup (in /usr/lib/libglib-2.0.so.0.400.6)

 7.6% : 0x43BC9F: (within /usr/lib/libgdk-x11-2.0.so.0.400.9)

 6.9% : 0x510B3C: (within /usr/lib/libfreetype.so.6.3.7)

 5.2% : 0x2A4A6B: __gconv_open (in /lib/tls/libc-2.3.3.so)
== 1 ===========================
Context accounted for 7.7% of measured spacetime
 0x5A32A5: g_strdup (in /usr/lib/libglib-2.0.so.0.400.6)

Called from:
 1.8% : 0x8BF606: gtk_icon_source_copy (in /usr/lib/libgtk-x11-2.0.so.0.400.9)

 1.1% : 0x67AF6B: g_param_spec_internal (in /usr/lib/libgobject-2.0.so.0.400.6)

 0.9% : 0x91FCFC: (within /usr/lib/libgtk-x11-2.0.so.0.400.9)

 0.8% : 0x57EEBF: g_quark_from_string (in /usr/lib/libglib-2.0.so.0.400.6)

 and 155 other insignificant places
Optimieren von GNOME-Software
Callum McKenzie
Robert Love
McKenzie
Robert
Love
0.1
William Johnston
Erstmalige Umwandlung in das DocBook-Format.
Die Optimierung von Software kann verschiedene Ziele verfolgen: Geschwindigkeit, Programmgröße oder Speicherverbrauch. Dieser Abschnitt enthält Leitfäden und Anleitungen zum Optimieren Ihrer Software.