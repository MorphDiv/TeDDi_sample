# language_name_wals:	Greek (Modern)
# language_name_glotto:	Modern Greek
# ISO_6393:	ell
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Grek
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/el.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

Προγραμματισμός με
Murray
Cumming
Bernhard
Rieder
Κεφάλαιο "Όρια χρόνου".
Jonathon
Jongsma
Κεφάλαιο "Σχεδίαση με Cairo".
Κεφάλαιο "Εργασία με πηγαίο κώδικα του gtkmm".
Κεφάλαιο "Πρόσφατα αρχεία".
Ole
Laursen
Μέρη του κεφαλαίου "Διεθνοποίηση".
Marko
Anastasov
Κεφάλαιο "Εκτύπωση".
Daniel
Elstner
Ενότητα "Δημιουργία δομής" του κεφαλαίου "Συσκευασία βιβλιοθηκών C με gmmproc".
Chris
Vine
Κεφάλαιο "Πολυνηματικά προγράμματα".
David
King
Ενότητα στο Gtk::Πλέγμα.
Pedro
Ferreira
Κεφάλαιο στα συμβάντα πληκτρολογίου.
Kjell
Ahlstedt
Μέρη της ενημέρωσης από gtkmm 2 σε gtkmm 3.
Αυτό το βιβλίο εξηγεί βασικές έννοιες του
2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
Murray Cumming
Επιτρέπεται η αντιγραφή, η διανομή και/ή τροποποίηση αυτού του εγγράφου υπό τους όρους της Ελεύθερης άδειας τεκμηρίωσης GNU, έκδοσης 1.2 ή σε οποιαδήποτε μεταγενέστερη, όπως αυτή δημοσιεύεται από το Ίδρυμα ελεύθερου λογισμικού· χωρίς αμετάβλητα τμήματα, χωρίς κείμενα εξωφύλλου ή οπισθόφυλλου. Μπορείτε να λάβετε ένα αντίγραφο της Ελεύθερης άδειας τεκμηρίωσης GNU από το Ίδρυμα ελεύθερου λογισμικού επισκεπτόμενοι τον ιστότοπό τους ή γράφοντας στο: Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
Εισαγωγή
Αυτό το βιβλίο
Αυτό το βιβλίο εξηγεί βασικές έννοιες του
Αυτό το βιβλίο υποθέτει καλή κατανόηση της C++ και πώς να δημιουργείτε προγράμματα C++.
Θα θέλαμε πάρα πολύ να ακούσουμε οποιαδήποτε προβλήματα έχετε μαθαίνοντας το
gtkmm
Η
Η
Γιατί χρησιμοποιούμε τη
Η
Η
Η κληρονομικότητα μπορεί να χρησιμοποιηθεί για παραγωγή νέων γραφικών συστατικών. Η παραγωγή νέων γραφικών συστατικών σε κώδικα GTK+ C είναι τόσο περίπλοκη και επιρρεπής σε σφάλματα που σχεδόν κανένας κωδικοποιητής C δεν το κάνει. Ως προγραμματιστής C++, ξέρετε ότι η παραγωγή είναι μια βασική αντικειμενοστραφής τεχνική.
Μπορούν να χρησιμοποιηθούν στιγμιότυπα μελών, απλοποιώντας τη διαχείριση μνήμης. Όλα τα γραφικά συστατικά GTK+ C αντιμετωπίζονται με τη χρήση δεικτών.Ως κωδικοποιητής C++, ξέρετε ότι οι δείκτες πρέπει να αποφεύγονται, όπου είναι δυνατό.
Η
Η
Η Qt του Trolltech είναι ο πλησιέστερος ανταγωνιστής με τη
Οι προγραμματιστές της
Η
Η
Εγκατάσταση
Εξαρτήσεις
Πριν την προσπάθεια εγκατάστασης του
libsigc++ 2.0
GTK+ 3.0
glibmm
cairomm
pangomm
atkmm
Αυτές οι εξαρτήσεις έχουν τις δικές τους εξαρτήσεις, συμπεριλαμβανόμενων των ακόλουθων εφαρμογών και βιβλιοθηκών:
pkg-config
glib
ATK
Pango
cairo
gdk-pixbuf
Γιούνιξ και Λίνουξ
Προκατασκευασμένα πακέτα
Οι πρόσφατες εκδόσεις της
Τα ονόματα των πακέτων της
Τα ονόματα του πακέτου δεν θα αλλάζουν όταν νέες συμβατές εκδόσεις API/ABI της
Εγκατάσταση από την πηγή
Αν η διανομή σας δεν παρέχει ένα προκατασκευασμένο πακέτο της
Αφού έχετε εγκαταστήσει όλες τις εξαρτήσεις, μεταφορτώστε τον πηγαίο κώδικα της
# ./configure
# make
# make install
Να θυμάστε ότι σε ένα λειτουργικό σύστημα Γιούνιξ ή Λίνουξ θα χρειαστείτε προφανώς να είσαστε
Το σενάριο
Από προεπιλογή, η
Θα πρέπει να είστε πολύ προσεκτικοί κατά την εγκατάσταση σε τυπικά προθέματα συστήματος όπως
Αν θέλετε να βοηθήσετε στην ανάπτυξη της
Microsoft Windows
Οι GTK+ και
Τα βασικά
Αυτό το κεφάλαιο θα εισάγει μερικές από τις πιο σημαντικές πτυχές της κωδικοποίησης της
Η υπάρχουσα γνώση της C++ θα σας βοηθήσει με τη
Απλό παράδειγμα
Για να ξεκινήσουμε την εισαγωγή μας στη
Πηγαίος κώδικας
Θα εξηγήσουμε τώρα κάθε γραμμή του παραδείγματος
#include &lt;gtkmm.hgt;
Όλα τα προγράμματα της
Glib::RefPtrlt;Gtk::Applicationgt; app = Gtk::Application::create(argc, argv, "org.gtkmm.examples.base")·
Η επόμενη πρόταση:
Οι επόμενες δύο γραμμές κώδικα δημιουργούν ένα παράθυρο και ορίζουν το προεπιλεγμένο (αρχικό) μέγεθος τους:
Gtk::Window window;
window.set_default_size(200, 200);
Η τελευταία γραμμή εμφανίζει το παράθυρο και εισάγει τον κύριο βρόχο επεξεργασίας της
return app-gt;run(window);
g++ simple.cc -o simple `pkg-config gtkmm-3.0 --cflags --libs`
Μετά την εισαγωγή του πηγαίου κώδικα στη
Κεφαλίδες και σύνδεση
Αν και έχουμε εμφανίσει την εντολή μεταγλώττισης για το απλό παράδειγμα, θα πρέπει πραγματικά να χρησιμοποιήσετε τα εργαλεία automake και autoconf, όπως περιγράφονται στο "Autoconf, Automake, Libtool", από τον G. V. Vaughan κ.α. Τα χρησιμοποιούμενα παραδείγματα σε αυτό το βιβλίο περιλαμβάνονται στο πακέτο
Για απλοποίηση της μεταγλώττισης, χρησιμοποιούμε
PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.8.0])
Όμως, αυτό είναι ακόμα πιο απλό όταν χρησιμοποιείται η μακροεντολή
gtkmm-3.0 είναι το όνομα της τρέχουσας σταθερής API. Υπήρξε μια παλιότερη API που λεγότανε gtkmm-2-4 που εγκαθίσταται παράλληλα όταν είναι διαθέσιμη. Υπήρξαν πολλές εκδόσεις του gtkmm-2.4, όπως gtkmm 2.10 και θα υπάρξουν αρκετές εκδόσεις του gtkmm-3.0 API. Σημειώστε ότι το όνομα API δεν αλλάζει για κάθε έκδοση, επειδή αυτό θα ήταν μια ασύμβατη διακοπή API και ABI. Θεωρητικά, μπορεί να υπάρξει μια μελλοντική API gtkmm-4.0 που θα εγκαθίσταται παράλληλα με το gtkmm-3.0 χωρίς να επηρεάζει τις υπάρχουσες εφαρμογές.
Σημειώστε ότι αν αναφέρετε πρόσθετα αρθρώματα πέρα από το gtkmm-3.0, θα πρέπει να χωρίζονται από διαστήματα, όχι κόμματα.
Openismus έχει περισσότερη
Γραφικά συστατικά
Οι εφαρμογές της
m_box.pack_start(m_Button1);
m_box.pack_start(m_Button2);
m_frame.add(m_box);
Τα γραφικά συστατικά τακτοποιούνται μέσα στα γραφικά συστατικά του περιέκτη όπως σκελετοί (frames) και σημειωματάρια, σε μια ιεραρχία των γραφικών συστατικών μέσα σε γραφικά συστατικά. Μερικά από αυτά τα γραφικά συστατικά του περιέκτη όπως το
Τα περισσότερα από τα κεφάλαια σε αυτό το βιβλίο πραγματεύονται ειδικά γραφικά συστατικά. Δείτε την ενότητα
Αν και μπορείτε να ορίσετε τη διάταξη και την εμφάνιση των παραθύρων και των γραφικών συστατικών με τον κώδικα C++, θα βρείτε πιο βολικό να σχεδιάσετε τις διεπαφές χρήστη σας με το
Αν και τα στιγμιότυπα γραφικών συστατικών του
Σήματα
Η
m_button1.signal_clicked().connect( sigc::mem_fun(*this,
 &HelloWorld::on_button_clicked) );
Η
Για περισσότερο λεπτομερείς πληροφορίες για τα σήματα, δείτε το
Για πληροφορίες υλοποίησης των δικών σας σημάτων αντί για απλή σύνδεση σε υπάρχοντα σήματα της
Glib::ustring
Μπορεί να εκπλαγείτε μαθαίνοντας ότι η
Το std::string χρησιμοποιεί 8 δυαδικά ψηφία ανά χαρακτήρα, αλλά 8 δυαδικά δεν είναι αρκετά για κωδικοποίηση γλωσσών όπως αραβικά, κινέζικα και ιαπωνικά. Αν και οι κωδικοποιήσεις για αυτές τις γλώσσες έχουν τώρα καθοριστεί από την κοινοπραξία Unicode, οι γλώσσες C και C++ δεν παρέχουν ακόμα καμιά προτυποποιημένη υποστήριξη Unicode. GTK+ και GNOME επιλέγουν την υλοποίηση του Unicode χρησιμοποιώντας UTF-8 και αυτό συσκευάζεται από το Glib::ustring. Παρέχει σχεδόν ακριβώς την ίδια διεπαφή ως std::string, μαζί με αυτόματες μετατροπές προς και από std::string.
Ένα από τα πλεονεκτήματα του UTF-8 είναι ότι δεν χρειάζεστε να το χρησιμοποιήσετε εκτός και το θέλετε, έτσι δεν χρειάζεστε να τροποποιήσετε όλο τον κώδικά σας μονομιάς. Η
Σημειώστε ότι το UTF-8 δεν είναι συμβατό με κωδικοποιήσεις 8 δυαδικών όπως το ISO-8859-1. Για παράδειγμα, τα γερμανικά umlauts δεν είναι στην περιοχή ASCII και χρειάζεται περισσότερο από 1 ψηφιολέξη στην κωδικοποίηση UTF-8. Αν ο κώδικας σας περιέχει κυριολεκτικές συμβολοσειρές 8 δυαδικών, πρέπει να τις μετατρέψετε σε UTF-8 (π.χ. ο βαυαρικός χαιρετισμός "Grüß Gott" πρέπει να είναι "Gr\\xC3\\xBC\\xC3\\x9F Gott").
Θα πρέπει να αποφύγετε τον αριθμητικό δείκτη τεχνοτροπίας C και συναρτήσεις όπως strlen(). Σε UTF-8, κάθε χαρακτήρας μπορεί να χρειαστεί οπουδήποτε από 1 έως 6 ψηφιολέξεις, έτσι δεν είναι δυνατό να θεωρήσετε ότι η επόμενη ψηφιολέξη είναι ένας άλλος χαρακτήρας. Η
Αντίθετα με τη λύση Unicode UCS-2 των Windows, αυτό δεν απαιτεί καμιά ειδική επιλογή μεταγλωττιστή για επεξεργασία κυριολεκτικών συμβολοσειρών και δεν καταλήγει σε εκτελέσιμα Unicode και βιβλιοθήκες που είναι ασύμβατες με τις αντίστοιχες ASCII.
Αναφορά
Δείτε την ενότητα
Ενδιάμεσοι τύποι
Μερικές API που σχετίζονται με τη gtkmm χρησιμοποιούν ενδιάμεσους περιέκτες δεδομένων, όπως



Δεν θα πρέπει να δηλώσετε αυτούς τους τύπους εσείς. Θα πρέπει αντίθετα να χρησιμοποιήσετε τον τυπικό περιέκτη C++ που προτιμάτε. Το glibmm θα το μετατρέψει για σας. Να μερικοί από αυτούς τους ενδιάμεσους τύπους:
Ανάμειξη APIs C και C++
Μπορείτε να χρησιμοποιήσετε APIs C που δεν έχουν ακόμα βολικές διεπαφές C++. Δεν είναι γενικά πρόβλημα να χρησιμοποιήσετε APIs C από C++ και τη
Για να χρησιμοποιήσετε ένα στιγμιότυπο της
Gtk::Button* button = new Gtk::Button("example");
gtk_button_do_something_new(button-gt;gobj());
Για να πάρετε ένα στιγμιότυπο της
GtkButton* cbutton = get_a_button();
Gtk::Button* button = Glib::wrap(cbutton);
Hello World στη
Έχουμε τώρα μάθει αρκετά για να κοιτάξουμε ένα πραγματικό παράδειγμα. Σύμφωνα με μια παλιά παράδοση της επιστήμης των υπολογιστών, θα εισάγουμε τώρα Hello World, στη
Δοκιμάστε να μεταγλωττίσετε και να το εκτελέσετε πριν να συνεχίσουμε. Θα πρέπει να δείτε κάτι σαν αυτό:
Hello World
Αρκετά συναρπαστικό; Ας εξετάσουμε τον κώδικα. Πρώτα, την κλάση
class HelloWorld : public Gtk::Window
{

public:
 HelloWorld()·
 virtual ~HelloWorld();

protected:
 //Signal handlers:
 virtual void on_button_clicked();

 //Member widgets:
 Gtk::Button m_button;
};
Αυτή η κλάση υλοποιεί το παράθυρο "Hello World". Παράγεται από τη
HelloWorld::HelloWorld()
:
 m_button ("Hello World")
{
 set_border_width(10)·
 m_button.signal_clicked().connect(sigc::mem_fun(*this,
 &HelloWorld::on_button_clicked));
 add(m_button);.
 m_button.show();
}
Σημειώστε ότι έχουμε χρησιμοποιήσει μια πρόταση αρχικοποίησης για να δώσουμε στο αντικείμενο
Έπειτα, καλούμε τη μέθοδο
Έπειτα συνδέουμε έναν χειριστή σήματος στο
Κατόπιν, χρησιμοποιούμε τη μέθοδο
Τώρα ας κοιτάξουμε στη συνάρτηση
int main(int argc, char** argv)
{
 Glib::RefPtrlt;Gtk::Applicationgt; app = Gtk::Application::create(argc, argv, "org.gtkmm.example");

 HelloWorld helloworld;
 return app-gt;run(helloworld);
}
Πρώτα, δημιουργούμε ένα αποθηκευμένο αντικείμενο στον έξυπνο δείκτη
Έπειτα, κάνουμε ένα αντικείμενο της κλάσης μας
Αλλαγές στη
Η
Η βιβλιοθήκη της
Η
Οι
Η
Η
Η

Το Gtk::ComboBox τώρα παράγεται από CellLayout, επιτρέποντας ευκολότερη διάταξη και στοίχιση των
Οι
Οι

Οι
Η Widget::on_expose_event() αντικαταστάθηκε από Widget::on_draw(), που υποθέτει ότι το cairomm χρησιμοποιείται για σχεδίαση, μέσα από την παρεχόμενη
Η
Οι
Η
Τώρα χρησιμοποιούμε std::vector σε αρκετές μεθόδους αντί για τους ενδιάμεσους τύπους *Handle για να κάνουμε την API πιο σαφή.
Όλες οι παρωχημένες API αφαιρέθηκαν στην
Ως πρώτο βήμα για μεταφορά του πηγαίου κώδικά σας στο
Κουμπιά
Η
Κουμπιά πίεσης

Κουμπιά εναλλαγής

Πλαίσια ελέγχου

Ραδιοπλήκτρα

Σημειώστε ότι, λόγω του συστήματος θεμάτων του GTK+, η εμφάνιση αυτών των γραφικών συστατικών θα ποικίλει. Στην περίπτωση των πλαισίων ελέγχου και ραδιοπλήκτρων, μπορεί να ποικίλουν σημαντικά.
Κουμπί
Κατασκευαστές
Υπάρχουν δύο τρόποι δημιουργίας ενός κουμπιού. Μπορείτε να ορίσετε μια συμβολοσειρά ετικέτας στον κατασκευαστή
Για τον ορισμό ενός πλήκτρου επιταχυντή για περιήγηση πληκτρολογίου, τοποθετήστε μια υπογράμμιση πριν από έναν από τους χαρακτήρες της ετικέτας και ορίστε
Gtk::Button* pButton = new Gtk::Button("_Something", true);
Έτοιμα στοιχεία συνιστώνται για χρήση στα κουμπιά. Από την
Η
Παράδειγμα
Αυτό το παράδειγμα δημιουργεί ένα κουμπί με μια εικόνα και μια ετικέτα.
παράδειγμα κουμπιών
Το γραφικό συστατικό
πατημένο
Εκπέμπεται όταν πατιέται το κουμπί.
ελευθερωμένο
Εκπέμπεται όταν πατιέται το κουμπί.
πατημένο
Εκπέμπεται όταν πατιέται το κουμπί και ελευθερώνεται.
εισαγωγή
Εκπέμπεται όταν ο δείκτης του ποντικιού μετακινείται πάνω από το παράθυρο του κουμπιού.
αποχώρηση
Εκπέμπεται όταν ο δείκτης του ποντικιού αφήνει το παράθυρο του κουμπιού.
Κουμπί εναλλαγής
Οι
Για ανάκτηση της κατάστασης της
Μπορείτε να χρησιμοποιήσετε τη μέθοδο
Η
Κουμπί ελέγχου
Η
Ραδιοπλήκτρο
Όπως τα πλαίσια ελέγχου, τα ραδιοπλήκτρα κληρονομούν επίσης από την
Ομάδες
Υπάρχουν δύο τρόποι να ρυθμίσετε μια ομάδα ραδιοπλήκτρων. Ο πρώτος τρόπος είναι η δημιουργία κουμπιών και η ρύθμιση των ομάδων τους κατόπιν. Μόνο οι πρώτοι δύο κατασκευαστές χρησιμοποιούνται. Στο παρακάτω παράδειγμα, κάνουμε μια νέα κλάση παραθύρων που λέγεται
class RadioButtons : public Gtk::Window
{
public:
 RadioButtons();

protected:
 Gtk::RadioButton m_rb1, m_rb2, m_rb3;
};

RadioButtons::RadioButtons()
 : m_rb1("button1"),
 m_rb2("button2"),
 m_rb3("button3")
{
 Gtk::RadioButton::Group group = m_rb1.get_group();
 m_rb2.set_group(group);
 m_rb3.set_group(group);
}
Είπαμε στη
m_rb2.set_group(m_rb1.get_group()); //δεν δουλεύει
Σημειώστε ότι δεν μπορείτε απλά να βάλετε
Ο δεύτερος τρόπος να ρυθμίσετε τα ραδιοπλήκτρα είναι να κάνετε πρώτα μια ομάδα και έπειτα να προσθέσετε ραδιοπλήκτρα σε αυτή. Ιδού ένα παράδειγμα:
class RadioButtons : public Gtk::Window
{
public:
 RadioButtons();
};

RadioButtons::RadioButtons()
{
 Gtk::RadioButton::Group group;
 Gtk::RadioButton *m_rb1 = Gtk::manage(
 new Gtk::RadioButton(group,"button1"));
 Gtk::RadioButton *m_rb2 = manage(
 new Gtk::RadioButton(group,"button2"));
 Gtk::RadioButton *m_rb3 = manage(
 new Gtk::RadioButton(group,"button3"));
}
Κάναμε μια νέα ομάδα δηλώνοντας απλά μια μεταβλητή,
Μέθοδοι
Τα
Το παρακάτω παράδειγμα δείχνει τη χρήση των
Γραφικά συστατικά περιοχής
Οι
Όπως θα εξηγηθεί στην ενότητα
Γραφικά συστατικά γραμμής κύλισης
Αυτές είναι τυπικές γραμμές κύλισης. Πρέπει να χρησιμοποιηθούν μόνο για κύλιση ενός άλλου γραφικού συστατικού, όπως,
Ο προσανατολισμός μιας
Κλιμάκωση γραφικών συστατικών
Τα γραφικά συστατικά (ή "ολισθητές")
Όσον αφορά
Χρήσιμες μέθοδοι
Τα γραφικά συστατικά
Η εμφανιζόμενη τιμή από ένα γραφικό συστατικό κλίμακας στρογγυλοποιείται σε μια δεκαδική θέση από προεπιλογή, όπως είναι το πεδίο
Επίσης, η τιμή μπορεί να σχεδιαστεί σε διαφορετικές θέσεις σχετικά με τον περιέκτη, που ορίζεται από τη μέθοδο
Αυτό το παράδειγμα εμφανίζει ένα παράθυρο με τρία γραφικά συστατικά περιοχής που όλα είναι συνδεμένα με την ίδια ρύθμιση, μαζί με λίγα στοιχεία ελέγχου για ρύθμιση κάποιων παραμέτρων που αναφέρθηκαν παραπάνω και στην ενότητα των ρυθμίσεων, έτσι μπορείτε να δείτε πώς επηρεάζουν τον τρόπο εργασίας αυτά τα γραφικά συστατικά για τον χρήστη.
Ποικίλα γραφικά συστατικά
Ετικέτα
Οι ετικέτες είναι η κύρια μέθοδος τοποθέτησης μη επεξεργάσιμου κειμένου στα παράθυρα, για παράδειγμα η τοποθέτηση ενός τίτλου δίπλα σε ένα γραφικό συστατικό
Το πλάτος της ετικέτας θα προσαρμοστεί αυτόματα. Μπορείτε να παράξετε ετικέτες πολλαπλών γραμμών βάζοντας αλλαγές γραμμών ("\
") στη συμβολοσειρά της ετικέτας.
Το κείμενο της ετικέτας μπορεί να στοιχιστεί χρησιμοποιώντας τη μέθοδο
Το Gtk::Label υποστηρίζει κάποια απλή μορφοποίηση, για παράδειγμα επιτρέπει τη δημιουργία κάποιου έντονου, χρωματιστού ή μεγαλύτερου κειμένου. Μπορείτε να το κάνετε δίνοντας μια συμβολοσειρά στο
Παρακάτω είναι ένα σύντομο παράδειγμα που επεξηγεί αυτές τις λειτουργίες. Αυτό το παράδειγμα χρησιμοποιεί το γραφικό συστατικό πλαίσιο για καλύτερη εμφάνιση των τεχνοτροπιών ετικέτας. (Το γραφικό συστατικό πλαισίου εξηγείται στην ενότητα
Καταχώριση
Απλή χρήση
Τα γραφικά συστατικά καταχώρισης επιτρέπουν στον χρήστη να εισάγει κείμενο. Μπορείτε να αλλάξετε τα περιεχόμενα με τη μέθοδο
Ενίοτε μπορεί να θέλετε να κάνετε ένα γραφικό συστατικό
Για την είσοδο των κωδικών πρόσβασης, συνθηματικών και άλλων πληροφοριών που δεν θέλετε να εμφανίζονται στην οθόνη, η κλήση της
Μπορεί να θέλετε να ειδοποιηθεί όποτε ο χρήστης πληκτρολογεί σε ένα γραφικό συστατικό καταχώρισης κειμένου. Η
Αν περάσετε
Απλό παράδειγμα καταχώρισης
Αυτό το παράδειγμα χρησιμοποιεί την
Συμπλήρωση καταχώρισης
Ένα γραφικό συστατικό
Για την ενεργοποίηση αυτής της λειτουργίας, πρέπει να δημιουργήσετε ένα αντικείμενο
Η
Εναλλακτικά, αν μια πλήρης λίστα των πιθανών καταχωρίσεων μπορεί να είναι υπερβολικά μεγάλη ή υπερβολικά άβολη για να δημιουργηθεί, μια σχισμή επανάκλησης μπορεί να οριστεί με
Παράδειγμα συμπλήρωσης καταχώρισης
Αυτό το παράδειγμα δημιουργεί μια
Εικονίδια καταχώρισης
Ένα γραφικό συστατικό
Παράδειγμα εικονιδίου καταχώρισης
Αυτό το παράδειγμα δείχνει ένα γραφικό συστατικό
Καταχώριση με εικονίδιο
Πρόοδος καταχώρισης
Ένα γραφικό συστατικό
Παράδειγμα προόδου καταχώρισης
Αυτό το παράδειγμα δείχνει ένα γραφικό συστατικό
Καταχώριση με γραμμή προόδου
Κουμπί αυξομείωσης
Μια
Η τιμή μπορεί να έχει έναν ρυθμίσιμο αριθμό δεκαδικών θέσεων και το βήμα του μεγέθους είναι διαμορφώσιμο. Οι






Οι
Επιπρόσθετα, το πλήκτρο του ποντικιού 3 μπορεί να χρησιμοποιηθεί για άμεση μετάβαση στις τιμές
Η
Ο αριθμός των δεκαδικών θέσεων μπορεί να αλλαχτεί χρησιμοποιώντας τη μέθοδο
Μπορείτε να ορίσετε τιμή κουμπιού αυξομείωσης χρησιμοποιώντας τη μέθοδο
Η μέθοδος
Για να αποτραπεί η πληκτρολόγηση από τον χρήστη μη αριθμητικών χαρακτήρων στο πλαίσιο καταχώρισης, περάστε
Για να κάνετε την
Για να την εξαναγκάσετε να προσκολληθεί στο πλησιέστερο
Να ένα παράδειγμα μιας
Γραμμή προόδου
Οι γραμμές προόδου χρησιμοποιούνται για την εμφάνιση της κατάστασης της συνεχιζόμενης λειτουργίας. Για παράδειγμα, μια
Για την αλλαγή της εμφανιζόμενης τιμής, χρησιμοποιήστε τη μέθοδο
Μια
Κατάσταση δραστηριότητας
Εκτός από την υπόδειξη του ποσού της προόδου που έχει συμβεί, η γραμμή προόδου μπορεί επίσης να χρησιμοποιηθεί για να δείξει ότι υπάρχει κάποια δραστηριότητα· αυτό γίνεται τοποθετώντας τη γραμμή προόδου στην
Για να το κάνετε αυτό, χρειάζεται να καλέσετε τη μέθοδο
Η γραμμή προόδου μπορεί επίσης να εμφανίσει μια ρυθμίσιμη συμβολοσειρά κειμένου μέσα στην υποδοχή, χρησιμοποιώντας τη μέθοδο
Γραμμή πληροφοριών (InfoBar)
Μια
Συμβουλές οθόνης
Οι συμβουλές οθόνης είναι τα μικρά παράθυρα πληροφοριών που αναδύονται όταν αφήνετε τον δείκτη σας πάνω από ένα γραφικό συστατικό για λίγα δευτερόλεπτα. Χρησιμοποιήστε την
Αναφορά γραφικού συστατικού
Αναφορά συμβουλής οθόνης
Συμβουλή οθόνης
Γραφικά συστατικά περιέκτη
Όλα τα γραφικά συστατικά περιέκτη παράγονται από την
Περιέκτες μοναδικού στοιχείου
Τα γραφικά συστατικά περιέκτη μοναδικού στοιχείου παράγονται από
Θα συζητήσουμε επίσης το γραφικό συστατικό
Σκελετός (frame)
Οι σκελετοί (Frames) μπορούν να περικλείουν ένα ή μια ομάδα γραφικών συστατικών μέσα σε ένα πλαίσιο, προαιρετικά με τίτλο. Για παράδειγμα, μπορείτε να βάλετε μια ομάδα
Με φατνώματα (Paned)
Τα φατνώματα (Panes) διαιρούν ένα γραφικό συστατικό σε δύο μισά, που χωρίζονται από ένα μετακινήσιμο χώρισμα. Τα δύο μισά (φατνώματα) μπορούν να προσανατολιστούν ή οριζόντια (πλάι-πλάι) ή κάθετα (το ένα πάνω από το άλλο).
Αντίθετα με τα άλλα γραφικά συστατικά σε αυτήν την ενότητα, τα γραφικά συστατικά φατνωμάτων (pane) δεν περιέχουν ένα αλλά δύο θυγατρικά γραφικά συστατικά, ένα σε κάθε φάτνωμα. Συνεπώς, θα πρέπει να χρησιμοποιήσετε
Μπορείτε να ρυθμίσετε τη θέση του χωρίσματος χρησιμοποιώντας τη μέθοδο
Κυλιόμενο παράθυρο
Τα γραφικά συστατικά
Τα κυλιόμενα παράθυρα έχουν
Να ένα απλό παράδειγμα που πακετάρει 100 κουμπιά εναλλαγής σε ένα κυλιόμενο παράθυρο. Δοκιμάστε αυξομείωση του παραθύρου για να δείτε την αντίδραση των γραμμών κύλισης.
Σκελετός όψης (AspectFrame)
Το γραφικό συστατικό
Το παρακάτω πρόγραμμα χρησιμοποιεί μία
Στοίχιση
Το γραφικό συστατικό
Χρειάζεται να ορίσετε τα χαρακτηριστικά της
Αυτό το παράδειγμα στοιχίζει δεξιά ένα κουμπί σε ένα παράθυρο χρησιμοποιώντας ένα γραφικό συστατικό
Δείτε την ενότητα
Γραφικά συστατικά πολλαπλών στοιχείων
Τα γραφικά συστατικά πολλαπλών στοιχείων κληρονομούν από την
Πακετάρισμα
Έχετε προφανώς σημειώσει ότι τα παράθυρα
Πολλά πακέτα εργαλείων GUI απαιτούν την ακριβή τοποθέτηση γραφικών συστατικών σε ένα παράθυρο, χρησιμοποιώντας απόλυτη τοποθέτηση, χρησιμοποιώντας συχνά έναν οπτικό επεξεργαστή. Αυτό οδηγεί σε πολλά προβλήματα:
Τα γραφικά συστατικά δεν αναδιατάσσουν τους εαυτούς τους όταν το παράθυρο αυξομειώνεται. Κάποια γραφικά συστατικά κρύβονται όταν το παράθυρο γίνεται μικρότερο και πολύς άχρηστος χώρος εμφανίζεται όταν το παράθυρο γίνεται μεγαλύτερο.
Είναι αδύνατο να προβλέψετε τον απαραίτητο χώρο για κείμενο αφού έχει μεταφραστεί σε άλλες γλώσσες ή όταν εμφανίζεται με μια διαφορετική γραμματοσειρά. Στο Γιούνιξ είναι επίσης αδύνατο να προβλέψτε τις επιδράσεις κάθε θέματος και διαχειριστή παραθύρου.
Η αλλαγή της διάταξης ενός παραθύρου "άμεσα", για να εμφανιστούν κάποια πρόσθετα γραφικά συστατικά, για παράδειγμα, είναι σύνθετη. Απαιτεί κουραστικούς επανυπολογισμούς κάθε θέσης του γραφικού συστατικού.
Το
Το
Ναι, αυτό είναι σωστό: ένα παράθυρο μπορεί να περιέχει το πολύ ένα γραφικό συστατικό. Πώς, τότε, μπορούμε να χρησιμοποιούμε ένα παράθυρο για ο,τιδήποτε χρήσιμο; Τοποθετώντας έναν περιέκτη πολλαπλού θυγατρικού στο παράθυρο. Τα πιο χρήσιμα γραφικά συστατικά περιεκτών είναι οι
Η
Η
Υπάρχουν αρκετοί άλλοι περιέκτες, που θα συζητήσουμε επίσης.
Αν δεν έχετε χρησιμοποιήσει ποτέ πριν ένα πακέτο εργαλείων συσκευασίας, μπορεί να πάρει κάμποσο για να το χρησιμοποιήσετε. Θα βρείτε προφανώς, όμως, ότι δεν χρειάζεστε να βασίζεστε σε οπτικές μορφές επεξεργαστών τόσο πολύ όσο θα πρέπει με άλλα πακέτα εργαλείων.
Ένα βελτιωμένο Hello World
Ας ρίξουμε μια ματιά σε ένα ελαφρά βελτιωμένο
Hello World 2
Μετά τη δόμηση και εκτέλεση αυτού του προγράμματος, προσπαθήστε να αυξομειώσετε το παράθυρο για να δείτε τη συμπεριφορά. Επίσης, δοκιμάστε να παίξετε με τις επιλογές στη
Πλαίσια (Boxes)
Οι περισσότερες συσκευασίες χρησιμοποιούν πλαίσια (boxes) όπως στο παραπάνω παράδειγμα. Αυτά είναι αόρατοι περιέκτες στους οποίους μπορούμε να συσκευάσουμε τα γραφικά συστατικά μας. Όταν συσκευάζονται γραφικά συστατικά σε ένα οριζόντιο πλαίσιο, τα αντικείμενα εισάγονται οριζόντια από αριστερά προς τα δεξιά ή δεξιά προς τα αριστερά ανάλογα με το αν χρησιμοποιείται
Προσθήκη γραφικών συστατικών
Επιλογές συσκευασίας ανά θυγατρικό
Οι μέθοδοι
Υπάρχουν αρκετές επιλογές που διέπουν τον τρόπο συσκευασίας των γραφικών συστατικών και αυτό μπορεί να μπερδεύει στην αρχή. Αν δυσκολεύεστε, τότε είναι μερικές φορές καλή ιδέα να παίξετε με τον σχεδιαστή γραφικής διεπαφής
Υπάρχουν βασικά πέντε διαφορετικές τεχνοτροπίες, όπως φαίνεται σε αυτήν την εικόνα:
Συσκευασία πλαισίου (Box) 1
Κάθε γραμμή περιέχει ένα οριζόντιο
Αυτή είναι η δήλωση της μεθόδου
void pack_start(Gtk::Widgetamp; child,
 Gtk::PackOptions options = Gtk::PACK_EXPAND_WIDGET,
 guint padding = 0);
Το πρώτο όρισμα είναι το γραφικό συστατικό που συσκευάζετε. Στο παράδειγμά μας όλα αυτά είναι



Το όρισμα
Το όρισμα
Επιλογές συσκευασίας ανά περιέκτη
Gtk::Box(Gtk::Orientation orientation = Gtk::ORIENTATION_HORIZONTAL, int spacing = 0);
void set_spacing(int spacing);
void set_homogeneous(bool homogeneous = true);
Ιδού ο κατασκευαστής για το γραφικό συστατικό
Ποια είναι η διαφορά μεταξύ διακένου (που ορίστηκε όταν δημιουργείται το πλαίσιο (box)) και συμπλήρωσης (που ορίζεται όταν συσκευάζονται στοιχεία); Το διάκενο προστίθεται μεταξύ αντικειμένων και η συμπλήρωση προστίθεται σε όποια πλευρά του γραφικού συστατικού. Η παρακάτω εικόνα πρέπει να το ξεκαθαρίζει:
Συσκευασία πλαισίου (Box) 2
Gtk::επιλογές εφαρμογής και γραμμής εντολών
Το παρακάτω παράδειγμα προγράμματος απαιτεί μια επιλογή γραμμής εντολών. Ο πηγαίος κώδικας εμφανίζει δύο τρόπους χειρισμού των επιλογών της γραμμής εντολών σε συνδυασμό με την
Χειριστείτε τις επιλογές στη
Δώστε όλες τις επιλογές της γραμμής εντολών στη
Πρέπει να ορίσετε μια προαιρετική παράμετρο
Να ο πηγαίος κώδικας για το παράδειγμα που παρήγαγε τα παραπάνω στιγμιότυπα. Όταν εκτελείτε αυτό το παράδειγμα, δώστε έναν αριθμό μεταξύ 1 και 3 ως επιλογή της γραμμής εντολών, για να δείτε σε χρήση τις διαφορετικές επιλογές συσκευασίας.
Πλαίσια με κουμπιά (ButtonBoxes)
Τα πλαίσια με κουμπιά (Button boxes) είναι ένας βολικός τρόπος γρήγορης τακτοποίησης μιας ομάδας κουμπιών. Ο προσανατολισμός τους μπορεί να είναι ή οριζόντιος ή κάθετος.

Τα κουμπιά προστίθενται σε μία
Τα πλαίσια με κουμπιά (Button boxes) υποστηρίζουν πολλές τεχνοτροπίες διάταξης. Η τεχνοτροπία μπορεί να ανακτηθεί και να αλλαχθεί χρησιμοποιώντας
Πλαίσιο με κουμπιά (Button Box)
Πλέγμα
Μια
Τα θυγατρικά γραφικά συστατικά μπορούν να καλύψουν πολλαπλές γραμμές ή στήλες, χρησιμοποιώντας την
Μπορείτε να ορίσετε τις ιδιότητες
Αυτό το παράδειγμα δημιουργεί ένα παράθυρο με τρία κουμπιά σε ένα πλέγμα. Τα πρώτα δύο κουμπιά είναι στην ανώτερη γραμμή, από αριστερά προς τα δεξιά. Ένα τρίτο κουμπί προσαρτάται κάτω από το πρώτο κουμπί, σε μια χαμηλότερη γραμμή, καλύπτοντας δύο στήλες.
Πίνακας
Η
Η
Σημειωματάριο
Μια A
Χρησιμοποιήστε τις μεθόδους
Για να βρείτε την τρέχουσα ορατή σελίδα, χρησιμοποιήστε τη μέθοδο
Για προγραμματιστική αλλαγή της επιλεγμένης σελίδας, χρησιμοποιήστε τη μέθοδο
Βοηθός
Μια
Χρησιμοποιήστε τις μεθόδους
Για τον προσδιορισμό της τρέχουσας ορατής σελίδας, χρησιμοποιήστε τη μέθοδο
Για τον ορισμό του τίτλου μιας σελίδας, χρησιμοποιήστε τη μέθοδο
Για την προσθήκη γραφικών συστατικών σε μια περιοχή ενέργειας, χρησιμοποιήστε τη μέθοδο
Το γραφικό συστατικό προβολή δένδρου (TreeView)
Το γραφικό συστατικό
Το πρότυπο
Κάθε
Αν και μπορείτε θεωρητικά να υλοποιήσετε το δικό σας πρότυπο, θα χρησιμοποιείτε κανονικά τις κλάσεις προτύπου ή την
Αποθήκευση λίστας (ListStore), για γραμμές
Η
Προβολή δένδρου - Αποθήκευση λίστας (TreeView - ListStore)
Αποθήκευση δένδρου, για μια ιεραρχία
Η
Προβολή δένδρου - Αποθήκευση λίστας (TreeView - ListStore)
Στήλες προτύπου
Η κλάση
class ModelColumns : public Gtk::TreeModelColumnRecord
{
public:

 ModelColumns()
 { add(m_col_text); add(m_col_number); }

 Gtk::TreeModelColumnlt;Glib::ustringgt; m_col_text;
 Gtk::TreeModelColumnlt;intgt; m_col_number;
};

ModelColumns m_Columns;
Ορίζετε την
Glib::RefPtrlt;Gtk::ListStoregt; refListStore =
 Gtk::ListStore::create(m_Columns);
Σημειώστε ότι το στιγμιότυπο (όπως m_Columns εδώ) πρέπει συνήθως να μην είναι στατικό, επειδή χρειάζεται συχνά να δημιουργηθεί αφού η glibmm έχει δημιουργηθεί.
Προσθήκη γραμμών
Προσθέστε γραμμές στο πρότυπο με τις μεθόδους
Gtk::TreeModel::iterator iter = m_refListStore-gt;append();
Μπορείτε να αφαιρέσετε την αναφορά από τον επαναλήπτη για να πάρετε τη γραμμή:
Gtk::TreeModel::Row row = *iter;
Προσθήκη θυγατρικών γραμμών
Τα πρότυπα
Gtk::TreeModel::iterator iter_child =
 m_refTreeStore-gt;append(row.children());
Ορισμός τιμών
Μπορείτε να χρησιμοποιήσετε τη
row[m_Columns.m_col_text] = "sometext";
Λήψη τιμών
Μπορείτε να χρησιμοποιήσετε τη
Glib::ustring strText = row[m_Columns.m_col_text];
int number = row[m_Columns.m_col_number];
Ο μεταγλωττιστής θα παραπονεθεί αν χρησιμοποιήσετε έναν ακατάλληλο τύπο. Για παράδειγμα, αυτό θα μπορούσε να δημιουργήσει ένα σφάλμα μεταγλωττιστή:
//compiler error - no conversion from ustring to int.
int number = row[m_Columns.m_col_text];
"Κρυφές" στήλες
Μπορεί να θέλετε να συνδέσετε πρόσθετα δεδομένα με κάθε γραμμή. Αν συμβαίνει αυτό, απλά προσθέστε το ως μια στήλη προτύπου, αλλά μην το προσθέσετε στην προβολή.
Η προβολή
Η προβολή είναι το ενεργό γραφικό συστατικό (
Χρήση ενός προτύπου
Μπορείτε να ορίσετε μία
m_TreeView.set_model(m_refListStore);
Προσθήκη στηλών προβολής
Μπορείτε να χρησιμοποιήσετε τη μέθοδο
m_TreeView.append_column("Messages", m_Columns.m_col_text);
Όταν χρησιμοποιείτε αυτήν απλή αντικατάσταση
Περισσότερες από μια στήλη προτύπου ανά στήλη προβολής
Για την απόδοση περισσότερων από μια στήλης προτύπου σε μια στήλη προβολής, χρειάζεται να δημιουργήσετε το γραφικό συστατικό
Έπειτα χρησιμοποιήστε την
Να κάποιο παράδειγμα κώδικα από το
Gtk::TreeView::Column* pColumn =
 Gtk::manage(new Gtk::TreeView::Column("Icon Name"));

// m_columns.icon and m_columns.iconname είναι στήλες στο μοντέλο.
// pColumn είναι η στήλη στην προβολή δένδρου:
pColumn-gt;pack_start(m_columns.icon, /* expand= */ false);
pColumn-gt;pack_start(m_columns.iconname);

m_TreeView.append_column(*pColumn);
Ορίζοντας τις λεπτομέρειες CellRenderer
Η προεπιλεγμένη
int cols_count = m_TreeView.append_column_editable("Alex", m_columns.alex);
Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);
if(pColumn)
{
 Gtk::CellRendererToggle* pRenderer =
 static_castlt;Gtk::CellRendererToggle*gt;(pColumn-gt;get_first_cell());
 pColumn-gt;add_attribute(pRenderer-gt;property_visible(), m_columns.visible);
 pColumn-gt;add_attribute(pRenderer-gt;property_activatable(), m_columns.world);
Μπορείτε επίσης να συνδέσετε τα σήματα
Gtk::CellRendererToggle* pRenderer =
 Gtk::manage( new Gtk::CellRendererToggle() );
pRenderer-gt;signal_toggled().connect(
 sigc::bind( sigc::mem_fun(*this,
 &Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)
);
Επεξεργάσιμα κελιά
Αυτόματα αποθηκευμένα επεξεργάσιμα κελιά.
Κελιά σε μια
Υλοποίηση προσαρμοσμένης λογικής για επεξεργάσιμα κελιά.
Όμως, μπορεί να μην θέλετε οι νέες τιμές να αποθηκευτούν αμέσως. Για παράδειγμα, μπορεί να θέλετε να περιορίσετε την είσοδο σε συγκεκριμένους χαρακτήρες ή περιοχές τιμών.
Για να το πετύχετε, θα πρέπει να χρησιμοποιήσετε τις κανονικές μεθόδους
Θα πρέπει έπειτα να αλλάξετε τύπο σε
Για παράδειγμα, για CellRendererText, μπορείτε να ορίσετε την ιδιότητα
cell.property_editable() = true;
Για ένα CellRendererToggle, μπορείτε να ορίσετε την
Μπορείτε έπειτα να συνδεθείτε με το κατάλληλο "επεξεργασμένο" σήμα. Για παράδειγμα, συνδεθείτε στις
Στον χειριστή σήματός σας, θα πρέπει να εξετάσετε τη νέα τιμή και έπειτα να την αποθηκεύσει στο πρότυπο, αν αυτό είναι κατάλληλο για την εφαρμογή σας.
Επανάληψη στις γραμμές προτύπου
Η
typedef Gtk::TreeModel::Children type_children; //minimise code length.
type_children children = refModel-gt;children();
for(type_children::iterator iter = children.begin();
 iter != children.end(); ++iter)
{
 Gtk::TreeModel::Row row = *iter;
 //Do something with the row - see above for set/get.
}
Θυγατρικά γραμμή
Gtk::TreeModel::Children children = row.children();
Όταν χρησιμοποιείτε μια
Η επιλογή
Για να βρείτε ποιες γραμμές έχει επιλέξει ο χρήστης, πάρτε το αντικείμενο
Glib::RefPtrlt;Gtk::TreeSelectiongt; refTreeSelection =
 m_TreeView.get_selection();
Μεμονωμένη ή πολλαπλή επιλογή
refTreeSelection-gt;set_mode(Gtk::SELECTION_MULTIPLE);
Από προεπιλογή, μόνο μεμονωμένες γραμμές μπορούν να επιλεγούν, αλλά μπορείτε να επιτρέψετε πολλαπλή επιλογή ορίζοντας την κατάσταση, ως εξής:
Οι επιλεγμένες γραμμές
Για μεμονωμένη επιλογή, μπορείτε να καλέσετε απλά την
TreeModel::iterator iter = refTreeSelection-gt;get_selected();
if(iter) //Αν κάτι έχει επιλεγεί
{
 TreeModel::Row row = *iter;
 //Do something with the row.
}
Για πολλαπλή επιλογή, χρειάζεται να ορίσετε μια επανάκληση και να της δώσετε
refTreeSelection-gt;selected_foreach_iter(
 sigc::mem_fun(*this, &TheClass::selected_row_callback) );

void TheClass::selected_row_callback(
 const Gtk::TreeModel::iteratoramp; iter)
{
 TreeModel::Row row = *iter;
 //Do something with the row.
}
Το "αλλαγμένο" σήμα
Για απάντηση στο πάτημα του χρήστη σε μια γραμμή ή περιοχή γραμμών, συνδεθείτε με το σήμα ως εξής:
refTreeSelection-gt;signal_changed().connect(
 sigc::mem_fun(*this, &Example_IconTheme::on_selection_changed)
);
Αποτρέποντας την επιλογή γραμμής
Μπορεί ο χρήστης να μην πρέπει να μπορεί να επιλέξει κάθε στοιχείο στη λίστα ή δένδρο σας. Για παράδειγμα, στο gtk-demo, μπορείτε να επιλέξετε μια παρουσίαση για να δείτε τον πηγαίο κώδικα, αλλά δεν έχει νόημα να επιλέξετε μια κατηγορία παρουσίασης.
Για τον έλεγχο των γραμμών που μπορούν να επιλεγούν, χρησιμοποιήστε τη μέθοδο
m_refTreeSelection-gt;set_select_function( sigc::mem_fun(*this,
 &DemoWindow::select_function) );
και έπειτα
bool DemoWindow::select_function(
 const Glib::RefPtrlt;Gtk::TreeModelgt;amp; model,
 const Gtk::TreeModel::Pathamp; path, bool)
{
 const Gtk::TreeModel::iterator iter = model-gt;get_iter(path);
 return iter-gt;children().empty(); // only allow leaf nodes to be selected
}
Αλλαγή της επιλογής
Για να αλλάξετε την επιλογή, ορίστε έναν
Gtk::TreeModel::Row row = m_refModel-gt;children()[5]; //The fifth row.
if(row)
 refTreeSelection-gt;select(row);
ή
Gtk::TreeModel::iterator iter = m_refModel-gt;children().begin()
if(iter)
 refTreeSelection-gt;select(iter);
Ταξινόμηση
Τα τυπικά πρότυπα δένδρου (
Αναφορά TreeSortable
Ταξινόμηση πατώντας στις στήλες
Για να μπορεί ένας χρήστης να πατά σε μία κεφαλίδα στήλης
Gtk::TreeView::Column* pColumn = treeview.get_column(0);
if(pColumn)
 pColumn-gt;set_sort_column(m_columns.m_col_id);
Ανεξάρτητα ταξινομημένες προβολές του ίδιου προτύπου
Η
Glib::RefPtrlt;Gtk::TreeModelSortgt; sorted_model =
 Gtk::TreeModelSort::create(model);
sorted_model-gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);
treeview.set_model(sorted_model);
Σημειώστε, όμως, ότι η TreeView θα δώσει επαναλήπτες στο ταξινομημένο πρότυπο. Πρέπει να τους μετατρέψετε σε επαναλήπτες στο υποκείμενο θυγατρικό πρότυπο για να εκτελέσετε ενέργειες σε αυτό το πρότυπο. Για παράδειγμα:
void ExampleWindow::on_button_delete()
{
 Glib::RefPtrlt;Gtk::TreeSelectiongt; refTreeSelection =
 m_treeview.get_selection();
 if(refTreeSelection)
 {
 Gtk::TreeModel::iterator sorted_iter =
 m_refTreeSelection-gt;get_selected();
 if(sorted_iter)
 {
 Gtk::TreeModel::iterator iter =
 m_refModelSort-gt;convert_iter_to_child_iter(sorted_iter);
 m_refModel-gt;erase(iter);
 }
 }
}
Αναφορά ταξινόμησης τύπου δένδρου (TreeModelSort)
Μεταφορά κι απόθεση
Η
Αναδιατάξιμες γραμμές
Αν καλέσετε τη
Όμως, αυτό δεν επιτρέπει κανένα στοιχείο ελέγχου του οποίου τα στοιχεία μπορούν να μετακινηθούν και όπου μπορούν να αποτεθούν. Αν χρειάζεστε αυτόν τον πρόσθετο έλεγχο, τότε μπορείτε να δημιουργήσετε ένα παράγωγο
Αυτό παρουσιάζεται στο παράδειγμα drag_and_drop.
Αναδυόμενο μενού περιεχομένων
Πολλά άτομα χρειάζονται να υλοποιήσουν δεξιό πάτημα σε μενού περιεχομένων για την
Χειρισμός
Για την αναγνώριση ενός πατήματος του δεξιού πλήκτρου του ποντικιού, χρειάζεστε να χειριστείτε το σήμα
Αυτό παρουσιάζεται στο παράδειγμα αναδυόμενου προσαρμοσμένου μενού.
Παραδείγματα
Αποθήκευση λιστών
Αυτό το παράδειγμα έχει ένα γραφικό συστατικό
Αποθήκευση δένδρου
Αυτό το παράδειγμα είναι πολύ παρόμοιο με το παράδειγμα
Αυτό το παράδειγμα είναι ταυτόσημο με το παράδειγμα
Προβολή δένδρου (TreeView) - Επεξεργάσιμα κελιά
Αυτό το παράδειγμα μοιάζει πολύ με το παράδειγμα
Προβολή δένδρου - Μεταφορά και απόθεση
Αυτό το παράδειγμα μοιάζει πολύ με το παράδειγμα
Προβολή δένδρου - Αναδυόμενο μενού περιεχομένων
Σύνθετα πλαίσια
Το γραφικό συστατικό
Η λίστα παρέχεται μέσα από
Το πρότυπο
Το πρότυπο για ένα ComboBox μπορεί να οριστεί και να συμπληρωθεί ακριβώς όπως μια
ModelColumns()
{ add(m_col_id); add(m_col_name); }

 Gtk::TreeModelColumnlt;intgt; m_col_id;
 Gtk::TreeModelColumnlt;Glib::ustringgt; m_col_name;
};

ModelColumns m_columns;
Μετά την προσάρτηση των γραμμών σε αυτό το πρότυπο, θα πρέπει να δώσετε το πρότυπο στην
Το επιλεγμένο στοιχείο
Για να βρείτε ποιο στοιχείο, αν υπάρχει, έχει επιλέξει ο χρήστης από το ComboBox, καλέστε
Gtk::TreeModel::iterator iter = m_Combo.get_active();
if(iter)
{
 Gtk::TreeModel::Row row = *iter;

 //Λήψη των δεδομένων για την επιλεγμένη γραμμή, χρησιμοποιώντας τη
 //γνώση μας του προτύπου δένδρου:
 int id = row[m_Columns.m_col_id];
 set_something_id_chosen(id); //Η δικιά σας συνάρτηση.
}
else
 set_nothing_chosen(); //Η δικιά σας συνάρτηση.
Απάντηση σε αλλαγές
Μπορεί να χρειαστείτε να αντιδράσετε σε κάθε αλλαγή της επιλογής στο ComboBox, για παράδειγμα να ενημερώσετε άλλα γραφικά συστατικά. Για να γίνει αυτό, θα πρέπει να χειριστείτε το σήμα
m_combo.signal_changed().connect( sigc::mem_fun(*this,
 &ExampleWindow::on_combo_changed) );
Πλήρες παράδειγμα
ComboBox
Απλό παράδειγμα κειμένου
ComboBoxText
ComboBox με μια καταχώριση
Μια
Η στήλη κειμένου
m_combo.set_entry_text_column(m_columns.m_col_name);
Για να μπορεί να αλληλεπιδράσει η
Όταν διαλέγετε μια επιλογή από το πτυσσόμενο μενού, η τιμή από αυτήν τη στήλη θα τοποθετηθεί στην
Η καταχώριση
Επειδή ο χρήστης μπορεί να εισάγει ένα ελεύθερο κείμενο, μια ενεργή γραμμή προτύπου δεν είναι αρκετή για να πει ποιο κείμενο έχει εισάγει ο χρήστης. Συνεπώς, θα πρέπει να ανακτήσετε το γραφικό συστατικό
Gtk::Entry* entry = m_Combo.get_entry();
if (entry)
{
 // The Entry shall receive focus-out events.
 entry-gt;add_events(Gdk::FOCUS_CHANGE_MASK);

 // Alternatively you can connect to m_Combo.signal_changed().
 entry-gt;signal_changed().connect(sigc::mem_fun(*this,
 &ExampleWindow::on_entry_changed) );

 entry-gt;signal_activate().connect(sigc::mem_fun(*this,
 &ExampleWindow::on_entry_activate) );

 entry-gt;signal_focus_out_event().connect(sigc::mem_fun(*this,
 &ExampleWindow::on_entry_focus_out_event) );
}
Όταν ο χρήστης εισάγει τυχαίο κείμενο, μπορεί να μην είναι αρκετό να συνδεθεί με το σήμα
Τα συμβάντα Χ περιγράφονται πιο λεπτομερώς στην ενότητα
ComboBox με καταχώριση
ComboBoxText με καταχώριση
TextView
Το γραφικό συστατικό
Η ενδιάμεση μνήμη

Η
Επαναλήπτες
Ετικέτες και μορφοποίηση
Ετικέτες
Για να ορίσετε ότι κάποιο κείμενο στην ενδιάμεση μνήμη πρέπει να έχει ειδική μορφοποίηση, πρέπει να ορίσετε μια ετικέτα που θα κρατήσει αυτήν την πληροφορία μορφοποίησης και έπειτα θα εφαρμόσει αυτήν την ετικέτα στην περιοχή του κειμένου. Για παράδειγμα, για τον ορισμό της ετικέτας και των ιδιοτήτων της:
Glib::RefPtrlt;Gtk::TextBuffer::Taggt; refTagMatch =
 Gtk::TextBuffer::Tag::create();
refTagMatch-gt;property_background() = "orange";
Μπορείτε να ορίσετε ένα όνομα για την
Η κλάση
TagTable
Κάθε
Glib::RefPtrlt;Gtk::TextBuffer::TagTablegt; refTagTable =
 Gtk::TextBuffer::TagTable::create();
refTagTable-gt;add(refTagMatch);
//Ας ελπίσουμε ότι μια μελλοντική έκδοση του
Μπορείτε επίσης να χρησιμοποιήσετε την
Εφαρμογή ετικετών
Αν έχετε δημιουργήσει μια
refBuffer-gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);
refBuffer-gt;insert_with_tag(iter, "Some text", refTagMatch);
Ή μπορείτε να ορίσετε την ετικέτα, όταν εισάγετε πρώτα το κείμενο:
Μπορείτε να εφαρμόσετε περισσότερες από μία
Σημάδια
Οι επαναλήπτες
Glib::RefPtrlt;Gtk::TextBuffer::Markgt; refMark =
 refBuffer-gt;create_mark(iter);
Μπορείτε έπειτα να χρησιμοποιήσετε τη μέθοδο
Υπάρχουν δύο ενσωματωμένες
Όπως αναφέρθηκε παραπάνω, κάθε
Όπως η
Προεπιλεγμένη μορφοποίηση
Η
Κύλιση
Η
Γραφικά συστατικά και ChildAnchors
Μπορείτε να ενσωματώσετε γραφικά συστατικά, όπως
Glib::RefPtrlt;Gtk::TextChildAnchorgt; refAnchor =
 refBuffer-gt;create_child_anchor(iter);
Έπειτα, για να προσθέσετε ένα γραφικό συστατικό σε αυτή τη θέση, χρησιμοποιήστε
m_TextView.add_child_at_anchor(m_Button, refAnchor);
Μενού και Εργαλειοθήκες
Υπάρχουν ειδικές APIs για μενού και εργαλειοθήκες, αλλά θα πρέπει συνήθως να τις αντιμετωπίσετε μαζί, χρησιμοποιώντας την
Αυτό εμπεριέχει τη χρήση των κλάσεων
Ενέργειες
Δημιουργήστε πρώτα τις
Τα ορίσματα στην
Μπορείτε επίσης να ορίσετε έναν χειριστή σήματος όταν καλείτε την
Σημειώστε ότι πρέπει να ορίσετε ενέργειες για υπομενού καθώς και για στοιχεία μενού.
Για παράδειγμα:
m_refActionGroup = Gtk::ActionGroup::create();

m_refActionGroup-gt;add( Gtk::Action::create("MenuFile", "_File") );
m_refActionGroup-gt;add( Gtk::Action::create("New", "_New"),
 sigc::mem_fun(*this, &ExampleWindow::on_action_file_new) );
m_refActionGroup-gt;add( Gtk::Action::create("ExportData", "Export Data"),
 sigc::mem_fun(*this, &ExampleWindow::on_action_file_open) );
m_refActionGroup-gt;add( Gtk::Action::create("Quit", "_Quit"),
 sigc::mem_fun(*this, &ExampleWindow::on_action_file_quit) );
Σημειώστε ότι εκεί ορίζουμε τα ονόματα των ενεργειών, όπως θα φαίνονται στους χρήστες σε μενού και εργαλειοθήκες. Συνεπώς, εκεί θα πρέπει να κάνετε μεταφράσιμες τις συμβολοσειρές, βάζοντας τες μέσα στην μακροεντολή _().
UIManager
Έπειτα θα πρέπει να δημιουργήσετε μια
Για παράδειγμα,
Glib::RefPtrlt;Gtk::UIManagergt; m_refUIManager =
 Gtk::UIManager::create();
m_refUIManager-gt;insert_action_group(m_refActionGroup);
add_accel_group(m_refUIManager-gt;get_accel_group());
Έπειτα, μπορείτε να ορίσετε την ενεργή ορατή διάταξη των μενού και εργαλειοθηκών και να προσθέσετε τη διάταξη γραφικής διεπαφής στην
Glib::ustring ui_info =
 "lt;uigt;"
 " &lt;menubar name='MenuBar'gt;"
 " &lt;menu action='MenuFile'gt;"
 " &lt;menuitem action='New'/gt;"
 " &lt;menuitem action='Open'/gt;"
 " &lt;separator/gt;"
 " &lt;menuitem action='Quit'/gt;"
 " &lt;/menugt;"
 " &lt;menu action='MenuEdit'gt;"
 " &lt;menuitem action='Cut'/gt;"
 " &lt;menuitem action='Copy'/gt;"
 " &lt;menuitem action='Paste'/gt;"
 " &lt;/menugt;"
 " &lt;/menubargt;"
 " &lt;toolbar name='ToolBar'gt;"
 " &lt;toolitem action='Open'/gt;"
 " &lt;toolitem action='Quit'/gt;"
 " &lt;/toolbargt;"
 "lt;/uigt;";

m_refUIManager-gt;add_ui_from_string(ui_info);
Να θυμάστε ότι αυτά τα ονόματα είναι απλά αναγνωριστικά που χρησιμοποιούμε όταν δημιουργούμε τις ενέργειες. Δεν είναι το κείμενο που θα δει ο χρήστης στα μενού και τις εργαλειοθήκες. Δίνουμε αυτά τα αναγνώσιμα από άνθρωπο ονόματα όταν δημιουργούμε τις ενέργειες.
Για δημιουργία μιας
Gtk::Widget* pMenubar = m_refUIManager-gt;get_widget("/MenuBar");
pBox-gt;add(*pMenuBar, Gtk::PACK_SHRINK);
Αναδυόμενα μενού
Η
Η διάταξη γραφικής διεπαφής για ένα αναδυόμενο μενού πρέπει να χρησιμοποιήσει τον κόμβο
Glib::ustring ui_info =
 "lt;uigt;"
 " &lt;popup name='PopupMenu'gt;"
 " &lt;menuitem action='ContextEdit'/gt;"
 " &lt;menuitem action='ContextProcess'/gt;"
 " &lt;menuitem action='ContextRemove'/gt;"
 " &lt;/popupgt;"
 "lt;/uigt;";

m_refUIManager-gt;add_ui_from_string(ui_info);
Για εμφάνιση του αναδυόμενου μενού, χρησιμοποιήστε τη μέθοδο
bool ExampleWindow::on_button_press_event(GdkEventButton* event)
{
 if( (event-gt;type == GDK_BUTTON_PRESS) &amp;
 (event-gt;button == 3) )
 {
 m_Menu_Popup-gt;popup(event-gt;button, event-gt;time);
 return true; //It has been handled.
 }
 else
 return false;
}
Κύριο παράδειγμα μενού
Κύριο μενού
Αναδυόμενο παράδειγμα μενού
Αναδυόμενο μενού
Παλέτα εργαλείου
Μια
Τα στοιχεία της
Οι
Gtk::ToolItemGroup* group_brushes =
 Gtk::manage(new Gtk::ToolItemGroup("Brushes"));
m_ToolPalette.add(*group_brushes);
Οι
Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, "Big"));
button-gt;set_tooltip_text("Big Brush);
group_brushes-gt;insert(*button);
Μπορείτε έπειτα να χειριστείτε στην
Αναφορά παλέτας εργαλείου
Αναφορά ομάδας στοιχείου παλέτας
Αναφορά στοιχείου εργαλείου
Καλέστε τη
Δείτε το κεφάλαιο
Παράδειγμα παλέτας εργαλείου
Αυτό το παράδειγμα προσθέτει μια
Προσαρμογές
Η
Για να μπορούν αυτές οι εφαρμογές να αντιδρούν στις αλλαγές, για παράδειγμα όταν ένας χρήστης μετακινεί μια γραμμή κύλισης, η
Δημιουργία μιας προσαρμογής
Το
Glib::RefPtrlt;Gtk::Adjustmentgt; Gtk::Adjustment::create(
 double value,
 double lower,
 double upper,
 double step_increment = 1,
 double page_increment = 10,
 double page_size = 0);
Το όρισμα
Χρήση προσαρμογών με τον εύκολο τρόπο
Τα προσαρμόσιμα γραφικά συστατικά μπορούν να διαιρεθούν χοντρικά σε αυτά τα οποία χρησιμοποιούν και απαιτούν ειδικές μονάδες για αυτές τις τιμές και σε αυτά που τα θεωρούν ως ελεύθερους αριθμούς.
Η ομάδα που θεωρεί τις τιμές ως τυχαίους αριθμούς περιλαμβάνει τα γραφικά συστατικά
Η άλλη ομάδα περιλαμβάνει τα γραφικά συστατικά
Αν μοιράζεστε ένα αντικείμενο προσαρμογής μεταξύ ενός γραφικού συστατικού γραμμής κύλισης και ενός προβολής κειμένου (TextView), ο χειρισμός της γραμμής κύλισης θα προσαρμόσει αυτόματα το γραφικό συστατικό προβολής κειμένου. Μπορείτε να το ρυθμίσετε όπως αυτό:
// δημιουργεί τις δικές του προσαρμογές
Gtk::TextView textview·
// χρησιμοποιεί την νεοδημιουργούμενη προσαρμογή για τη γραμμή κύλισης επίσης
Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL)·
Προσαρμογή εσωτερικών
Εντάξει, αυτό είναι ωραίο, αλλά τι θα συμβεί αν θελήσετε να δημιουργήσετε τους δικούς σας χειριστές για να απαντούν όταν ο χρήστης ρυθμίζει ένα γραφικό συστατικό
Όπως αναφέρθηκε νωρίτερα, η
Έτσι, για παράδειγμα, αν έχετε ένα γραφικό συστατικό
void cb_rotate_picture (MyPicture* picture)
{
 picture-gt;set_rotation(adj-gt;get_value());
...
και να το συνδέσετε στην προσαρμογή του γραφικού συστατικού κλίμακας όπως αυτό:
adj-gt;signal_value_changed().connect(sigc::bindlt;MyPicture*gt;(sigc::mem_fun(*this,
 &cb_rotate_picture), picture));
Τι συμβαίνει αν ένα γραφικό συστατικό αναδιαμορφώνει τα πεδία
Τα γραφικά συστατικά
Δεν θα χρειαστείτε ποτέ να προσαρτήσετε έναν χειριστή σε αυτό το σήμα, εκτός και γράφετε έναν νέο τύπο γραφικού συστατικού περιοχής.
adjustment-gt;signal_changed();
Γραφικά συστατικά χωρίς X-Windows
Μερικά γραφικά συστατικά δεν έχουν συνδεμένο ένα X-Window, έτσι δεν δέχονται συνεπώς συμβάντα Χ. Αυτό σημαίνει ότι τα σήματα που περιγράφηκαν στην ενότητα
Ιδού μια λίστα μερικών από αυτά τα γραφικά συστατικά:
Gtk::Alignment
Gtk::Arrow
Gtk::AspectFrame
Gtk::Bin
Gtk::Box
Gtk::Button
Gtk::CheckButton
Gtk::Fixed
Gtk::Frame
Gtk::Grid
Gtk::Image
Gtk::Label
Gtk::MenuItem
Gtk::Notebook
Gtk::Paned
Gtk::RadioButton
Gtk::Range
Gtk::ScrolledWindow
Gtk::Separator
Gtk::Table (παρωχημένο από την έκδοση 3.4 του
Αυτά τα γραφικά συστατικά χρησιμοποιούνται κυρίως για διάκοσμο ή διάταξη, έτσι δεν θα χρειάζεστε συχνά τη σύλληψη συμβάντων σε αυτά. Προορίζονται να μην έχουν X-Window για να βελτιώσουν την απόδοση.
Πλαίσιο συμβάντων (Event Box)
Μερικά γραφικά συστατικά της
Αν και το όνομα
Ο κατασκευαστής για
Gtk::EventBox()·
Ένα θυγατρικό γραφικό συστατικό μπορεί να προστεθεί στο
event_box.add(child_widget);
Το παρακάτω παράδειγμα δείχνει και τις δύο χρήσεις ενός
Διάλογοι
Οι διάλογοι χρησιμοποιούνται ως δευτερεύοντα παράθυρα, για να δώσουν ειδικές πληροφορίες ή να ρωτήσουν. Τα παράθυρα
Υπάρχουν αρκετές παραγόμενες κλάσεις
Για να συσκευάσετε γραφικά συστατικά σε έναν προσαρμοσμένο διάλογο, θα πρέπει να τις συσκευάσετε στην
Η μέθοδος
Διάλογος μηνύματος (MessageDialog)
Η
Διάλογος επιλογής αρχείου (FileChooserDialog)
Η
Οι περισσότερες από τις χρήσιμες μεθόδους μέλους για αυτήν την κλάση είναι στην πραγματικότητα στη βασική κλάση
Επιλογέας αρχείου (FileChooser)
Διάλογος επιλογής χρώματος (ColorChooserDialog)
Η
Διάλογος επιλογής γραμματοσειράς (FontChooserDialog)
Η
Μη αναγκαστικό περί του διαλόγου (AboutDialog)
Η
Οι περισσότεροι διάλογοι σε αυτό το κεφάλαιο είναι αναγκαστικοί, παγώνουν την υπόλοιπη εφαρμογή ενώ εμφανίζονται. Είναι επίσης δυνατή η δημιουργία μη αναγκαστικού διαλόγου, που δεν παγώνει άλλα παράθυρα στην εφαρμογή. Το παρακάτω παράδειγμα εμφανίζει μία μη αναγκαστική
Περί διαλόγου (AboutDialog)
Το γραφικό συστατικό περιοχής σχεδίασης
Το γραφικό συστατικό
Η GTK+ χρησιμοποιεί την API σχεδίασης
Μπορείτε να σχεδιάσετε πολύ προχωρημένα σχήματα χρησιμοποιώντας το Cairo, αλλά οι μέθοδοι για να γίνει αυτό είναι αρκετά βασικές. Το Cairo παρέχει μεθόδους για σχεδίαση ευθειών γραμμών, καμπύλων γραμμών και τόξων (συμπεριλαμβανομένων κύκλων). Αυτά τα βασικά σχήματα μπορούν να συνδυαστούν για να δημιουργήσουν πιο σύνθετα σχήματα και μονοπάτια που μπορούν να γεμίσουν με συμπαγή χρώματα, διαβαθμίσεις, μοτίβα και άλλα. Επιπλέον, το Cairo μπορεί να εκτελέσει σύνθετους μετασχηματισμούς, να συνθέσει εικόνες και να αποδώσει εξομαλυμένο κείμενο.
Cairo και Pango
Αν και το Cairo μπορεί να αποδώσει κείμενο, δεν σημαίνει ότι είναι αντικατάσταση του Pango. Το Pango είναι μια καλύτερη επιλογή αν χρειάζεται να εκτελέσετε πιο προχωρημένη απόδοση κειμένου όπως αναδίπλωση ή ελλειπτικό κείμενο. Η σχεδίαση κειμένου με το Cairo πρέπει να γίνεται μόνο αν το κείμενο είναι μέρος ενός γραφικού.
Σε αυτήν την ενότητα του μαθήματος, θα καλύψουμε το βασικό πρότυπο σχεδίασης του Cairo, θα περιγράψουμε κάθε βασικό στοιχείο σχεδίασης με κάποιες λεπτομέρειες (με παραδείγματα) και έπειτα θα παρουσιάσουμε μια απλή εφαρμογή που χρησιμοποιεί Cairo για τη σχεδίαση ενός προσαρμοσμένου γραφικού συστατικού ρολογιού.
Το πρότυπο σχεδίασης Cairo
Η βασική ιδέα σχεδίασης στο Cairo εμπεριέχει τον ορισμό 'αόρατων' μονοπατιών και έπειτα βάψιμο ή γέμισμά τους για να γίνουν ορατά.
Για να κάνετε οποιαδήποτε σχεδίαση στο
Το παρακάτω παράδειγμα εμφανίζει πώς να ρυθμιστεί ένα περιεχόμενο Cairo με ένα χρώμα προσκηνίου κόκκινου και ένα πλάτος 2. Οποιεσδήποτε λειτουργίες σχεδίασης που χρησιμοποιούν αυτό το περιεχόμενο θα χρησιμοποιήσουν αυτές τις ρυθμίσεις.
Gtk::DrawingArea myArea;
Cairo::RefPtrlt;Cairo::Contextgt; myContext = myArea.get_window()-gt;create_cairo_context();
myContext-gt;set_source_rgb(1.0, 0.0, 0.0);
myContext-gt;set_line_width(2.0);
Κάθε
Υπάρχει ένας αριθμός από μεταβλητές κατάστασης γραφικών που μπορεί να οριστεί για περιεχόμενο Cairo. Τα πιο κοινά γνωρίσματα περιεχομένου είναι χρώμα (χρησιμοποιώντας
Είναι καλή πρακτική να βάζετε όλες τις τροποποιήσεις στην κατάσταση γραφικών μεταξύ κλήσεων συναρτήσεων
void doSomething(const Cairo::RefPtrlt;Cairo::Contextgt;amp; context, int x)
{
 context-gt;save();
 // αλλαγή κατάστασης γραφικών
 // εκτέλεση λειτουργιών σχεδίασης
 context-gt;restore();
}
Η τρέχουσα κατάσταση μιας
Η εικονική μέθοδος
Σχεδίαση ευθειών γραμμών
Αφού τα η βιβλιοθήκη γραφικών Cairo γράφτηκε με υποστήριξη για πολλαπλούς προορισμούς εξόδου (το σύστημα παραθύρου Χ, εικόνες PNG, OpenGL, κλπ), υπάρχει μια διάκριση μεταξύ συντεταγμένων χώρου χρήστη και χώρου συσκευής. Η αντιστοίχιση μεταξύ αυτών των δύο συστημάτων συντεταγμένων προεπιλέγει σε αντιστοίχιση ένα προς ένα, έτσι ώστε οι ακέραιες τιμές να απεικονίζουν χοντρικά εικονοστοιχεία στην οθόνη, αλλά αυτή η ρύθμιση μπορεί να προσαρμοστεί, εάν θέλετε. Μερικές φορές, μπορεί να είναι χρήσιμο να κλιμακώσετε τις συντεταγμένες έτσι ώστε το πλήρες πλάτος και ύψος ενός παραθύρου να βρίσκεται από 0 μέχρι 1 (η 'τετράγωνη μονάδα') ή κάποια άλλη απεικόνιση που δουλεύει για την εφαρμογή σας. Αυτό μπορεί να γίνει με τη λειτουργία
Τώρα που κατανοήσαμε τα βασικά της βιβλιοθήκης γραφικών του Cairo, είμαστε σχεδόν έτοιμοι να ξεκινήσουμε τη σχεδίαση. Θα αρχίσουμε με τα πιο απλά στοιχεία σχεδίασης: την ευθεία γραμμή. Αλλά πρώτα χρειάζεται να ξέρετε λίγα για το σύστημα συντεταγμένων του Cairo. Η αρχή του συστήματος συντεταγμένων του Cairo βρίσκεται στην πάνω αριστερή γωνία του παραθύρου με θετικές τιμές x στα δεξιά και θετικές τιμές y προς τα κάτω.
Σε αυτό το παράδειγμα, θα κατασκευάσουμε ένα μικρό, αλλά πλήρως λειτουργικό πρόγραμμα της
Αφού έχετε τελειώσει τη δημιουργία του μονοπατιού σας, δεν έχετε σχεδιάσει ακόμα τίποτα ορατό ακόμα. Για να κάνετε ορατό το μονοπάτι, πρέπει να χρησιμοποιήσετε τη συνάρτηση
Πολλές συναρτήσεις σχεδίασης Cairo έχουν μια παραλλαγή
Περιοχή σχεδίασης - Γραμμές
Αυτό το πρόγραμμα περιέχει μια μοναδική κλάση,
Σχεδίαση με σχετικές συντεταγμένες
Στο παραπάνω παράδειγμα σχεδιάσαμε καθετί χρησιμοποιώντας απόλυτες συντεταγμένες. Μπορείτε επίσης να σχεδιάσετε χρησιμοποιώντας σχετικές συντεταγμένες. Για μια ευθεία γραμμή, αυτό γίνεται με τη συνάρτηση
Τεχνοτροπίες γραμμής
Πέρα από τη σχεδίαση βασικών ευθειών γραμμών, υπάρχει ένας αριθμός από πράγματα που μπορείτε να προσαρμόσετε σε μια γραμμή. Έχετε ήδη δει παραδείγματα ρύθμισης χρώματος και πλάτους γραμμής, αλλά υπάρχουν κι άλλα.
Αν έχετε σχεδιάσει μια σειρά γραμμών που σχηματίζουν μια διαδρομή, μπορεί να θελήσετε να τις ενώσετε μαζί με έναν συγκεκριμένο τρόπο. Το Cairo προσφέρει τρεις διαφορετικούς τρόπους για ένωση γραμμών μεταξύ τους: μύτη, λοξότμηση και στρογγυλό. Αυτά εμφανίζονται παρακάτω:
Διαφορετικοί τύποι ένωσης στο Cairo
Η τεχνοτροπία ένωσης γραμμής ορίζεται χρησιμοποιώντας τη συνάρτηση
Τα άκρα της γραμμής μπορούν να έχουν διαφορετικές τεχνοτροπίες επίσης. Η προεπιλεγμένη τεχνοτροπία είναι να αρχίζει και να σταματά η γραμμή ακριβώς στα σημεία προορισμού της γραμμής. Αυτό λέγεται ένα κουτσουρεμένο άκρο. Οι άλλες επιλογές είναι στρογγυλή (χρησιμοποιεί ένα στρογγυλό τέλος, με το κέντρο του κύκλου στο τελικό σημείο) ή τετράγωνη (χρησιμοποιεί ένα τετραγωνισμένο τέλος, με το κέντρο του τετραγώνου στο τελικό σημείο). Αυτή η ρύθμιση ορίζεται χρησιμοποιώντας τη συνάρτηση
Υπάρχουν άλλα πράγματα που μπορείτε να προσαρμόσετε επίσης, συμπεριλαμβανομένων της δημιουργίας γραμμών με παύλες και άλλα. Για περισσότερες πληροφορίες, δείτε την τεκμηρίωση API Cairo.
Σχεδίαση λεπτών γραμμών
Αν δοκιμάσετε να σχεδιάσετε γραμμές πλάτους ενός εικονοστοιχείου, μπορεί να σημειώσετε ότι η γραμμή μερικές φορές παρουσιάζεται θολωμένη και πλατύτερη από όσο θα έπρεπε να είναι. Αυτό συμβαίνει επειδή το Cairo θα προσπαθήσει να σχεδιάσει από την επιλεγμένη θέση και στις δυο πλευρές (μισή σε καθεμιά), έτσι αν είσαστε τοποθετημένοι ακριβώς στην τομή των εικονοστοιχείων και θέλετε μια γραμμή με πλάτος ένα εικονοστοιχείο, το Cairo θα προσπαθήσει να χρησιμοποιήσει το μισό κάθε γειτονικού εικονοστοιχείου, που δεν είναι δυνατό (ένα εικονοστοιχείο είναι η μικρότερη δυνατή μονάδα). Αυτό συμβαίνει όταν το πλάτος της γραμμής είναι ένας περιττός αριθμός εικονοστοιχείων (όχι μόνο ένα εικονοστοιχείο).
Το τέχνασμα είναι η τοποθέτηση στη μέση του εικονοστοιχείου όπου θέλετε η γραμμή να σχεδιαστεί και έτσι εγγυάται ότι παίρνετε τα επιθυμητά αποτελέσματα. Δείτε
Περιοχή σχεδίασης - Λεπτές γραμμές
Σχεδίαση καμπύλων γραμμών
Πέρα από τη σχεδίαση ευθειών γραμμών το Cairo επιτρέπει την εύκολη σχεδίαση καμπύλων γραμμών (τεχνικά μια κυβική εύκαμπτη καμπύλη Bézier) χρησιμοποιώντας τις συναρτήσεις
Αυτή η απλή εφαρμογή σχεδιάζει μια καμπύλη με Cairo και εμφανίζει τα σημεία ελέγχου για κάθε άκρο της καμπύλης.
Η μόνη διαφορά μεταξύ αυτού του παραδείγματος και του παραδείγματος της ευθείας γραμμής είναι στη συνάρτηση
Κάνουμε μια κλήση στη
Η κλήση στη
Σχεδίαση τόξων και κύκλων
Με το Cairo, η ίδια συνάρτηση χρησιμοποιείται για σχεδίαση τόξων, κύκλων ή ελλείψεων:
context-gt;save();
context-gt;translate(x, y);
context-gt;scale(width / 2.0, height / 2.0);
context-gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);
context-gt;restore();
Για σχεδίαση μιας έλλειψης, μπορείτε να κλιμακώσετε τον τρέχοντα πίνακα μετασχηματισμού κατά διαφορετικά ποσά στις κατευθύνσεις Χ και Υ. Για παράδειγμα, για τη σχεδίαση μιας έλλειψης με κέντρο στο
Ιδού ένα παράδειγμα απλού προγράμματος που σχεδιάζει ένα τόξο, έναν κύκλο και μια έλλειψη σε μια περιοχή σχεδίασης.
Περιοχή σχεδίασης - Τόξα
Υπάρχουν κάποια πράγματα να σημειώσετε για αυτόν τον κώδικα του παραδείγματος. Πάλι, η μόνη πραγματική διαφορά μεταξύ αυτού του παραδείγματος και των προηγούμενων είναι η συνάρτηση
Σημειώστε ότι σε αυτήν την περίπτωση, έχουμε εκφράσει σχεδόν καθετί ως προς το ύψος και το πλάτος του παραθύρου, συμπεριλαμβάνοντας το πλάτος των γραμμών. Λόγω αυτού, όταν αυξομειώνετε το παράθυρο, καθετί κλιμακώνεται με το παράθυρο. Επίσης, σημειώστε ότι υπάρχουν τρεις ενότητες σχεδίασης στη συνάρτηση και καθεμιά συσκευάζεται με ένα ζεύγος
Η ενότητα για σχεδίαση ενός τόξου εισάγει μια νέα συνάρτηση,
Σχεδίαση αριστερόστροφα
Η συνάρτηση
Σχεδίαση κειμένου
Σχεδίαση κειμένου με Pango
Το κείμενο σχεδιάζεται μέσα από διατάξεις Pango. Ο πιο εύκολος τρόπος για δημιουργία μιας
Ιδού ένα παράδειγμα προγράμματος που σχεδιάζει κάποιο κείμενο, κάποιο από αυτό ανάποδα. Το κεφάλαιο εκτύπωσης περιέχει ένα άλλο
Περιοχή σχεδίασης - Κείμενο
Σχεδίαση εικόνων
Υπάρχει μια μέθοδος για σχεδίαση από μια
Προφανώς ο πιο συνηθισμένος τρόπος δημιουργίας
Η
Ιδού ένα μικρό τμήμα κώδικα για σύζευξη τους όλων μαζί: (Σημειώστε ότι συνήθως δεν θα πρέπει να φορτώνετε την εικόνα κάθε φορά στον χειριστή σήματος σχεδίασης! Εμφανίζεται απλά εδώ για να τα διατηρήσει όλα μαζί.)
bool MyArea::on_draw(const Cairo::RefPtrlt;Cairo::Contextgt;amp; cr)
{
 Glib::RefPtrlt;Gdk::Pixbufgt; image = Gdk::Pixbuf::create_from_file("myimage.png");
 // Draw the image at 110, 90, εκτός από το πιο εξωτερικό 10 pixels.
 Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);
 cr-gt;rectangle(110, 90, image-gt;get_width()-20, image-gt;get_height()-20);
 cr-gt;fill();
 return true;
}
Ιδού ένα παράδειγμα απλού προγράμματος που σχεδιάζει μια εικόνα.
Περιοχή σχεδίασης - Εικόνα
Εφαρμογή παραδείγματος: Δημιουργία ενός ρολογιού με Cairo
Τώρα, που έχουμε καλύψει τα βασικά της σχεδίασης με Cairo, ας δοκιμάσουμε να τα βάλουμε όλα μαζί και να δημιουργήσουμε μια απλή εφαρμογή που πράγματι κάνει κάτι. Το παρακάτω παράδειγμα χρησιμοποιεί Cairo για τη δημιουργία ενός προσαρμοσμένου γραφικού συστατικού
Όπως πριν, όλο σχεδόν το ενδιαφέρον υλικό γίνεται στον χειριστή σήματος σχεδίασης
Τώρα, ας ρίξουμε μια ματιά στον κώδικα που εκτελεί την ενεργή σχεδίαση. Η πρώτη ενότητα της
Η συνάρτηση
Μετά τη σχεδίαση του περιγράμματος, πηγαίνουμε γύρω από το ρολόι και σχεδιάζουμε υποδιαιρέσεις για κάθε ώρα, με μια μεγαλύτερη υποδιαίρεση στα 12, 3, 6 και 9. Τώρα, τελικά είμαστε έτοιμοι να υλοποιήσουμε την λειτουργία διατήρησης του χρόνου του ρολογιού, που εμπεριέχει απλά τη λήψη των τρεχουσών τιμών για ώρες, λεπτά και δευτερόλεπτα και σχεδίαση των δεικτών στις σωστές γωνίες.
Η
Πηγές και προορισμοί
Τα πράγματα μεταφέρονται από
προορισμός: Ένα όνομα, όπως "ΣΥΜΒΟΛΟΣΕΙΡΑ"
πληροφορία: Ένα αναγνωριστικό που θα σταλεί στα σήματά σας για να σας πει ποια TargetEntry χρησιμοποιήθηκε.
σημαίες: Χρησιμοποιούνται μόνο για μεταφορά και απόθεση, αυτό καθορίζει αν τα δεδομένα μπορούν να μετακινηθούν σε άλλα γραφικά συστατικά και εφαρμογές, ή μόνο στα ίδια.
Τα αντικείμενα
Η
void drag_source_set(const std::vectorlt;Gtk::TargetEntrygt;amp; targets,
 Gdk::ModifierType start_button_mask, Gdk::DragAction actions);
Το


void drag_dest_set(const std::vectorlt;Gtk::TargetEntrygt;amp; targets,
 Gtk::DestDefaults flags, Gdk::DragAction actions);
Οι
Οι
Όταν ένας προορισμός απόθεσης έχει αποδεχτεί ένα μεταφερόμενο στοιχείο, συγκεκριμένα σήματα θα εκπεμφθούν, ανάλογα με το ποια ενέργεια έχει επιλεγεί. Για παράδειγμα, ο χρήστης μπορεί να έχει πατημένο το πλήκτρο
Αντιγραφή



Το πηγαίο γραφικό συστατικό θα εκπέμψει αυτά τα σήματα, με αυτήν τη σειρά:



Το γραφικό συστατικό προορισμού θα εκπέμψει αυτά τα σήματα, με αυτήν τη σειρά:
Μετακίνηση

Κατά τη διάρκεια μιας
Περιεχόμενο μεταφοράς (DragContext)
Τα σήματα μεταφοράς και απόθεσης παρέχουν ένα DragContext, που περιέχει κάποια πληροφορία για τη λειτουργία μεταφοράς και απόθεσης και μπορεί να χρησιμοποιηθεί για να επηρεάσει τη διεργασία. Για παράδειγμα, μπορείτε να ανακαλύψετε το πηγαίο γραφικό συστατικό, ή να αλλάξετε το εικονίδιο της μεταφοράς και απόθεσης, χρησιμοποιώντας τις μεθόδους
Να ένα πολύ απλό παράδειγμα, που δείχνει μια λειτουργία μεταφοράς και απόθεσης
Υπάρχει ένα πιο σύνθετο παράδειγμα στο examples/others/dnd.
Το πρόχειρο
Η λειτουργία αντιγραφής-επικόλλησης απλού κειμένου παρέχεται ελεύθερα από γραφικά συστατικά όπως
Μπορείτε συνήθως να προσποιηθείτε ότι η
Η εφαρμογή σας δεν χρειάζεται να περιμένει για τις λειτουργίες του προχείρου, ιδιαίτερα μεταξύ του χρόνου όταν ο χρήστης επιλέγει αντιγραφή και έπειτα αργότερα επιλέγει επικόλληση. Οι περισσότερες μέθοδοι
Προορισμοί
Διαφορετικές εφαρμογές περιέχουν διαφορετικούς τύπους δεδομένων και μπορεί να κάνουν τα δεδομένα διαθέσιμα σε μια ποικιλία μορφών. Η
Για παράδειγμα, η
Ένας προορισμός μπορεί να είναι σε μια ποικιλία δυαδικών μορφών. Αυτό το κεφάλαιο και τα παραδείγματα θεωρούν ότι τα δεδομένα είναι κείμενο 8 δυαδικών. Αυτό μπορεί να επιτρέψει τη χρήση μιας μορφής XML για τα δεδομένα του προχείρου. Όμως, αυτό μπορεί προφανώς να μην είναι κατάλληλο για δυαδικά δεδομένα όπως εικόνες. Η
Η API της
Όταν ο χρήστης ζητά να αντιγράψει κάποια δεδομένα, θα πρέπει να πείτε στο
Glib::RefPtrlt;Gtk::Clipboardgt; refClipboard = Gtk::Clipboard::get();

//Προορισμοί:
std::vectorlt;Gtk::TargetEntrygt; targets;
targets.push_back( Gtk::TargetEntry("example_custom_target") );
targets.push_back( Gtk::TargetEntry("UTF8_STRING") );

refClipboard-gt;set( targets,
 sigc::mem_fun(*this, &ExampleWindow::on_clipboard_get),
 sigc::mem_fun(*this, &ExampleWindow::on_clipboard_clear) );
Η επανάκληση θα δώσει τότε τα αποθηκευμένα δεδομένα, όταν ο χρήστης επιλέγει την επικόλληση δεδομένων. Για παράδειγμα:
void ExampleWindow::on_clipboard_get(
 Gtk::SelectionDataamp; selection_data, guint /* info */)
{
 const std::string target = selection_data.get_target();

 if(target == "example_custom_target")
 selection_data.set("example_custom_target", m_ClipboardStore);
}
Το
Η επανάκληση καθαρισμού επιτρέπει την απελευθέρωση χρησιμοποιούμενης μνήμης από τα αποθηκευμένα δεδομένα όταν το πρόχειρο αντικαθιστά τα δεδομένα του με κάτι άλλο.
Επικόλληση
Όταν ο χρήστης ζητά την επικόλληση δεδομένων από την
refClipboard-gt;request_contents("example_custom_target",
 sigc::mem_fun(*this, &ExampleWindow::on_clipboard_received) );
Ιδού ένα παράδειγμα μεθόδου επανάκλησης:
void ExampleWindow::on_clipboard_received(
 const Gtk::SelectionDataamp; selection_data)
{
 Glib::ustring clipboard_data = selection_data.get_data_as_string();
 //Do something with the pasted data.
}
Εύρεση των διαθέσιμων προορισμών
Για την εύρεση των προορισμών που είναι προς το παρόν διαθέσιμοι στην
refClipboard-gt;request_targets( sigc::mem_fun(*this,
 &ExampleWindow::on_clipboard_received_targets) )·
Αν η επανάκλησή σας, συγκρίνεται το διάνυσμα των διαθέσιμων προορισμών με αυτά που υποστηρίζει η εφαρμογή σας για επικόλληση. Μπορείτε να ενεργοποιήσετε ή να απενεργοποιήσετε το στοιχείο μενού επικόλλησης, ανάλογα με το αν η επικόλληση είναι προς το παρόν δυνατή. Για παράδειγμα:
void ExampleWindow::on_clipboard_received_targets(
 const std::vectorlt;Glib::ustringgt;amp; targets)
{
 const bool bPasteIsPossible =
 std::find(targets.begin(), targets.end(),
 example_target_custom) != targets.end();

 // Ενεργοποίηση/απενεργοποίηση του κατάλληλου κουμπιού επικόλλησης:
 m_Button_Paste.set_sensitive(bPasteIsPossible);
}
Απλό
Αυτό το παράδειγμα επιτρέπει αντιγραφή και επικόλληση των ειδικών δεδομένων εφαρμογής, χρησιμοποιώντας τον τυπικό προορισμό κειμένου. Αν και είναι απλό, δεν είναι ιδανικό επειδή δεν αναγνωρίζει ότι τα δεδομένα
Πρόχειρο - Απλό
Ιδανικό
Ορίζει έναν προσαρμοσμένο προορισμό προχείρου, αν και η μορφή αυτού του προορισμού είναι ακόμα κείμενο.
Υποστηρίζει την επικόλληση 2 προορισμών - και του προσαρμοσμένου και ενός κειμένου που δημιουργεί μια παρουσίαση ελεύθερου κειμένου των προσαρμοσμένων δεδομένων.
Χρησιμοποιεί τη
Αυτό είναι όπως το απλό παράδειγμα, αλλά
Πρόχειρο - Ιδανικό
Εκτύπωση
Στο επίπεδο ανάπτυξης της εφαρμογής, η API εκτύπωσης της
Λειτουργία εκτύπωσης (PrintOperation)
Το κύριο αντικείμενο είναι




Για κάθε σελίδα που χρειάζεται να απεικονιστεί, τα παρακάτω σήματα εκπέμπονται:



Η μέθοδος
Διαμόρφωση σελίδας
Η κλάση
Θα πρέπει να αποθηκεύσετε την επιλεγμένη
//Μέσα σε μια κλάση που κληρονομεί από Gtk::Window και διατηρεί m_refPageSetup και m_refSettings ως μέλη...
Glib::RefPtrlt;Gtk::PageSetupgt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);
m_refPageSetup = new_page_setup;
Για παράδειγμα,
Το σύστημα συντεταγμένων Cairo, στον χειριστή
Απεικόνιση κειμένου
Η απόδοση κειμένου γίνεται χρησιμοποιώντας Pango. Το αντικείμενο
Δείτε
Ασύγχρονες λειτουργίες
Από προεπιλογή, η
Η
// Στην μέθοδο της κλάσης ExampleWindow...
Glib::RefPtrlt;PrintOperationgt; op = PrintOperation::create();
// ...Ορίστε τη λειτουργία...
op-gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &ExampleWindow::on_printoperation_done), op));
// Εκτελέστε τη λειτουργία
void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtrlt;PrintOperationgt;amp; op)
{
 if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)
 //ειδοποιήστε τον χρήστη
 else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)
 //Ενημερώστε τις ρυθμίσεις εκτύπωσης με αυτές που χρησιμοποιούνται στον προσανατολισμό εκτύπωσης

 if (! op-gt;is_finished())
 op-gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &ExampleWindow::on_printoperation_status_changed), op));
}
Δεύτερο, ελέγξτε για σφάλμα και συνδεθείτε με το σήμα
void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtrlt;PrintFormOperationgt;amp; op)
{
 if (op-gt;is_finished())
 //Η εργασία εκτύπωσης τελείωσε
 else
 //πάρτε την κατάσταση με get_status() ή get_status_string()

 //Ενημέρωση της διεπαφής χρήστη
}
Τελικά, ελέγξτε την κατάσταση. Για παράδειγμα,
Εξαγωγή σε PDF
Glib::RefPtrlt;Gtk::PrintOperationgt; op = Gtk::PrintOperation::create();
// ...Ρύθμιση λειτουργίας...
op-gt;set_export_filename("test.pdf");
Gtk::PrintOperationResult res = op-gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);
Η επιλογή 'εκτύπωση σε αρχείο' είναι διαθέσιμη στον διάλογο εκτύπωσης, χωρίς την ανάγκη πρόσθετης υλοποίησης. Όμως, είναι χρήσιμο μερικές φορές να δημιουργήσετε ένα αρχείο pdf άμεσα από κώδικα. Για παράδειγμα,
Επέκταση του διαλόγου εκτύπωσης
Ορίστε τον τίτλο της καρτέλας μέσα από την
Λήψη των δεδομένων από τα γραφικά συστατικά στον χειριστή σήματος
Μπορείτε να προσθέσετε μια προσαρμοσμένη καρτέλα στον διάλογο εκτύπωσης:
Gtk::Widget* CustomPrintOperation::on_create_custom_widget()
{
 set_custom_tab_label("My custom tab");

 Gtk::Box* hbox = new Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 8);
 hbox-gt;set_border_width(6);

 Gtk::Label* label = Gtk::manage(new Gtk::Label("Enter some text: "));
 hbox-gt;pack_start(*label, false, false);
 label-gt;show();

 hbox-gt;pack_start(m_Entry, false, false);
 m_Entry.show();

 return hbox;
}

void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)
{
 Glib::ustring user_input = m_Entry.get_text();
 //...
}
Αν και το σήμα
Το παράδειγμα στο examples/book/printing/advanced δείχνει αυτό.
Προεπισκόπηση
// σε μια κλάση που κληρονομεί από Gtk::Window...
Glib::RefPtrlt;PrintOperationgt; op = PrintOperation::create();
// ...ρύθμιση λειτουργίας...
op-gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);
Ο εγγενής διάλογος εκτύπωσης GTK+ έχει ένα πλήκτρο προεπισκόπησης, αλλά μπορείτε επίσης να ξεκινήσετε μια προεπισκόπηση άμεσα από μια εφαρμογή:
Στο Γιούνιξ, ο προεπιλεγμένος χειριστής προεπισκόπησης χρησιμοποιεί ένα εξωτερικό πρόγραμμα προβολής. Στα Windows, ο εγγενής διάλογος προεπισκόπησης θα εμφανιστεί. Αν είναι απαραίτητο, μπορείτε να αντικαταστήσετε αυτήν τη συμπεριφορά και να δώσετε έναν προσαρμοσμένο διάλογο προεπισκόπησης. Δείτε το παράδειγμα που βρίσκεται στο /examples/book/printing/advanced.
Το παρακάτω παράδειγμα δείχνει πώς να εκτυπώσετε κάποια είσοδο από μια διεπαφή χρήστη. Εμφανίζει πώς να υλοποιήσετε τις
Εκτύπωση - Απλή
Πρόσφατα χρησιμοποιημένα έγγραφα
Η
Κάθε στοιχείο στον κατάλογο των πρόσφατα χρησιμοποιημένων αρχείων ταυτοποιείται από το URI του και μπορεί να συσχετιστεί με μεταδεδομένα. Τα μεταδεδομένα μπορούν να χρησιμοποιηθούν για τον ορισμό του τρόπου εμφάνισης του αρχείου, μια περιγραφή του αρχείου, τον τύπο του mime, ποια εφαρμογή το καταχωρίζει, αν είναι ιδιωτικό στην εφαρμογή καταχώρισης και πολλά άλλα πράγματα.
Πρόσφατος διαχειριστής (RecentManager)
Η
Μπορείτε να δημιουργήσετε μια νέα
Η
Προσθήκη στοιχείων στον κατάλογο των πρόσφατων αρχείων
Για να προσθέσετε ένα νέο αρχείο στον κατάλογο των πρόσφατων εγγράφων, στην πιο απλή περίπτωση, χρειάζεστε μόνο να δώσετε το URI. Για παράδειγμα:
Glib::RefPtrlt;Gtk::RecentManagergt; recent_manager = Gtk::RecentManager::get_default();
recent_manager-gt;add_item(uri);
Αν θέλετε να καταχωρίσετε ένα αρχείο με μεταδεδομένα, μπορείτε να περάσετε μια παράμετρο







Πέρα από την προσθήκη στοιχείων στον κατάλογο, μπορείτε επίσης να αναζητήσετε στοιχεία από τον κατάλογο και να τροποποιήσετε ή να αφαιρέσετε στοιχεία.
Αναζήτηση στοιχείων στον κατάλογο των πρόσφατων αρχείων
Για την αναζήτηση πρόσφατα χρησιμοποιημένων αρχείων, η
Glib::RefPtrlt;Gtk::RecentInfogt; info;
try
{
 info = recent_manager-gt;lookup_item(uri);
}
catch(const Gtk::RecentManagerErroramp; ex)
{
 std::cerr &lt;lt; "RecentManagerError: " &lt;lt; ex.what() &lt;lt; std::endl;
}
if (info)
{
 // το στοιχείο βρέθηκε
}
Ένα αντικείμενο
Αν δεν θέλετε να ψάξετε για ένα συγκεκριμένο URI, αλλά αντίθετα θέλετε να πάρετε έναν κατάλογο όλων των πρόσφατα χρησιμοποιημένων στοιχείων, η
std::vectorlt; Glib::RefPtrlt;Gtk::RecentInfogt; &gt; info_list = recent_manager-gt;get_items();
Η μέγιστη ηλικία των στοιχείων στον κατάλογο των πρόσφατα χρησιμοποιημένων αρχείων μπορεί να οριστεί με την
Τροποποίηση του καταλόγου των πρόσφατων αρχείων
Εκεί μπορεί να υπάρχουν φορές που χρειάζεστε να τροποποιήσετε τον κατάλογο των πρόσφατων αρχείων. Για παράδειγμα, αν ένα αρχείο μετακινήθηκε ή μετονομάστηκε, μπορεί να χρειαστεί να ενημερώσετε τη θέση του αρχείου στον κατάλογο πρόσφατων αρχείων, έτσι ώστε να μην δείχνει μια εσφαλμένη θέση. Μπορείτε να ενημερώσετε τη θέση ενός στοιχείου χρησιμοποιώντας την
Πέρα από την αλλαγή του URI ενός αρχείου, μπορείτε επίσης να αφαιρέσετε στοιχεία από τον κατάλογο, είτε ένα τη φορά είτε καθαρίζοντας τα όλα μονομιάς. Το πρώτο πραγματοποιείται με την
Οι συναρτήσεις
Επιλογή προσφάτων (RecentChooser)
Η
Η
Οι
Απλό παράδειγμα διαλόγου επιλογής προσφάτων (RecentChooserDialog)
Παρακάτω εμφανίζεται ένα απλό παράδειγμα χρήσης των κλάσεων
Αν αυτή είναι η πρώτη φορά που χρησιμοποιείτε ένα πρόγραμμα που χρησιμοποιεί τον σκελετό πρόσφατων αρχείων, ο διάλογος μπορεί να είναι κενός στην αρχή. Αλλιώς πρέπει να εμφανίσει έναν κατάλογο των πρόσφατα χρησιμοποιημένων καταχωρισμένων εγγράφων από άλλες εφαρμογές.
Μετά την επιλογή του στοιχείου μενού
Ο κατασκευαστής για την
Φιλτράρισμα πρόσφατων αρχείων
Για οποιαδήποτε κλάση
Αφού έχετε δημιουργήσει και ρυθμίσει το φίλτρο να ταιριάζει μόνο τα στοιχεία που θέλετε, μπορείτε να εφαρμόσετε ένα φίλτρο σε ένα γραφικό συστατικό επιλογής με τη συνάρτηση
Δέκτες και δότες (Plugs and Sockets)
Επισκόπηση
Κάπου-κάπου, μπορεί να είναι χρήσιμο να μπορείτε να ενσωματώσετε ένα γραφικό συστατικό από μια άλλη εφαρμογή στην εφαρμογή σας. Η
Η επικοινωνία μεταξύ μιας
Ο τρόπος που οι
Δότες (Sockets)
Μια
Δέκτες (Plugs)
Μια
Αφού μια
Σύνδεση δοτών και δεκτών
Αφού ένα αντικείμενο
Δημιουργήστε ένα αντικείμενο
Δημιουργήστε μια
Υπάρχουν δύο βασικές στρατηγικές που μπορούν να χρησιμοποιηθούν:
Παράδειγμα δεκτών και δοτών (Plugs and Sockets)
Το παρακάτω είναι ένα απλό παράδειγμα χρήσης δεκτών και δοτών. Η μέθοδος επικοινωνίας μεταξύ διεργασιών διατηρείται σκόπιμα πολύ απλή: Η
Αυτό το παράδειγμα δημιουργεί δύο εκτελέσιμα προγράμματα:
Ξεκινήστε το πρόγραμμα
$ ./plug &
Μετά από το οποίο θα πρέπει να δείτε κάτι όπως το παρακάτω:
Το αναγνωριστικό του παραθύρου είναι: 69206019
Έπειτα αρχίστε το πρόγραμμα
$ ./socket
Μετά την έναρξη του
I've been embedded.
A plug was added
Η πρώτη γραμμή της εξόδου είναι από το
If for some reason the
Συμβάντα πληκτρολογίου
Τα συμβάντα Χ διαφέρουν με κάποιους τρόπους από άλλα σήματα. Αυτές οι διαφορές περιγράφονται στην ενότητα
Όποτε πατάτε ή απελευθερώνετε ένα πλήκτρο, εκπέμπεται ένα συμβάν. Μπορείτε να συνδέσετε έναν χειριστή σήματος για να επεξεργαστεί τέτοια συμβάντα.
Για να δεχτείτε τα συμβάντα του πληκτρολογίου, πρέπει πρώτα να; καλέσετε τη συνάρτηση
Για να προσδιορίσετε ποιο πλήκτρο πατήθηκε ή απελευθερώθηκε διαβάζετε την τιμή της
bool on_key_press_or_release_event(GdkEventKey* event)
{
 if (event-gt;type == GDK_KEY_PRESS &amp;
 event-gt;keyval == GDK_KEY_1 &amp;
 (event-gt;state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)
 {
 handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key
 return true;
 }
 return false;
}

Gtk::Entry m_entry; // στον ορισμό κλάσης

// στον κατασκευαστή κλάσης
m_entry.signal_key_press_event().connect( sigc::ptr_fun(amp;on_key_press_or_release_event) );
m_entry.signal_key_release_event().connect( sigc::ptr_fun(amp;on_key_press_or_release_event) );
m_entry.add_events(Gdk::KEY_PRESS_MASK | Gdk::KEY_RELEASE_MASK);
Ιδού ένα απλό παράδειγμα:
Σε αυτό το παράδειγμα υπάρχουν τρεις συντομεύσεις πληκτρολογίου: η
Συμβάντα πληκτρολογίου - απλό
Διάδοση συμβάντος
Διάδοση συμβάντος σημαίνει ότι, όταν ένα συμβάν εκπέμπεται σε ένα συγκεκριμένο γραφικό συστατικό, μπορεί να περαστεί στο γονικό τους γραφικό συστατικό (και αυτό το γραφικό συστατικό μπορεί να το περάσει στο γονικό του, και ούτω καθεξής) και, αν το γονικό έχει έναν χειριστή συμβάντος, αυτός ο χειριστής θα κληθεί.
Αντίθετα με άλλα συμβάντα, τα συμβάντα πληκτρολογίου στέλνονται πρώτα στο παράθυρο ανωτάτου επιπέδου (
Το συμβάν θα διαδοθεί μέχρι να φτάσει στο γραφικό συστατικό ανωτάτου επιπέδου, ή μέχρι να σταματήστε τη διάδοση επιστρέφοντας
Σημειώστε, ότι μετά την ακύρωση ενός συμβάντος, καμιά άλλη συνάρτηση δεν θα κληθεί (ακόμα κι αν είναι από το ίδιο γραφικό συστατικό).
Σε αυτό το παράδειγμα υπάρχουν τρεις χειριστές συμβάντων που καλούνται μετά τον προεπιλεγμένο χειριστή συμβάντος της
Στην
Ο σκοπός αυτού του παραδείγματος είναι να εμφανίσει τα βήματα που παίρνει το συμβάν όταν εκπέμπεται.
Όταν γράφετε στην καταχώριση, ένα συμβάν απελευθέρωσης πλήκτρου θα εκπεμφθεί, που θα πάει πρώτα στο παράθυρο ανωτάτου επιπέδου (
Συμβάντα πληκτρολογίου - Διάδοση συμβάντος
Λήξεις χρόνου, είσοδος/έξοδος και αδρανείς συναρτήσεις
Λήξεις χρόνου
Μπορεί να αναρωτιέστε πώς γίνεται η
sigc::connection Glib::SignalTimeout::connect(const sigc::slotlt;boolgt;amp; slot,
 unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);
Το πρώτο όρισμα είναι μια
my_connection.disconnect();
bool MyCallback() { std::cout &lt;lt; "Hello World!\
" &lt;lt; std::endl; return true; }
Ένας άλλος τρόπος καταστροφής της σύνδεσης είναι ο χειριστής σήματός σας. Πρέπει να είναι του τύπου
Μπορείτε να σταματήσετε τη μέθοδο λήξης χρόνου επιστρέφοντας
Ιδού ένα παράδειγμα αυτής της τεχνικής:
Εποπτεία εισόδου/εξόδου
Ένα αποτελεσματικό γνώρισμα του Glib (μια από τις βιβλιοθήκες που υπόκεινται στην
sigc::connection Glib::SignalIO::connect(const sigc::slotlt;bool,Glib::IOConditiongt;amp; slot,
 int fd, Glib::IOCondition condition,
 int priority = Glib::PRIORITY_DEFAULT);
Το πρώτο όρισμα είναι μια σχισμή που θέλετε να κληθεί όταν το συγκεκριμένο συμβάν (δείτε όρισμα 3) συμβαίνει στον περιγραφέα του αρχείου που ορίσατε χρησιμοποιώντας το όρισμα δύο. Το όρισμα τρία μπορεί να είναι ένα ή περισσότερα (χρησιμοποιώντας
Glib::IO_IN - Κλήση της μεθόδου σας όταν υπάρχουν δεδομένα έτοιμα για ανάγνωση στον περιγραφέα αρχείου σας.
Glib::IO_OUT - Κλήση της μεθόδου σας όταν ο περιγραφέας αρχείου είναι έτοιμος για εγγραφή.
Glib::IO_PRI - Κλήση της μεθόδου σας όταν ο περιγραφέας αρχείου έχει επείγοντα δεδομένα για ανάγνωση.
Glib::IO_ERR - Κλήση της μεθόδου σας όταν ένα σφάλμα προκύψει στον περιγραφέα αρχείου.
Glib::IO_HUP - Κλήση της μεθόδου σας όταν διακόψει (η σύνδεση έχει διακοπεί συνήθως για διοχετεύσεις και υποδοχές).
Η τιμή επιστροφής είναι μια
bool input_callback(Glib::IOCondition condition);
όπου η
Ένα μικρό παράδειγμα ακολουθεί. Για τη χρήση του παραδείγματος εκτελέστε το απλά από ένα τερματικό· δεν δημιουργεί παράθυρο. Θα δημιουργήσει μια διοχέτευση με όνομα
Αδρανείς συναρτήσεις
Αν θέλετε να ορίσετε μια μέθοδο που καλείται όταν τίποτα άλλο δεν συμβαίνει, χρησιμοποιήστε την ακόλουθη:
sigc::connection Glib::SignalIdle::connect(const sigc::slotlt;boolgt;amp; slot,
 int priority = Glib::PRIORITY_DEFAULT_IDLE);
Αυτό προκαλεί την
bool idleFunc();
Αφού αυτό είναι πολύ παρόμοιο με τις παραπάνω μεθόδους αυτή η εξήγηση πρέπει να είναι αρκετή για την κατανόηση του τι συμβαίνει. Όμως, να ένα μικρό παράδειγμα:
Αυτό το παράδειγμα δείχνει λίγο τη διαφορά των μεθόδων αδράνειας και λήξης χρόνου. Αν χρειάζεστε μεθόδους που καλούνται περιοδικά και η ταχύτητα δεν είναι πολύ σημαντική, τότε θέλετε μεθόδους χρόνου λήξης. Αν θέλετε μεθόδους που καλούνται όσον το δυνατό πιο συχνά (όπως υπολογισμός κλαστικού στο παρασκήνιο), τότε χρησιμοποιήστε τις αδρανείς μεθόδους.
Δοκιμάστε την εκτέλεση του παραδείγματος και αυξήστε το φορτίο του συστήματος. Η ανώτερη γραμμή προόδου θα αυξάνεται σταθερά· η κατώτερη γραμμή θα επιβραδύνεται.
Διαχείριση μνήμης
Κανονική διαχείριση μνήμης C++
Η
Ιδού μερικά παραδείγματα κανονικής διαχείρισης μνήμης C++:
Τα γραφικά συστατικά εμβέλειας κλάσης
Αν ένας προγραμματιστής δεν χρειάζεται δυναμική κατανομή μνήμης, μπορούν να χρησιμοποιηθούν αυτόματα γραφικά συστατικά στην εμβέλεια της κλάσης. Ένα πλεονέκτημα των αυτόματων γραφικών συστατικών σε εμβέλεια κλάσης είναι ότι η διαχείριση μνήμης ομαδοποιείται σε μια θέση. Ο προγραμματιστής δεν διακινδυνεύει διαρροές μνήμης από αποτυχία
Το κύριο μειονέκτημα χρήσης γραφικών συστατικών εμβέλειας κλάσης είναι η εμφάνιση της υλοποίησης κλάσης αντί για την διεπαφή κλάσης στην κεφαλίδα κλάσης.
#include &lt;gtkmm/button.hgt;
#include &lt;gtkmm/window.hgt;
class Foo : public Gtk::Window
{
private:
 Gtk::Button theButton;
 // θα καταστραφεί όταν το αντικείμενο Foo καταστραφεί
};
Γραφικά συστατικά εμβέλειας συνάρτησης
{
 Gtk::Button aButton;
 aButton.show();
 ...
 app-gt;run();
}
Αν ένας προγραμματιστής δεν χρειάζεται ένα γραφικό συστατικό εμβέλειας κλάσης, ένα γραφικό συστατικό εμβέλειας συνάρτησης μπορεί επίσης να χρησιμοποιηθεί. Τα πλεονεκτήματα της εμβέλειας συνάρτησης πάνω στην εμβέλεια κλάσης είναι η αυξημένη απόκρυψη δεδομένων και οι μειωμένες εξαρτήσεις.
Η δυναμική κατανομή με νέο και διαγραφή
Gtk::Button* pButton = new Gtk::Button("Test");

// κάντε κάτι χρήσιμο με το pButton

delete pButton;
Αν και, στις περισσότερες περιπτώσεις, ο προγραμματιστής θα προτιμήσει να επιτρέψει στους περιέκτες την αυτόματη καταστροφή των θυγατρικών τους χρησιμοποιώντας την
Διαχειριζόμενα γραφικά συστατικά
Εναλλακτικά, μπορείτε να επιτρέψετε ένα χειριστήριο περιέκτη του γραφικού συστατικού όταν το γραφικό συστατικό καταστρέφεται. Στις περισσότερες περιπτώσεις, θέλετε ένα γραφικό συστατικό να κρατήσει μόνο όσο ο περιέκτης είναι μέσα. Για ανάθεση της διαχείρισης χρόνου ζωής του γραφικού συστατικού στο περιέκτη του, δημιουργήστε το πρώτα με την
Δυναμική κατανομή με manage() και add()
Η
MyContainer::MyContainer()
{
 Gtk::Button* pButton = Gtk::manage(new Gtk::Button("Test"));
 add(*pButton); //προσθήκη του *pButton στο MyContainer
}

Φυσικά, ένας περιέκτης ανωτάτου επιπέδου δεν θα προστεθεί σε άλλον περιέκτη. Ο προγραμματιστής είναι υπεύθυνος για την καταστροφή του περιέκτη ανωτάτου επιπέδου χρησιμοποιώντας μία από τις παραδοσιακές τεχνικές της C++. Για παράδειγμα, το παράθυρο ανωτάτου επιπέδου σας μπορεί να είναι απλά ένα στιγμιότυπο στη συνάρτησή σας
Κοινόχρηστοι πόροι
Κάποια αντικείμενα, όπως
Glib::RefPtrlt;Gdk::Pixbufgt; pixbuf = Gdk::Pixbuf::create_from_file(filename);
Αντικείμενα όπως
int width = 0;
if(pixbuf)
{
 width = pixbuf-gt;get_width();
}
Δεν έχετε τρόπο λήψης μιας γυμνής
Όταν η
Glib::RefPtrlt;Gdk::Pixbufgt; pixbuf2 = pixbuf;
Αν αντιγράψετε μια
Δείτε το
Bjarne Stroustrup, "The C++ Programming Language" Forth Edition - section 34.3
Nicolai M. Josuttis, "The C++ Standard Library" - section 4.2
Αν θέλετε να μάθετε περισσότερα για τους έξυπνους δείκτες, μπορείτε να ψάξετε σε αυτά τα βιβλία:
Glade and Gtk::Builder
Αν και μπορείτε να χρησιμοποιήσετε τον κώδικα C++ για να δημιουργήσετε και να τακτοποιήσετε τα γραφικά συστατικά, αυτό μπορεί σύντομα να γίνει κουραστικό και επαναλαμβανόμενο. Και απαιτεί μια αναμεταγλώττιση για την εμφάνιση των αλλαγών. Η εφαρμογή
Απαιτείται λιγότερος κώδικας C++.
Οι αλλαγές διεπαφής χρήστη μπορούν να φανούν πιο γρήγορα, έτσι οι διεπαφές χρήστη μπορούν να βελτιωθούν.
Οι σχεδιαστές χωρίς προγραμματιστικές δεξιότητες μπορούν να δημιουργήσουν και να επεξεργαστούν διεπαφές χρήστη.
Αυτό έχει τα ακόλουθα πλεονεκτήματα:
Χρειάζεστε ακόμα κώδικα C++ για να αντιμετωπίσετε αλλαγές διεπαφής χρήστη που προκλήθηκαν από ενέργειες χρήστη, αλλά η χρήση της
Φόρτωση του αρχείου .glade
Glib::RefPtrlt;Gtk::Buildergt; builder = Gtk::Builder::create_from_file("basic.glade");
Η
Glib::RefPtrlt;Gtk::Buildergt; builder = Gtk::Builder::create_from_file("basic.glade", "treeview_products");
Για δημιουργία μόνο ενός παραθύρου, ή απλά μόνο ενός από τα θυγατρικά γραφικά συστατικά, μπορείτε να ορίσετε το όνομα ενός θυγατρικού γραφικού συστατικού ως τη δεύτερη παράμετρο. Για παράδειγμα,
Πρόσβαση γραφικών συστατικών
Gtk::Dialog* pDialog = 0;
builder-gt;get_widget("DialogBasic", pDialog);
Η πρόσβαση ενός γραφικού συστατικού, για παράδειγμα σε ένα διάλογο
Η
Να θυμάστε ότι δεν δημιουργείτε ένα γραφικό συστατικό με τη
Η
Αυτό το απλό παράδειγμα εμφανίζει πώς να φορτώσετε ένα αρχείο
Χρησιμοποιώντας παράγωγα γραφικά συστατικά
Μπορείτε να χρησιμοποιήσετε την
DerivedDialog* pDialog = 0;
builder-gt;get_widget_derived("DialogBasic", pDialog);
Χρησιμοποιήστε
Η παραγόμενη κλάση σας πρέπει να έχει έναν κατασκευαστή που παίρνει έναν δείκτη στον υποκείμενο τύπο C και το στιγμιότυπο
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtrlt;Gtk::Buildergt;amp; builder)
: Gtk::Dialog(cobject)
{
}
Πρέπει να καλέσετε τον κατασκευαστή της βασικής κλάσης στον κατάλογο αρχικοποίησης, δίνοντας τον δείκτη C. Για παράδειγμα,
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtrlt;Gtk::Buildergt;amp; builder)
: Gtk::Dialog(cobject),
 m_builder(builder),
 m_pButton(0)
{
 //Λήψη του στιγμιοτύπου κουμπιού Glade και σύνδεση με χειριστή σήματος:
 m_builder-gt;get_widget("quit_button", m_pButton);
 if(m_pButton)
 {
 m_pButton-gt;signal_clicked().connect( sigc::mem_fun(*this, &DerivedDialog::on_button_quit) );
 }
}
Μπορείτε έπειτα να ενθυλακώσετε τον χειρισμό των θυγατρικών γραφικών συστατικών στον κατασκευαστή της παράγωγης κλάσης, ίσως χρησιμοποιώντας την
Αυτό το παράδειγμα εμφανίζει πώς να φορτώσετε ένα αρχείο
Διεθνοποίηση και τοπικοποίηση
Οι εφαρμογές
Μπορεί να μην προβλέψετε την ανάγκη υποστήριξης πρόσθετων γλωσσών, αλλά δεν μπορείτε ποτέ να το αποκλείσετε. Φυσικά, είναι ευκολότερο να αναπτύξετε την εφαρμογή κατάλληλα από την αρχή αντί να την τροποποιήσετε αργότερα.
Η διαδικασία συγγραφής πηγαίου κώδικα που επιτρέπει την μετάφραση λέγεται
Η κύρια δραστηριότητα στην διεργασία διεθνοποίησης είναι η εύρεση των συμβολοσειρών που βλέπουν οι χρήστες και η σημείωσή τους για μετάφραση. Δεν χρειάζεστε να το κάνετε όλο μονομιάς - αν εγκαταστήσετε την απαραίτητη υποδομή του έργου σωστά, τότε η εφαρμογή σας θα δουλέψει κανονικά ανεξάρτητα από το πόσες συμβολοσειρές έχετε καλύψει.
Οι κυριολεκτικές συμβολοσειρές πρέπει να πληκτρολογηθούν στα αγγλικά, αλλά περιβαλόμενες από μια μακροεντολή. Το εργαλείο
Προετοιμασία του έργου σας
Στις παρακάτω οδηγίες θα θεωρήσουμε ότι δεν χρησιμοποιείτε την
Θεωρούμε επίσης ότι χρησιμοποιείτε autotools (π.χ.
Δημιουργήστε έναν υποκατάλογο με όνομα
Το
# keep this file sorted alphabetically, one language code per line
de
ja
(Επιπλέον, θα έχετε τα αρχεία
Το
src/main.cc
src/other.cc
Αν χρησιμοποιείτε μια
Τώρα που υπάρχει μια θέση να βάλετε τις μεταφράσεις σας, χρειάζεται να αρχικοποιήσετε τις
IT_PROG_INTLTOOL([0.35.0])

GETTEXT_PACKAGE=programname
AC_SUBST(GETTEXT_PACKAGE)
AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], ["$GETTEXT_PACKAGE"],
 [The domain to use with gettext])
AM_GLIB_GNU_GETTEXT

PROGRAMNAME_LOCALEDIR=[${datadir}/locale]
AC_SUBST(PROGRAMNAME_LOCALEDIR)
Αυτή η μεταβλητή
Προσθέστε
INTLTOOL_FILES = intltool-extract.in \\
 intltool-merge.in \\
 intltool-update.in
Ορίστε το
Προσθέστε το
DISTCLEANFILES = ... intltool-extract \\
 intltool-merge \\
 intltool-update \\
 po/.intltool-merge-cache
Ενημερώστε το
Στο ανώτατο επίπεδο Makefile.am:
Στο
AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\"${PROGRAMNAME_LOCALEDIR}\\"
Αυτή η μακροεντολή θα χρησιμοποιηθεί όταν αρχικοποιείτε την
Σημειώνοντας συμβολοσειρές για μετάφραση
Οι κυριολεκτικές συμβολοσειρές πρέπει να πληκτρολογηθούν στον πηγαίο κώδικα στα αγγλικά, αλλά θα πρέπει να περιβάλλονται από μια κλήση στη συνάρτηση
Το πακέτο
display_message("Getting ready for i18n.");
display_message(_("Getting ready for i18n."));
Όμως, η
xgettext -a -o my-strings --omit-header *.cc *.h
Για αναφορά, είναι δυνατή η δημιουργία ενός αρχείου που περιέχει όλες τις συμβολοσειρές που εμφανίζονται στον κώδικά σας, ακόμα κι αν δεν σημειώνονται για μετάφραση, μαζί με το όνομα του αρχείου και τις αναφορές αριθμού γραμμής. Για τη δημιουργία ενός τέτοιου αρχείου με όνομα
bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);
bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
textdomain(GETTEXT_PACKAGE);
Τελικά, για να σας επιτρέψει το πρόγραμμα να χρησιμοποιήσετε τη μετάφραση για την τρέχουσα τοπική ρύθμιση, προσθέστε αυτόν τον κώδικα στην αρχή του αρχείου
Πώς δουλεύει το gettext
Το σενάριο
Την ώρα εγκατάστασης τα αρχεία
Όταν η εφαρμογή εκτελείται, η βιβλιοθήκη
Δοκιμή και προσθήκη μεταφράσεων
intltool-update --pot
Για να πειστείτε ότι το κάνατε σωστά, ίσως θελήσετε να προσθέσετε μια μετάφραση για νέες τοπικές ρυθμίσεις. Για να το κάνετε αυτό, πηγαίνετε στον υποκατάλογο
Αυτό θα δημιουργήσει ένα αρχείο με όνομα
Είναι δυνατό συγκεκριμένες συμβολοσειρές να σημειωθούν ως
Πόροι
README του εργαλείου διεθνοποίησης (Intltool)
Πώς να χρησιμοποιήσετε το git για μεταφραστές GNOME
εγχειρίδιο λήψης κειμένου (gettext)
gtkmm_hello

gnomemm_hello
Περισσότερες πληροφορίες για το τι βρίσκεται πίσω από τη διεργασία διεθνοποίησης και τοπικοποίησης παρουσιάζεται και επιδεικνύεται στο:
Αναμένεται UTF8
Μια σωστά διεθνοποιημένη εφαρμογή δεν θα κάνει υποθέσεις για τον αριθμό των ψηφιολέξεων σε έναν χαρακτήρα. Αυτό σημαίνει ότι δεν πρέπει να χρησιμοποιείτε αριθμητικό δείκτη για να περιδιαβείτε τους χαρακτήρες σε μια συμβολοσειρά και σημαίνει ότι δεν πρέπει να χρησιμοποιήσετε
Όμως, προφανώς αποφεύγετε ήδη γυμνούς πίνακες char* και αριθμητικούς δείκτες χρησιμοποιώντας την
Glib::ustring and std::iostreams
std::ostringstream output·
output.imbue(std::locale(""))· // χρήση των τοπικών ρυθμίσεων χρήστη για αυτήν τη ροή
output &lt;lt; percentage &lt;lt; " % done"·
label-gt;set_text(Glib::locale_to_utf8(output.str()))·
Δυστυχώς, η ενσωμάτωση με τις τυπικές ροές εισόδου/εξόδου δεν είναι πλήρως αλάνθαστη. Η
Παγίδες
Υπάρχουν λίγα συνηθισμένα λάθη που πρέπει να βρείτε τελικά οι ίδιοι. Αλλά αυτή η ενότητα μπορεί να σας βοηθήσει να τα αποφύγετε.
Ίδιες συμβολοσειρές, διαφορετική σημασιολογία
Μερικές φορές δύο αγγλικές συμβολοσειρές είναι ταυτόσημες, αλλά έχουν διαφορετικά νοήματα σε διαφορετικά περιεχόμενα, έτσι μπορεί προφανώς να μην είναι ταυτόσημα όταν μεταφράζονται. Αφού οι αγγλικές συμβολοσειρές χρησιμοποιούνται ως κλειδιά αναζήτησης, αυτό προκαλεί προβλήματα.
Σε αυτές τις περιπτώσεις, θα πρέπει να προσθέσετε πρόσθετους χαρακτήρες στις συμβολοσειρές. Για παράδειγμα, χρησιμοποιήστε
// σημείωση στους μεταφραστές: μην μεταφράζετε το τμήμα "[noun]" είναι
// εδώ απλά για να ξεχωρίσει τη συμβολοσειρά από μια άλλη συμβολοσειρά "jumps"
text = strip(gettext("jumps[noun]"), "[noun]");
Σύνθεση των συμβολοσειρών
Οι προγραμματιστές της C χρησιμοποιούν την
Για παράδειγμα, αυτός ο κώδικας μπορεί να είναι προβληματικός:
std::cout &lt;lt; _("Current amount: ") &lt;lt; amount
 &lt;lt; _(" Future: ") &lt;lt; future &lt;lt; std::endl;

label.set_text(_("Really delete ") + filename + _(" now?"));
std::cout &lt;lt; Glib::ustring::compose(
 _("Current amount: %1 Future: %2"), amount, future) &lt;lt; std::endl;

label.set_text(Glib::ustring::compose(_("Really delete %1 now?"), filename));
Έτσι θα πρέπει ή να αποφύγετε αυτήν την κατάσταση ή να χρησιμοποιήσετε
Υποθέτοντας το εμφανιζόμενο μέγεθος των συμβολοσειρών
Δεν ξέρετε ποτέ πόσο χώρο θα πάρει μια συμβολοσειρά στην οθόνη όταν μεταφραστεί. Μπορεί πιθανόν να είναι διπλάσια από το μέγεθος της αρχικής αγγλικής συμβολοσειράς. Ευτυχώς, τα περισσότερα γραφικά συστατικά της
Σπάνιες λέξεις
Θα πρέπει να αποφεύγετε κρυπτογραφικές συντομεύσεις, αργκό, ή φρασεολογία. Είναι συνήθως δύσκολο να μεταφραστούν και είναι συχνά δύσκολες ακόμα και για μητρικούς ομιλητές να τις κατανοήσουν. Για παράδειγμα, προτιμήστε "application" από "app"
Χρήση χαρακτήρων μη ASCII στις συμβολοσειρές
Προς το παρόν, η
Για την παράκαμψη του, μπορείτε να γράψετε ένα σχόλιο στον πηγαίο κώδικα ακριβώς πριν τη συμβολοσειρά, λέγοντας στους μεταφραστές να χρησιμοποιήσουν τον ειδικό χαρακτήρα, αν είναι διαθέσιμος στις γλώσσες τους. Για τα αγγλικά, μπορείτε τότε να κάνετε μια μετάφραση σε αγγλικά Αμερικής
Λήψη βοήθειας με τις μεταφράσεις
Αν το πρόγραμμά σας είναι ελεύθερου λογισμικού, υπάρχει ένα ολόκληρο υποέργο του
Ο τρόπος που δουλεύει είναι ότι στέλνετε τον πηγαίο κώδικα σας σε ένα αποθετήριο git, όπου οι μεταφραστές μπορούν να το προσπελάσουν, έπειτα επικοινωνείτε με την ταχυδρομική λίστα του gnome-i18n και ζητάτε να προστεθεί το πρόγραμμά σας στο
Έπειτα επιβεβαιώνετε την ενημέρωση του αρχείου
Σημειώστε ότι οι περισσότερες ομάδες γλώσσας αποτελούνται μόνο από 1-3 άτομα, έτσι αν το πρόγραμμά σας περιέχει πολλές συμβολοσειρές, μπορεί να κρατήσει κάμποσο πριν οποιοσδήποτε έχει τον χρόνο να το κοιτάξει. Επίσης, οι περισσότεροι μεταφραστές δεν θέλουν να σπαταλούν τον χρόνο τους (η μετάφραση είναι μια πολύ χρονοβόρα εργασία), έτσι δεν αξιολογούν το έργο σας ως πραγματικά σοβαρό (με την έννοια ότι είναι βελτιωμένο και συντηρούμενο) μπορεί να αποφασίσουν να διαθέσουν τον χρόνο τους σε κάποιο άλλο έργο.
Προσαρμοσμένα γραφικά συστατικά
Η
Προσαρμοσμένοι περιέκτες
Η
Η
Η
Η
Η
Η
Η
Η
Η
Η
Κατά την παραγωγή από
Οι εικονικές μέθοδοι
Δεν υπάρχει εγγύηση ότι θα πάρετε το
Η
Εκτός και ο περιέκτης σας είναι ένα παράθυρο ανωτάτου επιπέδου που παράγεται από την
Αντικαθιστώντας την
Αν και ο περιέκτης σας μπορεί να έχει τη δική του μέθοδο ορισμού των θυγατρικών γραφικών συστατικών, θα πρέπει ακόμα να δώσετε μια υλοποίηση για τις εικονικές μεθόδους
Η υλοποίηση της μεθόδου
Αυτό το παράδειγμα υλοποιεί έναν περιέκτη με δύο θυγατρικά γραφικά συστατικά, το ένα πάνω από το άλλο. Φυσικά, σε αυτήν την περίπτωση μπορεί να είναι πολύ πιο απλά να χρησιμοποιήσετε απλά μια κάθετη
Προσαρμοσμένος περιέκτης
Παράγοντας άμεσα από την
Η
Η
Η
Η
Η
Η
Η
Η
Η
Η
Η
Όταν προέρχεται από την
Οι πρώτες 6 μέθοδοι στον προηγούμενο πίνακα αντικαταστάθηκαν επίσης στους προσαρμοσμένους περιέκτες. Περιγράφονται συνοπτικά στην ενότητα
Τα περισσότερα προσαρμοσμένα γραφικά συστατικά χρειάζονται τη δικιά τους
Αυτό το παράδειγμα υλοποιεί ένα γραφικό συστατικό που σχεδιάζει ένα τρίγωνο Penrose.
Προσαρμοσμένο γραφικό συστατικό
Πολυνηματικά προγράμματα
Οι περιορισμοί
Η
Αυτές οι αλληλεπιδράσεις εγείρονται από το γεγονός ότι, μεταξύ άλλων πραγμάτων, μια κλάση που κληρονομεί από την
Όμως, απαιτείται φροντίδα όταν συγγράφονται προγράμματα με βάση την
Οι κανόνες
Αυτό απαιτεί έναν αριθμό από κανόνες να παρατηρούνται κατά την εγγραφή πολυνηματικών προγραμμάτων χρησιμοποιώντας την
Χρησιμοποιήστε την
Ένα αντικείμενο
Οποιοδήποτε αντικείμενο
Ένα αντικείμενο
Αν ένα ειδικό αντικείμενο κλάσης προέρχεται από την
Αν και η
Οι παραλλαγές connect*_once(),
Χρήση Glib::Dispatcher
Οι συνδεμένες υποδοχές με αντικείμενα
Μερικοί κανόνες ασφάλειας νημάτων με τη χρήση της
Πέρα από το γεγονός ότι συνδεμένες υποδοχές εκτελούνται πάντα στο νήμα δέκτη, τα αντικείμενα
Ένα αντικείμενο
Αυτό είναι ένα παράδειγμα προγράμματος με δύο νήματα, ένα νήμα GUI, όπως σε όλα τα προγράμματα της
Μια
Πολυνηματικά προγράμματα
Συνιστώμενες τεχνικές
Αυτή η ενότητα είναι απλά μια συγκέντρωση σοφίας, γενικές οδηγίες τεχνοτροπίας και συμβουλές για δημιουργία εφαρμογών
Χρήση των GNU
Τα γραφικά συστατικά υποκλάσεων για καλύτερη οργάνωση του κώδικά σας. Θα πρέπει προφανώς να δημιουργήσετε υποκλάσεις στο κύριο
Δημιουργήστε τα δικά σας σήματα αντί να περάσετε ολόγυρα δείκτες. Τα αντικείμενα μπορούν να επικοινωνούν μεταξύ τους μέσα από σήματα και χειριστές σήματος. Αυτό είναι πολύ πιο απλό από αντικείμενα που κρατούν δείκτες μεταξύ τους και καλούν μεθόδους μεταξύ τους. Οι κλάσεις
Χρόνος ζωής εφαρμογής
Οι περισσότερες εφαρμογές θα έχουν μόνο μια
Τα περισσότερα από τα παραδείγματά μας χρησιμοποιούν αυτήν την τεχνική.
Χρησιμοποιώντας ένα γραφικό συστατικό
Όλα τα παραδείγματά μας τείνουν να έχουν την ίδια δομή. Ακολουθούν αυτά τα βήματα για τη χρήση μιας
Δηλώστε μια μεταβλητή του τύπου
Ορίστε τα γνωρίσματα του γραφικού συστατικού. Αν το γραφικό συστατικό δεν έχει προεπιλεγμένο κατασκευαστή, τότε θα χρειαστείτε να αρχικοποιήσετε το γραφικό συστατικό στον κατάλογο αρχικοποίησης του κατασκευαστή της κλάσης περιέκτη.
Συνδέστε οποιοδήποτε σήμα που θέλετε να χρησιμοποιήσετε με τους κατάλληλους χειριστές.
Συσκευάστε το γραφικό συστατικό σε έναν περιέκτη χρησιμοποιώντας την κατάλληλη κλήση, π.χ.
Καλέστε
Η
Συνεισφορά
Αυτό το έγγραφο, όπως πολύ άλλο μεγάλο λογισμικό εκεί, δημιουργήθηκε δωρεάν από εθελοντές. Αν έχετε γνώσεις για οποιαδήποτε όψη της
Ιδανικά, θα θέλαμε να
Αν αποφασίσετε να συνεισφέρετε, παρακαλούμε στείλτε τη συνεισφορά σας στην ταχυδρομική λίστα
Ο έξυπνος δείκτης RefPtr
Η
Ένας έξυπνος δείκτης δρα παρόμοια με έναν κανονικό δείκτη. Ιδού μερικά παραδείγματα.
Αντιγραφή
Μπορείτε να αντιγράψετε
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf2 = refPixbuf;
Φυσικά αυτό σημαίνει ότι μπορείτε να αποθηκεύσετε τις
std::listlt; Glib::RefPtrlt;Gdk::Pixbufgt; &gt; listPixbufs;
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);
listPixbufs.push_back(refPixbuf);
Αποαναφορά
Μπορείτε να αποαναφέρετε έναν έξυπνο δείκτη με τον τελεστή -gt;, για να καλέσετε τις μεθόδους του υποκείμενου στιγμιότυπου, ακριβώς όπως ένας κανονικός δείκτης.
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);
int width = refPixbuf-gt;get_width();
Αλλά αντίθετα με τους περισσότερους έξυπνους δείκτες, δεν μπορείτε να χρησιμοποιήσετε τον τελεστή * για να προσπελάσετε το υποκείμενο στιγμιότυπο.
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);
Gdk::Pixbufamp; underlying = *refPixbuf; //Σφάλμα σύνταξης - δεν θα μεταγλωττίσει.
Αλλαγή τύπου
Μπορείτε να μετατρέψετε μια
Glib::RefPtrlt;Gtk::TreeStoregt; refStore = Gtk::TreeStore::create(columns);
Glib::RefPtrlt;Gtk::TreeModelgt; refModel = refStore;
Αυτό σημαίνει ότι οποιαδήποτε μέθοδος που παίρνει ένα όρισμα
Μπορείτε επίσης να μετατρέψετε σε έναν παράγωγο τύπο, αλλά η σύνταξη είναι λίγο διαφορετική από ότι με έναν κανονικό δείκτη.
Glib::RefPtrlt;Gtk::TreeStoregt; refStore =
Glib::RefPtrlt;Gtk::TreeStoregt;::cast_dynamic(refModel);
Glib::RefPtrlt;Gtk::TreeStoregt; refStore2 =
Glib::RefPtrlt;Gtk::TreeStoregt;::cast_static(refModel);
Έλεγχος για κενό
Ακριβώς όπως οι κανονικοί δείκτες, μπορείτε να ελέγξετε αν η
Glib::RefPtrlt;Gtk::TreeModelgt; refModel = m_TreeView.get_model();
if(refModel)
{
 int cols_count = refModel-gt;get_n_columns();
 ...
}
Αλλά αντίθετα με τους κανονικούς δείκτες, οι
Σταθερότητα
Η χρήση της λέξης-κλειδί
Συνεπώς, η ισοδύναμη
Η
Σύνδεση χειριστών σημάτων
Οι κλάσεις γραφικών συστατικών
Ιδού ένα παράδειγμα ενός χειριστή σήματος που συνδέθηκε σε ένα σήμα:
#include &lt;gtkmm/button.hgt;

void on_button_clicked()
{
 std::cout &lt;lt; "Hello World" &lt;lt; std::endl;
}

main()
{
 Gtk::Button button("Hello World");
 button.signal_clicked().connect(sigc::ptr_fun(amp;on_button_clicked));
}
Υπάρχουν μάλλον πολλά να σκεφτείτε για αυτόν τον (μη λειτουργικό) κώδικα. Πρώτα ας αναγνωρίσουμε τα εμπλεκόμενα μέρη:
Ο χειριστής σήματος είναι
Το συνδέουμε στο αντικείμενο
Όταν το πλήκτρο εκπέμπει το σήμα του
Τώρα ας κοιτάξουμε στη σύνδεση ξανά:
...
 button.signal_clicked().connect(sigc::ptr_fun(amp;on_button_clicked));
 ...
Σημειώστε ότι δεν περάσαμε έναν δείκτη στην
Η
Ιδού ένα ελαφρώς μεγαλύτερο παράδειγμα υποδοχών σε δράση:
void on_button_clicked();

class some_class
{
 void on_button_clicked();
};

some_class some_object;

main()
{
 Gtk::Button button;
 button.signal_clicked().connect( sigc::ptr_fun(amp;on_button_clicked) );
 button.signal_clicked().connect( sigc::mem_fun(some_object, &some_class::on_button_clicked) );
}
Η πρώτη κλήση στην
Το επόμενο είναι πιο ενδιαφέρον. Η
Ένα άλλο πράγμα που πρέπει να σημειώσετε για αυτό το παράδειγμα είναι ότι κάναμε την κλήση στην
Μόλις σας είπαμε ότι το σήμα
Εγγραφή χειριστών σημάτων
Για την εύρεση του τύπου του χειριστή σήματος που μπορείτε να συνδέσετε με ένα σήμα, μπορείτε να το κοιτάξετε στην τεκμηρίωση αναφοράς ή στο αρχείο κεφαλίδας. Ιδού ένα παράδειγμα της δήλωσης σήματος που μπορείτε να δείτε στις κεφαλίδες
Glib::SignalProxy1lt;bool, Gtk::DirectionTypegt; signal_focus()
Πέρα από το όνομα του σήματος (
Οι ίδιες αρχές εφαρμόζονται για σήματα που έχουν περισσότερα ορίσματα. Ιδού ένα με τρία (ελήφθησαν από
Glib::SignalProxy3lt;void, const TextBuffer::iteratoramp;, const Glib::ustrinamp;, intgt; signal_insert();
Ακολουθεί την ίδια μορφή. Ο αριθμός 3 στο τέλος του ονόματος τύπου δείχνει ότι ο χειριστής σήματος θα χρειαστεί τρία ορίσματα. Ο πρώτος τύπος στον κατάλογο τύπων είναι
void on_insert(const TextBuffer::iteratoramp; pos, const Glib::ustringamp; text, int bytes)
Αποσύνδεση χειριστών σημάτων
Ας κοιτάξουμε τη μέθοδο του σήματος
sigc::signallt;void,intgt;::iterator signallt;void,intgt;::connect( const sigc::slotlt;void,intgt;amp; );
Σημειώστε ότι η τιμή επιστροφής είναι του τύπου
Αντικατάσταση προεπιλεγμένων χειριστών σημάτων
Μέχρι τώρα σας έχουμε πει να εκτελείτε ενέργειες σε απάντηση των πατημάτων πλήκτρου και το παρόμοιο χειριζόμενοι σήματα. Αυτός είναι σίγουρα ένας καλός τρόπος να γίνονται τα πράγματα, αλλά δεν είναι ο μόνος τρόπος.
Αντί για την επίπονη σύνδεση χειριστών σημάτων σε σήματα, μπορείτε να κάνετε απλά μια νέα κλάση που κληρονομεί από ένα γραφικό συστατικό - ας πούμε, ένα πλήκτρο - και έπειτα να αντικαταστήσετε τον προεπιλεγμένο χειριστή σήματος, όπως τον Button::on_clicked(). Αυτό μπορεί να είναι πιο απλό από την αγκίστρωση χειριστών σήματος για καθετί.
Η δημιουργία υποκλάσεων δεν είναι πάντα ο καλύτερος τρόπος πραγματοποίησης. Είναι χρήσιμος μόνο όταν θέλετε το γραφικό συστατικό να χειρίζεται το δικό του σήμα από μόνο του. Αν θέλετε κάποια άλλη κλάση να χειρίζεται το σήμα, τότε θα χρειαστείτε να συνδέσετε έναν ξεχωριστό χειριστή. Αυτό είναι ακόμα περισσότερο αληθές, αν θέλετε αρκετά αντικείμενα να χειρίζονται το ίδιο σήμα, ή αν θέλετε ένας χειριστής σήματος να απαντά στο ίδιο σήμα από διαφορετικά αντικείμενα.
Οι κλάσεις
Ας κοιτάξουμε ένα παράδειγμα αντικατάστασης:
#include &lt;gtkmm/button.hgt;

class OverriddenButton : public Gtk::Button
{
protected:
 virtual void on_clicked();
}

void OverriddenButton::on_clicked()
{
 std::cout &lt;lt; "Hello World" &lt;lt; std::endl;

 // κλήση της έκδοσης της μεθόδου της κλάσης βάσης:
 Gtk::Button::on_clicked();
}
Εδώ ορίζουμε μια νέα κλάση που λέγεται
Δεν χρειάζεται πάντα να καλέσετε τη γονική μέθοδο· υπάρχουν φορές που μπορεί να μην το θέλετε. Σημειώστε ότι, καλούμε τη γονική μέθοδο
Σύνδεση πρόσθετων ορισμάτων
m_button1.signal_clicked().connect( sigc::bindlt;Glib::ustringgt;( sigc::mem_fun(*this, &HelloWorld::on_button_clicked), "button 1") );
virtual void on_button_clicked(Glib::ustring data);
Αν χρησιμοποιείτε έναν χειριστή σήματος για λήψη του ίδιου σήματος από αρκετά γραφικά συστατικά, μπορεί να σας αρέσει ο χειριστής σήματος να δεχτεί μερικές πρόσθετες πληροφορίες. Για παράδειγμα, μπορεί να θελήσετε να μάθετε ποιο κουμπί πατήθηκε. Μπορείτε να το κάνετε με την
Η
Σήματα συμβάντος Χ
Η κλάση
Μπορεί ενίοτε να βρείτε χρήσιμο τον χειρισμό συμβάντων Χ, όταν υπάρχει κάτι που δεν μπορείτε να πραγματοποιήσετε με κανονικά σήματα. Η
Αυτά τα σήματα συμπεριφέρονται λίγο διαφορετικά. Η επιστρεφόμενη τιμή από τον χειριστή σήματος δείχνει αν έχει "χειριστεί" πλήρως το συμβάν. Αν η τιμή είναι
Ο χειρισμός ενός συμβάντος Χ δεν επηρεάζει τα άλλα σήματα του γραφικού συστατικού. Αν χειρίζεστε το
Σημειώστε επίσης ότι όλα τα γραφικά συστατικά δέχονται όλα τα συμβάντα Χ από προεπιλογή. Για να δεχτείτε πρόσθετα συμβάντα Χ, μπορείτε να χρησιμοποιήσετε τη
bool on_button_press(GdkEventButton* event);
Gtk::Button button("label");
button.signal_button_press_event().connect( sigc::ptr_fun(amp;on_button_press) );
Όταν το ποντίκι είναι πάνω από το πλήκτρο και ένα πλήκτρο του ποντικιού πατιέται, Θα κληθεί η
Ο
Αλληλουχία χειριστή σήματος
button.signal_button_press_event().connect( sigc::ptr_fun(amp;on_mywindow_button_press), false );
Από προεπιλογή, οι χειριστές σήματός σας καλούνται μετά από οποιουσδήποτε προηγουμένως συνδεμένους χειριστές σήματος. Όμως, αυτό μπορεί να είναι ένα πρόβλημα με τα σήματα συμβάντος Χ. Για παράδειγμα, οι υπάρχοντες χειριστές σήματος, ή ο προεπιλεγμένος χειριστής σήματος, μπορεί να επιστρέψει
Το συμβάν δίνεται πρώτα στο γραφικό συστατικό που συμβαίνει το συμβάν. Αν όλοι οι χειριστές σήματος σε αυτό το γραφικό συστατικό επιστρέψουν
Εξαιρέσεις στους χειριστές σήματος
Όταν ένα πρόγραμμα ματαιώνεται λόγω μιας ανεπίλυτης εξαίρεσης C++, είναι μερικές φορές δυνατή η χρήση ενός αποσφαλματωτή για την εύρεση της θέσης όπου συνέβη η εξαίρεση. Αυτό είναι πιο δύσκολο από ό,τι συνήθως, αν η εξαίρεση συνέβη από έναν χειριστή σήματος.
Αυτή η ενότητα περιγράφει κυρίως τι μπορείτε να περιμένετε σε ένα σύστημα Λίνουξ, όταν χρησιμοποιείτε το
// without_signal.cc
#include &lt;gtkmm.hgt;

bool throwSomething()
{
 throw "Something";
 return true;
}

int main(int argc, char** argv)
{
 throwSomething();
 Glib::RefPtrlt;Gtk::Applicationgt; app =
 Gtk::Application::create(argc, argv, "org.gtkmm.without_signal");
 return app-gt;run();
}
Πρώτα, ας κοιτάξουμε ένα απλό παράδειγμα όπου μια εξαίρεση προκαλείται από μια κανονική συνάρτηση (χωρίς χειριστή σήματος).
&gt; gdb without_signal
(gdb) run
terminate called after throwing an instance of 'char const*'

Program received signal SIGABRT, Aborted.
(gdb) backtrace
#7 0x08048864 in throwSomething () at without_signal.cc:6
#8 0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12
Εδώ είναι ένα απόσπασμα από μια συνεδρία της
// with_signal.cc
#include &lt;gtkmm.hgt;

bool throwSomething()
{
 throw "Something";
 return true;
}

int main(int argc, char** argv)
{
 Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);
 Glib::RefPtrlt;Gtk::Applicationgt; app =
 Gtk::Application::create(argc, argv, "org.gtkmm.with_signal");
 app-gt;hold();
 return app-gt;run();
}
Τώρα, ας δείτε τι συμβαίνει όταν μια εξαίρεση συμβαίνει από έναν χειριστή σήματος. Ιδού ο πηγαίος κώδικας.
&gt; gdb with_signal
(gdb) run
(with_signal:2703): glibmm-ERROR **:
unhandled exception (type unknown) in signal handler

Program received signal SIGTRAP, Trace/breakpoint trap.
(gdb) backtrace
#2 0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77
#3 Glib::exception_handlers_invoke () at exceptionhandler.cc:150
#4 0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212
#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178
#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16
Και εδώ είναι ένα απόσπασμα από μια συνεδρία της
&gt; gdb with_signal
(gdb) catch throw
Catchpoint 1 (throw)
(gdb) run
Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()
(gdb) backtrace
#0 0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6
#1 0x08048bd4 in throwSomething () at with_signal.cc:6
(gdb) continue
Continuing.
(with_signal:2375): glibmm-ERROR **
unhandled exception (type unknown) in signal handler

Program received signal SIGTRAP, Trace/breakpoint trap.
Για να δείτε πού συμβαίνει η εξαίρεση, μπορείτε να χρησιμοποιήσετε την εντολή της
(gdb) catch throw
(gdb) commands
(gdb) backtrace
(gdb) continue
(gdb) end
(gdb) set pagination off
(gdb) run
Αν υπάρχουν πολλές λήψεις εξαιρέσεων πριν την ενδιαφέρουσα μη ληφθείσα, αυτή η μέθοδος μπορεί να είναι κουραστική. Μπορεί να αυτοματοποιηθεί με τις ακόλουθες εντολές της
Δημιουργία των σημάτων σας.
Τώρα που έχετε δει σήματα και χειριστές σήματος στην
Αυτό δεν είναι καθαρά μια
sigc::signallt;void, bool, intgt; signal_something;
Για παράδειγμα, για τη δημιουργία ενός σήματος που στέλνει 2 παραμέτρους, έναν
class Server
{
public:
 //στοιχείο πρόσβασης σήματος:
 typedef sigc::signallt;void, bool, intgt; type_signal_something;
 type_signal_something signal_something();

protected:
 type_signal_something m_signal_something;
};

Server::type_signal_something Server::signal_something()
{
 return m_signal_something;
}
Μπορείτε να δηλώσετε απλά ότι το σήμα ως μια δημόσια μεταβλητή μέλους, αλλά μερικά άτομα το βρίσκουν άσχημο και προτιμούν να το κάνουν διαθέσιμο μέσα από μια μέθοδο στοιχείου πρόσβασης, ως εξής:
server.signal_something().connect(
 sigc::mem_fun(client, &Client::on_server_something) );
Μπορείτε έπειτα να το συνδέσετε με το σήμα χρησιμοποιώντας την ίδια σύνταξη που χρησιμοποιείται όταν συνδέεται τα σήματα
Αυτό είναι ένα πλήρως λειτουργικό παράδειγμα που ορίζει και χρησιμοποιεί προσαρμοσμένα σήματα.
Σύγκριση με άλλα συστήματα σηματοδότησης
(Μια παρένθεση: η
Οι χειριστές σήματος
Αναφορικά με την αντικατάσταση χειριστών σημάτων: Μπορείτε να το κάνετε στον κόσμο της άμεσης C της GTK+ επίσης· για υτό είναι το σύστημα αντικειμένου του GTK. Αλλά στην GTK+, πρέπει να περάσετε μέσα από κάποιες περίπλοκες διαδικασίες για να πάρετε αντικειμενοστραφή χαρακτηριστικά όπως κληρονομικότητα και υπερφόρτωση. Στην C++, είναι απλό, αφού αυτά τα χαρακτηριστικά υποστηρίζονται στην ίδια τη γλώσσα· μπορείτε να επιτρέψετε στον μεταγλωττιστή να κάνει τη βρόμικη δουλειά.
Αυτή είναι μια από τις θέσεις όπου η ομορφιά της C++ πραγματικά εμφανίζεται. Κάποιος δεν θα σκεφτόταν να δημιουργήσει υποκλάση ενός γραφικού συστατικού GTK+ απλά για να αντικαταστήσει τη μέθοδό ενέργειας του· είναι απλά υπερβολικό πρόβλημα. Στην GTK+, χρησιμοποιείτε σχεδόν πάντα σήματα για να κάνετε τα πράγματα, εκτός και γράφετε ένα νέο γραφικό συστατικό. Αλλά λόγω των μεθόδων αντικατάστασης είναι τόσο εύκολο στη C++, είναι πλήρως πρακτικό - και λογικό - να δημιουργήσετε μια υποκλάση ενός πλήκτρου για αυτόν τον σκοπό.
Η
Ένα από τα μεγάλα πλεονεκτήματα της
Η
Δόμηση της
Παρακαλούμε, δείτε
Εργασία με τον πηγαίο κώδικα gtkmm
Αν ενδιαφέρεστε να βοηθήσετε την ανάπτυξη της
Ο πιο εύκολος τρόπος για να το κάνετε αυτό είναι η χρήση της
Σημειώστε ότι για τη δόμηση της
Εγκατάσταση της jhbuild
Για να εγκαταστήσετε την
moduleset = 'gnome-suites-core-deps-3.12'
Η ενότητα
modules = [ 'gtkmm' ]
Μετά την ρύθμιση της σωστής ομάδας ενοτήτων, χρειάζεστε να πείτε στην
Μπορείτε να δομήσετε αρκετές ενότητες ορίζοντας τη μεταβλητή
Ορίζοντας ένα πρόθεμα
Από προεπιλογή, η διαμόρφωση της
Όταν μεταφορτώσατε την
Εγκατάσταση και χρήση της έκδοσης git της
Αφού έχετε ρυθμίσει την
Εγκατάσταση της
Αν όλα δούλεψαν σωστά, θα πρέπει να μπορείτε να δομήσετε την
Αυτή η εντολή θα δομήσει και θα εγκαταστήσει μια σειρά ενοτήτων και θα πάρει προφανώς αρκετά την πρώτη φορά για να ολοκληρωθεί. Μετά την πρώτη φορά, όμως, θα πρέπει να πάτε λίγο γρηγορότερα, αφού χρειάζεται μόνο να αναδομήσετε τα αρχεία που αλλάξατε από την τελευταία δόμηση. Εναλλακτικά, αφού έχετε δομήσει και εγκαταστήσει την
Χρήση της έκδοσης git της
Αφού έχετε εγκαταστήσει την έκδοση git της
Αφού έχετε δημιουργήσει το λογισμικό σας, θα χρειαστείτε να εκτελέσετε το πρόγραμμά σας μέσα σε περιβάλλον jhbuild επίσης. Για να το κάνετε αυτό, μπορείτε να χρησιμοποιήσετε πάλι την εντολή
Συσκευασία βιβλιοθηκών C με gmmproc
Η
Αυτό εμπεριέχει μια ποικιλία εργαλείων, μερικά από τα οποία ξεπερασμένα, αλλά τουλάχιστον δουλεύουν και χρησιμοποιήθηκαν με επιτυχία από αρκετά έργα.
Η δομή δημιουργίας
Η παραγωγή του πηγαίου κώδικα για μια API συσκευαστή τεχνοτροπίας gtkmm απαιτεί τη χρήση εργαλείων όπως
Για παράδειγμα, ας θεωρήσουμε ότι πακετάρουμε μια βιβλιοθήκη C που λέγεται libsomething. Παρέχει μια API με βάση
Αντιγραφή του έργου σκελετού
$ git clone git://git.gnome.org/mm-common
 $ cp -a mm-common/skeletonmm libsomethingmm
Τυπικά η βιβλιοθήκη συσκευαστή μας πρέπει να ονομαστεί libsomethingmm. Μπορούμε να ξεκινήσουμε αντιγράφοντας το





Αυτό παρέχει μια δομή καταλόγου για τα πηγαία αρχεία .hg και .ccg και τα δημιουργούμενα αρχεία .h και .cc, με τα αρχεία συμπερίληψης Automake
$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \\
 d="${f%/*}"; b="${f##*/}"; mv "$f" "$d/${b//skeleton/libsomething}"; \\
 done
Καθώς και μετονομασία των καταλόγων, θα πρέπει να μετονομάσουμε μερικά από τα πηγαία αρχεία. Για παράδειγμα:
Σημειώστε ότι τα αρχεία που τελειώνουν σε
Τροποποίηση αρχείων δόμησης
Τώρα επεξεργαζόμαστε τα αρχεία για να προσαρμόσουμε στις ανάγκες μας. Μπορείτε να προτιμήσετε τη χρήση ενός βοηθήματος πολλαπλού αρχείου αναζήτησης-αντικατάστασης για αυτό, όπως
Όλες οι αναφορές της
Παρόμοια, αντικαταστήστε όλα τα στιγμιότυπα της
configure.ac
Η γραμμή
Είναι συνηθισμένο για σύνδεση ενοτήτων να ανιχνεύουμε τον αριθμό έκδοσης της βιβλιοθήκης που συσκευάζεται. Έτσι, για παράδειγμα, αν η βιβλιοθήκη C είναι στην έκδοση 1.23.4, τότε η αρχική έκδοση της ενότητας σύνδεσης μπορεί να είναι 1.23.0. Όμως, αποφύγετε το ξεκίνημα με έναν άρτιο δευτερεύοντα αριθμό έκδοσης επειδή αυτό συνήθως δείχνει μια σταθερή έκδοση.
Η γραμμή
Η γραμμή
Η ομάδα
Στο
Αρχεία Makefile.am
Στο
binding_name
Το όνομα της βιβλιοθήκης, όπως libsomethingmm.
wrap_init_flags
Οι πρόσθετες σημαίες της γραμμής εντολών που πέρασαν στο σενάριο
Στο
lib_LTLIBRARIES
Αυτή η μεταβλητή πρέπει να αναφέρει το σωστό όνομα βιβλιοθήκης και αυτό το όνομα βιβλιοθήκης πρέπει να χρησιμοποιηθεί για να σχηματίσει τα ονόματα μεταβλητών
AM_CPPFLAGS
Οι επιλογές της γραμμής εντολών που πέρασαν στον προεπεξεργαστή C.
AM_CXXFLAGS
Οι επιλογές της γραμμής εντολών που πέρασαν στον μεταγλωττιστή C++.
Κατόπιν πρέπει να προσαρμοστούμε στα ποικίλα αρχεία
Δημιουργία αρχείων .hg και .ccg
Πρέπει τώρα να δημιουργήσουμε τα πρώτα μας αρχεία
Πρέπει να αναφέρουμε όλα τα αρχεία μας
Οποιαδήποτε πρόσθετα μη δημιουργούμενα πηγαία αρχεία
Στην ενότητα
Δημιουργία των αρχείων .defs.
αντικείμενα (GObjects, γραφικά συστατικά, διεπαφές, απλές δομές και δομές τύπου πλαισίου)
συναρτήσεις
απαριθμήσεις
σήματα
ιδιότητες
vfuncs
Τα αρχεία
gtk.defs
Περιλαμβάνει τα άλλα αρχεία.
gtk_methods.defs
Αντικείμενα και συναρτήσεις.
gtk_enums.defs
Απαριθμήσεις.
gtk_signals.defs
Σήματα και ιδιότητες.
gtk_vfuncs.defs
vfuncs (πεδία μέλους δείκτη συνάρτησης σε δομές), γραμμένα με το χέρι.
Προς το παρόν, έχουμε ξεχωριστά εργαλεία για δημιουργία διαφορετικών τμημάτων αυτών των
Το σενάριο
Δημιουργία των μεθόδων .defs
$ ./h2def.py /usr/include/gtk-3.0/gtk/*.h &gt; gtk_methods.defs
Αυτό το αρχείο
Δημιουργία των απαριθμήσεων .defs
$ ./enum.pl /usr/include/gtk-3.0/gtk/*.h &gt; gtk_enums.defs
Αυτό το αρχείο
Δημιουργώντας τα σήματα και τις ιδιότητες .defs
$ cd tools/extra_defs_gen
$ ./generate_extra_defs &gt; gtk_signals.defs
Αυτό το αρχείο
Πρέπει να επεξεργαστείτε τον πηγαίο κώδικα του δικού σας εργαλείου
#include &lt;libsomething.hgt;

int main(int, char**)
{
 something_init();

 std::cout &lt;lt; get_defs(SOME_TYPE_WIDGET)
 &lt;lt; get_defs(SOME_TYPE_STUFF);
 return 0;
}
Έπειτα επεξεργαστείτε το αρχείο
Συγγραφή των vfuncs .defs
Αυτό το αρχείο
Τα αρχεία .hg και .ccg
Τα πηγαία αρχεία .hg και .ccg είναι πολύ παρόμοια. με τα πηγαία αρχεία .h και .cc της C++, αλλά περιέχουν πρόσθετες μακροεντολές, όπως
#include &lt;gtkmm/bin.hgt;
#include &lt;gtkmm/activatable.hgt;
_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/bin_p.h)

namespace Gtk
{

class Button
 : public Bin,
 public Activatable
{
 _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)
 _IMPLEMENTS_INTERFACE(Activatable)
public:

 _CTOR_DEFAULT
 explicit Button(const Glib::ustringamp; label, bool mnemonic = false);

 _WRAP_METHOD(void set_label(const Glib::ustringamp; label), gtk_button_set_label)

 ...

 _WRAP_SIGNAL(void clicked(), "clicked")

 ...

 _WRAP_PROPERTY("label", Glib::ustring)
};

} // namespace Gtk
Ένα αρχείο .hg θα περιλαμβάνει τυπικά κάποιες κεφαλίδες και έπειτα θα δηλώνει μια κλάση, χρησιμοποιώντας μερικές μακροεντολές για να προσθέσει API ή συμπεριφορά σε αυτήν την κλάση. Για παράδειγμα, στην
_DEFS()
Καθορίζει τον κατάλογο προορισμού για τις δημιουργούμενες πηγές και το όνομα του κύριου αρχείου .defs που η
_PINCLUDE()
Λέει στην
_CLASS_GTKOBJECT()
Λέει στην
_IMPLEMENTS_INTERFACE()
Λέει στην
_CTOR_DEFAULT
Προσθήκη προεπιλεγμένου κατασκευαστή.

Προσθέστε μεθόδους για συσκευασία τμημάτων της API C.
Οι μακροεντολές σε αυτό το παράδειγμα κάνει το εξής:
$ cd gtk/src
$ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm
Τα αρχεία .h και .cc θα δημιουργηθούν από τα αρχεία .hg και .ccg με επεξεργασία τους με την
Σημειώστε ότι παρείχαμε την
Θα πρέπει να αποφύγετε να συμπεριλάβετε την κεφαλίδα C της κεφαλίδας σας C++, για να αποφύγετε τη μόλυνση του καθολικού χώρου ονόματος και την εξαγωγή περιττών δημόσιων API. Αλλά θα χρειαστείτε να συμπεριλάβετε τις απαραίτητες κεφαλίδες C από το αρχείο σας .ccg.
Οι μακροεντολές εξηγούνται πιο λεπτομερώς στις παρακάτω ενότητες.
Μετατροπές m4
_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')
Οι μακροεντολές που χρησιμοποιείτε στα αρχεία .hg και .ccg χρειάζεται συχνά να ξέρουν πώς να μετατρέψετε έναν τύπο C++ σε έναν τύπο C, ή αντίστροφα. Η gmmproc παίρνει αυτήν την πληροφορία από ένα αρχείο .m4 στον κατάλογό σας
Η
_CONVERSION(`PrintSettingsamp;',`GtkPrintSettings*',__FR2P)
_CONVERSION(`const PrintSettingsamp;',`GtkPrintSettings*',__FCR2P)
_CONVERSION(`const Glib::RefPtrlt;Printergt;amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))
Κάποιες πρόσθετες μακροεντολές το κάνουν ευκολότερο και ομοιόμορφο. Ψάξτε στα αρχεία .m4 της gtkmm για παραδείγματα. Για παράδειγμα:
Αρχικοποιήσεις m4
Συχνά με τις μεθόδους συσκευασίας, είναι επιθυμητό να αποθηκεύσετε την επιστροφή της συνάρτησης C σε αυτό που λέγεται μια παράμετρος εξόδου. Σε αυτήν την περίπτωση, η μέθοδος C++ επιστρέφει τον
_INITIALIZATION(`Gtk::Widgetamp;',`GtkWidget*',`$3 = Glib::wrap($4)')
Για παράδειγμα, αν υπήρξε μια συνάρτηση C που επέστρεψε έναν
Η
Μακροεντολές κλάσης
Η μακροεντολή κλάσης δηλώνει την ίδια την κλάση και τη σχέση της με τον υποκείμενο τύπο C. Δημιουργεί κάποιους εσωτερικούς κατασκευαστές, το μέλος
Άλλες μακροεντολές, όπως
_CLASS_GOBJECT
Αυτή η μακροεντολή δηλώνει έναν συσκευαστή για έναν τύπο που παράγεται από την
_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )
_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)
Για παράδειγμα, από το
_CLASS_GTKOBJECT
Αυτή η μακροεντολή δηλώνει έναν συσκευαστή για έναν τύπο του οποίου ο συσκευαστής παράγεται από την
_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )
_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)
Για παράδειγμα, από το
Θα χρησιμοποιήσουμε τυπικά αυτή τη μακροεντολή όταν η κλάση παράγεται ήδη από την Gtk::Object. Για παράδειγμα, θα την χρησιμοποιήσετε όταν συσκευάζετε ένα γραφικό συστατικό GTK+, επειδή η Gtk::Widget παράγεται από Gtk::Object.
Μπορείτε επίσης να παράξετε κλάσεις μη γραφικού συστατικού από Gtk::Object έτσι ώστε να μπορεί να χρησιμοποιηθεί χωρίς
_CLASS_BOXEDTYPE
Αυτή η μακροεντολή δηλώνει έναν συσκευαστή για μια δομή μη
_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free function )
_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)
Για παράδειγμα, από
_CLASS_BOXEDTYPE_STATIC
Αυτή η μακροεντολή δηλώνει έναν συσκευαστή για μια απλή μεταβιβάσιμη δομή όπως
_CLASS_BOXEDTYPE_STATIC( C++ class, C class )
_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)
Για παράδειγμα, για
_CLASS_OPAQUE_COPYABLE
Αυτή η μακροεντολή δηλώνει έναν συσκευαστή για μια αδιαφανή δομή που έχει ελεύθερες συναρτήσεις και συναρτήσεις αντιγραφής. Οι νέες και ελεύθερες συναρτήσεις καθώς και οι συναρτήσεις αντιγραφής θα χρησιμοποιηθούν για αρχικοποίηση του προεπιλεγμένου κατασκευαστή, για αντιγραφή κατασκευαστή και καταστροφέα.
_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, free function )
_CLASS_OPAQUE_COPYABLE(Checksum, GChecksum, NONE, g_checksum_copy, g_checksum_free)
Για παράδειγμα, από
_CLASS_OPAQUE_REFCOUNTED
Αυτή η μακροεντολή δηλώνει έναν συσκευαστή για μια αδιαφανή δομή μετρημένης αναφοράς. Ο συσκευαστής C++ δεν μπορεί να είναι άμεσα αρχικοποιημένος και μπορεί μόνο να χρησιμοποιηθεί με την
_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref function, unref function )
_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)
Για παράδειγμα, για
_CLASS_GENERIC
Αυτή η μακροεντολή μπορεί να χρησιμοποιηθεί για να συσκευάσει δομές που δεν προσαρμόζονται σε οποιαδήποτε ειδική κατηγορία.
_CLASS_GENERIC( C++ class, C class )
_CLASS_GENERIC(AttrIter, PangoAttrIterator)
Για παράδειγμα, για
_CLASS_INTERFACE
Αυτή η μακροεντολή δηλώνει έναν συσκευαστή για έναν τύπο που παράγεται από
_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, Base C++ class (optional), Base C class (optional) )
_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)
Για παράδειγμα, από
_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)
Δύο πρόσθετες παράμετροι είναι προαιρετικές, για την περίπτωση που η διεπαφή προέρχεται από μια άλλη διεπαφή, που πρέπει να είναι η περίπτωση όταν η GInterface έχει μια άλλη GInterface ως προαπαιτούμενη. Για παράδειγμα, από
Μακροεντολές κατασκευαστή
Οι μακροεντολές
class TextMark : public Glib::Object
{
 _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject)

protected:
 _WRAP_CTOR(TextMark(const Glib::ustringamp; name, bool left_gravity = true), gtk_text_mark_new)

public:
 _WRAP_CREATE(const Glib::ustringamp; name, bool left_gravity = true)
Κατά τη χρήση της
Αυτή η μακροεντολή δημιουργεί έναν προεπιλεγμένο κατασκευαστή χωρίς ορίσματα.
_WRAP_CTOR
Αυτή η μακροεντολή δημιουργεί έναν κατασκευαστή με ορίσματα, ισοδύναμο με μια συνάρτηση C
Δημιουργία σφάλματος (errthrow)
Αυτό λέει στο gmmproc ότι η
Παίρνει επίσης ένα προαιρετικό πρόσθετο όρισμα:
Κατασκευαστές κωδικοποίησης με το χέρι
Button::Button(const Glib::ustringamp; label, bool mnemonic)
:
 _CONSTRUCT("label", label.c_str(), "use_underline", gboolean(mnemonic))
{}
Όταν ένας κατασκευαστής πρέπει να είναι μερικώς χειρόγραφος επειδή, για παράδειγμα, οι παράμετροι της συνάρτησης C
Μακροεντολές μεθόδου
_WRAP_METHOD
Αυτή η μακροεντολή παράγει τη μέθοδο C++ για να συσκευάσει μια συνάρτηση C.
_WRAP_METHOD( C++ method signature, C function name)
_WRAP_METHOD(void set_text(const Glib::ustringamp; text), gtk_entry_set_text)
Για παράδειγμα, από
Η συνάρτηση C (π.χ.
επιστροφή αναφοράς (refreturn)
Κάντε μια πρόσθετη
Χρησιμοποιήστε την τελευταία παράμετρο GError** της συνάρτησης C για να δημιουργήσετε μια εξαίρεση.
παρωχημένο
Βάζει τον δημιουργούμενο κώδικα σε ομάδες #ifdef. Το κείμενο για τα παρωχημένα μπορεί να οριστεί ως προαιρετική παράμετρος.
σταθερή έκδοση (constversion)
Καλέστε απλά την μη σταθερή έκδοση της ίδιας συνάρτησης, αντί για τη δημιουργία σχεδόν διπλού κώδικα.
ifdef
Βάζει τον δημιουργούμενο κώδικα σε ομάδες #ifdef.
όνομα υποδοχής (slot_name)
Καθορίζει το όνομα της παραμέτρου υποδοχής της μεθόδου, αν έχει μία. Αυτό ενεργοποιεί την
υποδοχή επανάκλησης (slot_callback)
Χρησιμοποιείται σε συνδυασμό με την επιλογή
Χωρίς αντιγραφή υποδοχής (no_slot_copy)
Λέει στην
Υπάρχουν κάποια προαιρετικά πρόσθετα ορίσματα:
Τα αντικείμενα χρησιμοποιούνται μέσα από
Αντικείμενα σταθερών χρησιμοποιούνται μέσα από
Συσκευασία των παραμέτρων
#m4 _CONVERSION(`GSList*',`std::vectorlt;Widget*gt;',`Glib::SListHandlerlt;Widget*gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
Η συσκευασία
Επιλέγοντας ποιοι τύποι C++ πρέπει να χρησιμοποιηθούν είναι επίσης σημαντικό όταν συσκευάζετε API της C. Αν και είναι συνήθως φανερό ποιοι τύποι C++ πρέπει να χρησιμοποιηθούν στη μέθοδο C++, ιδού μερικές υποδείξεις:
_WRAP_METHOD_DOCS_ONLY
Αυτή η μακροεντολή είναι παρόμοια με την
_WRAP_METHOD_DOCS_ONLY(C function name)
_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)
Για παράδειγμα, από
_IGNORE / _IGNORE_SIGNAL
Η
_IGNORE(C function name 1, C function name2, etc)
_IGNORE_SIGNAL(C signal name 1, C signal name2, etc)
_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing)
Για παράδειγμα, από
_WRAP_SIGNAL
Αυτή η μακροεντολή παράγει το σήμα τεχνοτροπίας libsigc++ της C++ για να συσκευάσει ένα σήμα GObject. Στην πραγματικότητα παράγει μια δημόσια μέθοδο στοιχείου πρόσβασης, όπως
_WRAP_SIGNAL( υπογραφή χειριστή σήματοςC++ , όνομα σήματος C)
_WRAP_SIGNAL(void clicked(),"clicked")
Τα σήματα συνήθως έχουν δείκτες συνάρτησης στη δομή GTK, με μια αντίστοιχη τιμή απαρίθμησης και μια
χωρίς προεπιλεγμένο χειριστή (no_default_handler)
Μην δημιουργείτε μια εικονική μέθοδο
προσαρμοσμένος προεπιλεγμένος χειριστής (custom_default_handler)
Δημιουργήστε μια δήλωση της εικονικής μεθόδου
προσαρμοσμένη επανάκληση c (custom_c_callback)
Μην δημιουργείτε μια συνάρτηση επανάκλησης C για το σήμα. Χρησιμοποιήστε αυτό όταν πρέπει να δημιουργήσετε μια συνάρτηση επανάκλησης με το χέρι.
Κάντε μια πρόσθετη
_WRAP_PROPERTY
Αυτή η μακροεντολή δημιουργεί μια μέθοδο C++ για συσκευασία μιας ιδιότητας GObject C. Πρέπει να ορίσετε το όνομα της ιδιότητας και τον επιθυμητό τύπο C++ για την ιδιότητα. Η
_WRAP_PROPERTY( όνομα ιδιότητας C, τύπος C++)
_WRAP_PROPERTY("label", Glib::ustring)
_WRAP_VFUNC
Αυτή η μακροεντολή παράγει τη μέθοδο C++ για να συσκευάσει μια εικονική συνάρτηση C.
_WRAP_VFUNC( υπογραφή μεθόδου C++, όνομα συνάρτησης C)
_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)
Για παράδειγμα, από
Η συνάρτηση C (π.χ.
Κάντε μια πρόσθετη
επιστροφή αναφοράς τύπου c (refreturn_ctype)
Κάντε μια πρόσθετη
Χρησιμοποιήστε την τελευταία παράμετρο GError** της εικονικής συνάρτησης C (αν υπάρχει μία) για τη δημιουργία εξαίρεσης.
Προσαρμοσμένη εικονική συνάρτηση (custom_vfunc)
Μην δημιουργείτε έναν ορισμό της εικονικής συνάρτησης στο αρχείο
επανάκληση προσαρμοσμένης εικονικής συνάρτησης (custom_vfunc_callback)
Μην δημιουργείτε μια συνάρτηση επανάκλησης C για την vfunc. Χρησιμοποιήστε αυτό όταν πρέπει να δημιουργήσετε μια συνάρτηση επανάκλησης με το χέρι.
Ένας κανόνας στον οποίον ενδέχεται να υπάρχουν εξαιρέσεις: Αν η εικονική συνάρτηση C επιστρέφει έναν δείκτη σε ένα αντικείμενο που παράγεται από την
Άλλες μακροεντολές
_IMPLEMENTS_INTERFACE
Αυτή η μακροεντολή δημιουργεί έναν κώδικα αρχικοποίησης για τη διεπαφή.
_IMPLEMENTS_INTERFACE(όνομα διεπαφής C++)
_IMPLEMENTS_INTERFACE(Activatable)
Υπάρχει ένα προαιρετικό πρόσθετο όρισμα:
_WRAP_ENUM
Αυτή η μακροεντολή δημιουργεί μια απαρίθμηση C++ για να συσκευάσει μια απαρίθμηση C. Πρέπει να ορίσετε το επιθυμητό όνομα C++ και το όνομα της υποκείμενης απαρίθμησης C.
_WRAP_ENUM(WindowType, GtkWindowType)
Για παράδειγμα, από
Αν η απαρίθμηση δεν είναι μια
_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)
Για παράδειγμα, από
_WRAP_ENUM_DOCS_ONLY
Αυτή η μακροεντολή δημιουργεί μια ομάδα τεκμηρίωσης Doxygen για την απαρίθμηση. Αυτό είναι χρήσιμο για απαριθμήσεις που δεν μπορούν να συσκευαστούν με
_WRAP_GERROR
Αυτή η μακροεντολή δημιουργεί μια κλάση εξαίρεσης C++, που παράγεται από Glib::Error, με μια απαρίθμηση κώδικα και μια μέθοδο code(). Πρέπει να ορίσετε το επιθυμητό όνομα C++, το όνομα της αντίστοιχης απαρίθμησης C και το πρόθεμα για τις τιμές απαρίθμησης C.
Αυτή η εξαίρεση μπορεί τότε να δημιουργηθεί από μεθόδους που δημιουργούνται από _WRAP_METHOD() με επιλογή δημιουργία σφάλματος (errthrow).
_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)
Για παράδειγμα, από
_MEMBER_GET / _MEMBER_SET
Χρησιμοποιήστε αυτές τις μακροεντολές αν συσκευάζετε μια απλή δομή ή τύπου πλαισίου που παρέχει άμεση πρόσβαση στα μέλη δεδομένων, για να δημιουργήσετε λήπτες και μεταλλάκτες (getters and setters) για τα μέλη δεδομένων.
_MEMBER_GET(C++ name, C name, C++ type, C type)
_MEMBER_SET(C++ name, C name, C++ type, C type)
_MEMBER_GET(x, x, int, int)
Για παράδειγμα, στο
_MEMBER_GET_PTR / _MEMBER_SET_PTR
Χρησιμοποιήστε αυτές τις μακροεντολές για αυτόματη παροχή ληπτών και μεταλλακτών (getters and setters) για ένα μέλος δεδομένων που είναι τύπου δείκτη. Για τη συνάρτηση δεκτών, θα δημιουργήσει δύο μεθόδους, μια σταθερή και μια μη σταθερή.
_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)
_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)
// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)
// Είναι απλά ένα σχόλιο. Είναι δύσκολο να βρεθεί ένα πραγματικό παράδειγμα.
Για παράδειγμα, για
_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT
χρησιμοποιήστε αυτές τις μακροεντολές για να δώσετε λήπτες και μεταλλάκτες (getters and setters) για ένα μέλος δεδομένων που είναι τύπου
_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)
_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)
_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)
Για παράδειγμα, σε Pangomm,
Επεξεργασία παραμέτρου gmmproc
Η
Αναδιάταξη παραμέτρου
void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,
 GdkEventMask events);
_WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},
 const Glib::RefPtrlt;const Gdk::Devicegt;amp; device{device}),
 gtk_widget_set_device_events)
_WRAP_METHOD(void set_device_events(Gdk::EventMask events{.}, const
 Glib::RefPtrlt;const Gdk::Devicegt;amp; device{.}),
 gtk_widget_set_device_events)
Για όλες τις μακροεντολές που επεξεργάζονται υπογραφές μεθόδου, είναι δυνατό να ορίσετε μια διαφορετική σειρά για τις παραμέτρους C++ αντί για την υπάρχουσα σειρά στη συνάρτηση C, στην εικονική συνάρτηση ή σήμα. Για παράδειγμα, ας πούμε ότι η παρακάτω συνάρτηση C συσκευάστηκε ως μια μέθοδος C++ για την κλάση
Παρακαλούμε σημειώστε ότι όταν αναδιατάσσονται παράμετροι για μια υπογραφή μεθόδου
Προαιρετική επεξεργασία παραμέτρου
GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar*
 label);
_WRAP_CTOR(ToolButton(Widgetamp; icon_widget, const Glib::ustringamp;
 label{?}), gtk_tool_button_new)
Για όλες τις μακροεντολές που επεξεργάζονται υπογραφές μεθόδου εκτός από τις
Επεξεργασία παραμέτρου εξόδου
GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);
_WRAP_METHOD(void get_request_mode(SizeRequestModeamp; mode{OUT})
 const, gtk_widget_get_request_mode)
_INITIALIZATION(`SizeRequestModeamp;',`GtkSizeRequestMode',`$3 =
 (SizeRequestMode)($4)')
_INITIALIZATION(`SizeRequestModeamp;',`GtkSizeRequestMode',`$3 =
 ($1)($4)')
Με την
gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view,
 GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);
_WRAP_METHOD(bool get_cell_rect(const TreeModel::Pathamp; path, const
 CellRendereramp; cell, Gdk::Rectangleamp; rect{gt;gt;}) const,
 gtk_icon_view_get_cell_rect)
_INITIALIZATION(`Gdk::Rectangleamp;',`GdkRectangle', `$3 =
 Glib::wrap(amp;($4))')
Η
Βασικοί τύποι
Μερικοί από τους βασικούς τύπους που χρησιμοποιούνται στα APIs της C έχουν καλύτερες εναλλακτικές στη C++. Για παράδειγμα, δεν υπάρχει ανάγκη για έναν τύπο
Ισοδύναμοι βασικοί τύποι
Τύπος C
Τύπος C++
gboolean
bool
gint
int
guint
gdouble
double
gunichar
gchar*
std::string

Πηγαία αρχεία κωδικοποιημένα με το χέρι
Μπορεί να θέλετε να συμπεριλάβετε πρόσθετα πηγαία αρχεία που δεν θα δημιουργηθούν από την
Αρχικοποίηση
void init()
{
 Gtk::Main::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.
 wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.
}
Η βιβλιοθήκη σας πρέπει να αρχικοποιηθεί πριν να μπορέσει να χρησιμοποιηθεί, για να καταχωρίσει τους νέους τύπους που κάνει διαθέσιμους. Επίσης, η βιβλιοθήκη C που συσκευάζετε μπορεί να έχει τη δικιά της συνάρτηση αρχικοποίησης που θα πρέπει να καλέσετε. Μπορείτε να το κάνετε σε μια συνάρτηση
Η υλοποίηση της μεθόδου
Προβλήματα στη API της C.
Μπορεί να αντιμετωπίσετε μερικά προβλήματα στη βιβλιοθήκη που συσκευάζετε, ιδιαίτερα αν είναι ένα νέο έργο. Ιδού μερικά συνηθισμένα προβλήματα με λύσεις.
Αδύνατη η προδήλωση δομών
typedef struct _ExampleWidget ExampleWidget;

struct _ExampleWidget
{
 ...
};
Συμβατικά, οι δομές δηλώνονται σε κεφαλίδες τεχνοτροπίας glib/GTK+ ως εξής:
Ο πρόσθετος ορισμός τύπου επιτρέπει να χρησιμοποιηθεί η δομή σε μια κεφαλίδα χωρίς συμπερίληψη του πλήρους ορισμού της, απλά προδηλώνοντάς την, επαναλαμβάνοντας αυτόν τον τύπο ορισμού. Αυτό σημαίνει ότι δεν πρέπει να συμπεριλάβετε την κεφαλίδα της βιβλιοθήκης C στην κεφαλίδα της C++, κρατώντας την έξω από τη δημόσια API. Η
example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'
../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here
make[4]: *** [example-widget.lo] Error 1
example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol
../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'
Αυτό το σφάλμα μεταγλωττιστή μπορεί να μοιάζει ως εξής:
Αυτό είναι εύκολο να διορθώσετε στη βιβλιοθήκη C, γιαυτό στείλτε μια διόρθωση στον σχετικό συντηρητή.
Έλλειψη ιδιοτήτων
GtkWidget* example_widget_new(int something, const char* thing)
{
 return g_object_new (EXAMPLE_TYPE_WIDGET, "something", something, "thing", thing, NULL);
}
Συμβατικά, τα αντικείμενα τεχνοτροπίας glib/GTK+ έχουν συναρτήσεις
Αυτό επιτρέπει στους συνδυασμούς γλωσσών να υλοποιήσουν τα δικά τους ισοδύναμα (όπως κατασκευαστές C++), χωρίς τη χρήση της συνάρτησης
Τουλάχιστον, η συνάρτηση
GtkWidget* example_widget_new(int something, const char* thing)
{
 ExampleWidget* widget;
 widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);
 example_widget_construct(widget, "something", something, "thing", thing);
}

void example_widget_construct(ExampleWidget* widget, int something, const char* thing)
{
 //Do stuff that uses private API:
 widget-gt;priv-gt;thing = thing;
 do_something(something);
}
Μια άλλη παράκαμψη είναι η προσθήκη μιας συνάρτησης
Η προσθήκη ιδιοτήτων και η επιβεβαίωση ότι αλληλεπιδρούν σωστά μεταξύ τους, είναι σχετικά δύσκολο να διορθωθεί στη βιβλιοθήκη C, αλλά είναι δυνατή, έτσι στείλτε ένα σφάλμα και προσπαθήστε να στείλετε μια διόρθωση στον σχετικό συντηρητή.
Τεκμηρίωση
Γενικά, τα έργα τεχνοτροπίας gtkmm χρησιμοποιούν Doxygen, που διαβάζει ειδικά μορφοποιημένα σχόλια C++ και δημιουργεί τεκμηρίωση HTML. Μπορείτε να γράψετε αυτά τα σχόλια doxygen άμεσα στα αρχεία κεφαλίδας.
Επαναχρησιμοποίηση τεκμηρίωσης C
Μπορεί να θέλετε να επαναχρησιμοποιήσετε την τεκμηρίωση που υπάρχει για τη βιβλιοθήκη C που συσκευάζετε. Οι βιβλιοθήκες C τεχνοτροπίας GTK χρησιμοποιούν τυπικά gtk-doc και συνεπώς έχουν σχόλια πηγαίου κώδικα μορφοποιημένα για gtk-doc και κάποια πρόσθετη τεκμηρίωση σε αρχεία .sgml και .xml. Το σενάριο docextract_to_xml.py, από τον κατάλογο
./docextract_to_xml.py -s ~/checkout/gnome/gtk+/gtk/ &gt; gtk_docs.xml
Επειδή αυτός ο αυτόματος μετασχηματισμός δεν είναι πάντα κατάλληλος, μπορεί να θελήσετε να δώσετε χειρόγραφο κείμενο για μια συγκεκριμένη μέθοδο. Μπορείτε να το κάνετε αντιγράφοντας τον κόμβο XML για τη συνάρτηση από το αρχείο σας
Διάρθρωση κατασκευής τεκμηρίωσης
Αν αντιγράφετε το πηγαίο δένδρο σκελετού σε mm-common και αντικαταστήσετε το κείμενο του δεσμευτικού θέσης, τότε θα έχετε ήδη κατάλληλα αρχεία
Ελληνική μεταφραστική ομάδα του GNOME
 Δημήτρης Σπίγγος <dmtrs32\@gmail\.com>, 2013
Για περισσότερα δείτε: http://gnome.gr
Πολιτικές αναβάθμισης



Η
Μπορείτε να τροποποιήσετε την πολιτική ενημέρωσης χρησιμοποιώντας τη μέθοδο
Διεθνοποίηση των εφαρμογών GNOME
Gtk::Button* pButton = new Gtk::Button(Gtk::Stock::OK);
Όπου είναι δυνατό θα πρέπει να χρησιμοποιείτε έτοιμα στοιχεία, για να εξασφαλίσετε συνέπεια με άλλες εφαρμογές και να βελτιώσετε την εμφάνιση των εφαρμογών σας χρησιμοποιώντας εικονίδια. Για παράδειγμα,
όπου
Gtk::Adjustment(float value,
 float lower,
 float upper,
 float step_increment = 1,
 float page_increment = 10,
 float page_size = 0);


Το γραφικό συστατικό προορισμού θα εκπέμψει αυτό το σήμα, αφού ο προορισμός της πηγής έχει εκπέμψει το σήμα
Η
Για παράδειγμα, από