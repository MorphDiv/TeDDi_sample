# language_name_wals:	Greek (Modern)
# language_name_glotto:	Modern Greek
# ISO_6393:	ell
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Grek
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/el.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

Ένας γρήγορος οδηγός για τη βελτιστοποίηση των προγραμμάτων του GNOME
Αυτή είναι μια σύντομη εισαγωγή στη βελτιστοποίηση, τόσο στο πώς όσο και στο γιατί. Οι λεπτομέρειες για ξεχωριστά εργαλεία παραλείονται για μελλοντικά άρθρα, αλλά παρέχεται μια συλλογή από υποδείξεις και κόλπα.
Τι θα βελτιστοποιήσουμε;
Όταν βελτιστοποιούμε για το GNOME, το πρώτο πράγμα που θυμόμαστε είναι ότι δεν προσπαθούμε να κάνουμε ένα πρόγραμμα καλύτερο, προσπαθούμε να κάνουμε το χρήστη που χρησιμοποιεί τον υπολογιστή πιο ευχαριστημένο.
Καλύτερα προγράμματα σημαίνει πιο ευχαριστημένοι χρήστες, αλλά υπάρχουν μερικές βελτιώσεις που θα τους κάνουν πιο ευχαριστημένους από άλλες: η σπιρτάδα της ανταπόκρισης, ο χρόνος εκκίνησης, η ευκολία στην πρόσβαση των εντολών και το να μην γίνεται πολύ αργός ο υπολογιστής όταν υπάρχουν ανοικτά περισσότερα από δύο προγράμματα.
Η παραδοσιακή βελτιστοποίηση ασχολείται με έννοιες όπως η χρήση του επεξεργαστή, το μέγεθος του κώδικα, ο αριθμός των κλικ του ποντικιού και η χρήση της μνήμης από το πρόγραμμα. Αυτή η δεύτερη λίστα έχει επιλεγεί για να συσχετίζεται με την πρώτη, ωστόσο υπάρχει μια σημαντική διαφορά: Αυτός που χρησιμοποιεί το GNOME δε νοιάζεται για τη δεύτερη λίστα, νοιάζεται όμως πολύ για την πρώτη. Όταν βελτιστοποιούμε προγράμματα του GNOME μειώνουμε τη χρήση του επεξεργαστή, της μνήμης και λοιπά, αλλά όλα αυτά είναι μέσα για να προχωρήσουμε, όχι για τον τελικό μας σκοπό. Εμείς βελτιστοποιούμε για τους ανθρώπους.
Εφαρμόζοντας τη βελτιστοποίηση
Η προηγούμενη ενότητα παρέλειψε ένα σημαντικό παράγοντα: για να βελτιστοποιηθεί κάτι πρέπει να είναι μετρήσιμο. Δε μπορείτε να βελτιστοποιήσετε την ευχαρίστηση. Ωστόσο, μπορείτε να μετρήση το χρόνο εκκίνησης ώστε να μπορείτε να δείτε αν τον έχετε βελτιώσει. Ευελπιστούμε ότι η ευτυχία θα επέλθει.
Η βελτιστοποίηση είναι μια διαδικασία μέτρησης, βελτίωσης και μέτρησης ξανά. Οπότε το πρώτο πράγμα που πρέπει να κάνετε είναι να βρείτε έναν τρόπο για να μετρήσετε αυτό που βελτιστοποιείτε. Στην καλύτερη περίπτωση, αυτή η μέτρηση θα είναι ένας μοναδικός αριθμός, για παράδειγμα ο χρόνος που χρειάζεται για να ολοκληρωθεί μια εργασία. Αυτή η είναι η δοκιμή μέτρησής σας, και είναι ο μοναδικός τρόπος για να δείτε αν κερδίζετε ή αν χάνετε. Υπάρχει τεράστια διαφορά ανάμεσα σε ένα πρόγραμμα που
Όταν θα έχετε μια βασική δοκιμή μέτρησης θα πρέπει να ανακαλύψετε γιατί ο κώδικάς σας δεν πάει τόσο καλά όσο θα έπρεπε. Είναι δελεαστικό να το κάνετε αυτό παρατηρώντας: να κοιτάτε τον κώδικα ψάχνοντας για κάτι που μοιάζει να θέλει βελτίωση. Χωρίς αμφιβολία, θα κάνετε λάθος. Η χρήση ενός βοηθητικού προγράμματος profiler το οποίο δίνει μια λεπτομερή ανατομία του τι κάνει πραγματικό το πρόγραμμά σας είναι ο μόνος τρόπος για να είστε βέβαιοι.
Συνήθως το πρόβλημα εντοπίζεται σε μικρά τμήματα του κώδικα. Διαλέξτε το χειρότερο από αυτά και συγκεντρωθείτε πρώτα σ' αυτό. Όταν θα έχετε τελειώσει μ' αυτό, τρέξτε ξανά το profiler και επαναλάβετε τη διαδικασία. Καθώς θα προχωράτε, το κέρδος από κάθε βήμα θα μειώνεται, και σε κάποιο σημείο θα πρέπει να αποφασίσετε αν τα αποτελέσματα είναι αρκετά καλά. Αν η προσπάθειές σας έχουν ως αποτέλεσμα τη βελτίωση μόνο κατά 10-% κάθε φορά, τότε έχετε περάσει το σημείο όπου μπορείτε πια να σταματήσετε.
Μη συγκεντρωθείτε στο δέντρο και χάσετε το δάσος. Για παράδειγμα, αντί να προσπαθείτε να επιταχύνετε ένα κομμάτι κώδικα, σκεφτείτε αν χρειάζεται καν να τρέχει. Μήπως μπορεί να συνδυαστεί με κάποιο άλλο κομμάτι; Μήπως μπορούν τα αποτελέσματα της προηγούμενης λειτουργίας του να αποθηκευτούν και να χρησιμοποιηθούν ξανά; Δε θα χρειαστεί καν να βελτιστοποιηθεί αν βρίσκεται σε ένα μέρος όπου ο χρήστης δε θα το προσέξει ποτέ. Ακόμα χειρότερα, ο κώδικας μπορεί να είναι ήδη βελτιστοποιημένος και να κάνει τώρα τους βαριούς του υπολογισμούς για να μην τους χρειαστεί αργότερα. Ούτε ο κώδικας τρέχει απομονωμένος, ούτε η βελτιστοποίηση.
Υποδείξεις
Τα βασικά
Τρέξτε ξανά τις δοκιμαστικές σας μετρήσεις μετά από κάθε αλλαγή που κάνετε στον κώδικα και κρατήστε μια καταγραφή όλων των αλλαγών που κάνετε και πώς αυτές επηρεάζουν τις μετρήσεις. Αυτό σας βοηθά να αναιρείτε κάποια λάθη, όπως επίσης και να μην τα επαναλαμβάνετε.
Βεβαιωθείτε ότι ο κώδικάς σας είναι σωστός και χωρίς σφάλματα προτού τον βελτιστοποιήσετε. Ελέγξτε ότι είναι σωστός και χωρίς σφάλματα και μετά τη βελτιστοποίηση.
Βελτιστοποιήστε σε ψηλό επίπεδο πριν προχωρήσετε στις λεπτομέρειες.
Χρησιμοποιήστε το σωστό αλγόριθμο. Το κλασικό παράδειγμα είναι να χρησιμοποιήσετε το quick-sort αντί το bubble-sort. Υπάρχουν πολλά ακόμα, μερικά εξοικονομούν μνήμη, μερικά εξοικονομούν επεξεργαστή. Επίσης, δείτε τι συντόμια μπορείτε να ακολουθήσετε: μπορείτε να ταξινομήσετε και γρηγορότερα από το quick-sort αν μπορείτε να κάνετε μερικούς συμβιβασμούς.
Η βελτιστοποίηση είναι και θέμα ισορροπίας. Η προσωρινή αποθήκευση αποτελεσμάτων επιταχύνει τους υπολογισμούς, αλλά κοστίζει σε μνήμη. Η αποθήκευση δεδομένων στο δίσκο εξοικονομεί τη μνήμη, αλλά κοστίζει σε χρόνο όταν θα πρέπει να διαβάσετε τις πληροφορίες από το δίσκο.
Βεβαιωθείτε ότι χρησιμοποιείτε μια πλατιά ποικιλία από εισόδους για τις οποίες θα βελτιστοποιήσετε. Αν δεν το κάνετε αυτό, εύκολα θα καταλήξετε σε ένα κομμάτι κώδικα προσεκτικά βελτιστοποιημένο για συγκεκριμένη λειτουργία αλλά όχι για άλλες.
Αποφύγετε τις σπάταλες λειτουργίες: Πολλαπλές μικρές αναγνώσεις από το δίσκο, χρήση πάρα πολλής μνήμης ώστε να χρειάζεται να χρησιμοποιείται προσωρινή μνήμη στο δίσκο, γενικά οτιδήποτε γράφει ή διαβάζει από το δίσκο αν δεν είναι εντελώς απαραίτητο. Το δίκτυο επίσης είναι αργό. Αποφύγετε επίσης λειτουργίες γραφικών οι οποίες χρειάζονται απάντηση από τον εξυπηρετητή X.
Παγίδες για τους ανυποψίαστους
Προσέχετε τις παρενέργειες. Συχνά μπορεί να υπάρχουν περίεργες αλληλεπιδράσεις μεταξύ διαφορετικών κομματιών κώδικα, και η επιτάχυνση ενός κομματιού μπορεί να επιβραδύνει ένα άλλο.
Όταν χρονομετράτε τον κώδικα, ακόμα και σε ένα «ήσυχο» σύστημα, γεγονότα εκτός από το πρόγραμμα προσθέτουν «θόρυβο» στα αποτελέσματα των μετρήσεων. Τρέξτε πολλές φορές το πρόγραμμα και πάρτε το μέσο όρο. Αν ο κώδικας είναι πολύ σύντομος, η ανάλυση του χρονομέτρου είναι επίσης προβληματική. Σε τέτοια περίπτωση, χρονομετρήστε την εκτέλεση του κώδικα για 100 ή 1000 φορές. Αν οι φορές που χρονομετράτε διαρκούν περισσότερο από μερικά δευτερόλεπτα, τότε θα πρέπει να είστε εντάξει.
Είναι πάρα πολύ εύκολο να σας παραπλανήσει ο profiler. Υπάρχουν περιπτώσεις ανθρώπων που βελτιστοποιούσαν τον βρόχο παύσης του λειτουργικού συστήματος επειδή εκεί τους έδειχνε ο profiler ότι ρο σύστημα σπαταλούσε τον περισσότερο χρόνο του! Μη βελτιστοποιείτε κώδικα που δεν κάνει τίποτα χρήσιμο για το χρήστη.
Να θυμάστε τους πόρους του εξυπηρετητή X. Η χρήση μνήμης του προγράμματός σας δεν περιλαμβάνει τα pixmap που αποθηκεύονται στις διεργασίες του εξυπηρετητή X, αλλά και πάλι χρησιμοποιούν μνήμη. Χρησιμοποιήστε το xrestop για να δείτε ποιοι πόροι χρησιμοποιούνται από το πρόγραμμά σας.
Υποδείξεις χαμηλού επιπέδου
Όταν βελτιστοποιείτε τη χρήση της μνήμης, προσέξτε τη διαφορά ανάμεσα στη μέγιστη χρήση και στη μέση χρήση. Σχεδόν πάντα κατανέμεται κάποια ποσότητα μνήμης για χρήση από το πρόγραμμα, το οποίο είναι συνήθως κακό. Κάποια μνήμη είναι μόνο κατανεμημένη για λίγο, και αυτό μπορεί να είναι αποδεκτό. Εργαλεία όπως το massif χρησιμοποιούν την έννοια του χωροχρόνου, το γινόμενο της ποσότητας της μνήμης που χρησιμοποιείται και της διάρκειας κατά την οποία ήταν κατανεμημένη.
Τα απλοποιημένα κομμάτια κώδικα που κάνουν μόνο πράγματα που ξέρετε είναι ουσιώδη, γιατί σας δίνουν το απόλυτα χαμηλότερο όριο για το χρόνο που χρειάζεται ο κώδικάς σας. Για παράδειγμα, όταν βελτιστοποιείτε ένα βρόχο, χρονομετρήστε τον ενώ είναι άδειος. Αν αυτός ο χρόνος είναι πολύ μεγάλος, τότε δε θα σας βοηθήσει καθόλου η μικροβελτιστοποίηση, και θα πρέπει να αλλάξετε το σχεδιασμό σας. Βεβαιωθείτε ότι ο μεταγλωττιστής δε βελτιστοποιεί τον άδειο βρόχο.
Αφαιρέστε κώδικα από εσωτερικούς βρόχους. Ένα λίγο πιο πολύπλοκο κομμάτι κώδικα που εκτελείται μια φορά είναι πολύ γρηγορότερο από ένα απλούστερο κομμάτι κώδικα που εκτελείται χίλιες φορές. Αποφύγετε να καλείτε συχνά αργό κώδικα.
Δώστε στον μεταγλωττιστή όσες περισσότερες υποδείξεις μπορείτε. Χρησιμοποιήστε τη λέξη κλειδί const. Χρησιμοποιήστε τη
Μη χρησιμοποιείτε τη γλώσσα assembly. Δεν είναι φορητή, και ενώ μπορεί να είναι γρήγορη σε έναν επεξεργαστή, δεν είναι εγγυημένο ότι θα είναι γρήγορη και σε οποιοδήποτε άλλο επεξεργαστή που υοπστηρίζει εκείνη την αρχιτεκτονική (π.χ. Athlon vs Pentium 4).
Μη ξαναγράψετε μια υφιστάμενη βιβλιοθήκη εκτός και αν είστε βέβαιοι ότι είναι αδικαιολόγητα αργή. Πολλές βιβλιοθήκες που καταπονούν τον επεξεργαστή είναι ήδη βελτιστοποιημένες. Αντίστοιχα, μερικές ρουτίνες βιβλιοθηκών είναι αργές, ειδικά μερικές που κάνουν πολλές κλήσεις συστήματος στο λειτουργικό σύστημα.
Ελαχιστοποιήστε τον αριθμό των βιβλιοθηκών με τις οποίες συνδέεστε. Με όσο λιγότερες βιβλιοθήκες συνδέεται ένα πρόγραμμα, τόσο γρηγορότερα ξεκινά. Αυτό είναι κάτι δύσκολο να γίνει στο GNOME.
Κόλπα υψηλού επιπέδου
Εκμεταλλευτείτε το συγχρονισμό. Αυτό δε σημαίνει μόνο να χρησιμοποιείτε πολλαπλούς επεξεργαστές, αλλά και να εκμεταλλεύεστε το χρόνο που ο χρήστης σπαταλά να σκέφτεται τι θα κάνει στη συνέχεια, για να κάνετε μερικούς υπολογισμούς που χρειάζεστε. Κάντε υπολογισμούς ενώ περιμένετε για πληροφορίες να φορτωθούν από το δίσκο. Εκμεταλλευτείτε πολλαπλούς πόρους, χρησιμοποιώντας τους ταυτόχρονα.
Ξεγελάστε. Ο χρήστης χρειάζεται μόνο να νομίζει ότι ο υπολογιστής είναι γρήγορος, άσχετα αν πραγματικά είναι. Σημασία έχει ο χρόνος μεταξύ της εντολής και της απάντησης, και όχι αν η απάντηση υπολογίστηκε από πριν, ή ήταν προσωρινά αποθηκευμένη, ή ακόμα και αν θα υπολογιστεί αργότερα σε κάποιο πιο βολικό χρόνο, φτάνει ο χρήστης να πάρει αυτό που περιμένει.
Κάντε πράγματα στον ανενεργό βρόχο. Είναι ευκολότερο στον προγραμματισμό από τη χρήση πολυνηματικότητας, αλλά και πάλι επιτυγχάνει να κάνει πράγματα χωρίς να το αντιλαμβάνεται ο χρήστης. Να είστε όμως προσεκτικοί, γιατί αν σπαταλάτε πολύ χρόνο στον ανενεργό βρόχο τότε το πρόγραμμά σας γίνεται αργό. Οπότε να δίνεται τακτικά τον έλεγχο στον κύριο βρόχο.
Αν όλα τα υπόλοιπα αποτύχουν, πείτε στο χρήστη ότι ο κώδικας είναι αργός και βάλτε μια μπάρα προόδου. Δε θα είναι τόσο ευχαριστημένος όσο θα ήταν αν του δίνατε άμεσα αποτελέσματα, αλλά τουλάχιστον θα ξέρουν ότι το πρόγραμμα δεν κόλλησε και ότι μπορούν να σηκωθούν και να φτιάξουν ένα καφεδάκι.
@@image: 'figures/massif-before.png'; md5=1a6b2ace548e6789ab8bfacb3727b345
@@image: 'figures/massif-after.png'; md5=36d1b4ad7ab49b28b69ad3eabbaa7069
Χρησιμοποιήστε το
Αυτό το άρθρο περιγράφει πώς χρησιμοποιείται ο δημιουργός προφίλ
Εισαγωγή
Το
Η heap είναι η περιοχή στη μνήμη η οποία κατανέμεται με συναρτήσεις όπως η malloc. Μεγαλώνει κατά απαίτηση και είναι συνήθως η μεγαλύτερη περιοχή της μνήμης σε ένα πρόγραμμα. Η στοίβα είναι εκεί όπου αποθηκεύονται όλα τα τοπικά δεδομένα για τις συναρτήσεις. Αυτό συμπεριλαμβάνει τις «αυτόματες» μεταβλητές στη C και τη διεύθυνση επιστροφής για τις υπορουτίνες. Η στοίβα είναι τυπικά πολύ μικρότερη και πολύ πιο ενεργή από τη heap. Δε θα ασχοληθούμε ειδικά με τη στοίβα μια που το
Το
Χρήση του
Το
Είναι επίσης χρήσιμο να πείτε στο
Η γραμμή-εντολών σας πρέπει επομένως να μοιάζει κάπως σαν:
valgrind --tool=massif --depth=5 --alloc-fn=g_malloc --alloc-fn=g_realloc --alloc-fn=g_try_malloc \\
 --alloc-fn=g_malloc0 --alloc-fn=g_mem_chunk_alloc same-gnome
Το
Ερμηνεία των αποτελεσμάτων
Η γραφική έξοδος δεδομένων του
Τα αρχεία κειμένων τακτοποιούνται ιεραρχικά βάση των τμημάτων, στην κορυφή είναι μία λίστα των χειρότερων χρηστών μνήμης που τακτοποιούνται κατά σειρά βάση την μείωση του χωροχρόνου. Κάτω από αυτά είναι και άλλα τμήματα, κάθε ένα διαιρεί τα αποτελέσματα σε μικρότερες λεπτομέρειες καθώς προχωράτε προς την κλήση-σωρού. Για να επεξηγήσουμε αυτό θα χρησιμοποιήσουμε την έξοδος δεδομένων της εντολής παραπάνω.
Έξοδος δεδομένων
Το
Στην κορυφή της γραφικής παράστασης βλέπουμε μια μεγάλη κίτρινη ζώνη με τίτλο gdk_pixbuf_new. Αυτό φαίνεται ως ένας ιδανικός υποψήφιος για βελτιστοποίηση, αλλά θα πρέπει να χρησιμοποιήσουμε το αρχείο κειμένων για να ανακαλύψουμε τι καλεί το gdk_pixbuf_new. Στην κορυφή του αρχείου κειμένων θα εμφανίζεται κάτι σαν το επόμενο:
Εντολή: ./same-gnome 

== 0 ===========================
Συναρτήσεις κατανομής σωρών που καταμετρήθηκε ως το 90.4% από το μετρίσιμο χωρόχρoνο

Καλείται από:
 28.8% : 0x6BF83A: gdk_pixbuf_new (στο /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)

 6.1% : 0x5A32A5: g_strdup (στο /usr/lib/libglib-2.0.so.0.400.6)

 5.9% : 0x510B3C: (μέσα στο /usr/lib/libfreetype.so.6.3.7)

 3.5% : 0x2A4A6B: __gconv_open (στο /lib/tls/libc-2.3.3.so)
Η γραμμή με το σύμβολο του '=' δείχνει πόσο βαθιά κάτω είμαστε στο ίχνος σωρού, σε αυτήν την περίπτωση είμαστε στην κορυφή. Μετά από αυτό απαριθμεί τους βαρύτερους χρήστες της μνήμης έτσι ώστε να μειωθεί ο χωρόχρονος. Ο χωρόχρονος είναι το λόγος του ποσού της μνήμης που χρησιμοποιείται και του χρόνου χρησιμοποίησης του. Αντιστοιχεί στον περιοχή των ζωνών στη γραφική παράσταση. Αυτό το μέρος του αρχείου μας λέει αυτό που ξέρουμε ήδη: το μεγαλύτερο μέρος του χωροχρόνου αφιερώνεται στο gdk_pixbuf_new. Για να ανακαλύψουν τι κάλεσε το gdk_pixbuf_new πρέπει να ψάξουμε περαιτέρω μέσα στο αρχείο κειμένου:
== 4 ===========================
Πλαίσιο καταμέτρησης για το 28.8% του υπολογίσιμου χωροχρόνου
 0x6BF83A: gdk_pixbuf_new (στο /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)
 0x3A998998: (μέσα στο /usr/lib/gtk-2.0/2.4.0/loaders/libpixbufloader-png.so)
 0x6C2760: (μέσα στο /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)
 0x6C285E: gdk_pixbuf_new_from_file (στο /usr/lib/libgdk_pixbuf-2.0.so.0.400.9)

Καλείται από:
 27.8% : 0x804C1A3: load_scenario (same-gnome.c:463)

 0.9% : 0x3E8095E: (μέσα στο /usr/lib/libgnomeui-2.so.0.792.0)

 και 1 άλλη ασήμαντη θέση
Η πρώτη γραμμή μας λέει ότι είμαστε τώρα τέσσερα επίπεδα βαθιά μέσα στο σωρό. Από κάτω βρίσκεται η λίστα των κλήσεων λειτουργίας που μας οδηγεί από εδώ στο gdk_pixbuf_new. Τελικά υπάρχει μία λίστα λειτουργιών που είναι στο επόμενο κάτω επίπεδο και καλούν αυτές τις λειτουργίες. Υπάρχουν, φυσικά, καταχωρήσεις για τα επίπεδα 1, 2, και 3, αλλά αυτό είναι το πρώτο επίπεδο που φθάνει ακριβός στον κώδικα GDK του
Τώρα που ξέρουμε ποιο μέρος του κώδικά μας χρησιμοποιεί όλο χωρόχρονο μπορούμε να εξετάσουμε και να ανακαλύψουμε το γιατί. Ως αποτέλεσμα βλέπουμε ότι το load_scenario φορτώνει την pixbuf από ένα αρχείο και έπειτα δεν απελευθερώνει ποτέ την μνήμη. Αφού προσδιορίσαμε τον προβληματικό κώδικα, μπορούμε να αρχίσουμε να τον διορθώνουμε.
Ενέργειες πάνω στα αποτελέσματα
Μειώνοντας την κατανάλωση του χωροχρόνου είναι κάτι καλό, αλλά υπάρχουν δύο τρόποι για την μείωση του που δεν είναι ισότιμες. Μπορείτε είτε να μειώσετε το ποσό μνήμης που διατίθεται, ή μειώστε το χρονικό διάστημα που του διατίθεται. Εξετάστε για μια στιγμή ένα πρότυπο σύστημα με μόνο δύο διαδικασίες ενεργές. Και οι δύο διαδικασίες καταναλώνουν σχεδόν όλη την φυσική μνήμη RAM και εάν κάποια στιγμή επικαλύψει η μία την άλλη το σύστημα θα κάνει αντιμετάθεση και όλα θα επιβραδύνουν. Προφανώς εάν μειώνουμε τη χρήση μνήμης σε κάθε διαδικασία με παράγοντα του δύο θα μπορούν ειρηνικά να συνυπάρξουν χωρίς την ανάγκη για αντιμετάθεση. Εάν αντ' αυτού μειώσουμε το χρόνο που διατίθεται η μνήμη με παράγοντα του δύο τότε τα δύο προγράμματα μπορούν να συνυπάρξουν, αλλά μόνο εφ' όσον οι περίοδοι υψηλής χρήσης της μνήμης τους δεν επικαλύπτονται. Έτσι είναι καλύτερο να μειωθεί το ποσό μνήμης που διατίθεται.
Δυστυχώς, η επιλογή της βελτιστοποίησης περιορίζεται επίσης από τις ανάγκες του προγράμματος. Το μέγεθος των δεδομένων του pixbuf στο
Έξοδος δεδομένων
Η χρήση του χωροχρόνου από το gdk_pixbuf_new είναι τώρα μια λεπτή ζώνη που έχει σύντομες αναλαμπές (είναι τώρα η δέκατη έκτη ζώνη και βαθυπόρφυρη απόχρωση). Σαν έχτρα χαρακτηριστικό, η μέγιστη χρήση μνήμης έχει ελαττωθεί κατά 200 kB δεδομένου ότι η αιχμή εμφανίζεται πριν η μνήμη δεσμευτεί. Εάν δύο διαδικασίες όπως αυτή εκτελούνται από κοινού οι πιθανότητες της μέγιστης χρήσης μνήμης συμπίπτουν, και ως εκ τούτου ο κίνδυνος αντιμετάθεσης, θα είναι αρκετά χαμηλός.
Μπορούμε να το κάνουμε καλύτερα; Μια γρήγορη εξέταση της εξόδου δεδομένων του
Εντολή: ./same-gnome 

== 0 ===========================
Συναρτήσεις κατανομής σωρών που καταμετρήθηκε ως το 87.6% από το μετρίσιμο χωρόχρονο

Καλείται από:
 7.7% : 0x5A32A5: g_strdup (στο /usr/lib/libglib-2.0.so.0.400.6)

 7.6% : 0x43BC9F: (μέσα στο /usr/lib/libgdk-x11-2.0.so.0.400.9)

 6.9% : 0x510B3C: (μέσα στο /usr/lib/libfreetype.so.6.3.7)

 5.2% : 0x2A4A6B: __gconv_open (στο /lib/tls/libc-2.3.3.so)
Εάν το εξετάσουμε ποιο ενδελεχώς θα δούμε ότι καλείται από πολλές, πολλές, διαφορετικές θέσεις.
== 1 ===========================
Πλαίσιο καταμέτρησης για το 7.7% του υπολογίσιμου χωροχρόνου
 0x5A32A5: g_strdup (στο /usr/lib/libglib-2.0.so.0.400.6)

Called from:
 1.8% : 0x8BF606: gtk_icon_source_copy (στο /usr/lib/libgtk-x11-2.0.so.0.400.9)

 1.1% : 0x67AF6B: g_param_spec_internal (στο /usr/lib/libgobject-2.0.so.0.400.6)

 0.9% : 0x91FCFC: (μέσα στο /usr/lib/libgtk-x11-2.0.so.0.400.9)

 0.8% : 0x57EEBF: g_quark_from_string (στο /usr/lib/libglib-2.0.so.0.400.6)

 και 155 άλλες ασήμαντες θέσεις
Τώρα αντιμετωπίζουμε την ελάττωση της ανταμοιβή μας για τις προσπάθειες βελτιστοποίησής. Οι συμβουλές γραφικών παραστάσεων είναι μια άλλη πιθανή προσέγγιση: Και οι δύο ζώνες "other" και "heap admin" είναι αρκετά μεγάλες. Αυτό μας λέει ότι υπάρχουν πολλές μικρές κατανομές που έχουν γίνει από ποικίλες θέσεις. Η εξάλειψη τους θα είναι δύσκολη, αλλά εάν μπορέσουν να ομαδοποιηθούν τότε οι μεμονωμένες κατανομές μπορούν να γίνουν μεγαλύτερες και η επιβάρυνση του "heap admin" μπορεί να μειωθεί.
Caveats
Υπάρχουν μερικά πράγματα που θα πρέπει να προσέξετε: Αρχικά, ο χωρόχρονος εμφανίζεται μόνο ως ποσοστό, πρέπει να το συγκρίνετε με το γενικό μέγεθος του προγράμματος για να αποφασίσει εάν το ποσό μνήμης αξίζει να δαπανηθεί. Η γραφική παράσταση, με τον κάθετο άξονα σε kilobyte, είναι ιδανικό για κάτι τέτοιο.
Αφετέρου,to
Οι αναζητήσεις δίσκου θεωρούνται επιβλαβής
Οι αναζητήσεις του δίσκου είναι από τις ποιο δαπανηρές διαδικασίες που μπορείτε ενδεχομένως να εκτελέσετε. Μπορεί να μην το καταλάβετε αυτό απλά εξετάζοντας πόσες από αυτές εκτελείτε, αλλά πιστέψτε μας, είναι πολλές. Συνεπώς, παρακαλώ να αποφεύγεται την ακόλουθη μη-βέλτιστη συμπεριφορά:
Τοποθετώντας πολλά μικρά αρχεία παντού στον δίσκο.
Άνοιγμα, δηλώσεις, και ανάγνωση πολλών μικρών αρχείών παντού στον δίσκο.
Κάνοντας τα ανωτέρω σε αρχεία που δημιουργήθηκαν σε διαφορετικούς χρόνους, ώστε να εξασφαλιστεί ότι είναι τεμαχισμένα και να προκαλούν ακόμη περισσότερη αναζήτηση.
Κάνοντας τα ανωτέρω σε αρχεία που είναι σε διαφορετικούς καταλόγους, ώστε να εξασφαλιστεί ότι βρίσκονται σε διαφορετικές ομάδες κυλίνδρων και έτσι να προκαλεί ακόμη περισσότερη αναζήτηση.
Επαναλαμβανόμενη εκτέλεση των ανωτέρω όταν θα έπρεπε να γίνει μια μόνο φορά.
Τρόποι με τους οποίους μπορείτε να βελτιστοποιήσετε τον κώδικά σας για είναι φιλικός με τις αναζητήσεις:
Παγιώστε τα δεδομένα σε ένα ενιαίο αρχείο.
Κρατήστε τα δεδομένα μαζί στον ίδιο κατάλογο.
Τοποθέτηση των δεδομένων στην προσωρινή μνήμη ώστε να μην χρειάζεται συνεχώς να ξαναδιαβάζονται.
Διαμοιρασμός δεδομένων ώστε να μη χρειάζεται να τα ξαναδιαβάζει από το δίσκο κάθε εφαρμογή όταν φορτώνει.
Καλύτερα να αντιγράφετε όλα τα δεδομένα στην προσωρινή μνήμη σε ένα ενιαίο δυαδικό αρχείο που ευθυγραμμίζεται κατάλληλα και μπορεί να είναι mmaped.
Το πρόβλημα με την αναζητήσεις δίσκων είναι αρκετά σύνθετο όσο αναφορά την ανάγνωση, το όποιο είναι δυστυχώς αυτό που κάνουμε. Να θυμάστε, η ανάγνωση είναι γενικά σύγχρονή ενώ η εγγραφή είναι ασύγχρονη. Αυτό κάνει ποιο σύνθετο το πρόβλημα, διατάσσοντας σειριακά κάθε ανάγνωση, και συμβάλλοντας στη λανθάνουσα κατάσταση του προγράμματος.
Βελτιστοποίηση λογισμικού του GNOME
Πρόγραμμα τεκμηρίωσης του GNOME
2004-2005
Callum McKenzie
Robert Love
Callum
McKenzie
Robert
Love
Χορηγείται η άδεις στην αντιγραφή, διανομή ή/και τροποποίηση του παρόντος εγγράφου υπό τους όρους του
Πολλά από τα ονόματα που χρησιμοποιούνται από τις επιχειρήσεις για να διαφοροποιήσουν τα προϊόντα τους και τις υπηρεσίες τους εμφανίζονται ως εμπορικά σήματα. Όπου αυτά τα ονόματα εμφανίζονται σε οποιαδήποτε τεκμηρίωση του GNOME, και αυτά τα εμπορικά σήματα γίνονται γνωστά στα μέλη του έργου τεκμηρίωσης του GNOME, τα ονόματα θα τυπώνονται με κεφαλαία γράμματα ή γράμματα τίτλων.
0.1
Νοέμβριος 2007
William Johnston
Μετατροπή από Intial στην μορφή docbook.
Το λογισμικό μπορεί να βελτιστοποιηθεί από πολλές απόψεις: για την ταχύτητα, το μέγεθος του προγράμματος, ή τη χρήση μνήμης. Αυτό το τμήμα περιέχει οδηγούς και σεμινάρια για τη βελτιστοποίηση του λογισμικού σας.
Ελληνική μεταφραστική ομάδα GNOME
 Γιάννης Κατσαμπίρης <giannis1_86\@hotmail\.com>
 Σίμος Ξενιτέλλης <simos\@gnome\.org>
 Κωνσταντίνος Κουράτορας <kouratoras\@gmail\.com>
 Σωτηρία Τζιούρη <sotitz\@gmail\.com>
 Τζένη Πετούμενου <epetoumenou\@gmail\.com>
 Τουρνάρης Παύλος-Πέτρος <p\.tournaris\@gmail\.com>

Για περισσότερα δείτε http://www.gnome.gr/