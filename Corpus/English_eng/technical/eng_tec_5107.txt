# language_name_wals:	English
# language_name_glotto:	English
# ISO_6393:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	PHP
# source:	https://object.pouta.csc.fi/OPUS-PHP/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/PHP.php
# copyright_long:	http://opus.nlpl.eu/PHP.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

PHP Manual
Prev
Next
(PHP 3 = 3.0.8, PHP 4)
This function parses an XML file into 2 parallel array structures, one (index) containing pointers to the location of the appropriate values in the values array.
These last two parameters must be passed by reference.
Below is an example that illustrates the internal structure of the arrays being generated by the function.
We use a simple note tag embeded inside a para tag, and then we parse this an print out the structures generated:
$simple = "para note simple note / note / para"; $p = xml_parser_create(); xml_parse_into_struct($p,$simple,$vals,$index); xml_parser_free($p); echo "Index array\n"; print_r($index); echo "\nVals array\n"; print_r($vals);
Index array Array ([PARA] = Array ([0] = 0 [1] = 2) [NOTE] = Array ([0] = 1)) Vals array Array ([0] = Array ([tag] = PARA [type] = open [level] = 1) [1] = Array ([tag] = NOTE [type] = complete [level] = 2 [value] = simple note) [2] = Array ([tag] = PARA [type] = close [level] = 1))
Event-driven parsing (based on the expat library) can get complicated when you have an XML document that is complex.
This function does not produce a DOM style object, but it generates structures amenable of being transversed in a tree fashion.
Thus, we can create objects representing the data in the XML file easily.
Let 's consider the following XML file representing a small database of aminoacids information:
Example 1. moldb.xml - small database of molecular information
?xml version=" 1.0 "? moldb molecule name Alanine / name symbol ala / symbol code A / code type hydrophobic / type / molecule molecule name Lysine / name symbol lys / symbol code K / code type charged / type / molecule / moldb
Example 2. parsemoldb.php - parses moldb.xml into and array of molecular objects
?php class AminoAcid {var $name; / / aa name var $symbol; / / three letter symbol var $code; / / one letter code var $type; / / hydrophobic, charged or neutral function AminoAcid ($aa) {foreach ($aa as $k= $v) $this - $k = $aa[$k];}} function readDatabase($filename) {/ / read the xml database of aminoacids $data = implode("",file($filename)); $parser = xml_parser_create(); xml_parser_set_option($parser,XML_OPTION_CASE_FOLDING,0); xml_parser_set_option($parser,XML_OPTION_SKIP_WHITE,1); xml_parse_into_struct($parser,$data,$values,$tags); xml_parser_free($parser); / / loop through the structures foreach ($tags as $key= $val) {if ($key == "molecule") {$molranges = $val; / / each contiguous pair of array entries are the / / lower and upper range for each molecule definition for ($i=0; $i count($molranges); $i+=2) {$offset = $molranges[$i] + 1; $len = $molranges[$i + 1] - $offset; $tdb[] = parseMol(array_slice($values, $offset, $len));}} else {continue;}} return $tdb;} function parseMol($mvalues) {for ($i=0; $i count($mvalues); $i++) $mol[$mvalues[$i]["tag"]] = $mvalues[$i]["value"]; return new AminoAcid($mol);} $db = readDatabase("moldb.xml"); echo "** Database of AminoAcid objects:\n"; print_r($db);?
** Database of AminoAcid objects:
Array ([0] = aminoacid Object ([name] = Alanine [symbol] = ala [code] = A [type] = hydrophobic) [1] = aminoacid Object ([name] = Lysine [symbol] = lys [code] = K [type] = charged))
Prev
Home
Next
xml_get_error_code
Up
xml_parse