# language_name_wals:	English
# language_name_glotto:	English
# ISO_6393:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	part
# comments:	NA

translator-credits
external ref='media/02_jsgrid_01.png' md5='3fdc22d361cf801f71557fdc76ae5b49'
external ref='media/02_jsgrid_02.png' md5='07db86b0043ba5c3c24a90d7322bd81e'
external ref='media/02_jsgrid_03.png' md5='817351e73c687d47253c56ed06b6629f'
external ref='media/02_jsgrid_04.png' md5='eeaead27cee2851877fc3cfe66177f07'
external ref='media/02_jsgrid_05.png' md5='a3ad12f432d5977fc1f66302ad5b7498'
external ref='media/02_jsgrid_06.png' md5='450e48dbf6b8f5ce1c208e4812e1714b'
external ref='media/02_jsgrid_07.png' md5='0b304d70728903fbb2601d55bf00fdb9'
external ref='media/02_jsgrid_08.png' md5='78890beb47bd11360154b8ca4d50d1ff'
Taryn Fox
2012
Learn how to lay out UI components, like Images and Labels.
2. Welcome to the Grid
This tutorial will show you how to create basic widgets, or parts of the GNOME user interface, like Images and Labels. You'll then learn how to arrange them all in a Grid, which lets you put widgets exactly where you want them.
Have you taken
Going native
In the last tutorial, we created what was basically a GNOME window frame for a web app. All the GNOME-specific code we needed to learn revolved around putting the WebView -- the widget containing our application -- into an ApplicationWindow, and telling it to display. The application itself was written in HTML and JavaScript, just like most pages on the web.
This time, we're going to use only native GNOME widgets. A widget is just a thing, like a checkbox or picture, and GNOME has a wide variety of them to choose from. We call them "native" widgets to distinguish them from things like the button and header in the web app we wrote. Because instead of using web code, these are going to be 100 percent GNOME, using GTK+.
GTK+ stands for "GIMP Toolkit". It's like a toolbox of widgets that you can reach into, while building your applications. It was originally written for
Setting up our application
Before we dig out any widgets from the GTK+ toolbox, we first need to write the basic boilerplate code that our application requires.
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
This part always goes at the start of your code. Depending on what you'll be doing with it, you may want to declare more imports here. What we're writing today is pretty basic, so these are all we need; Gtk for the widgets, and Lang so we can use Lang.bind to connect our application's activate and startup signals to the requisite functions.
Speaking of which:
const WelcomeToTheGrid = new Lang.Class({
 Name: 'Welcome to the Grid',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
This is the start of the application itself, and the _init function which creates it. It tells _buildUI to create an ApplicationWindow, which we're going to call _window, and it tells our window to present itself whenever needed.
This part, again, is pretty much copy-and-paste, but you always want to give your application a unique name.
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 10,
 title: "Welcome to the Grid"});
Finally, we start off the _buildUI function by creating a new ApplicationWindow. We specify that it goes with this application, that it should appear in the center of the screen, and that there should be at least 10 pixels between the outside edge and any widgets inside of it. We also give it a title, which will appear at the top of the window.
Reaching into the GTK+ toolbox
What widgets should we use? Well, let's say we want to write an application that looks like this:
We're going to need, at the very least, a picture and a text label to go with it. Let's start with the picture:
// Create an image
 this._image = new Gtk.Image ({ file: "gnome-image.png" });
You can download the image file used in this example
// Create a label
 this._label = new Gtk.Label ({ label: "Welcome to GNOME, too!" });
That code adds in the label beneath. You can see how we create widgets, here; each one is a part of Gtk, and we can give it properties that customize how it behaves. In this case, we set the Image's file property to be the filename of the picture we want, and the Label's label property to be the sentence that we want beneath the picture.
Yes, it sounds redundant for a Label to have a label property, but it's not. Other widgets that contain text have a label property, so it's
We can't just add these widgets to our window in order, though, the same way HTML elements appear in the order you write them. That's because an ApplicationWindow can only contain one widget.
How do we get around that? By making that one widget a container widget, which can hold more than one widget and organize them inside it. Behold: The Grid.
// Create the Grid
 this._grid = new Gtk.Grid ();
We're not giving it any properties yet. Those will come later, as we learn how to use the Grid's powers. First, let's attach the Image and Label we made to our Grid.
// Attach the image and label to the grid
 this._grid.attach (this._image, 0, 0, 1, 1);
 this._grid.attach (this._label, 0, 1, 1, 1);
This code looks awfully complicated, but it's not. Here's what those numbers mean:
The
The
The
// Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 }

});

// Run the application
let app = new WelcomeToTheGrid ();
app.application.run (ARGV);
Now that we've created the Grid and attached all our widgets to it, we add it to the window and tell the window to show itself, as the last part of the _buildUI function. As always, to finish up we create a new instance of the application's class and tell it to run.
Save your application as welcome_to_the_grid.js. Then, to run your application just open a terminal, go to the directory where your application is at, and type

There we go! But wait. That doesn't look right. Why is the Label crammed up next to the Image like that? That doesn't look as nice, and it makes it harder to read. What can we do about this?
Tweaking the Grid
One thing we can do, is we can give the Label a margin_top property when we create it. This works sort of like setting a margin for an HTML element using inline CSS styling.
// Create a label
 this._label = new Gtk.Label ({
 label: "Welcome to GNOME, too!",
 margin_top: 20 });
Of course, if we do that then if we replace the Label with something else -- or add in another widget -- then we have to repeat the margin_top on it too. Otherwise we end up with something like this:
We could give the Image a margin_bottom property, but that won't work when the new Label is in a separate column. So how about we try this instead:
// Create the Grid
 this._grid = new Gtk.Grid ({
 row_spacing: 20 });
That makes it so that there are always 20 pixels of space in between each horizontal row.
Yes, you can also set the column_spacing property on a Grid, or the margin_left and margin_right properties on any widget. Try them out, if you like!
Adding more widgets
If we did want to add a second Label, how would we do it so that it actually looked like it belonged there? One way is to center the Image on top, so that it's above both Labels instead of just the one on the left. That's where those other numbers in the Grid's attach method come in:
// Create a second label
 this._labelTwo = new Gtk.Label ({
 label: "The cake is a pie." });

 // Attach the image and labels to the grid
 this._grid.attach (this._image, 0, 0, 2, 1);
 this._grid.attach (this._label, 0, 1, 1, 1);
 this._grid.attach (this._labelTwo, 1, 1, 1, 1);
After we create the second Label, we attach it to the Grid to the right of the first Label. Remember, the first two numbers count columns and rows from left to right and top to bottom, starting with 0. So if the first Label is in column 0 and row 1, we can put the second in column 1 and row 1 to put it to the right of the first Label.
Note the number 2 in the attach statement for the Image. That's what does the trick here. That number is how many columns the Image spans, remember? So when we put it together, we get something like this:
There are two things you should take note of, here.
Setting the Image to span two columns doesn't stretch the picture itself horizontally. Instead, it stretches the invisible box taken up by the Image widget to fill both columns, then places the Image in the center of that box.
Even though we've set the Grid's row_spacing and the ApplicationWindow's border_width properties, we haven't yet set anything that puts a border in between the two Labels. They were separate earlier when the Image was in only one column, but now that it spans both GNOME doesn't see a reason to keep them apart.
There are at least three ways we can get around that last one. First, we can set a margin_left or margin_right on one of the Labels:
Second, we can set the Grid's column_homogenous property to true.
// Create the Grid
 this._grid = new Gtk.Grid ({
 column_homogeneous: true,
 row_spacing: 20 });
That makes it look something like this:
And third, we can set the Grid's column_spacing property, the same way we set its row_spacing.
// Create the Grid
 this._grid = new Gtk.Grid ({
 column_spacing: 20,
 row_spacing: 20 });
That makes it look like this:
Using stock images
GNOME has a lot of stock images on hand already, that we can use if we don't feel like creating our own or if we want a universally-recognized icon. Here's how we create a stock image, compared to how we create a normal one:
// Create an image
 this._image = new Gtk.Image ({ file: "gnome-image.png" });

 // Create a second image using a stock icon
 this._icon = new Gtk.Image ({ stock: 'gtk-about' });
After that, we attach it to the Grid to the left of the first Label. (We aren't using the second one for this example.)
// Attach the images and label to the grid
 this._grid.attach (this._image, 0, 0, 2, 1);
 this._grid.attach (this._icon, 0, 1, 1, 1);
 this._grid.attach (this._label, 1, 1, 1, 1);
That gives us this, when we run it:
That's what the stock "About" icon looks like. You can see a list of all the stock items starting with gtk-about in
We put single quotes around 'gtk-about' here because, unlike text strings that have double quotes around them, that part will never need to be translated into another language. In fact, if it
What's next?
Before we go on to the next tutorial, let's try something a little different:
// Create a button
 this._button = new Gtk.Button ({
 label: "Welcome to GNOME, too!"});

 // Attach the images and button to the grid
 this._grid.attach (this._image, 0, 0, 2, 1);
 this._grid.attach (this._icon, 0, 1, 1, 1);
 this._grid.attach (this._button, 1, 1, 1, 1);
That's right, we turned the Label into a Button just by changing the name! If you run the application and click on it, though, you'll find that it doesn't do anything. How do we make our Button do something? That's what we'll find out, in
If you like, feel free to spend some time experimenting with Grids, Labels, and Images, including stock images.
One trick you can use to make more complex layouts is to nest Grids inside of each other. This lets you group together related widgets, and rearrange them easily. Take a look at the
Complete code sample
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const WelcomeToTheGrid = new Lang.Class({
 Name: 'Welcome to the Grid',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 10,
 title: "Welcome to the Grid"});

 // Create the Grid
 this._grid = new Gtk.Grid ({
 // column_homogeneous: true,
 // column_spacing: 20,
 row_spacing: 20 });

 // Create an image
 this._image = new Gtk.Image ({ file: "gnome-image.png" });

 // Create a second image using a stock icon
 this._icon = new Gtk.Image ({ stock: 'gtk-about' });

 // Create a label
 this._label = new Gtk.Label ({
 label: "Welcome to GNOME, too!",
 /* margin_top: 20 */ });

 /* Create a second label
 this._labelTwo = new Gtk.Label ({
 label: "The cake is a pie." }); */

 /* Create a button
 this._button = new Gtk.Button ({
 label: "Welcome to GNOME, too!"}); */

 // Attach the images and button to the grid
 this._grid.attach (this._image, 0, 0, 2, 1);
 this._grid.attach (this._icon, 0, 1, 1, 1);
 this._grid.attach (this._label, 1, 1, 1, 1);

 // this._grid.attach (this._label, 0, 1, 1, 1);
 // this._grid.attach (this._labelTwo, 1, 1, 1, 1);

 // this._grid.attach (this._button, 1, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 }

});

// Run the application
let app = new WelcomeToTheGrid ();
app.application.run (ARGV);
external ref='media/03_jssignal_01.png' md5='8d6ecab185f4af4534cc255d62b58b8e'
external ref='media/03_jssignal_02.png' md5='ba941390fbafc4a0f653c8f70bca92c0'
external ref='media/03_jssignal_03.png' md5='49ecf251b0bf57543c8d79a77b6f306d'
external ref='media/03_jssignal_04.png' md5='dfc5221ca15ca9fba7d3c76a73804e2d'
Create Buttons and other widgets that do things when you click on them.
3. Getting the Signal
In the last tutorial, we learned how to create widgets like Labels, Images, and Buttons. Here, we'll learn how to make Buttons and other input widgets actually do things, by writing functions which handle the signals they send when they are clicked on or interacted with.
A basic application
In GNOME, widgets that you can interact with, like Buttons and Switches, send out signals when they are clicked on or activated. A Button, for instance, sends out the "clicked" signal when somebody clicks on it. When this happens, GNOME looks for the part in your code that says what to do.
How do we write that code? By connecting that Button's "clicked" signal to a callback function, which is a function you write just to handle that signal. So whenever it gives off that signal, the function connected to that signal is run.
Here is an extremely basic example:
This ApplicationWindow has a Button and a Label inside it, arranged in a Grid. Whenever the Button is clicked, a variable that holds the number of cookies is increased by 1, and the Label that shows how many cookies there are is updated.
The cookies in this example are not the same as the cookies that you get from websites, which store your login information and may keep track of which sites you've visited. They're just imaginary treats. You may bake some real ones if you like.
Here is the basic, boilerplate code that goes at the start of the application, before we start creating the window and widgets. Besides the application having a unique name, the biggest change from the usual boilerplate is that we create a global variable right near the beginning, to hold the number of cookies.
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

// We start out with 0 cookies
var cookies = 0;

const GettingTheSignal = new Lang.Class({
 Name: 'Getting the Signal',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
Take a look at the part that uses our application's connect method and Lang.bind, to connect its activate and startup signals to the functions that present the window and build the UI. We're going to do the same thing with our Button when we get to it, except that we're going to connect its "clicked" signal instead.
Click the button
As usual, we'll put all the code to create our Button and other widgets inside the _buildUI function, which is called when the application starts up.
// Build the application's UI
 _buildUI: function() {
First, we create the window itself:
// Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 200,
 default_width: 400,
 title: "Click the button to get a cookie!"});
Note that we've set its default_height and default_width properties. These let us control how tall and wide the ApplicationWindow will be, in pixels.
Next, we'll create the Label that shows us the number of cookies. We can use the cookies variable as part of the Label's label property.
// Create the label
 this._cookieLabel = new Gtk.Label ({
 label: "Number of cookies: " + cookies });
Now we'll create the Button. We set its label property to show the text that we want on the Button, and we connect its "clicked" signal to a function called _getACookie, which we'll write after we're done building our application's UI.
// Create the cookie button
 this._cookieButton = new Gtk.Button ({ label: "Get a cookie" });

 // Connect the cookie button to the function that handles clicking it
 this._cookieButton.connect ('clicked', Lang.bind (this, this._getACookie));
Finally, we create a Grid, attach the Label and Button to it, add it to the window and tell the window to show itself and its contents. That's all we need inside the _buildUI function, so we close it with a bracket, as well as a comma that tells GNOME to go on to the next function. Note that even though we wrote the code for the Label first, we can still attach it to the Grid in a way that will put it on the bottom.
// Create a grid to arrange everything inside
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 row_spacing: 20 });

 // Put everything inside the grid
 this._grid.attach (this._cookieButton, 0, 0, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();

 },
Now, we write the _getACookie function. Whenever our Button sends out its "clicked" signal, the code in this function will run. In this case, all it does is increase the number of cookies by 1, and update the Label to show the new number of cookies. We do this using the Label's set_label method.
Many widgets have the same properties and methods. Both Labels and Buttons, for instance, have a label property that says what text is inside them, and get_label and set_label methods that let you check what that text is and change it, respectively. So if you learn how one widget works, you'll also know how others like it work.
_getACookie: function() {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

});
Finally, we run the application, using the same kind of code as in our last tutorial.
// Run the application
let app = new GettingTheSignal ();
app.application.run (ARGV);
Flip the switch
Buttons aren't the only input widgets in our GTK+ toolbox. We can also use switches, like the one in this example. Switches don't have a label property, so we have to create a separate Label that says what it does to go next to it.
A Switch has two positions, Off and On. When a Switch is turned on, its text and background color change, so you can tell which position it's in.
You may have seen Switches like these in GNOME's accessibility menu, which let you turn features like large text and the on-screen keyboard on and off. In this case, the Switch controls our imaginary cookie dispenser. If the Switch is turned on, you can get cookies by clicking the "Get a cookie" Button. If it's turned off, clicking the Button won't do anything.
You can get to the accessibility menu by clicking on the outline of a human, near your name in the upper-right corner of the screen.
Here's how we create the Switch:
// Create the switch that controls whether or not you can win
 this._cookieSwitch = new Gtk.Switch ();
We don't actually need to connect the Switch to anything. All we need to do is write an if statement in our _getACookie function, to check to see if the Switch is turned on. If we wanted to make something happen as soon as you flip the Switch, though, we would connect its notify::active signal, like so:
// Connect the switch to the function that handles it
 this._cookieSwitch.connect ('notify::active', Lang.bind (this, this._cookieDispenser));
A Switch is set to the off position by default. If we wanted the Switch to start out turned on, we would set the value of its active property to true when we create it.
this._cookieSwitch = new Gtk.Switch ({ active: true });
Let's just create it normally, though, and then create the Label that goes with it. We want the Switch and the Label to be kept right next to each other, so we'll create a Grid just for them, then put that Grid in our larger Grid that holds all the widgets inside it. Here's what the code looks like to create all that:
// Create the switch that controls whether or not you can win
 this._cookieSwitch = new Gtk.Switch ();

 // Create the label to go with the switch
 this._switchLabel = new Gtk.Label ({
 label: "Cookie dispenser" });

 // Create a grid for the switch and its label
 this._switchGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Put the switch and its label inside that grid
 this._switchGrid.attach (this._switchLabel, 0, 0, 1, 1);
 this._switchGrid.attach (this._cookieSwitch, 1, 0, 1, 1);
And now we arrange everything in the larger Grid like so.
// Put everything inside the grid
 this._grid.attach (this._cookieButton, 0, 0, 1, 1);
 this._grid.attach (this._switchGrid, 0, 1, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 2, 1, 1);
Now we change the _getACookie function so that it checks to see if the cookie dispenser is turned on. We do that by using the Switch's get_active method. It returns true if the Switch is turned on, and false if the Switch is turned off.
When a method is used in an if statement like this, the code inside the if statement is executed if the method returns true.
_getACookie: function() {

 // Is the cookie dispenser turned on?
 if (this._cookieSwitch.get_active()) {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

 }
Tuning the radio
Another type of input widget we can use is called the RadioButton. You create them in groups, and then only one RadioButton in a group can be selected at a time. They're called RadioButtons because they work like the channel preset button in old-style car radios. The radio could only be tuned to one station at a time, so whenever you pressed one button in, another would pop back out.
First off, let's change our ApplicationWindow's name and increase its border_width property, so that our widgets aren't packed in too tightly. The border_width is the number of pixels between any widget and the edge of the window.
// Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 200,
 default_width: 400,
 border_width: 20,
 title: "Choose the one that says 'cookie'!"});
After that, we create the RadioButtons. Remember how they're created in groups? The way we do that, is we set each new RadioButton's group property to the name of another RadioButton.
// Create the radio buttons
 this._cookieRadio = new Gtk.RadioButton ({ label: "Cookie" });
 this._notCookieOne = new Gtk.RadioButton ({ label: "Not cookie",
 group: this._cookieRadio });
 this._notCookieTwo = new Gtk.RadioButton ({ label: "Not cookie",
 group: this._cookieRadio });
Next, we create a Grid for the RadioButtons. Remember, we don't have to arrange things in Grids in the same order that we create them in.
// Arrange the radio buttons in their own grid
 this._radioGrid = new Gtk.Grid ();
 this._radioGrid.attach (this._notCookieOne, 0, 0, 1, 1);
 this._radioGrid.attach (this._cookieRadio, 0, 1, 1, 1);
 this._radioGrid.attach (this._notCookieTwo, 0, 2, 1, 1);
Normally, the RadioButton that's selected by default is the one that's the name of the group. We want the first "Not cookie" button to be selected by default, though, so we use its set_active method.
We could also set its active property to true when we create it.
// Set the button that will be at the top to be active by default
 this._notCookieOne.set_active (true);
Now we arrange everything in our main Grid like usual ...
// Put everything inside the grid
 this._grid.attach (this._radioGrid, 0, 0, 1, 1);
 this._grid.attach (this._cookieButton, 0, 1, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 2, 1, 1);
And then we change our _getACookie function to test to see if the cookie button is the one that's selected.
_getACookie: function() {

 // Did you select "cookie" instead of "not cookie"?
 if (this._cookieRadio.get_active()) {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

 }
Can you spell "cookie"?
The last input widget we're going to cover is the Entry widget, which is used for single-line text entry.
If you need to be able to enter in a whole paragraph or more, like if you are building a text editor, you'll want to look at the much more customizable
After we change the window's name, we create the Entry widget.
// Create the text entry field
 this._spellCookie = new Gtk.Entry ();
Next, we arrange everything in the Grid ...
// Put everything inside the grid
 this._grid.attach (this._spellCookie, 0, 0, 1, 1);
 this._grid.attach (this._cookieButton, 0, 1, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 2, 1, 1);
And now we modify _getACookie's if statement again, using the Entry's get_text method to retrieve the text that you entered into it and see if you spelled "cookie" right. We don't care whether you capitalize "cookie" or not, so we use JavaScript's built-in toLowerCase method to change the Entry's text to all lower case inside the if statement.
An Entry widget doesn't have a label property, which is a set text string that the user can't change. (You can't normally change the label on a Button, for instance.) Instead, it has a text property, which changes to match what the user types in.
_getACookie: function() {

 // Did you spell "cookie" correctly?
 if ((this._spellCookie.get_text()).toLowerCase() == "cookie") {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

 }
Keep reading, if you'd like to see the complete code for each version of our cookie maker application.
The main JavaScript tutorials page has
Complete code samples
Code sample with Button
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

// We start out with 0 cookies
var cookies = 0;

const GettingTheSignal = new Lang.Class({
 Name: 'Getting the Signal',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 200,
 default_width: 400,
 title: "Click the button to get a cookie!"});

 // Create the label
 this._cookieLabel = new Gtk.Label ({
 label: "Number of cookies: " + cookies });

 // Create the cookie button
 this._cookieButton = new Gtk.Button ({ label: "Get a cookie" });

 // Connect the cookie button to the function that handles clicking it
 this._cookieButton.connect ('clicked', Lang.bind (this, this._getACookie));

 // Create a grid to arrange everything inside
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 row_spacing: 20 });

 // Put everything inside the grid
 this._grid.attach (this._cookieButton, 0, 0, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();

 },



 _getACookie: function() {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

});

// Run the application
let app = new GettingTheSignal ();
app.application.run (ARGV);
Code sample with Switch
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

// We start out with 0 cookies
var cookies = 0;

const GettingTheSignal = new Lang.Class({
 Name: 'Getting the Signal',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 200,
 default_width: 400,
 title: "Click the button to get a cookie!"});

 // Create the label
 this._cookieLabel = new Gtk.Label ({
 label: "Number of cookies: " + cookies });

 // Create the cookie button
 this._cookieButton = new Gtk.Button ({
 label: "Get a cookie" });

 // Connect the cookie button to the function that handles clicking it
 this._cookieButton.connect ('clicked', Lang.bind (this, this._getACookie));

 // Create the switch that controls whether or not you can win
 this._cookieSwitch = new Gtk.Switch ();

 // Create the label to go with the switch
 this._switchLabel = new Gtk.Label ({
 label: "Cookie dispenser" });

 // Create a grid for the switch and its label
 this._switchGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Put the switch and its label inside that grid
 this._switchGrid.attach (this._switchLabel, 0, 0, 1, 1);
 this._switchGrid.attach (this._cookieSwitch, 1, 0, 1, 1);

 // Create a grid to arrange everything else inside
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 row_spacing: 20 });

 // Put everything inside the grid
 this._grid.attach (this._cookieButton, 0, 0, 1, 1);
 this._grid.attach (this._switchGrid, 0, 1, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 2, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();

 },



 _getACookie: function() {

 // Is the cookie dispenser turned on?
 if (this._cookieSwitch.get_active()) {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

 }

});

// Run the application
let app = new GettingTheSignal ();
app.application.run (ARGV);
Code sample with RadioButton
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

// We start out with 0 cookies
var cookies = 0;

const GettingTheSignal = new Lang.Class({
 Name: 'Getting the Signal',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 200,
 default_width: 400,
 border_width: 20,
 title: "Choose the one that says 'cookie'!"});

 // Create the radio buttons
 this._cookieRadio = new Gtk.RadioButton ({ label: "Cookie" });
 this._notCookieOne = new Gtk.RadioButton ({ label: "Not cookie",
 group: this._cookieRadio });
 this._notCookieTwo = new Gtk.RadioButton ({ label: "Not cookie",
 group: this._cookieRadio });

 // Arrange the radio buttons in their own grid
 this._radioGrid = new Gtk.Grid ();
 this._radioGrid.attach (this._notCookieOne, 0, 0, 1, 1);
 this._radioGrid.attach (this._cookieRadio, 0, 1, 1, 1);
 this._radioGrid.attach (this._notCookieTwo, 0, 2, 1, 1);

 // Set the button that will be at the top to be active by default
 this._notCookieOne.set_active (true);

 // Create the cookie button
 this._cookieButton = new Gtk.Button ({
 label: "Get a cookie" });

 // Connect the cookie button to the function that handles clicking it
 this._cookieButton.connect ('clicked', Lang.bind (this, this._getACookie));

 // Create the label
 this._cookieLabel = new Gtk.Label ({
 label: "Number of cookies: " + cookies });

 // Create a grid to arrange everything inside
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 row_spacing: 20 });

 // Put everything inside the grid
 this._grid.attach (this._radioGrid, 0, 0, 1, 1);
 this._grid.attach (this._cookieButton, 0, 1, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 2, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();

 },



 _getACookie: function() {

 // Did you select "cookie" instead of "not cookie"?
 if (this._cookieRadio.get_active()) {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

 }

});

// Run the application
let app = new GettingTheSignal ();
app.application.run (ARGV);
Code sample with Entry
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

// We start out with 0 cookies
var cookies = 0;

const GettingTheSignal = new Lang.Class({
 Name: 'Getting the Signal',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 200,
 default_width: 400,
 border_width: 20,
 title: "Spell 'cookie' to get a cookie!"});

 // Create the text entry field
 this._spellCookie = new Gtk.Entry ();

 // Create the cookie button
 this._cookieButton = new Gtk.Button ({
 label: "Get a cookie" });

 // Connect the cookie button to the function that handles clicking it
 this._cookieButton.connect ('clicked', Lang.bind (this, this._getACookie));

 // Create the label
 this._cookieLabel = new Gtk.Label ({
 label: "Number of cookies: " + cookies });

 // Create a grid to arrange everything inside
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 row_spacing: 20 });

 // Put everything inside the grid
 this._grid.attach (this._spellCookie, 0, 0, 1, 1);
 this._grid.attach (this._cookieButton, 0, 1, 1, 1);
 this._grid.attach (this._cookieLabel, 0, 2, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();

 },



 _getACookie: function() {

 // Did you spell "cookie" correctly?
 if ((this._spellCookie.get_text()).toLowerCase() == "cookie") {

 // Increase the number of cookies by 1 and update the label
 cookies++;
 this._cookieLabel.set_label ("Number of cookies: " + cookies);

 }

 }

});

// Run the application
let app = new GettingTheSignal ();
app.application.run (ARGV);
external ref='media/aboutdialog_GMenu.png' md5='a36117a559fa98e25e2f6b3db593639f'
AboutDialog (C)
Monica Kochofar
Display information about an application
AboutDialog
An AboutDialog example using Gtk.ApplicationWindow and Menu

#include &lt;gtk/gtk.hgt;



/* Callback function in which reacts to the "response" signal from the user in
 * the message dialog window.
 * This function is used to destroy the dialog window.
 */
static void
on_close (GtkDialog *dialog,
 gint response_id,
 gpointer user_data)
{
 /*This will cause the dialog to be destroyed*/
 gtk_widget_destroy (GTK_WIDGET (dialog));

}



/* Callback function for the response signal "activate" related to the SimpleAction
 * "about_action".
 * This function is used to cause the about dialog window to popup.
 */
static void
about_cb (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GtkWidget *about_dialog;

 about_dialog = gtk_about_dialog_new ();

 /* Lists of authors/ documentators to be used later, they must be initialized
 * in a null terminated array of strings.
 */
 const gchar *authors[] = {"GNOME Documentation Team", NULL};
 const gchar *documenters[] = {"GNOME Documentation Team", NULL};

 /* We fill in the information for the about dialog */
 gtk_about_dialog_set_program_name (GTK_ABOUT_DIALOG (about_dialog), "AboutDialog Example");
 gtk_about_dialog_set_copyright (GTK_ABOUT_DIALOG (about_dialog), "Copyright \\xc2\\xa9 2012 GNOME Documentation Team");
 gtk_about_dialog_set_authors (GTK_ABOUT_DIALOG (about_dialog), authors);
 gtk_about_dialog_set_documenters (GTK_ABOUT_DIALOG (about_dialog), documenters);
 gtk_about_dialog_set_website_label (GTK_ABOUT_DIALOG (about_dialog), "GNOME Developer Website");
 gtk_about_dialog_set_website (GTK_ABOUT_DIALOG (about_dialog), "http://developer.gnome.org");

 /* We do not wish to show the title, which in this case would be 
 * "AboutDialog Example". We have to reset the title of the messagedialog 
 * window after setting the program name.
 */
 gtk_window_set_title (GTK_WINDOW (about_dialog), "");

 /* To close the aboutdialog when "close" is clicked we connect the response 
 * signal to on_close
 */
 g_signal_connect (GTK_DIALOG (about_dialog), "response", 
 G_CALLBACK (on_close), NULL);

 /* Show the about dialog */
 gtk_widget_show (about_dialog); 
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;

 GSimpleAction *about_action;

 /* Create a window with a title and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "AboutDialog Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);

 /* Create a new simple action, giving it a NULL parameter type. It will 
 * always be NULL for actions invoked from a menu. (e.g clicking on an "ok" 
 * or "cancel" button)
 */
 about_action = g_simple_action_new ("about", NULL); 

 /* Connect the "activate" signal to the appropriate callback function. 
 * It will indicate that the action was just activated.
 */
 g_signal_connect (about_action, "activate", G_CALLBACK (about_cb), 
 GTK_WINDOW (window));

 /* Adds the about_action to the overall action map. An Action map is an 
 * interface that contains a number of named GAction instances 
 * (such as about_action) 
 */
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (about_action));

 gtk_widget_show_all (window);
}



/* Callback function for the response signal "activate" from the "quit" action 
 * found in the function directly below.
 */ 
static void
quit_cb (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GApplication *application = user_data;

 g_application_quit (application);
}



/* Startup function for the menu we are creating in this sample */
static void
startup (GApplication *app,
 gpointer user_data)
{
 GMenu *menu;
 GSimpleAction *quit_action;

 /* Initialize the GMenu, and add a menu item with label "About" and action 
 * "win.about". Also add another menu item with label "Quit" and action 
 * "app.quit" 
 */
 menu = g_menu_new ();
 g_menu_append (menu, "About", "win.about");
 g_menu_append (menu, "Quit", "app.quit");

 /* Create a new simple action for the application. (In this case it is the 
 * "quit" action.
 */
 quit_action = g_simple_action_new ("quit", NULL);

 /* Ensure that the menu we have just created is set for the overall application */
 gtk_application_set_app_menu (GTK_APPLICATION (app), G_MENU_MODEL (menu));

 g_signal_connect (quit_action, 
 "activate", 
 G_CALLBACK (quit_cb), 
 app);

 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (quit_action));

}



/* Startup function for the application */
int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 g_signal_connect (app, "startup", G_CALLBACK (startup), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}
In this sample we used the following:





AboutDialog (JavaScript)
A modal dialog window which shows information about an application and its creators. This one is triggered by clicking "About" in the application's menu, which is normally a good place to put it.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const AboutDialogExample = new Lang.Class({
 Name: 'AboutDialog Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsaboutdialog',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal creates the menu and builds the UI
 _onStartup: function() {
 this._initMenus();
 this._buildUI();
 },

 // Build the application's UI
 _buildUI: function(){
 // Create the application window
 this._window = new Gtk.ApplicationWindow({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "AboutDialog Example",
 default_height: 250,
 default_width: 350 });

 // Show the window and all child widgets
 this._window.show_all();
 },

 // Create the application menu
 _initMenus: function() {
 let menu = new Gio.Menu();
 menu.append("About", 'app.about');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 // Create the "About" menu option and have it call the _showAbout() function
 let aboutAction = new Gio.SimpleAction({ name: 'about' });
 aboutAction.connect('activate', Lang.bind(this,
 function() {
 this._showAbout();
 }));
 this.application.add_action(aboutAction);

 // Create the "Quit" menu option and have it close the window
 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },

 _showAbout: function() {

 // String arrays of the names of the people involved in the project
 var authors = ["GNOME Documentation Team"];
 var documenters = ["GNOME Documentation Team"];

 // Create the About dialog
 let aboutDialog = new Gtk.AboutDialog({ title: "AboutDialog Example",
 program_name: "GtkApplication Example",
 copyright: "Copyright \\xa9 2012 GNOME Documentation Team",
 authors: authors,
 documenters: documenters,
 website: "http://developer.gnome.org",
 website_label: "GNOME Developer Website" });

 // Attach the About dialog to the window
 aboutDialog.modal = true;
 aboutDialog.transient_for = this._window;

 // Show the About dialog
 aboutDialog.show();

 // Connect the Close button to the destroy signal for the dialog
 aboutDialog.connect('response', function() {
 aboutDialog.destroy();
 });
 }
});

// Run the application
let app = new AboutDialogExample();
app.application.run(ARGV);





AboutDialog (Python)
Marta Maria Casetti
A window that displays information about an application
An AboutDialog example using Gtk.ApplicationWindow and Menu (the "about" is displayed if "About" in the menu is selected).
Code used to generate this example
from gi.repository import Gtk
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 # constructor for a window (the parent window)
 def __init__(self, app):
 Gtk.Window.__init__(self, title="AboutDialog Example", application=app)
 self.set_default_size(200, 200)

 # create the about_action (a Gio.SimpleAction)
 about_action = Gio.SimpleAction.new("about", None)
 # connect the signal from the action to the function about_cb()
 about_action.connect("activate", self.about_cb)
 # add the action to the application
 app.add_action(about_action)

 # callback function for the about_action's "activate" signal
 def about_cb(self, action, parameter):
 # a Gtk.AboutDialog
 aboutdialog = Gtk.AboutDialog()

 # lists of authors and documenters (will be used later)
 authors = ["GNOME Documentation Team"]
 documenters = ["GNOME Documentation Team"]

 # we fill in the aboutdialog
 aboutdialog.set_program_name("AboutDialog Example")
 aboutdialog.set_copyright(
 "Copyright \\xc2\\xa9 2012 GNOME Documentation Team")
 aboutdialog.set_authors(authors)
 aboutdialog.set_documenters(documenters)
 aboutdialog.set_website("http://developer.gnome.org")
 aboutdialog.set_website_label("GNOME Developer Website")

 # we do not want to show the title, which by default would be "About AboutDialog Example"
 # we have to reset the title of the messagedialog window after setting
 # the program name
 aboutdialog.set_title("")

 # to close the aboutdialog when "close" is clicked we connect the
 # "response" signal to on_close
 aboutdialog.connect("response", self.on_close)
 # show the aboutdialog
 aboutdialog.show()

 # destroy the aboutdialog
 def on_close(self, action, parameter):
 action.destroy()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def quit_cb(self, action, parameter):
 self.quit()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 # create a menu (a Gio.Menu)
 menu = Gio.Menu()
 # append a menu item with label "About" and action "app.about"
 menu.append("About", "app.about")
 # append a menu item with label "Quit" and action "app.quit"
 menu.append("Quit", "app.quit")
 # set menu as the menu for the application
 self.set_app_menu(menu)

 # a new simpleaction - for the application
 quit_action = Gio.SimpleAction.new("quit", None)
 quit_action.connect("activate", self.quit_cb)
 self.add_action(quit_action)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for an AboutDialog widget
In line 15 the signal
API References



AboutDialog (Vala)
Ryan Lortie
Tiffany Antopolski
/* A window in the application */
public class Window : Gtk.ApplicationWindow {

 /* The constructor */
 public Window (Application app) {
 Object (application: app, title: "AboutDialog Example");

 var about_action = new SimpleAction ("about", null);

 about_action.activate.connect (this.about_cb);
 this.add_action (about_action);
 this.show_all ();
 }

 /* This is the callback function connected to the 'activate' signal
 * of the SimpleAction about_action.
 */
 void about_cb (SimpleAction simple, Variant? parameter) {
 string[] authors = { "GNOME Documentation Team", null };
 string[] documenters = { "GNOME Documentation Team", null };

 Gtk.show_about_dialog (this,
 "program-name", ("GtkApplication Example"),
 "copyright", ("Copyright \\xc2\\xa9 2012 GNOME Documentation Team"),
 "authors", authors,
 "documenters", documenters,
 "website", "http://developer.gnome.org",
 "website-label", ("GNOME Developer Website"),
 null);
 }
}

/* This is the Application */
public class Application : Gtk.Application {

 /* Here we override the activate signal of GLib.Application */
 protected override void activate () {
 new Window (this);
 }

 /* Here we override the startup signal of GLib.Application */
 protected override void startup () {

 base.startup ();

 var menu = new Menu ();
 menu.append ("About", "win.about");
 menu.append ("Quit", "app.quit");
 this.app_menu = menu;

 var quit_action = new SimpleAction ("quit", null);
 //quit_action.activate.connect (this.quit);
 this.add_action (quit_action);
 }

 /* The constructor */
 public Application () {
 Object (application_id: "org.example.application");
 }
}

/* main function creates Application and runs it */
int main (string[] args) {
 return new Application ().run (args);
}



Coming soon...
GNOME Documentation Project
Audio player
Tutorial for beginners (C)
A beginner's guide to GUI programming using GTK+, including code samples and practice exercises.
2013
Tutorial for beginners and code samples
Although these tutorials are designed for beginners, we can't cover all the basics. Before attempting to follow these tutorials, you are expected to be familiar with the following concepts:
Object oriented programming
The C programming language
By following these tutorials you will learn the basics of GUI programming using GTK+.
Tutorials
Code samples
To run the code samples:
Copy and paste the code into
In the terminal type:
gcc
./
For more information about compiling GTK+ programs see
You can also use the Vala compiler to compile these samples:
valac --pkg gtk+-3.0
To run:
Windows
Display widgets
Buttons and toggles
Numeric and text data entry
Multiline text editor
Menu, combo box and toolbar widgets
TreeView widget
Selectors
File selectors
Font selectors
Color Selectors
Layout containers
Ornaments
Scrolling
Miscellaneous
Exercises
Susanna Huhtanen
A beginner's guide to writing GNOME applications in JavaScript, including code samples and practice exercises.
JavaScript is one of the most popular programming languages on the web. It's not just for the web, though. If you have even a basic understanding of JavaScript, you can write full-fledged applications for GNOME.
GNOME Shell is what you see when you click on "Activities" in the top-left corner of your screen. It also controls the clock and the rest of the top panel. Besides showing how you to write GNOME applications, these tutorials will also show you how to use JavaScript to write GNOME Shell extensions, which give it new features or change the way it does things.
Getting Started
These tutorials are designed for people who already know how to write in JavaScript, and who have GNOME installed on their computers already, but who are new to developing GNOME applications. If you don't already know JavaScript, or if you need help getting GNOME set up, take a look at these resources first:



These samples show how to use widgets in your GNOME applications. Each one demonstrates a complete application which showcases the featured widget. At the end of each sample, you will find links to more detailed reference material.
Copy and paste the code into
In the terminal, type:
gjs
GTK+ widgets sample code (Python)
A guide to GUI programming using GTK+, including code samples and practice exercises.
GTK+ widgets sample code
If you are a beginner and you would like a tutorial to guide you step by step in an exploration of what you can do with GTK+ 3, you should go to the
Theory pages
Tutorial for beginners (Vala)
The Vala programming language:


Copy and paste the code into
valac --pkg gtk+-3.0
2011
Creative Commons Share Alike 3.0
Help make
Report a bug or suggest an improvement

This is a bug tracking system where users and developers can file details about bugs, crashes and request enhancements.
To participate you need an account which will give you the ability to gain access, file bugs, and make comments. Also, you need to register so you can receive updates by e-mail about the status of your bug. If you don't already have an account, just click on the
Once you have an account, log in, click on
To file your bug, choose the component
If you are requesting a new feature, choose
Your report will be given an ID number, and its status will be updated as it is being dealt with. Thanks for helping make
external ref='media/button.png' md5='8d69efbb3a0d3e043af6139b6492171c'
Button (C)
A button widget which emits a signal when clicked
Button
A button widget connected to a callback function that reverses its label when clicked.
#include &lt;gtk/gtk.hgt;



/*This is the callback function. It is a handler function which 
reacts to the signal. In this case, it will cause the button label's 
string to reverse.*/
static void
button_clicked (GtkButton *button,
 gpointer user_data)
{
 const char *old_label;
 char *new_label;

 old_label = gtk_button_get_label (button);
 new_label = g_utf8_strreverse (old_label, -1);

 gtk_button_set_label (button, new_label);
 g_free (new_label);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *button;

 /*Create a window with a title and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "GNOME Button");
 gtk_window_set_default_size (GTK_WINDOW (window), 250, 50);

 /*Create a button with a label, and add it to the window*/
 button = gtk_button_new_with_label ("Click Me");
 gtk_container_add (GTK_CONTAINER (window), button);

 /*Connecting the clicked signal to the callback function*/
 g_signal_connect (GTK_BUTTON (button),
 "clicked", 
 G_CALLBACK (button_clicked), 
 G_OBJECT (window));

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}


Button (JavaScript)
A button which can be connected to other widgets
A button widget that changes its label when you click it.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ButtonExample = new Lang.Class ({
 Name: 'Button Example',

 /* Create the application itself
 This boilerplate code is needed to build any GTK+ application. */
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jsbutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal initializes menus and builds the UI
 _onStartup: function () {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "GNOME Button",
 default_height: 50,
 default_width: 250 });

 // Create the button
 this.Button = new Gtk.Button ({label: "Click Me"});
 this._window.add (this.Button);

 // Bind it to a function that says what to do when the button is clicked
 this.Button.connect ("clicked", Lang.bind(this, this._clickHandler));

 // Show the window and all child widgets
 this._window.show_all();
 },

 // Here's the function that says what happens when the button is clicked
 _clickHandler: function () {
 this.Button.set_label ("Clicked!");
 }
});

// Run the application
let app = new ButtonExample ();
app.application.run (ARGV);

Button (Python)
A button widget connected to a simple callback function.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="GNOME Button", application=app)
 self.set_default_size(250, 50)

 # a button
 button = Gtk.Button()
 # with a label
 button.set_label("Click me")
 # connect the signal "clicked" emitted by the button
 # to the callback function do_clicked
 button.connect("clicked", self.do_clicked)
 # add the button to the window
 self.add(button)

 # callback function connected to the signal "clicked" of the button
 def do_clicked(self, button):
 print "You clicked me!"


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Button widget
In line 16 the

If the label of the button is a
To set an image (e.g. a stock image) for the button
image = Gtk.Image()
image.set_from_stock(Gtk.STOCK_ABOUT, Gtk.IconSize.BUTTON)
button.set_image(image)
You should not set a label for the button after this, otherwise it will show the label and not the image.
If we use


Button (Vala)
Button widget
/* A window in the application */
public class MyWindow : Gtk.ApplicationWindow {

 /* The constructor of the window */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "GNOME Button");

 var button = new Gtk.Button.with_label ("Click Me");
 button.clicked.connect (this.reverse_label);
 button.show ();

 this.window_position = Gtk.WindowPosition.CENTER;
 this.set_default_size (250,50);
 this.add (button);
 }

 /* The callback function connected to the
 * 'clicked' signal of the button.
 */
 void reverse_label (Gtk.Button button) {
 button.label = button.label.reverse ();
 }
}

/* This is the application. */
public class MyApplication : Gtk.Application {

 /* This is the constructor */
 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }

 /* Override the activate signal of GLib.Application */
 protected override void activate () {
 new MyWindow (this).show ();
 }
}

/* main creates and runs the application */
public int main (string[] args) {
 return new MyApplication ().run (args);
}
In this sample we used the following:
external ref='media/buttonbox_calculator.png' md5='ce0de08b7ac66f517290e33e6d33d508'
ButtonBox (JavaScript)
Meg Ford
A container for arranging buttons
ButtonBox
A calculator - the buttons are enclosed in horizontal ButtonBoxes.
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ButtonBoxExample = new Lang.Class ({
 Name: 'ButtonBox Example',

 // Create the application itthis
 _init: function () {
 this.application = new Gtk.Application({ application_id: 'org.example.jsbuttonbox' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this.window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function() {
 // Create the application window
 this.window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Calculator",
 default_width: 350,
 default_height: 200,
 border_width: 10 });
 this.entry = new Gtk.Entry();
 this.entry.set_text('0');
 // text aligned on the right
 this.entry.set_alignment(1);
 // the text in the entry cannot be modified by writing in it
 this.entry.set_can_focus(false);

 // a grid
 this.grid = new Gtk.Grid();
 this.grid.set_row_spacing(5);
 
 // to attach the entry
 this.grid.attach(this.entry, 0, 0, 1, 1);
 
 // the labels for the buttons
 this.buttons = [ 7, 8, 9, '/', 4, 5, 6, '*', 1, 2, 3, '-', 'C', 0, '=', '+' ];
 
 // each row is a ButtonBox, attached to the grid 
 for (i = 0; i &lt; 4; i++) {
 this.hbox = Gtk.ButtonBox.new(Gtk.Orientation.HORIZONTAL);
 this.hbox.set_spacing(5);
 this.grid.attach(this.hbox, 0, i + 1, 1, 1);
 // each ButtonBox has 4 buttons, connected to the callback function
 for (j= 0; j &lt; 4; j++) {
 this.button = new Gtk.Button();
 this.buttonLabel = (this.buttons[i * 4 + j].toString());
 this.button.set_label(this.buttonLabel);
 this.button.set_can_focus(false);
 this.button.connect("clicked", Lang.bind(this, this._buttonClicked, this.button));
 this.hbox.add(this.button);
 }
 }
 
 // some variables for the calculations
 this.firstNumber = 0;
 this.secondNumber = 0;
 this.counter = 0;
 this.operation = "";

 // add the grid to the window
 this.window.add(this.grid);
 this.window.show_all();
 },

 // callback function for all the buttons
 _buttonClicked: function(button) {
 this.button = button;
 // for the operations
 if (this.button.get_label() == '+') {
 this.counter += 1 
 if (this.counter &gt; 1)
 this._doOperation();
 this.entry.set_text('0');
 this.operation = "plus";
 }

 else if (this.button.get_label() == '-') {
 this.counter += 1;
 if (this.counter &gt; 1)
 this._doOperation();
 this.entry.set_text('0');
 this.operation = "minus";
 }

 else if (this.button.get_label() == '*') {
 this.counter += 1; 
 if (this.counter &gt; 1)
 this._doOperation();
 this.entry.set_text('0');
 this.operation = "multiplication";
 }

 else if (this.button.get_label() == '/') {
 this.counter += 1 
 if (this.counter &gt; 1)
 this._doOperation();
 this.entry.set_text('0');
 this.operation = "division";
 }

 // for =
 else if (this.button.get_label() == '=') {
 this._doOperation();
 this.entry.set_text(this.firstNumber.toString());
 this.counter = 1;
 }

 // for Cancel
 else if (this.button.get_label() == 'C') {
 this.firstNumber = 0;
 this.secondNumber = 0;
 this.counter = 0;
 this.entry.set_text('0');
 this.operation = "";
 }

 // for a digit button
 else {
 this.newDigit = parseInt(this.button.get_label());
 if (this.entry.get_text() == "error")
 this.number = 0;
 else
 this.number = parseInt(this.entry.get_text());
 this.number = this.number * 10 + this.newDigit; 
 if (this.counter == 0)
 this.firstNumber = this.number;
 else
 this.secondNumber = this.number;
 this.entry.set_text(this.number.toString());
 }
 },

 _doOperation: function() {
 if (this.operation == "plus") {
 this.firstNumber += this.secondNumber;
 } else if (this.operation == "minus") {
 this.firstNumber -= this.secondNumber;
 } else if (this.operation == "multiplication") {
 this.firstNumber *= this.secondNumber;
 } else if (this.operation == "division") {
 if (this.secondNumber != 0) {
 this.firstNumber /= this.secondNumber;
 } else {
 this.firstNumber = 0; 
 this.secondNumber = 0;
 this.counter = 0; 
 this.entry.set_text("error");
 this.operation = "";

 return
 }
 } else {
 this.firstNumber = 0;
 this.secondNumber = 0;
 this.counter = 0;
 this.entry.set_text("error");
 }
 }
});

// Run the application
let app = new ButtonBoxExample();
app.application.run (ARGV);





ButtonBox (Python)
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Calculator", application=app)
 self.set_default_size(350, 200)
 self.set_border_width(10)

 # an entry
 self.entry = Gtk.Entry()
 # with an initial text
 self.entry.set_text('0')
 # text aligned on the right
 self.entry.set_alignment(1)
 # the text in the entry cannot be modified writing in it
 self.entry.set_can_focus(False)

 # a grid
 grid = Gtk.Grid()
 grid.set_row_spacing(5)

 # to attach the entry
 grid.attach(self.entry, 0, 0, 1, 1)

 # the labels for the buttons
 buttons = [7, 8, 9, '/',
 4, 5, 6, '*',
 1, 2, 3, '-',
 'C', 0, '=', '+']

 # each row is a ButtonBox, attached to the grid
 for i in range(4):
 hbox = Gtk.ButtonBox.new(Gtk.Orientation.HORIZONTAL)
 hbox.set_spacing(5)
 grid.attach(hbox, 0, i + 1, 1, 1)
 # each ButtonBox has 4 buttons, connected to the callback function
 for j in range(4):
 button = Gtk.Button(label=buttons[i * 4 + j])
 button.set_can_focus(False)
 button.connect("clicked", self.button_clicked)
 hbox.add(button)

 # some variables for the calculations
 self.first_number = 0
 self.second_number = 0
 self.counter = 0
 self.operation = ""

 # add the grid to the window
 self.add(grid)

 # callback function for all the buttons
 def button_clicked(self, button):
 # for the operations
 if button.get_label() == '+':
 self.counter += 1
 if self.counter &gt; 1:
 self.do_operation()
 self.entry.set_text('0')
 self.operation = "plus"
 elif button.get_label() == '-':
 self.counter += 1
 if self.counter &gt; 1:
 self.do_operation()
 self.entry.set_text('0')
 self.operation = "minus"
 elif button.get_label() == '*':
 self.counter += 1
 if self.counter &gt; 1:
 self.do_operation()
 self.entry.set_text('0')
 self.operation = "multiplication"
 elif button.get_label() == '/':
 self.counter += 1
 if self.counter &gt; 1:
 self.do_operation()
 self.entry.set_text('0')
 self.operation = "division"
 # for =
 elif button.get_label() == '=':
 self.do_operation()
 self.entry.set_text(str(self.first_number))
 self.counter = 1
 # for Cancel
 elif button.get_label() == 'C':
 self.first_number = 0
 self.second_number = 0
 self.counter = 0
 self.entry.set_text('')
 self.operation = ""
 # for a digit button
 else:
 new_digit = int(button.get_label())
 if self.entry.get_text() == 'error':
 number = 0
 else:
 number = int(self.entry.get_text())
 number = number * 10 + new_digit
 if self.counter == 0:
 self.first_number = number
 else:
 self.second_number = number
 self.entry.set_text(str(number))

 def do_operation(self):
 if self.operation == "plus":
 self.first_number += self.second_number
 elif self.operation == "minus":
 self.first_number -= self.second_number
 elif self.operation == "multiplication":
 self.first_number *= self.second_number
 elif self.operation == "division":
 try:
 self.first_number /= self.second_number
 except ZeroDivisionError:
 self.first_number = 0
 self.second_number = 0
 self.counter = 0
 self.entry.set_text('error')
 self.operation = ""
 return
 else:
 self.first_number = 0
 self.second_number = 0
 self.counter = 0
 self.entry.set_text('error')


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Uselful methods for a ButtonBox widget
The layout of the ButtonBox are set with







C
Tutorials, code samples and plaform demos in C
Code samples and tutorial
Examples of applications
external ref='media/checkbutton.png' md5='7921a6812c87dd2b3781f4fad241e858'
CheckButton (C)
Create widgets with a discrete ToggleButton
CheckButton
This CheckButton toggles the title.
#include &lt;gtk/gtk.hgt;

/* signal handler for "toggled" signal of the CheckButton */
static void
toggled_cb (GtkToggleButton *toggle_button,
 gpointer user_data)
{
 GtkWindow *window = user_data;

 if (gtk_toggle_button_get_active (toggle_button))
 gtk_window_set_title (window, "CheckButton Example");
 else
 gtk_window_set_title (window, "");
}

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *checkbutton;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "CheckButton Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 300, 100);

 checkbutton = gtk_check_button_new_with_label ("Show Title");
 gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (checkbutton), TRUE);
 g_signal_connect (GTK_TOGGLE_BUTTON (checkbutton), "toggled", G_CALLBACK (toggled_cb), window);
 gtk_container_add (GTK_CONTAINER (window), checkbutton);
 gtk_widget_show_all (window);
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.example.checkbutton", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

CheckButton (JavaScript)
A box which can be checked or unchecked
This application has a CheckButton. Whether the box is checked dictates whether the window's title bar shows anything.
A CheckButton sends the "toggled" signal when it's checked or unchecked. While it's checked, the "active" property is true. While it's not, "active" tests as false.
Libraries to import
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
These are the libraries we need to import for this application to run. Remember that the line which tells GNOME that we're using Gjs always needs to go at the start.
Creating the application window
const CheckButtonExample = new Lang.Class({
 Name: 'CheckButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jscheckbutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
All the code for this sample goes in the CheckButtonExample class. The above code creates a
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 100,
 default_width: 300,
 border_width: 10,
 title: "CheckButton Example"});
The _buildUI function is where we put all the code to create the application's user interface. The first step is creating a new
Creating the checkbutton
// Create the check button
 this._button = new Gtk.CheckButton ({label: "Show Title"});
 this._window.add (this._button);

 // Have the check button be checked by default
 this._button.set_active (true);

 // Connect the button to a function that does something when it's toggled
 this._button.connect ("toggled", Lang.bind (this, this._toggledCB));
This code creates the checkbutton itself. The label next to the checkbutton is created by giving the checkbutton the "label" property and assigning a string value to it. Since this checkbutton toggles whether the window title is on or off, and the window title will be on to start with, we want the box to be checked by default. Whenever the user checks or unchecks the box, we call the _toggledCB function.
// Show the window and all child widgets
 this._window.show_all();
 },
This code finishes up creating the UI, by telling the window to show itself and all child widgets (which is just the checkbutton in this case).
Function which handles the checkbutton's toggling
_toggledCB: function () {

 // Make the window title appear or disappear when the checkbox is toggled
 if (this._button.get_active() == true)
 this._window.set_title ("CheckButton Example");
 else
 this._window.set_title ("");

 }

});
If the checkbutton is toggled from on to off, we want the window title to disappear. If it's toggled from off to on, we want it to reappear. We can tell which way it was toggled by testing to see whether it's active (checked) or not afterwards. A simple if / else statement which calls the checkbutton's get_active() method will work for this.
// Run the application
let app = new CheckButtonExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished CheckButtonExample class, and set the application running.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const CheckButtonExample = new Lang.Class({
 Name: 'CheckButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jscheckbutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 100,
 default_width: 300,
 border_width: 10,
 title: "CheckButton Example"});

 // Create the check button
 this._button = new Gtk.CheckButton ({label: "Show Title"});
 this._window.add (this._button);

 // Have the check button be checked by default
 this._button.set_active (true);

 // Connect the button to a function that does something when it's toggled
 this._button.connect ("toggled", Lang.bind (this, this._toggledCB));

 // Show the window and all child widgets
 this._window.show_all();
 },



 _toggledCB: function () {

 // Make the window title appear or disappear when the checkbox is toggled
 if (this._button.get_active() == true)
 this._window.set_title ("CheckButton Example");
 else
 this._window.set_title ("");

 }

});

// Run the application
let app = new CheckButtonExample ();
app.application.run (ARGV);
In-depth documentation

CheckButton (Python)
A toggle button in a window
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="CheckButton Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a new checkbutton
 button = Gtk.CheckButton()
 # with a label
 button.set_label("Show Title")
 # connect the signal "toggled" emitted by the checkbutton
 # with the callback function toggled_cb
 button.connect("toggled", self.toggled_cb)
 # by default, the checkbutton is active
 button.set_active(True)

 # add the checkbutton to the window
 self.add(button)

 # callback function
 def toggled_cb(self, button):
 # if the togglebutton is active, set the title of the window
 # as "Checkbutton Example"
 if button.get_active():
 self.set_title("CheckButton Example")
 # else, set it as "" (empty string)
 else:
 self.set_title("")


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a CheckButton widget
In line 17 the


CheckButton (Vala)
Create widgets with a disrete toggle button
/* A window in the application */
class MyWindow : Gtk.ApplicationWindow {

 /* The constructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "CheckButton Example");

 this.set_default_size (300, 100);
 this.border_width = 10;

 var checkbutton = new Gtk.CheckButton.with_label ("Show Title");

 /* Connect the checkbutton to the
 * callback function (aka. signal handler).
 */
 checkbutton.toggled.connect (this.toggled_cb);

 /* Add the button to the this window */
 this.add (checkbutton);

 checkbutton.set_active (true);
 checkbutton.show ();
 }

 /* The signal handler for the 'toggled' signal of the checkbutton. */
 void toggled_cb (Gtk.ToggleButton checkbutton) {
 if (checkbutton.get_active())
 this.set_title ("CheckButton Example");
 else
 this.set_title ("");
 }
}

/* This is the application */
class MyApplication : Gtk.Application {

 /* The constructor */
 internal MyApplication () {
 Object (application_id: "org.example.checkbutton");
 }

 /* Override the activate signal of GLib.Application */
 protected override void activate () {
 new MyWindow (this).show ();
 }

}

/* main creates and runs the application */
int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/colorbutton.png' md5='904539d26fe367bf99f9a0961cfc9a03'
ColorButton (JavaScript)
A button to launch a color selection dialog
ColorButton
This ColorButton launches a color selection dialog and prints in the terminal the RGB values of the color selected.
#!/usr/bin/gjs

const Gdk = imports.gi.Gdk;
const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ColorbuttonExample = new Lang.Class ({
 Name: 'Colorbutton Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({ application_id: 'org.example.jscolorbutton' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this.window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this.window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "ColorButton",
 default_width: 150,
 default_height: 50,
 border_width: 10 });

 this.button = new Gtk.ColorButton();
 this.color = new Gdk.RGBA();
 this.color.red = 0.0;
 this.color.green = 0.0;
 this.color.blue = 1.0;
 this.color.alpha = 0.5;
 this.button.set_rgba(this.color);
 this.button.connect("color-set", Lang.bind(this, this.onColorChosen));
 this.label = new Gtk.Label();
 this.label.set_text("Click to choose a color");

 let grid = new Gtk.Grid();
 grid.attach(this.button, 0, 0, 2, 1);
 grid.attach(this.label, 0, 1, 2, 1);
 this.window.add(grid);
 this.window.show_all();
 },

 onColorChosen: function() {
 let colorName = this.color.to_string();
 this.label.set_text("You chose the color " + colorName);
 }
});

// Run the application
let app = new ColorbuttonExample ();
app.application.run (ARGV);


ColorButton (Python)
from gi.repository import Gtk
from gi.repository import Gdk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="ColorButton", application=app)
 self.set_default_size(150, 50)
 self.set_border_width(10)

 # a colorbutton (which opens a dialogue window in
 # which we choose a color)
 self.button = Gtk.ColorButton()
 # with a default color (blue, in this instance)
 color = Gdk.RGBA()
 color.red = 0.0
 color.green = 0.0
 color.blue = 1.0
 color.alpha = 0.5
 self.button.set_rgba(color)

 # choosing a color in the dialogue window emits a signal
 self.button.connect("color-set", self.on_color_chosen)

 # a label
 label = Gtk.Label()
 label.set_text("Click to choose a color")

 # a grid to attach button and label
 grid = Gtk.Grid()
 grid.attach(self.button, 0, 0, 2, 1)
 grid.attach(label, 0, 1, 2, 1)
 self.add(grid)

 # if a new color is chosen, we print it as rgb(r,g,b) in the terminal
 def on_color_chosen(self, user_data):
 print "You chose the color: " + self.button.get_rgba().to_string()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a ColorButton widget

In line 23 the


ColorButton (Vala)
RGB values of the selected color are shown in the label.
/* This is the application. */
public class MyApplication : Gtk.Application {
 Gtk.Label label;

 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {
 /* Create the window of this application and show it. */
 var window = new Gtk.ApplicationWindow (this);
 window.title = "ColorButton";
 window.set_default_size (150, 50);
 window.set_border_width (10);

 /* Create a new ColorButton with default blue. */
 var blue = Gdk.RGBA ();
 blue.parse ("blue");
 var colorbutton = new Gtk.ColorButton.with_rgba (blue);

 label = new Gtk.Label ("Click to choose a color");

 var grid = new Gtk.Grid ();
 grid.attach (colorbutton, 0, 0, 1, 1);
 grid.attach_next_to (label, colorbutton, Gtk.PositionType.BOTTOM, 1, 1);

 colorbutton.color_set.connect (this.on_color_set);

 window.add (grid);
 window.show_all ();
 }

 void on_color_set (Gtk.ColorButton button) {
 var color = button.get_rgba ();
 label.set_text ("RGBA: " + color.to_string());
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}


external ref='media/combobox.png' md5='ab9e91bc1a58fe866cb00dd52159251d'
ComboBoxText (JavaScript)
A text-only drop-down menu
ComboBoxText
A ComboBox is a drop-down menu. The difference between a
Unless you need the added features of a full ComboBox, or are comfortable working with ListStores and TreeStores, you may find it a lot simpler to use a ComboBoxText whenever possible.
const ComboBoxTextExample = new Lang.Class ({
 Name: 'ComboBoxText Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jscomboboxtext'});

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },
All the code for this sample goes in the MessageDialogExample class. The above code creates a
// Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Welcome to GNOME",
 default_width: 200,
 border_width: 10 });
The _buildUI function is where we put all the code to create the application's user interface. The first step is creating a new
Creating the ComboBoxText
// Create the combobox
 this._comboBoxText = new Gtk.ComboBoxText();

 // Populate the combobox
 let distros = ["Select distribution", "Fedora", "Mint", "Suse"];
 for (let i = 0; i &lt; distros.length; i++)
 this._comboBoxText.append_text (distros[i]);
 this._comboBoxText.set_active (0);

 // Connect the combobox's 'changed' signal to our callback function
 this._comboBoxText.connect ('changed', Lang.bind (this, this._onComboChanged));
After we create the ComboBoxText, we use its
After we populate the ComboBoxText, we set its first entry to be active, so that we'll see the "Select distribution" line before we click on it. Then we connect its
If you'd like to add an entry to a ComboBoxText, you can use the
// Add the combobox to the window
 this._window.add (this._comboBoxText);

 // Show the window and all child widgets
 this._window.show_all();
 },
Finally, we add the ComboBoxText to the window, and tell the window to show itself and the widget inside it.
Function which handles your selection
_onComboChanged: function () {

 // The responses we'll use for our messagedialog
 let responses = ["",
 "Fedora is a community distro sponsored by Red Hat.",
 "Mint is a popular distro based on Ubuntu.",
 "SUSE is a name shared by two separate distros."];
We're going to create a pop-up
// Which combobox item is active?
 let activeItem = this._comboBoxText.get_active();

 // No messagedialog if you chose "Select distribution"
 if (activeItem != 0) {
 this._popUp = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 buttons: Gtk.ButtonsType.OK,
 message_type: Gtk.MessageType.INFO,
 text: responses[activeItem]});

 // Connect the OK button to a handler function
 this._popUp.connect ('response', Lang.bind (this, this._onDialogResponse));

 // Show the messagedialog
 this._popUp.show();
 }

 },
Before showing a MessageDialog, we first test to make sure you didn't choose the "Select distribution" message. After that, we set its text to be the entry in the array that corresponds to the active entry in our ComboBoxText. We do that using the
Other methods you can use include
After we create the MessageDialog, we connect its response signal to the _onDialogResponse function, then tell it to show itself.
_onDialogResponse: function () {

 this._popUp.destroy ();

 }

});
Since the only button the MessageDialog has is an OK button, we don't need to test its response_id to see which button was clicked. All we do here is destroy the popup.
// Run the application
let app = new ComboBoxTextExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished ComboBoxTextExample class, and set the application running.
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ComboBoxTextExample = new Lang.Class ({
 Name: 'ComboBoxText Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jscomboboxtext'});

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Welcome to GNOME",
 default_width: 200,
 border_width: 10 });

 // Create the combobox
 this._comboBoxText = new Gtk.ComboBoxText();

 // Populate the combobox
 let distros = ["Select distribution", "Fedora", "Mint", "Suse"];
 for (let i = 0; i &lt; distros.length; i++)
 this._comboBoxText.append_text (distros[i]);
 this._comboBoxText.set_active (0);

 // Connect the combobox's 'changed' signal to our callback function
 this._comboBoxText.connect ('changed', Lang.bind (this, this._onComboChanged));

 // Add the combobox to the window
 this._window.add (this._comboBoxText);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onComboChanged: function () {

 // The responses we'll use for our messagedialog
 let responses = ["",
 "Fedora is a community distro sponsored by Red Hat.",
 "Mint is a popular distro based on Ubuntu.",
 "SUSE is a name shared by two separate distros."];

 // Which combobox item is active?
 let activeItem = this._comboBoxText.get_active();

 // No messagedialog if you chose "Select distribution"
 if (activeItem != 0) {
 this._popUp = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 buttons: Gtk.ButtonsType.OK,
 message_type: Gtk.MessageType.INFO,
 text: responses[activeItem]});

 // Connect the OK button to a handler function
 this._popUp.connect ('response', Lang.bind (this, this._onDialogResponse));

 // Show the messagedialog
 this._popUp.show();
 }

 },



 _onDialogResponse: function () {

 this._popUp.destroy ();

 }

});

// Run the application
let app = new ComboBoxTextExample ();
app.application.run (ARGV);


ComboBox (C)
A widget used to choose from a list of items
ComboBox
This ComboBox prints to the terminal when you change your selection.
#include &lt;gtk/gtk.hgt;

/* This is the callback function. It is a handler function which reacts to the
 * signal. In this case, if the row selected is not the first one of the
 * ComboBox, we write its value in the terminal for the user.
 */
static void
on_changed (GtkComboBox *widget,
 gpointer user_data)
{
 GtkComboBox *combo_box = widget;

 if (gtk_combo_box_get_active (combo_box) != 0) {
 gchar *distro = gtk_combo_box_text_get_active_text (GTK_COMBO_BOX_TEXT(combo_box));
 g_print ("You chose %s\
", distro);
 g_free (distro);
 }

}


static void
activate (GtkApplication *app,
 gpointer user_data)
{
 gint i;
 GtkWidget *view;
 GtkWidget *window;
 GtkWidget *combo_box;

 /* Create a window with a title, border width, and a default size. Setting the
 * size to -1 means to use the "natural" default size.
 * (the size request of the window)
 */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Welcome to GNOME");
 gtk_window_set_default_size (GTK_WINDOW (window), 200, -1);
 gtk_container_set_border_width (GTK_CONTAINER (window), 10);


 /* Create the combo box and append your string values to it. */
 combo_box = gtk_combo_box_text_new ();
 const char *distros[] = {"Select distribution", "Fedora", "Mint", "Suse"};

 
 /* G_N_ELEMENTS is a macro which determines the number of elements in an array.*/ 
 for (i = 0; i &lt; G_N_ELEMENTS (distros); i++){
 gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (combo_box), distros[i]);
 }

 /* Choose to set the first row as the active one by default, from the beginning */
 gtk_combo_box_set_active (GTK_COMBO_BOX (combo_box), 0);

 /* Connect the signal emitted when a row is selected to the appropriate
 * callback function.
 */
 g_signal_connect (combo_box,
 "changed",
 G_CALLBACK (on_changed),
 NULL);

 /* Add it to the window */
 gtk_container_add (GTK_CONTAINER (window), combo_box);

 gtk_widget_show_all (window);
}


int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

external ref='media/combobox_multicolumn.png' md5='43f16648fb11ebc7d2f70825ed0f63b3'
ComboBox (JavaScript)
A customizable drop-down menu
A ComboBox is an extremely customizable drop-down menu. It holds the equivalent of a
You select a whole horizontal row at a time, so the icons aren't treated as separate options. They and the text beside them make up each option you can click on.
Working with a ListStore can be time-consuming. If you just want a simple text-only drop-down menu, take a look at the
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const ComboBoxExample = new Lang.Class ({
 Name: 'ComboBox Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jscombobox'});

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },
All the code for this sample goes in the ComboBoxExample class. The above code creates a
Creating the ListStore
// Create the liststore to put our options in
 this._listStore = new Gtk.ListStore();
 this._listStore.set_column_types ([
 GObject.TYPE_STRING,
 GObject.TYPE_STRING]);
This ListStore works like the one used in the
If we'd wanted to use our own icons that weren't already built in to GNOME, we'd have needed to use the



You need to put the line
// This array holds our list of options and their icons
 let options = [{ name: "Select" },
 { name: "New", icon: Gtk.STOCK_NEW },
 { name: "Open", icon: Gtk.STOCK_OPEN },
 { name: "Save", icon: Gtk.STOCK_SAVE }];

 // Put the options in the liststore
 for (let i = 0; i &lt; options.length; i++ ) {
 let option = options[i];
 let iter = this._listStore.append();
 this._listStore.set (iter, [0], [option.name]);
 if ('icon' in option)
 this._listStore.set (iter, [1], [option.icon]);
 }
Here we create an array of the text options and their corresponding icons, then put them into the ListStore in much the same way we would for a
"Select" isn't really an option so much as an invitation to click on our ComboBox, so it doesn't need an icon.
Creating the ComboBox
// Create the combobox
 this._comboBox = new Gtk.ComboBox({
 model: this._listStore});
Each ComboBox has an underlying "model" it takes all its options from. You can use a TreeStore if you want to have a ComboBox with branching options. In this case, we're just using the ListStore we already created.
// Create some cellrenderers for the items in each column
 let rendererPixbuf = new Gtk.CellRendererPixbuf();
 let rendererText = new Gtk.CellRendererText();

 // Pack the renderers into the combobox in the order we want to see
 this._comboBox.pack_start (rendererPixbuf, false);
 this._comboBox.pack_start (rendererText, false);

 // Set the renderers to use the information from our liststore
 this._comboBox.add_attribute (rendererText, "text", 0);
 this._comboBox.add_attribute (rendererPixbuf, "stock_id", 1);
This part, again, works much like creating CellRenderers and packing them into the columns of a
We use a CellRendererText to show the text, and a CellRendererPixbuf to show the icons. We can store the names of the icons' stock types as strings, but when we display them we need a CellRenderer that's designed for pictures.
Just like with a TreeView, the "model" (in this case a ListStore) and the "view" (in this case our ComboBox) are separate. Because of that, we can do things like have the columns in one order in the ListStore, and then pack the CellRenderers that correspond to those columns into the ComboBox in a different order. We can even create a TreeView or other widget that shows the information in the ListStore in a different way, without it affecting our ComboBox.
// Set the first row in the combobox to be active on startup
 this._comboBox.set_active (0);

 // Connect the combobox's 'changed' signal to our callback function
 this._comboBox.connect ('changed', Lang.bind (this, this._onComboChanged));
We want the "Select" text to be the part people see at first, that gets them to click on the ComboBox. So we set it to be the active entry. We also connect the ComboBox's
// Add the combobox to the window
 this._window.add (this._comboBox);

 // Show the window and all child widgets
 this._window.show_all();
 },
Finally, we add the ComboBox to the window, and tell the window to show itself and everything inside it.
_selected: function () {

 // The silly pseudohaiku that we'll use for our messagedialog
 let haiku = ["",
 "You ask for the new\
with no thought for the aged\
like fallen leaves trod.",
 "Like a simple clam\
revealing a lustrous pearl\
it opens for you.",
 "A moment in time\
a memory on the breeze\
these things can't be saved."];
We're going to create a pop-up
// Which combobox item is active?
 let activeItem = this._comboBox.get_active();

 // No messagedialog if you choose "Select"
 if (activeItem != 0) {
 this._popUp = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 buttons: Gtk.ButtonsType.OK,
 message_type: Gtk.MessageType.INFO,
 text: haiku[activeItem]});

 // Connect the OK button to a handler function
 this._popUp.connect ('response', Lang.bind (this, this._onDialogResponse));

 // Show the messagedialog
 this._popUp.show();
 }

 },
Before showing a MessageDialog, we first test to make sure you didn't choose the "Select" message. After that, we set its text to be the haiku in the array that corresponds to the active entry in our ComboBoxText. We do that using the
Other methods you can use include
// Run the application
let app = new ComboBoxExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished ComboBoxExample class, and set the application running.
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ComboBoxExample = new Lang.Class ({
 Name: 'ComboBox Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jscombobox'});

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Welcome to GNOME",
 default_width: 200,
 border_width: 10 });

 // Create the liststore to put our options in
 this._listStore = new Gtk.ListStore();
 this._listStore.set_column_types ([
 GObject.TYPE_STRING,
 GObject.TYPE_STRING]);

 // This array holds our list of options and their icons
 let options = [{ name: "Select" },
 { name: "New", icon: Gtk.STOCK_NEW },
 { name: "Open", icon: Gtk.STOCK_OPEN },
 { name: "Save", icon: Gtk.STOCK_SAVE }];

 // Put the options in the liststore
 for (let i = 0; i &lt; options.length; i++ ) {
 let option = options[i];
 let iter = this._listStore.append();
 this._listStore.set (iter, [0], [option.name]);
 if ('icon' in option)
 this._listStore.set (iter, [1], [option.icon]);
 }

 // Create the combobox
 this._comboBox = new Gtk.ComboBox({
 model: this._listStore});

 // Create some cellrenderers for the items in each column
 let rendererPixbuf = new Gtk.CellRendererPixbuf();
 let rendererText = new Gtk.CellRendererText();

 // Pack the renderers into the combobox in the order we want to see
 this._comboBox.pack_start (rendererPixbuf, false);
 this._comboBox.pack_start (rendererText, false);

 // Set the renderers to use the information from our liststore
 this._comboBox.add_attribute (rendererText, "text", 0);
 this._comboBox.add_attribute (rendererPixbuf, "stock_id", 1);

 // Set the first row in the combobox to be active on startup
 this._comboBox.set_active (0);

 // Connect the combobox's 'changed' signal to our callback function
 this._comboBox.connect ('changed', Lang.bind (this, this._onComboChanged));

 // Add the combobox to the window
 this._window.add (this._comboBox);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onComboChanged: function () {

 // The silly pseudohaiku that we'll use for our messagedialog
 let haiku = ["",
 "You ask for the new\
with no thought for the aged\
like fallen leaves trod.",
 "Like a simple clam\
revealing a lustrous pearl\
it opens for you.",
 "A moment in time\
a memory on the breeze\
these things can't be saved."];

 // Which combobox item is active?
 let activeItem = this._comboBox.get_active();

 // No messagedialog if you choose "Select"
 if (activeItem != 0) {
 this._popUp = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 buttons: Gtk.ButtonsType.OK,
 message_type: Gtk.MessageType.INFO,
 text: haiku[activeItem]});

 // Connect the OK button to a handler function
 this._popUp.connect ('response', Lang.bind (this, this._onDialogResponse));

 // Show the messagedialog
 this._popUp.show();
 }

 },



 _onDialogResponse: function () {

 this._popUp.destroy ();

 }

});

// Run the application
let app = new ComboBoxExample ();
app.application.run (ARGV);





ComboBox (Python)
ComboBox (one column)
This ComboBox prints to the terminal your selection when you change it.
from gi.repository import Gtk
import sys

distros = [["Select distribution"], ["Fedora"], ["Mint"], ["Suse"]]


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)
 self.set_default_size(200, -1)
 self.set_border_width(10)

 # the data in the model, of type string
 listmodel = Gtk.ListStore(str)
 # append the data in the model
 for i in range(len(distros)):
 listmodel.append(distros[i])

 # a combobox to see the data stored in the model
 combobox = Gtk.ComboBox(model=listmodel)

 # a cellrenderer to render the text
 cell = Gtk.CellRendererText()

 # pack the cell into the beginning of the combobox, allocating
 # no more space than needed
 combobox.pack_start(cell, False)
 # associate a property ("text") of the cellrenderer (cell) to a column (column 0)
 # in the model used by the combobox
 combobox.add_attribute(cell, "text", 0)

 # the first row is the active one by default at the beginning
 combobox.set_active(0)

 # connect the signal emitted when a row is selected to the callback
 # function
 combobox.connect("changed", self.on_changed)

 # add the combobox to the window
 self.add(combobox)

 def on_changed(self, combo):
 # if the row selected is not the first one, write its value on the
 # terminal
 if combo.get_active() != 0:
 print "You chose " + str(distros[combo.get_active()][0]) + "."
 return True


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a ComboBox widget
The ComboBox widget is designed around a
In line 35 the





ComboBox (Vala)
/* A window in the application */
class MyWindow : Gtk.ApplicationWindow {

 /* An instance array of linux distributions belonging to this window. */
 string[] distros = {"Select distribution", "Fedora", "Mint", "Suse"};

 /* This enum makes the code more readable when we refer to
 * the column as Column.DISTRO, instead of just 0.
 */
 enum Column {
 DISTRO
 }

 /* Constructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Welcome to GNOME");

 this.set_default_size (200, -1);
 this.border_width = 10;

 Gtk.ListStore liststore = new Gtk.ListStore (1, typeof (string));

 for (int i = 0; i &lt; distros.length; i++){
 Gtk.TreeIter iter;
 liststore.append (out iter);
 liststore.set (iter, Column.DISTRO, distros[i]);
 }

 Gtk.ComboBox combobox = new Gtk.ComboBox.with_model (liststore);
 Gtk.CellRendererText cell = new Gtk.CellRendererText ();
 combobox.pack_start (cell, false);

 combobox.set_attributes (cell, "text", Column.DISTRO);

 /* Set the first item in the list to be selected (active). */
 combobox.set_active (0);

 /* Connect the 'changed' signal of the combobox
 * to the signal handler (aka. callback function.
 */
 combobox.changed.connect (this.item_changed);

 /* Add the combobox to this window */
 this.add (combobox);
 combobox.show ();
 }

 /* Signal handler for the 'changed' signal of the combobox. */
 void item_changed (Gtk.ComboBox combo) {
 if (combo.get_active () !=0) {
 print ("You chose " + distros [combo.get_active ()] +"\
");
 }
 }
}

/* This is the application */
class MyApplication : Gtk.Application {

 /* Constructor */
 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }

 /* Override the activate signal of GLib.Application,
 * which is inherited by Gtk.Application.
 */
 protected override void activate () {

 /* Create the window of this application
 * and show it.
 */
 new MyWindow (this).show ();
 }
}

/* main creates and runs the application */
int main (string[] args) {
 return new MyApplication ().run (args);
}




ComboBox (two columns)
from gi.repository import Gtk
import sys

actions = [["Select", None],
 ["New", Gtk.STOCK_NEW],
 ["Open", Gtk.STOCK_OPEN],
 ["Save", Gtk.STOCK_SAVE]]


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)
 self.set_default_size(200, -1)
 self.set_border_width(10)

 # the data in the model, of type string on two columns
 listmodel = Gtk.ListStore(str, str)
 # append the data
 for i in range(len(actions)):
 listmodel.append(actions[i])

 # a combobox to see the data stored in the model
 combobox = Gtk.ComboBox(model=listmodel)

 # cellrenderers to render the data
 renderer_pixbuf = Gtk.CellRendererPixbuf()
 renderer_text = Gtk.CellRendererText()

 # we pack the cell into the beginning of the combobox, allocating
 # no more space than needed;
 # first the image, then the text;
 # note that it does not matter in which order they are in the model,
 # the visualization is decided by the order of the cellrenderers
 combobox.pack_start(renderer_pixbuf, False)
 combobox.pack_start(renderer_text, False)

 # associate a property of the cellrenderer to a column in the model
 # used by the combobox
 combobox.add_attribute(renderer_text, "text", 0)
 combobox.add_attribute(renderer_pixbuf, "stock_id", 1)

 # the first row is the active one at the beginning
 combobox.set_active(0)

 # connect the signal emitted when a row is selected to the callback
 # function
 combobox.connect("changed", self.on_changed)

 # add the combobox to the window
 self.add(combobox)

 def on_changed(self, combo):
 # if the row selected is not the first one, write on the terminal
 # the value of the first column in the model
 if combo.get_active() != 0:
 print "You chose " + str(actions[combo.get_active()][0]) + "\
"
 return True


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
In line 45 the


class MyWindow : Gtk.ApplicationWindow {

 string[] file = {"Select", "New", "Open", "Save"};
 string[] stock_item = {"","gtk-new", "gtk-open", "gtk-save"};

 enum Column {
 FILE,
 STOCK_ITEM 
 }

 /* Constructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Welcome to GNOME");

 this.set_default_size (200, -1);
 this.border_width = 10;

 Gtk.ListStore liststore = new Gtk.ListStore (2, typeof (string), typeof (string));

 for (int i = 0; i &lt; file.length; i++){
 Gtk.TreeIter iter;
 liststore.append (out iter);
 liststore.set (iter, Column.FILE, file[i]);
 liststore.set (iter, Column.STOCK_ITEM, stock_item[i]);
 }

 Gtk.ComboBox combobox = new Gtk.ComboBox.with_model (liststore);

 /* CellRenderers render the data. */
 Gtk.CellRendererText cell = new Gtk.CellRendererText ();
 Gtk.CellRendererPixbuf cell_pb = new Gtk.CellRendererPixbuf ();
 
 /* we pack the cell into the beginning of the combobox, allocating
 * no more space than needed;
 * first the image, then the text;
 * note that it does not matter in which order they are in the model,
 * the visualization is decided by the order of the cellrenderers
 */
 combobox.pack_start (cell_pb, false);
 combobox.pack_start (cell, false);

 /* associate a property of the cellrenderer to a column in the model
 * used by the combobox
 */
 combobox.set_attributes (cell_pb, "stock_id", Column.STOCK_ITEM);
 combobox.set_attributes (cell, "text", Column.FILE);

 /* Set the first item in the list to be selected (active). */
 combobox.set_active (0);

 /* Connect the 'changed' signal of the combobox
 * to the signal handler (aka. callback function.
 */
 combobox.changed.connect (this.item_changed);

 /* Add the combobox to this window */
 this.add (combobox);
 combobox.show ();
 }

 void item_changed (Gtk.ComboBox combo) {
 if (combo.get_active () !=0) {
 print ("You chose " + file [combo.get_active ()] +"\
");
 }
 }
}

class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }
}

int main (string[] args) {
 return new MyApplication ().run (args);
}




C++
Code samples and platform demos in C++
external ref='media/dialog.png' md5='c90a33386a600e892fe623d4072c8c38'
Dialog (C)
A popup window
Dialog
A dialog window that pops up when a button is pressed.
#include &lt;gtk/gtk.hgt;
 

/*Callback function in which reacts to the "response" signal. Be sure to place 
it before the function it is called in*/
static void
on_response (GtkDialog *dialog,
 gint response_id,
 gpointer user_data)
{
 /*For demonstration purposes, this will show the int value 
 of the response type*/
 g_print ("response is %d\
", response_id);
 
 /*This will cause the dialog to be destroyed*/
 gtk_widget_destroy (GTK_WIDGET (dialog));
}



/*Callback function in which reacts to the "clicked" signal*/
static void
show_dialog (GtkButton *button,
 gpointer user_data)
{
 GtkWindow *window = user_data;
 GtkWidget *dialog;
 GtkWidget *content_area;
 GtkWidget *label;

 gint response_id;

 /*Create the dialog window. Modal windows prevent interaction with other 
 windows in the same application*/
 dialog = gtk_dialog_new_with_buttons ("A Gtk+ Dialog", 
 window, 
 GTK_DIALOG_MODAL, 
 GTK_STOCK_OK, 
 GTK_RESPONSE_OK, 
 NULL);

 /*Create a label and attach it to the content area of the dialog*/
 content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
 label = gtk_label_new ("This demonstrates a dialog with a label");
 gtk_container_add (GTK_CONTAINER (content_area), label);

 /*The main purpose of this is to show dialog's child widget, label*/
 gtk_widget_show_all (dialog);
 
 /*Connecting the "response" signal from the user to the associated
 callback function*/
 g_signal_connect (GTK_DIALOG (dialog), 
 "response", 
 G_CALLBACK (on_response), 
 NULL);

}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *button;
 
 /*Create a window with a title and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "GNOME Button");
 gtk_window_set_default_size (GTK_WINDOW (window), 250, 50);

 /*Create a button with a label, and add it to the window*/
 button = gtk_button_new_with_label ("Click Me");
 gtk_container_add (GTK_CONTAINER (window), button);
 
 /*Connecting the clicked signal to the callback*/
 g_signal_connect (GTK_BUTTON (button), 
 "clicked", 
 G_CALLBACK (show_dialog), 
 GTK_WINDOW (window));
 
 gtk_widget_show_all (window);
}
 


int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;
 
 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 
 return status;
}


Dialog (JavaScript)
A customizable popup window, which has a content area and an action area. This example dialog's content area contains a short message, and its action area contains a button which dismisses the dialog.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const DialogExample = new Lang.Class ({
 Name: 'Dialog Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jsdialog',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Gtk.Dialog Example",
 default_height: 50,
 default_width: 250 });

 // Create a button
 this._button = new Gtk.Button ({label: "Click Me"});
 this._window.add (this._button);

 // Bind it to the function that creates the dialog
 this._button.connect ("clicked", Lang.bind(this, this._createDialog));

 // Show the window and all child widgets
 this._window.show_all();
 },

 _createDialog: function () {

 // Create the dialog
 this._dialog = new Gtk.Dialog ({ transient_for: this._window,
 modal: true,
 title: "A Gtk+ dialog" });

 // Create the dialog's content area, which contains a message
 this._contentArea = this._dialog.get_content_area();
 this._message = new Gtk.Label ({label: "This demonstrates a dialog with a label"});
 this._contentArea.add (this._message);

 // Create the dialog's action area, which contains a stock OK button
 this._actionArea = this._dialog.get_action_area();
 this._OKButton = new Gtk.Button.new_from_stock (Gtk.STOCK_OK);
 this._actionArea.add (this._OKButton);

 // Connect the button to the function that handles what it does
 this._OKButton.connect ("clicked", Lang.bind (this, this._OKHandler));

 this._dialog.show_all();
 },

 _OKHandler: function (dialog, response_id) {

 // Destroy the dialog
 this._dialog.destroy();
 }

});

// Run the application
let app = new DialogExample ();
app.application.run (ARGV);

Dialog (Python)
A dialog with the response signal connected to a callback function.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # construct a window (the parent window)

 def __init__(self, app):
 Gtk.Window.__init__(self, title="GNOME Button", application=app)
 self.set_default_size(250, 50)

 # a button on the parent window
 button = Gtk.Button("Click me")
 # connect the signal "clicked" of the button with the function
 # on_button_click()
 button.connect("clicked", self.on_button_click)
 # add the button to the window
 self.add(button)

 # callback function for the signal "clicked" of the button in the parent
 # window
 def on_button_click(self, widget):
 # create a Gtk.Dialog
 dialog = Gtk.Dialog()
 dialog.set_title("A Gtk+ Dialog")
 # The window defined in the constructor (self) is the parent of the dialog.
 # Furthermore, the dialog is on top of the parent window
 dialog.set_transient_for(self)
 # set modal true: no interaction with other windows of the application
 dialog.set_modal(True)
 # add a button to the dialog window
 dialog.add_button(button_text="OK", response_id=Gtk.ResponseType.OK)
 # connect the "response" signal (the button has been clicked) to the
 # function on_response()
 dialog.connect("response", self.on_response)

 # get the content area of the dialog, add a label to it
 content_area = dialog.get_content_area()
 label = Gtk.Label("This demonstrates a dialog with a label")
 content_area.add(label)
 # show the dialog
 dialog.show_all()

 def on_response(self, widget, response_id):
 print "response_id is", response_id
 # destroy the widget (the dialog) when the function on_response() is called
 # (that is, when the button of the dialog has been clicked)
 widget.destroy()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Dialog widget
In line 16 the signal
Instead of


Dialog (Vala)
A dialog with the response signal hooked up to a callback function.
/* A window in the application. */
public class MyWindow : Gtk.ApplicationWindow {

 /* Constructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "GNOME Button");

 this.window_position = Gtk.WindowPosition.CENTER;
 this.set_default_size (250,50);

 var button = new Gtk.Button.with_label ("Click Me");

 /* Connect the button's "clicked" signal to
 * the signal handler (aka. this.callback function).
 */
 button.clicked.connect (this.on_button_click);

 /* Add the button to this window and show it. */
 this.add (button);
 button.show ();
 }

 /* The signal handler for the buttons 'clicked' signal. */
 void on_button_click (Gtk.Button button) {
 var dialog = new Gtk.Dialog.with_buttons ("A Gtk+ Dialog", this,
 Gtk.DialogFlags.MODAL,
 Gtk.Stock.OK,
 Gtk.ResponseType.OK, null);

 var content_area = dialog.get_content_area ();
 var label = new Gtk.Label ("This demonstrates a dialog with a label");

 content_area.add (label);

 /* Connect the 'response' signal of the dialog
 * the signal handler. It is emitted when the dialog's
 * OK button is clicked.
 */
 dialog.response.connect (on_response);

 /* Show the dialog and all the widgets. */
 dialog.show_all ();
 }

 /* Signal handler for the 'response' signal of the dialog. */
 void on_response (Gtk.Dialog dialog, int response_id) {

 /* To see the int value of the ResponseType. This is only
 * for demonstration purposes.*/
 print ("response is %d\
", response_id);

 /* This causes the dialog to be destroyed. */
 dialog.destroy ();
 }

}

/* This is the application. */
public class MyApplication : Gtk.Application {

 /* The constructore of the application. */
 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }

 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {

 /* Create a window for the this application and show it. */
 new MyWindow (this).show ();
 }
}

/* The main function creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}




Help develop
The
If you would like to
external ref='media/entry.png' md5='8a828cffdcbaa4bad83342e109f28cc8'
Entry (C)
A single line text entry field
Entry
This application greets you in the terminal.
#include &lt;gtk/gtk.hgt;



/*This is the callback function. It is a handler function 
which reacts to the signal. In this case, it will grab the 
text input from the entry box and print out a line to the user.*/
static void
on_activate (GtkEntry *entry,
 gpointer user_data)
{
 const char *name;
 name = gtk_entry_get_text (entry);

 g_print ("\
Hello %s!\
\
", name);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *entry_box;

 /*Create a window with a title, a default size, 
 and a set border width*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "What is your name?");
 gtk_window_set_default_size (GTK_WINDOW (window), 300, 100);
 gtk_container_set_border_width (GTK_CONTAINER (window), 10);

 /*Create a new entry box, and add it to the window*/
 entry_box = gtk_entry_new ();
 gtk_container_add (GTK_CONTAINER (window), entry_box);

 /*Connecting the activate signal to the callback*/
 g_signal_connect (GTK_ENTRY (entry_box), "activate", 
 G_CALLBACK (on_activate), NULL);

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}
Entry (JavaScript)
A single-line text entry field
This application greets you by name through a pop-up window.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const EntryExample = new Lang.Class({
 Name: 'Entry Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsentry',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 100,
 default_width: 300,
 border_width: 10,
 title: "What is your name?"});

 // Create the text entry box
 this.entry = new Gtk.Entry ();
 this._window.add(this.entry);

 // Connect the text entry box to a function that responds to what you type in
 this.entry.connect("activate", Lang.bind (this, this._hello));

 // Show the window and all child widgets
 this._window.show_all();
 },



 _hello: function() {

 // Create a popup dialog to greet the person who types in their name
 this._greeter = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 text: "Hello, " + this.entry.get_text() + "!",
 message_type: Gtk.MessageType.OTHER,
 buttons: Gtk.ButtonsType.OK,
 });

 // Show the popup dialog
 this._greeter.show();

 // Bind the OK button to the function that closes the popup
 this._greeter.connect ("response", Lang.bind(this, this._okClicked));
 },

 _okClicked: function () {
 this._greeter.destroy();
 }

});

// Run the application
let app = new EntryExample ();
app.application.run (ARGV);

Entry (Python)
Sebastian Pölsterl
This application greets you in the terminal with the name you provide.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="What is your name?", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a single line entry
 name_box = Gtk.Entry()
 # emits a signal when the Enter key is pressed, connected to the
 # callback function cb_activate
 name_box.connect("activate", self.cb_activate)

 # add the Gtk.Entry to the window
 self.add(name_box)

 # the content of the entry is used to write in the terminal
 def cb_activate(self, entry):
 # retrieve the content of the widget
 name = entry.get_text()
 # print it in a nice form in the terminal
 print "Hello " + name + "!"


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for an Entry widget
In line 14 the signal




If we set

By default, if you press the Entry key the Gtk.Entry emits the signal
To set a frame around the entry:


If we have

An Entry widget can display progress or activity information behind the text. We use
An Entry widget can also show icons. These icons can be activatable by clicking, can be set up as drag source and can have tooltips. To add an icon, use

Entry (Vala)
/* A window in the application. */
class MyWindow : Gtk.ApplicationWindow {

 /* Constructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "What is your name?");

 var name_box = new Gtk.Entry ();

 /* Connect to the signal handler. */
 name_box.activate.connect (this.on_activate);
 name_box.show ();

 this.set_default_size (300, 100);
 this.border_width = 10;

 /* Add the name_box to this window. */
 this.add (name_box);
 }

 /* Signal handler (aka. callback function) for the 'activate'
 * signal of a Gtk.Entry.
 */
 void on_activate (Gtk.Entry entry) {
 name = entry.get_text ();
 print ("\
Hello " + name + "!\
\
");
 }
}

/* This is the application. */
class MyApplication : Gtk.Application {

 /* Constructor for the application. */
 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }

 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {

 /* Create a new window for this application
 * and show it. */
 new MyWindow (this).show ();
 }

}

/* The main function creats and runs the application. */
int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/filechooserdialog_save.png' md5='3a7a3b71b9d3a36066857843b68ff27f'
external ref='media/filechooserdialog_menu.png' md5='8a75f04127a70eba0ed68a9eb1d3bbca'
FileChooserDialog (Python)
A dialog suitable for "Open" and "Save" commands
FileChooserDialog
This FileChooserDialog saves a text document, which can be opened or written from scratch in a TextView (see below).
It is also possible to call a FileChooserDialog to open a new document.
Steps to recreate the example
Create a file .ui to describe an app-menu with items "New", "Open", "Save", "Save as", and "Quit". This can be done with Glade or in a text editor. See
Create a Python program for a Gtk.TextView with a Gtk.Buffer
In this program, create also the actions corresponding to the items in the app-menu, connect them to callback functions, and import the menu in the
"New" and "Quit" actions and callback functions are quite straightforward, see
"Open" callback should create and open a Gtk.FileChooserDialog for "Open", connected with another callback function for each of the two "Open" and "Cancel" buttons of the FileChooserDialog.
"Save as" works basically as "Open", but the callback function of the "Save" button depends on a more complex method
"Save" can be reduced to the case where the file is
Finally, the method
XML file which creates the app-menu
&lt;?xml version="1.0"?gt;
&lt;interfacegt;
 &lt;menu id="appmenu"gt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Newlt;/attributegt;
 &lt;attribute name="action"gt;win.newlt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Openlt;/attributegt;
 &lt;attribute name="action"gt;win.openlt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Savelt;/attributegt;
 &lt;attribute name="action"gt;win.savelt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Save As...lt;/attributegt;
 &lt;attribute name="action"gt;win.save-aslt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Quitlt;/attributegt;
 &lt;attribute name="action"gt;app.quitlt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/menugt;
&lt;/interfacegt;
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GObject
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(
 self, title="FileChooserDialog Example", application=app)
 self.set_default_size(400, 400)

 # the actions for the window menu, connected to the callback functions
 new_action = Gio.SimpleAction.new("new", None)
 new_action.connect("activate", self.new_callback)
 self.add_action(new_action)

 open_action = Gio.SimpleAction.new("open", None)
 open_action.connect("activate", self.open_callback)
 self.add_action(open_action)

 save_action = Gio.SimpleAction.new("save", None)
 save_action.connect("activate", self.save_callback)
 self.add_action(save_action)

 save_as_action = Gio.SimpleAction.new("save-as", None)
 save_as_action.connect("activate", self.save_as_callback)
 self.add_action(save_as_action)

 # the file
 self.file = None

 # the textview with the buffer
 self.buffer = Gtk.TextBuffer()
 textview = Gtk.TextView(buffer=self.buffer)
 textview.set_wrap_mode(Gtk.WrapMode.WORD)

 # a scrolled window for the textview
 self.scrolled_window = Gtk.ScrolledWindow()
 self.scrolled_window.set_policy(
 Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
 self.scrolled_window.add(textview)
 self.scrolled_window.set_border_width(5)

 # add the scrolled window to the window
 self.add(self.scrolled_window)

 # callback for new
 def new_callback(self, action, parameter):
 self.buffer.set_text("")
 print "New file created"

 # callback for open
 def open_callback(self, action, parameter):
 # create a filechooserdialog to open:
 # the arguments are: title of the window, parent_window, action,
 # (buttons, response)
 open_dialog = Gtk.FileChooserDialog("Pick a file", self,
 Gtk.FileChooserAction.OPEN,
 (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
 Gtk.STOCK_OPEN, Gtk.ResponseType.ACCEPT))

 # not only local files can be selected in the file selector
 open_dialog.set_local_only(False)
 # dialog always on top of the textview window
 open_dialog.set_modal(True)
 # connect the dialog with the callback function open_response_cb()
 open_dialog.connect("response", self.open_response_cb)
 # show the dialog
 open_dialog.show()

 # callback function for the dialog open_dialog
 def open_response_cb(self, dialog, response_id):
 open_dialog = dialog
 # if response is "ACCEPT" (the button "Open" has been clicked)
 if response_id == Gtk.ResponseType.ACCEPT:
 # self.file is the file that we get from the FileChooserDialog
 self.file = open_dialog.get_file()
 # an empty string (provisionally)
 content = ""
 try:
 # load the content of the file into memory:
 # success is a boolean depending on the success of the operation
 # content is self-explanatory
 # etags is an entity tag (can be used to quickly determine if the
 # file has been modified from the version on the file system)
 [success, content, etags] = self.file.load_contents(None)
 except GObject.GError as e:
 print "Error: " + e.message
 # set the content as the text into the buffer
 self.buffer.set_text(content, len(content))
 print "opened: " + open_dialog.get_filename()
 # if response is "CANCEL" (the button "Cancel" has been clicked)
 elif response_id == Gtk.ResponseType.CANCEL:
 print "cancelled: FileChooserAction.OPEN"
 # destroy the FileChooserDialog
 dialog.destroy()

 # callback function for save_as
 def save_as_callback(self, action, parameter):
 # create a filechooserdialog to save:
 # the arguments are: title of the window, parent_window, action,
 # (buttons, response)
 save_dialog = Gtk.FileChooserDialog("Pick a file", self,
 Gtk.FileChooserAction.SAVE,
 (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
 Gtk.STOCK_SAVE, Gtk.ResponseType.ACCEPT))
 # the dialog will present a confirmation dialog if the user types a file name that
 # already exists
 save_dialog.set_do_overwrite_confirmation(True)
 # dialog always on top of the textview window
 save_dialog.set_modal(True)
 # if self.file has already been saved
 if self.file is not None:
 try:
 # set self.file as the current filename for the file chooser
 save_dialog.set_file(self.file)
 except GObject.GError as e:
 print "Error: " + e.message
 # connect the dialog to the callback function save_response_cb()
 save_dialog.connect("response", self.save_response_cb)
 # show the dialog
 save_dialog.show()

 # callback function for the dialog save_dialog
 def save_response_cb(self, dialog, response_id):
 save_dialog = dialog
 # if response is "ACCEPT" (the button "Save" has been clicked)
 if response_id == Gtk.ResponseType.ACCEPT:
 # self.file is the currently selected file
 self.file = save_dialog.get_file()
 # save to file (see below)
 self.save_to_file()
 # if response is "CANCEL" (the button "Cancel" has been clicked)
 elif response_id == Gtk.ResponseType.CANCEL:
 print "cancelled: FileChooserAction.SAVE"
 # destroy the FileChooserDialog
 dialog.destroy()

 # callback function for save
 def save_callback(self, action, parameter):
 # if self.file is not already there
 if self.file is not None:
 self.save_to_file()
 # self.file is a new file
 else:
 # use save_as
 self.save_as_callback(action, parameter)

 # save_to_file
 def save_to_file(self):
 # get the content of the buffer, without hidden characters
 [start, end] = self.buffer.get_bounds()
 current_contents = self.buffer.get_text(start, end, False)
 # if there is some content
 if current_contents != "":
 # set the content as content of self.file.
 # arguments: contents, etags, make_backup, flags, GError
 try:
 self.file.replace_contents(current_contents,
 None,
 False,
 Gio.FileCreateFlags.NONE,
 None)
 print "saved: " + self.file.get_path()
 except GObject.GError as e:
 print "Error: " + e.message
 # if the contents are empty
 else:
 # create (if the file does not exist) or overwrite the file in readwrite mode.
 # arguments: etags, make_backup, flags, GError
 try:
 self.file.replace_readwrite(None,
 False,
 Gio.FileCreateFlags.NONE,
 None)
 print "saved: " + self.file.get_path()
 except GObject.GError as e:
 print "Error: " + e.message


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 # app action quit, connected to the callback function
 quit_action = Gio.SimpleAction.new("quit", None)
 quit_action.connect("activate", self.quit_callback)
 self.add_action(quit_action)

 # get the menu from the ui file with a builder
 builder = Gtk.Builder()
 try:
 builder.add_from_file("filechooserdialog.ui")
 except:
 print "file not found"
 sys.exit()
 menu = builder.get_object("appmenu")
 self.set_app_menu(menu)

 # callback function for quit
 def quit_callback(self, action, parameter):
 self.quit()

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a FileChooserDialog
Note that the action of the FileChooserDialog can be one of the following:
Besides the methods used in the


In a "Save as" dialog,
The default current folder is "recent items". To set another folder use








FileChooserDialog (Vala)
A dialog suitable for "Open" and "Save" commands.
Overview of the example
This example demonstrates how the FileChooserDialog can be used. It is incorporated into a very simple text editor application. All the
XML UI file which creates the app-menu
Vala Code
class MyWindow: Gtk.ApplicationWindow {

 /* MyWindow instance variables. */
 GLib.File? file;
 Gtk.TextBuffer buffer;
 Gtk.TextView textview;
 Gtk.ScrolledWindow scrolled_window;

 /* Create ActionEntries. */
 const ActionEntry[] actions = {
 { "new", new_cb },
 { "open", open_cb },
 { "save", save_cb },
 { "save-as", save_as_cb }
 };

 /* Constructor creates MyWindow, and add the scrolled_window. */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "FileChooserDialog Example");
 this.set_default_size (400, 400);

 /* Add the ActionEntries to MyWindow. */
 this.add_action_entries (actions, this);

 buffer = new Gtk.TextBuffer (null); //stores text to be displayed
 textview = new Gtk.TextView.with_buffer (buffer); //displays TextBuffer
 textview.set_wrap_mode (Gtk.WrapMode.WORD); //sets line wrapping

 scrolled_window = new Gtk.ScrolledWindow (null, null);
 scrolled_window.set_policy (Gtk.PolicyType.AUTOMATIC,
 Gtk.PolicyType.AUTOMATIC);

 scrolled_window.add (textview);
 scrolled_window.set_border_width (5);

 this.add (scrolled_window);
 this.show_all ();
 }

 void new_cb (SimpleAction action, Variant? parameter) {
 file = null;
 buffer.set_text ("");
 print ("New file created\
");
 }

 /* Create FileChooserDialog in OPEN mode. */
 void open_cb (SimpleAction action, Variant? parameter) {

 var open_dialog = new Gtk.FileChooserDialog ("Pick a file",
 this as Gtk.Window,
 Gtk.FileChooserAction.OPEN,
 Gtk.Stock.CANCEL,
 Gtk.ResponseType.CANCEL,
 Gtk.Stock.OPEN,
 Gtk.ResponseType.ACCEPT);

 open_dialog.local_only = false; //allow for uri
 open_dialog.set_modal (true);
 open_dialog.response.connect (open_response_cb);
 open_dialog.show ();
 }

 /* Either open the file and load the file contents or cancel. */
 void open_response_cb (Gtk.Dialog dialog, int response_id) {
 var open_dialog = dialog as Gtk.FileChooserDialog;

 switch (response_id) {
 case Gtk.ResponseType.ACCEPT: //open the file
 file = open_dialog.get_file();

 uint8[] file_contents;

 try {
 file.load_contents (null, out file_contents, null);
 }
 catch (GLib.Error err) { //handle the exception
 error ("%s\
", err.message);
 }
 /* Set the buffer text to be the contents of the file. */
 buffer.set_text ((string) file_contents,
 file_contents.length);

 print ("opened: %s\
", (open_dialog.get_filename ()));
 break;

 case Gtk.ResponseType.CANCEL:
 print ("cancelled: FileChooserAction.OPEN\
");
 break;
 }
 dialog.destroy ();
 }


 /* Create FileChooserDialog in SAVE mode. */
 void save_as_cb (SimpleAction action, Variant? parameter) {
 var save_dialog = new Gtk.FileChooserDialog ("Pick a file",
 this as Gtk.Window,
 Gtk.FileChooserAction.SAVE,
 Gtk.Stock.CANCEL,
 Gtk.ResponseType.CANCEL,
 Gtk.Stock.SAVE,
 Gtk.ResponseType.ACCEPT);

 save_dialog.set_do_overwrite_confirmation (true);
 save_dialog.set_modal (true);
 if (file != null) {
 try {
 (save_dialog as Gtk.FileChooser).set_file (file);
 }
 catch (GLib.Error error) {
 print ("%s\
", error.message);
 }
 }
 save_dialog.response.connect (save_as_response_cb);
 save_dialog.show ();
 }

 void save_as_response_cb (Gtk.Dialog dialog, int response_id) {
 var save_dialog = dialog as Gtk.FileChooserDialog;

 switch (response_id) {
 case Gtk.ResponseType.ACCEPT:
 file = save_dialog.get_file();
 this.save_to_file ();
 break;
 default:
 break;
 }
 dialog.destroy ();
 }

 /* Save the existing contents to the file.
 * If file does not exist, call save_as_cb.
 */
 void save_cb (SimpleAction action, Variant? parameter) {
 if (file != null) {
 this.save_to_file ();
 }
 else {
 save_as_cb (action, parameter);
 }
 }

 void save_to_file (){
 Gtk.TextIter start;
 Gtk.TextIter end;

 buffer.get_bounds (out start, out end);
 string current_contents = buffer.get_text (start, end, false);
 try {
 file.replace_contents (current_contents.data, null, false,
 GLib.FileCreateFlags.NONE, null, null);

 print ("saved: %s\
", file.get_path ());
 }
 catch (GLib.Error err) {
 error ("%s\
", err.message);
 }
 }
}

/* This is the application */
class MyApplication: Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show_all;
 }

 const ActionEntry[] actions = {
 { "quit", quit_cb }
 };

 void quit_cb (SimpleAction action, Variant? parameter) {
 this.quit ();
 }

 protected override void startup () {
 base.startup ();

 /* Setup actions */
 this.add_action_entries (actions, this);

 /* Setup menus */
 var builder = new Gtk.Builder ();
 try {
 builder.add_from_file ("filechooserdialog.ui");
 } catch (GLib.Error err) {
 error ("Unable to load file: %s\
", err.message);
 }
 this.app_menu = builder.get_object ("appmenu") as MenuModel;
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}
Relevant API documentation




external ref='media/fontchooserwidget.png' md5='9161245e307b432ae1313e9a9941edae'
FontChooserWidget (JavaScript)
A widget to choose a font
FontChooserWidget
A FontChooserWidget with a callback function.
//!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const FontChooserWidgetExample = new Lang.Class ({
 Name: 'Font Chooser Widget Example',

 // Create the application itthis
 _init: function () {
 this.application = new Gtk.Application({ application_id: 'org.example.fontchooserwidget' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this.window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function() {
 // Create the application window
 this.window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "FontChooserWidget",
 default_width: 200,
 default_height: 200,
 border_width: 10 });

 this.fontChooser = new Gtk.FontChooserWidget();
 // a default font
 this.fontChooser.set_font("Sans");
 // a text to preview the font
 this.fontChooser.set_preview_text("This is an example of preview text!");

 // connect signal from the font chooser to the callback function
 this.fontChooser.connect("notify::font", Lang.bind(this, this._fontCb));

 // add the font chooser to the window
 this.window.add(this.fontChooser);
 this.window.show_all();
 },

 // callback function:
 _fontCb: function() {
 // print in the terminal
 print("You chose the font " + this.fontChooser.get_font());
 }
});

// Run the application
let app = new FontChooserWidgetExample();
app.application.run (ARGV);

FontChooserWidget (Python)
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="FontChooserWidget", application=app)

 # a font chooser
 self.font_chooser = Gtk.FontChooserWidget()
 # a default font
 self.font_chooser.set_font("Sans")
 # a text to preview the font
 self.font_chooser.set_preview_text(
 "This is an example of preview text!")

 # connect signal from the font chooser to the callback function
 self.font_chooser.connect("notify::font", self.font_cb)

 # add the font chooser to the window
 self.add(self.font_chooser)

 # callback function:
 def font_cb(self, event, user_data):
 # print in the terminal
 print "You chose the font " + self.font_chooser.get_font()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a FontChooserWidget
In line 16 the
To set the font which is initially selected, use
To get the selected font use
To change the text which is shown in the preview area, use
FontChooserWidget (Vala)
Tiffany Antpoolski
A FontChooserWidget with a lambda callback function.
public class MyWindow : Gtk.ApplicationWindow {
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "FontChooserWidget");

 var font_chooser = new Gtk.FontChooserWidget ();
 font_chooser.set_font ("Sans");
 font_chooser.set_preview_text ("This is an example of preview text!");
 this.add (font_chooser);

 font_chooser.notify["font"].connect (() =gt; {
 print ("font: %s\
", font_chooser.get_font ().to_string ());
 print ("desc: %s\
", font_chooser.get_font_desc ().to_string ());
 print ("face: %s\
", font_chooser.get_font_face ().get_face_name ());
 print ("size: %d\
", font_chooser.get_font_size ());
 print ("family: %s\
", font_chooser.get_font_family ().get_name ());
 print ("monospace: %s\
\
", font_chooser.get_font_family ().is_monospace ().to_string ());
 });

 this.show_all ();
 }
}

public class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/gmenu.c.png' md5='f305fc3cae8d16d72b734ee53b559e33'
GMenu (C)
A simple implementation of GMenuModel
GMenu
A GtkApplication with a simple GMenu and SimpleActions
#include &lt;gtk/gtk.hgt;

static void
new_window (GSimpleAction *action,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("This does nothing. It is only a demonstration.\
");
}

static void
quit (GSimpleAction *action,
 GVariant *parameter,
 gpointer user_data)
{
 GApplication *application = user_data;

 g_application_quit (application);
}

static void
startup (GtkApplication *application,
 gpointer user_data)
{
 static const GActionEntry actions[] = {
 { "new", new_window },
 { "quit", quit }
 };

 GMenu *menu;

 g_action_map_add_action_entries (G_ACTION_MAP (application), actions, G_N_ELEMENTS (actions), application);

 menu = g_menu_new ();
 g_menu_append (menu, "New", "app.new");
 g_menu_append (menu, "Quit", "app.quit");
 gtk_application_set_app_menu (application, G_MENU_MODEL (menu));
 g_object_unref (menu);
}

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;

 window = gtk_application_window_new (app);

 gtk_window_set_application (GTK_WINDOW (window), GTK_APPLICATION (app));
 gtk_window_set_title (GTK_WINDOW (window), "Hello GNOME");

 gtk_widget_show_all (GTK_WIDGET (window));
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example",G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "startup", G_CALLBACK (startup), NULL);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}
external ref='media/gmenu.js.png' md5='16b8bee122197771ec8498dac42f196b'
GMenu (JavaScript)
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const Application = new Lang.Class ({
 Name: 'Application',

 //create the application
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.myapp',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 //connect to 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 //create the UI (in this case it's just the ApplicationWindow
 _buildUI: function() {
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Welcome to GNOME" });

 //uncommenting the line below will change the window size
 //this._window.set_default_size(600, 400);

 //show the window and all child widgets (none in this case)
 this._window.show_all();
 },

 _showNew: function() {
 print ("This doesn't do anything. It is only a demonstration.");
 },

 _showAbout: function() {
 print ("No AboutDialog here. This is only a demonstration.");
 },

 //create the menu items and connect the signals to the callback functions.
 _initMenus: function() {
 let menu = new Gio.Menu();
 menu.append("New",'app.new');
 menu.append("About", 'app.about');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 let newAction = new Gio.SimpleAction ({ name: 'new' });
 newAction.connect('activate', Lang.bind(this,
 function() {
 this._showNew();
 }));
 this.application.add_action(newAction);

 let aboutAction = new Gio.SimpleAction ({ name: 'about' });
 aboutAction.connect('activate', Lang.bind(this,
 function() {
 this._showAbout();
 }));
 this.application.add_action(aboutAction);

 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },

 //callback function for 'activate' signal
 _onActivate: function() {
 this._window.present();
 },

 //callback function for 'startup' signal
 _onStartup: function() {
 //You must call _initMenus() before calling _buildUI().
 this._initMenus();
 this._buildUI();
 }
});

//run the application
let app = new Application ();
app.application.run (ARGV);
external ref='media/gmenu.py.png' md5='52c68b34d5d566f37e9f803dedb6353a'
GMenu (Python)
A simple implementation of GMenu
from gi.repository import Gtk
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="GMenu Example", application=app)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 # start the application
 Gtk.Application.do_startup(self)

 # create a menu
 menu = Gio.Menu()
 # append to the menu three options
 menu.append("New", "app.new")
 menu.append("About", "app.about")
 menu.append("Quit", "app.quit")
 # set the menu as menu of the application
 self.set_app_menu(menu)

 # create an action for the option "new" of the menu
 new_action = Gio.SimpleAction.new("new", None)
 # connect it to the callback function new_cb
 new_action.connect("activate", self.new_cb)
 # add the action to the application
 self.add_action(new_action)

 # option "about"
 about_action = Gio.SimpleAction.new("about", None)
 about_action.connect("activate", self.about_cb)
 self.add_action(about_action)

 # option "quit"
 quit_action = Gio.SimpleAction.new("quit", None)
 quit_action.connect("activate", self.quit_cb)
 self.add_action(quit_action)

 # callback function for "new"
 def new_cb(self, action, parameter):
 print "This does nothing. It is only a demonstration."

 # callback function for "about"
 def about_cb(self, action, parameter):
 print "No AboutDialog for you. This is only a demonstration."

 # callback function for "quit"
 def quit_cb(self, action, parameter):
 print "You have quit."
 self.quit()

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a GSimpleAction and a GMenu
In line 33 the signal
Useful methods for a GSimpleAction:
To create a new action that is
action = Gio.SimpleAction.new("name", parameter_type)
where
action = Gio.SimpleAction.new_stateful("name", parameter_type, initial_state)
where


Useful methods for a GMenu:
To insert an item in the menu in position
To append or prepend an item in the menu use respectively
Another way of adding items to the menu is to create them as
about = Gio.MenuItem.new("About", "app.about")
menu.append_item(about)
We can also add a whole subsection in a menu using
To add a submenu that will expand and collapse, use
To remove an item from the menu, use
To set a label for the menu, use


external ref='media/gmenu.vala.png' md5='7a9f381fc3ed5bf8d1c50d2acb095400'
GMenu (Vala)

/* A window in the application. */
public class Window : Gtk.ApplicationWindow {

 /* Constructor */
 public Window (Application app) {
 Object (application: app, title: "Gmenu Example");

 var about_action = new SimpleAction ("about", null);

 /* Connect the 'activate' signal to the
 * signal handler (aka. callback).
 */
 about_action.activate.connect (this.about_cb);

 /* Add the action to this window. */
 this.add_action (about_action);

 this.show ();
 }

 /* Signal handler for 'activate' signal of the SimpleAction. */
 void about_cb (SimpleAction simple, Variant? parameter) {
 print ("This does nothing. It is only a demonstration.\
");
 }
}

/* This is the Application. */
public class Application : Gtk.Application {

 /* Constructor */
 public Application () {
 Object (application_id: "org.example.application");
 }

 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {

 /* Create a new window for this application. */
 new Window (this);
 }

 /* Override the 'startup' signal of GLib.Application. */
 protected override void startup () {
 base.startup ();

 var menu = new Menu ();
 menu.append ("About", "win.about");
 menu.append ("Quit", "app.quit");
 this.app_menu = menu;

 var quit_action = new SimpleAction ("quit", null);
 quit_action.activate.connect (this.quit);
 this.add_action (quit_action);
 }
}

/* main function creates Application and runs it. */
int main (string[] args) {
 return new Application ().run (args);
}




external ref='media/grid.png' md5='27d45da115401127456a3b854dcfc5be'
Grid (C)
Pack widgets in rows and columns
Grid
A button widget connected to a progress bar.
#include &lt;gtk/gtk.hgt;



/*Signal handler for the "clicked" signal of the Button. Each
click generates a progress bar pulse*/
static void
on_button_click (GtkButton *button,
 gpointer user_data)
{
 GtkProgressBar *progress_bar = user_data;
 gtk_progress_bar_pulse (progress_bar);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *grid;
 GtkWidget *window;
 GtkWidget *button;
 GtkWidget *progress_bar;

 /*Create the window and set a title*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Grid Example");

 /*Create a button with a label*/
 button = gtk_button_new_with_label ("Button");

 /*Create the progress bar*/
 progress_bar = gtk_progress_bar_new ();

 /*Create a grid and attach the button and progress bar
 accordingly*/
 grid = gtk_grid_new ();
 gtk_grid_attach (GTK_GRID (grid), button, 1, 1, 1, 1);
 gtk_grid_attach_next_to (GTK_GRID (grid), 
 progress_bar, 
 button, 
 GTK_POS_BOTTOM, 1, 1);

 /*Connecting the clicked signal to the callback function*/
 g_signal_connect (GTK_BUTTON (button), "clicked", 
 G_CALLBACK (on_button_click), progress_bar);

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (grid));

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

Grid (JavaScript)
A button widget connected to a progress bar, inside of a grid which handles the layout.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const GridExample = new Lang.Class ({
 Name: 'Grid Example',

 /* Create the application itself
 This boilerplate code is needed to build any GTK+ application. */
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jsgrid',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal initializes menus and builds the UI
 _onStartup: function () {
 this._buildUI ();
 },




 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Grid Example"});

 // Create the grid
 this.Grid = new Gtk.Grid ();

 // Create the widgets inside the grid
 this.progressBar = new Gtk.ProgressBar ();
 this.Button = new Gtk.Button ({ label: "Button" });
 this.Button.connect ("clicked", Lang.bind(this, this._clickHandler));

 // Assemble the grid
 this._window.add (this.Grid);
 this.Grid.attach (this.Button, 1, 1, 1, 1);
 this.Grid.attach_next_to (this.progressBar, this.Button, Gtk.PositionType.BOTTOM, 1, 1);

 // Show the window and all child widgets
 this._window.show_all();
 },

 // Here's the function that says what happens when the button is clicked
 _clickHandler: function () {
 this.progressBar.pulse ();
 }


});

// Run the application
let app = new GridExample ();
app.application.run (ARGV);


external ref='media/grid_simple.png' md5='c806f2e69b30373d4d2e08b41d6cc1f6'
Grid (Python)
Some labels in a grid.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Grid Example", application=app)

 # three labels
 label_top_left = Gtk.Label(label="This is Top Left")
 label_top_right = Gtk.Label(label="This is Top Right")
 label_bottom = Gtk.Label(label="This is Bottom")

 # a grid
 grid = Gtk.Grid()

 # some space between the columns of the grid
 grid.set_column_spacing(20)

 # in the grid:
 # attach the first label in the top left corner
 grid.attach(label_top_left, 0, 0, 1, 1)
 # attach the second label
 grid.attach(label_top_right, 1, 0, 1, 1)
 # attach the third label below the first label
 grid.attach_next_to(
 label_bottom, label_top_left, Gtk.PositionType.BOTTOM, 2, 1)

 # add the grid to the window
 self.add(grid)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Grid widget
To attach a widget






Grid (Vala)
Grid widget
public class MyWindow : Gtk.ApplicationWindow {

 Gtk.Widget progress_bar;

 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Grid Example");
 var grid = new Gtk.Grid();
 progress_bar = new Gtk.ProgressBar ();
 progress_bar.show ();

 var button = new Gtk.Button.with_label ("Button");
 button.clicked.connect (on_button_click);
 button.show ();

 this.add(grid);
 grid.attach(button, 0, 1, 1, 1);
 grid.attach_next_to (progress_bar, button, Gtk.PositionType.BOTTOM, 1, 1);
 grid.show ();
 }

 void on_button_click (Gtk.Button button) {
 (progress_bar as Gtk.ProgressBar).pulse ();
 }
}

public class MyApplication : Gtk.Application {
 protected override void activate () {

 new MyWindow (this).show ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");

 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/window.png' md5='eb0cde3530978619c25bddfaeb453345'
ApplicationWindow (C)
A toplevel window which can contain other widgets, and support GMenu
ApplicationWindow
A minimal GtkApplication with a GtkApplicationWindow
#include &lt;gtk/gtk.hgt;

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Hello GNOME");
 gtk_widget_show_all (window);
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}

ApplicationWindow (JavaScript)
GtkWindow subclass with GtkApplication support
A simple GtkApplicationWindow which can support Menus.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const Application = new Lang.Class ({
 Name: 'Application',

 //create the application
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.myapp',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 //connect to 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 //create the UI (in this case it's just the ApplicationWindow
 _buildUI: function () {
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Welcome to GNOME" });

 //uncommenting the line below will change the window size
 //this._window.set_default_size(600, 400);

 //show the window and all child widgets (none in this case)
 this._window.show_all();
 },

 //callback function for 'activate' signal
 _onActivate: function () {
 this._window.present ();
 },

 //callback function for 'startup' signal
 _onStartup: function () {
 this._buildUI ();
 }
});

//run the application
let app = new Application ();
app.application.run (ARGV);
ApplicationWindow (Python)
The simplest GtkApplication Window which can support
from gi.repository import Gtk
import sys

# a Gtk ApplicationWindow


class MyWindow(Gtk.ApplicationWindow):
 # constructor: the title is "Welcome to GNOME" and the window belongs
 # to the application app

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)


class MyApplication(Gtk.Application):
 # constructor of the Gtk Application

 def __init__(self):
 Gtk.Application.__init__(self)

 # create and activate a MyWindow, with self (the MyApplication) as
 # application the window belongs to.
 # Note that the function in C activate() becomes do_activate() in Python
 def do_activate(self):
 win = MyWindow(self)
 # show the window and all its content
 # this line could go in the constructor of MyWindow as well
 win.show_all()

 # start up the application
 # Note that the function in C startup() becomes do_startup() in Python
 def do_startup(self):
 Gtk.Application.do_startup(self)

# create and run the application, exit with the value returned by
# running the program
app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Gtk.ApplicationWindow widget


ApplicationWindow (Vala)
The simplest GtkApplication Window which can support Menus.
/* This is the application. */
public class MyApplication : Gtk.Application {
 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {
 /* Create the window of this application and show it. */
 var window = new Gtk.ApplicationWindow (this);
 window.title = "Welcome to GNOME";
 window.show ();
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/guitar-tuner.png' md5='35e615e0f5e293671d00c5c414ac2f6b'
external ref='media/guitar-tuner-glade.png' md5='f6606525443ab2160f53a87a454364d0'
external ref='media/guitar-tuner-pipeline.png' md5='5adc952909d92af5dae6954781b4ad5f'
Guitar tuner (C)
Use GTK+ and GStreamer to build a simple guitar tuner application for GNOME. Shows off how to use the interface designer.
Johannes Schmid
Guitar tuner
In this tutorial, we're going to make a program which plays tones that you can use to tune a guitar. You will learn how to:
Set up a basic project in Anjuta
Create a simple GUI with Anjuta's UI designer
Use GStreamer to play sounds
You'll need the following to be able to follow this tutorial:
An installed copy of the
Basic knowledge of the C programming language
Create a project in Anjuta
Before you start coding, you'll need to set up a new project in Anjuta. This will create all of the files you need to build and run the code later on. It's also useful for keeping everything together.
Start Anjuta and click
Choose
Make sure that
Click
#include &lt;config.hgt;
#include &lt;gtk/gtk.hgt;
Build the code for the first time
C is a rather verbose language, so don't be surprised that the file contains quite a lot of code. Most of it is template code. It loads an (empty) window from the user interface description file and shows it. More details are given below; skip this list if you understand the basics:
The three
The
Connecting signals is how you define what happens when you push a button, or when some other event happens. Here, the
The
The
This code is ready to be used, so you can compile it by clicking
Press
Create the user interface
A description of the user interface (UI) is contained in the GtkBuilder file. To edit the user interface, open
The layout of every UI in GTK+ is organized using boxes and tables. Let's use a vertical
Select a
Now, choose a
While the button is still selected, change the
Switch to the
Repeat the above steps for the other buttons, adding the next 5 strings with the names
Save the UI design (by clicking
Creating the signal handler
In the UI designer, you made it so that all of the buttons will call the same function,
To do this, open
void on_button_clicked (GtkWidget* button, gpointer user_data)
{

}
This signal handler has two arguments: a pointer to the
For now, we'll leave the signal handler empty while we work on writing the code to produce sounds.
GStreamer pipelines
GStreamer is GNOME's multimedia framework — you can use it for playing, recording, and processing video, audio, webcam streams and the like. Here, we'll be using it to produce single-frequency tones.
Conceptually, GStreamer works as follows: You create a
Between source and sink, you can apply various filters and converters to handle effects, format conversions and so on. Each element of the pipeline has properties which can be used to change its behaviour.
An example GStreamer pipeline.
Set up the pipeline
In this simple example we will use a tone generator source called
Insert the following line into
#include &lt;gst/gst.hgt;
This includes the GStreamer library. You also need to add a line to initialize GStreamer; put the following code on the line above the
gst_init (amp;argc, &argv);
Then, copy the following function into
static void
play_sound (gdouble frequency)
{
 GstElement *source, *sink;
 GstElement *pipeline;

 pipeline = gst_pipeline_new ("note");
 source = gst_element_factory_make ("audiotestsrc",
 "source");
 sink = gst_element_factory_make ("autoaudiosink",
 "output");

 /* set frequency */
 g_object_set (source, "freq", frequency, NULL);

 gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);
 gst_element_link (source, sink);

 gst_element_set_state (pipeline, GST_STATE_PLAYING);

 /* stop it after 500ms */
 g_timeout_add (LENGTH, (GSourceFunc) pipeline_stop, pipeline);
}
The first five lines create source and sink GStreamer elements (
The call to

Next,
Stopping playback
We don't want to play an annoying tone forever, so the last thing
Now, we'll write the
#define LENGTH 500 /* Length of playing in ms */

static gboolean
pipeline_stop (GstElement* pipeline)
{
 gst_element_set_state (pipeline, GST_STATE_NULL);
 g_object_unref (pipeline);

 return FALSE;
}
The call to
Define the tones
We want to play the correct sound when the user clicks a button. First of all, we need to know the frequencies for the six guitar strings, which are defined (at the top of
/* Frequencies of the strings */
#define NOTE_E 329.63
#define NOTE_A 440
#define NOTE_D 587.33
#define NOTE_G 783.99
#define NOTE_B 987.77
#define NOTE_e 1318.5
Now to flesh out the signal handler that we defined earlier,
/* Callback for the buttons */
void on_button_clicked (GtkButton* button,
 gpointer user_data)
{
 const gchar* text = gtk_button_get_label (button);

 if (g_str_equal (text, _("E")))
 play_sound (NOTE_E);
 else if (g_str_equal (text, _("A")))
 play_sound (NOTE_A);
 else if (g_str_equal (text, _("G")))
 play_sound (NOTE_G);
 else if (g_str_equal (text, _("D")))
 play_sound (NOTE_D);
 else if (g_str_equal (text, _("B")))
 play_sound (NOTE_B);
 else if (g_str_equal (text, _("e")))
 play_sound (NOTE_e);
}
A pointer to the
The text is then compared to the notes that we have using
Build and run the application
All of the code should now be ready to go. Click
If you haven't already done so, choose the
Reference Implementation
If you run into problems with the tutorial, compare your code with this
Next steps
Here are some ideas for how you can extend this simple demonstration:
Have the program automatically cycle through the notes.
Make the program play recordings of real guitar strings being plucked.
To do this, you would need to set up a more complicated GStreamer pipeline which allows you to load and play back music files. You'll have to choose
You might need to connect the elements in more complicated ways too. This could involve using
Automatically analyze notes that the user plays.
You could connect a microphone and record sounds from it using an
Use GTKmm and GStreamermm to build a simple guitar tuner application for GNOME. Shows off how to use the interface designer.
Basic knowledge of the C++ programming language
Choose
Make sure that
Click
#include &lt;gtkmm.hgt;
#include &lt;iostreamgt;
This is a very basic C++ code setting up GTKmm. More details are given below; skip this list if you understand the basics:
The three
The
Afterwards it calls a few functions which set up and then run the application. The
While the button is still selected, change the
Repeat the above steps for the other buttons, adding the next 5 strings with the labels
Save the UI design (by clicking
GStreamer is GNOME's multimedia framework — you can use it for playing, recording, and processing video, audio, webcam streams and the like. Here, we'll be using it to produce single-frequency tones. GStreamermm is the C++ binding to GStreamer which we will use here.
Using GStreamermm
To use GStreamermm, it has to be initialised. We do that by adding the following line of code next to the
 Gst::init (argc, argv);
While we are on it, also make sure that the
To simplify the handling of the pipeline we will define a helper class
class Sound
{
 public:
 Sound();

 void start_playing(double frequency);
 bool stop_playing();

 private:
 Glib::RefPtrlt;Gst::Pipelinegt; m_pipeline;
 Glib::RefPtrlt;Gst::Elementgt; m_source;
 Glib::RefPtrlt;Gst::Elementgt; m_sink;
};

Sound::Sound()
{
 m_pipeline = Gst::Pipeline::create("note");
 m_source = Gst::ElementFactory::create_element("audiotestsrc",
 "source");
 m_sink = Gst::ElementFactory::create_element("autoaudiosink",
 "output");
 m_pipeline-gt;add(m_source);
 m_pipeline-gt;add(m_sink);
 m_source-gt;link(m_sink);
}

void Sound::start_playing (double frequency)
{
 m_source-gt;set_property("freq", frequency);
 m_pipeline-gt;set_state(Gst::STATE_PLAYING);

 /* stop it after 200ms */
 Glib::signal_timeout().connect(sigc::mem_fun(*this, &Sound::stop_playing),
 200);
}

bool Sound::stop_playing()
{
 m_pipeline-gt;set_state(Gst::STATE_NULL);
 return false;
}
The code has the following purpose:
In the constructor, source and sink GStreamer elements (

In
Connecting the signals
We want to play the correct sound when the user clicks a button. That means that we have to connect to the signal that is fired when the user clicks the button. We also want to provide information to the called function which tone to play. GTKmm makes that quite easy as we can easily bind information with the
The function that is called when the user clicks a button can be pretty simple, as all the interesting stuff is done in the helper class now:
static void
on_button_clicked(double frequency, Sound* sound)
{
 sound-gt;start_playing (frequency);
}
It only calls the helper class we defined before to play the correct frequencies. With some more clever code we would also have been able to directly connect to the class without using the function but we will leave that to use as an exercise.
The code to set up the signals should be added to the
Sound sound;
Gtk::Button* button;

builder-gt;get_widget("button_E", button);
button-gt;signal_clicked().connect (sigc::bindlt;double, Sound*gt;(sigc::ptr_fun(amp;on_button_clicked),
 329.63, &sound));
At first we create an instance of our helper class that we want to use now and declare a variable for the button we want to connect to.
Next, we receive the button object from the user interface that was created out of the user interface file. Remember that
Finally we connect the
Now that we have set up the
All of the code should now be ready to go. Click
If you run into problems with the tutorial, compare your code with this
Further Reading
Many of the things shown above are explained in detail in the
Guitar tuner (JavaScript)
Use GTK+ and GStreamer to build a simple guitar tuner application for GNOME.
In this tutorial we'll construct a small application, Guitar Tuner, using JavaScript and GTK+ and GStreamer. To do and run all the code examples yourself, you need an editor to write code in, terminal and GNOME 3. or higher installed into your computer.









After reading this tutorial, you should see this in your screen:
Script for running the application
#!/usr/bin/gjs
This line tells how to run the script. It needs to be the first line of the code and it needs to be executable. To get the execution rights go to terminal and run in right folder: chmod +x scriptname. Or you can use the graphical filemanager. Just go to the right folder where your code is, right click you code file, choose properties, click the permissions tab and check the box for allow executing file as a program
var Gtk = imports.gi.Gtk;
var Gst = imports.gi.Gst;

const Mainloop = imports.mainloop;
In order to have a working program we need to import a few GObject Introspection -libraries to our use. For working UI, we need Gtk and for Gstreamer to work we need Gst. These are imported in the beginning so we have them at use everywhere. Also in the beginning we import a construct Mainloop to handle the timeout to be used with the tuning sounds.
Creating the main window for the application
Gtk.init(null, 0);
Gst.init(null, 0);

var guitarwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL, border_width: 100});
guitarwindow.title = "Guitar Tuner";
guitarwindow.connect("destroy", function(){Gtk.main_quit()});

guitarwindow.show();
Gtk.main();
Importing Gtk and Gst is not enough, we need to initialize them in order to get them working. When Gtk and Gst are up and running we need to create the window for the application. Later we are going to put all the buttons for making sounds inside this window. In order to get the window showing, we need to tell it to show and we need also to run the code with the Gtk.main()
Buttons for the tunes
var guitar_box = new Gtk.ButtonBox ({orientation: Gtk.Orientation.VERTICAL, spacing: 10});

var E = new Gtk.Button({label: "E"});
var A = new Gtk.Button({label: "A"});
var D = new Gtk.Button({label: "D"});
var G = new Gtk.Button({label: "G"});
var B = new Gtk.Button({label: "B"});
var e = new Gtk.Button({label: "e"});

guitar_box.add(E);
guitar_box.add(A);
guitar_box.add(D);
guitar_box.add(G);
guitar_box.add(B);
guitar_box.add(e);

guitarwindow.add(guitar_box);

guitar_box.show_all();
Because Gtk.Window can only contain a single widget, we need to create something under it to be able to add all the necessary buttons inside it. In this example we use Buttonbox. After creating the Buttonbox we create buttons with necessary labels. After we have the buttons we need to add them to the Buttonbox and the Buttonbox must be added to the Gtk.Window and everything in the Buttonbox must be shown.
After this stage you should have a window appearing to your screen showing 6 buttons. Right now the buttons don't do anything and we shall address that issue later. Before we can connect the button signals to something we need to code that something first.
Making the sounds with GStreamer
var frequencies = {E: 329.63, A: 440, D: 587.33, G: 783.99, B: 987.77, e: 1318.5}

function playSound(frequency){
 var pipeline = new Gst.Pipeline({name: "note"});
 var source = new Gst.ElementFactory.make("audiotestsrc","source");
 var sink = new Gst.ElementFactory.make("autoaudiosink","output");

 source.set_property('freq', frequency);
 pipeline.add(source);
 pipeline.add(sink);
 source.link(sink);
 pipeline.set_state(Gst.State.PLAYING);

 Mainloop.timeout_add(500, function () {
 pipeline.set_state(Gst.State.NULL);
 return false;
 });
}
The first thing we need to do is decide what tunes we want to make when we push a button. The frequencies list takes care of that. After that we get to actually making the sounds with the function playSound. For function playSound we give as an input a frequency (that we just defined in the frequencies variable). First thing we need to construct is a pipeline, a source and a sink. For the source we set the frequency. To the pipeline we add both the source and the sink and then we tell it to keep playing. As a last thing we use the const Mainloop to get the pipeline to stop after a 500ms.
Now we have the method of playing a tune when clicking a button. Next well make the conncetions between pushing a button and playing the correct sound from that button.
Connecting buttons to playSound
E.connect("clicked", function() {
 playSound(frequencies.E);
});
A.connect("clicked", function(){
 playSound(frequencies.A);
});
D.connect("clicked", function(){
 playSound(frequencies.D);
});
G.connect("clicked", function(){
 playSound(frequencies.G);
});
B.connect("clicked", function(){
 playSound(frequencies.B);
});
e.connect("clicked", function(){
 playSound(frequencies.e);
});
The method of connecting button clicks to playSound with the correct tune is by using the connect method of the button widget. So we choose a button to be connected and type
The whole program
So this is what all the parts combined looks like. When running this code, you should be able to tune your guitar(if you have correctly calibrated speakers).
#!/usr/bin/gjs
var Gtk = imports.gi.Gtk;
var Gst = imports.gi.Gst;

const Mainloop = imports.mainloop;

Gtk.init(null, 0);
Gst.init(null, 0);

var guitarwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL, border_width: 100});
guitarwindow.title = "Guitar Tuner";
guitarwindow.connect("destroy", function(){Gtk.main_quit()});

var guitar_box = new Gtk.ButtonBox ({orientation: Gtk.Orientation.VERTICAL, spacing: 10});

var E = new Gtk.Button({label: "E"});
var A = new Gtk.Button({label: "A"});
var D = new Gtk.Button({label: "D"});
var G = new Gtk.Button({label: "G"});
var B = new Gtk.Button({label: "B"});
var e = new Gtk.Button({label: "e"});

var frequencies = {E: 329.63, A: 440, D: 587.33, G: 783.99, B: 987.77, e: 1318.5}


function playSound(frequency){
 var pipeline = new Gst.Pipeline({name: "note"});

 var source = new Gst.ElementFactory.make("audiotestsrc","source");
 var sink = new Gst.ElementFactory.make("autoaudiosink","output");

 source.set_property('freq', frequency);
 pipeline.add(source);
 pipeline.add(sink);
 source.link(sink);
 pipeline.set_state(Gst.State.PLAYING);

 Mainloop.timeout_add(500, function () {
 pipeline.set_state(Gst.State.NULL);
 return false;
});
}

E.connect("clicked", function() {
 playSound(frequencies.E);
});
A.connect("clicked", function(){
 playSound(frequencies.A);
});
D.connect("clicked", function(){
 playSound(frequencies.D);
});
G.connect("clicked", function(){
 playSound(frequencies.G);
});
B.connect("clicked", function(){
 playSound(frequencies.B);
});
e.connect("clicked", function(){
 playSound(frequencies.e);
});

guitar_box.add(E);
guitar_box.add(A);
guitar_box.add(D);
guitar_box.add(G);
guitar_box.add(B);
guitar_box.add(e);

guitarwindow.add(guitar_box);

guitar_box.show_all();
guitarwindow.show();
Gtk.main();
Running the application form Terminal
To run this application open Terminal, go to the folder where your application is stored and then run

If you run into problems with the tutorial, compare your code with this
Guitar tuner (Python)
Basic knowledge of the Python programming language
Choose
Click
from gi.repository import Gtk, GdkPixbuf, Gdk
import os, sys
Run the code for the first time
Most of the code in the file is template code. It loads an (empty) window from the user interface description file and shows it. More details are given below; skip this list if you understand the basics:
The
A class is declared that will be the main class for our application. In the
Connecting signals is how you define what happens when you push a button, or when some other event happens. Here, the
The
This code is ready to be used, so you can run it by clicking
A description of the user interface (UI) is contained in the GtkBuilder file. To edit the user interface, open
Write the signal handler
To do this, open
def on_button_clicked (self, button):
This signal handler has two arguments: the usual Python class pointer, and the
Change the import line in
from gi.repository import Gtk, Gst, GObject
The
Gst.init_check(sys.argv)
Then, copy the following function into the class in
def play_sound(self, frequency):
 pipeline = Gst.Pipeline(name='note')
 source = Gst.ElementFactory.make('audiotestsrc', 'src')
 sink = Gst.ElementFactory.make('autoaudiosink', 'output')

 source.set_property('freq', frequency)
 pipeline.add(source)
 pipeline.add(sink)
 source.link(sink)
 pipeline.set_state(Gst.State.PLAYING)

 GObject.timeout_add(self.LENGTH, self.pipeline_stop, pipeline)
The first three lines create source and sink GStreamer elements and a pipeline element (which will be used as a container for the other two elements). The pipeline is given the name "note"; the source is named "source" and is set to the
The call to
The next two lines call
Next
We don't want to play an annoying tone forever, so the last thing
Now, we'll write the
def pipeline_stop(self, pipeline):
 pipeline.set_state(Gst.State.NULL)
 return False
You need to define the
LENGTH = 500
The call to
We want to play the correct sound when the user clicks a button. First of all, we need to know the frequencies for the six guitar strings, which are defined (at the beginning of the main class) inside a dictionary so we can easily map them to the names of the strings:
# Frequencies of the strings
frequencies = {
 'E': 329.63,
 'A': 440,
 'D': 587.33,
 'G': 783.99,
 'B': 987.77,
 'e': 1318.5
}
def on_button_clicked(self, button):
 label = button.get_child()
 text = label.get_label()

 self.play_sound (self.frequencies[text])
The button that was clicked is passed as an argument (
The label text is then used as a key for the dictionary and
Run the application
All of the code should now be ready to go. Click
If you run into problems with the tutorial, compare your code with this
Use
In this tutorial you will create an application which plays tones that you can use to tune a guitar. You will learn how to:
Set up a basic project using the
Create a simple GUI with
Use the
Basic knowledge of the
An installed copy of
Create a project in
Start
Click on the
Make sure that
Click
using GLib;
using Gtk;
The code loads an (empty) window from the user interface description file and displays it. More details are given below; you may choose to skip this list if you understand the basics:
The two
The constructor of the
Connecting signals is how you define what happens when you push a button, or when some other event happens. Here, the
The static
This code is ready to be used, so you can compile it by clicking
A description of the user interface (UI) is contained in the GtkBuilder file
The layout of every UI in GTK+ is organized using boxes and tables. Let's use a vertical GtkButtonBox here to assign six GtkButtons, one for each of the six guitar strings.
In the
You can also change the
Now, from the
While the button is still selected, scroll down in the
The
Click on the
This section will show you how to create the code to produce sounds.
Conceptually, GStreamer works as follows: You create a
In this example we will use a tone generator source called
We need to add a line to initialize GStreamer; put the following code on the line above the
Gst.init (ref args);
Then, copy the following function into
Gst.Element sink;
Gst.Element source;
Gst.Pipeline pipeline;

private void play_sound(double frequency)
{
 pipeline = new Gst.Pipeline ("note");
 source = Gst.ElementFactory.make ("audiotestsrc",
 "source");
 sink = Gst.ElementFactory.make ("autoaudiosink",
 "output");

 /* set frequency */
 source.set ("freq", frequency);

 pipeline.add (source);
 pipeline.add (sink);
 source.link (sink);

 pipeline.set_state (Gst.State.PLAYING);

 /* stop it after 200ms */
 var time = new TimeoutSource(200);

 time.set_callback(() =gt; {
 pipeline.set_state (Gst.State.NULL);
 return false;
 });
 time.attach(null);
}
The first three lines create source and sink GStreamer elements (
The call to

Next,
We don't want to play an annoying tone forever, so the last thing
In the UI designer, you made it so that all of the buttons will call the same function,
To do this, in the user interface file (guitar_tuner.ui) select one of the buttons by clicking on it, then open
public void on_button_clicked (Gtk.Button sender) {

}
You can also just type the code at the beginning of the class instead of using the drag and drop.
This signal handler has only one argument: the
Define the signal handler
We want to play the correct sound when the user clicks a button. For this, we flesh out the signal handler which we defined above,
public void on_button_clicked (Gtk.Button sender) {
 var label = sender.get_child () as Gtk.Label;
 switch (label.get_label()) {
 case "E":
 play_sound (329.63);
 break;
 case "A":
 play_sound (440);
 break;
 case "D":
 play_sound (587.33);
 break;
 case "G":
 play_sound (783.99);
 break;
 case "B":
 play_sound (987.77);
 break;
 case "e":
 play_sound (1318);
 break;
 default:
 break;
 }
}
The
The switch statement compares the label text to the notes that we can play, and
If you run into problems with the tutorial, compare your code with this
Further reading
To find out more about the Vala programming language you might want to check out the
external ref='media/hellognomewebapp.png' md5='948efb6148ede3bc6b47b4b0bbe4a74f'
Your first GNOME application!
1. Hello, GNOME!
This tutorial will show you how to write your first GNOME application in JavaScript. You will use JavaScript to write for GNOME the same way you would for the web. Afterwards, you will learn how to use "native" widgets, to write applications that look and feel like other GNOME apps.
Have you gotten GNOME installed on your computer, and
Let's start with a web page
Here's some basic HTML, CSS, and JavaScript code. Does this look familiar?
&lt;!DOCTYPE htmlgt;
&lt;htmlgt;
 &lt;headgt;
 &lt;titlegt;Hello, GNOME!lt;/titlegt;

 &lt;!-- Use JavaScript to show a greeting when someone clicks the button --gt;
 &lt;script type="application/javascript"gt;
 function greeting () {
 document.getElementById ("greeting").innerHTML = ("O hai!");
 }
 &lt;/scriptgt;

 &lt;!-- Very basic CSS style using the GNOME font --gt;
 &lt;style type="text/css"gt;
 body {
 font-face: Cantarell, sans-serif;
 text-align: center; }
 &lt;/stylegt;

 &lt;/headgt;
 &lt;bodygt;
 &lt;br /gt; &lt;br /gt;
 &lt;button type="button" onclick="greeting()"gt;Hello, GNOME!lt;/buttongt;

 &lt;!-- Empty H1 element gets filled in when the button is clicked --gt;
 &lt;h1 id="greeting"gt;lt;/h1gt;
 &lt;/bodygt;
&lt;/htmlgt;
Let's save this as
You
The best part? We're going to continue to use JavaScript, to write all the parts that make our app work with GNOME. Let's look at the code, and see how it's done!
Creating a GNOME window to frame our web app
First, we need to tell GNOME that this is a JavaScript application, which uses gjs. Gjs is GNOME's way of turning your JavaScript code into instructions it understands, so this line always has to go at the start of your applications.
#!/usr/bin/gjs
After that, we need to tell GNOME which libraries we want to import.
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Webkit = imports.gi.WebKit;
Just like how add-on libraries like jQuery let us do extra things with JavaScript, each of these libraries gives us new capabilities for our GNOME apps:


And
Now we create the application itself:
const HelloGNOME = new Lang.Class ({
 Name: 'Hello GNOME',
This will look familiar to you if you've worked with object-oriented JavaScript before. That's right; our whole application is a class called HelloGNOME. And as you can see, we've given it a property that says what its name is.
// Create the application itself
 _init: function () {
 this.application = new Gtk.Application ();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },
Here's some code you will more or less copy-and-paste for every JavaScript application you build. It creates a new Application, and then binds its activate and startup signals to functions that make the window show itself and build its user interface, respectively.
What does that mean? Well, everything in a GNOME application sends out a signal when something important happens. A button might send out the clicked signal when you click on it, for instance. Our job is to connect the signals to functions which handle them, and make the things that we want to have happen occur. We do this using each object's connect method, which takes two arguments: The signal we want to handle, and the Lang.bind function, which we have to use to tell connect which function we want to have handle the signal.
In this case, we want _onActivate to handle the activate signal, and _onStartup to handle the startup signal. _onActivate just tells the window to present itself; so basically, whenever you
When you copy and paste the above code for your own applications, be sure to change the name to a unique one each time.
Designing our window's UI
In the _buildUI function, we're going to tell GNOME about our window and the things inside it, one at a time. After that, we're going to connect everything together and put it all on display.
// Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 title: "Welcome to GNOME",
 default_height: 200,
 default_width: 400,
 window_position: Gtk.WindowPosition.CENTER });
The first object we create is an ApplicationWindow. It needs a title to go in the title bar, and its application property needs to be the application that we created, above. Beyond that, there are various ways of customizing how it looks, which the
// Create a webview to show the web app
 this._webView = new Webkit.WebView ();

 // Put the web app into the webview
 this._webView.load_uri (GLib.filename_to_uri (GLib.get_current_dir() +
 "/hellognome.html", null));
Remember how we imported Webkit right at the start? Here we're creating a new instance of a Webkit class called a WebView, which is more or less a browser window you can put inside of your app. After that, we then give it the URI that we want it to load when the application starts up.
We
// Put the webview into the window
 this._window.add (this._webView);

 // Show the window and all child widgets
 this._window.show_all();
 },

});
Each window can hold one, and only one, widget. Normally, we'd use a container widget like a
// Run the application
let app = new HelloGNOME ();
app.application.run (ARGV);
Finally, we create a new instance of our HelloGNOME class, and tell GNOME to run it.
Running your GNOME application
Now that we've created our first GNOME application, it's time to test it out! You don't need to compile your app or install any special software for this; GNOME has gjs built in, to let it run GNOME Shell. Just save

You should see more or less the same screenshot as before, with a button that you can click to make a short message appear.
You can use the terminal command

to navigate between directories inside the Terminal, in order to get to where you saved the files. There is also an extension for Nautilus, GNOME's file manager, which lets you right-click anywhere inside it to open a terminal window right there. Check the app you use to install new software (like Add/Remove Programs or the Software Center) for it.

Finally, if you want to just build GNOME applications using JavaScript libraries designed for the web, you can basically stop here and go do that! Check out
#!/usr/bin/gjs

const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Webkit = imports.gi.WebKit;

const HelloGNOME = new Lang.Class ({
 Name: 'Hello GNOME',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ();

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 title: "Welcome to GNOME",
 default_height: 200,
 default_width: 400,
 window_position: Gtk.WindowPosition.CENTER });

 // Create a webview to show the web app
 this._webView = new Webkit.WebView ();

 // Put the web app into the webview
 this._webView.load_uri (GLib.filename_to_uri (GLib.get_current_dir() +
 "/hellognome.html", null));

 // Put the webview into the window
 this._window.add (this._webView);

 // Show the window and all child widgets
 this._window.show_all();
 },

});

// Run the application
let app = new HelloGNOME ();
app.application.run (ARGV);
external ref='media/hello-world.png' md5='4c88a27211dfd1b33e504c9f78602f2d'
Hello World (C)
A basic "hello, world" application
How to build, install and create a
This tutorial will demonstrate how to:
create a small "Hello, World" application using GTK+
make the
how to set up the build system
Create the program
#include &lt;gtk/gtk.hgt;
static void
activate (GtkApplication* app,
 gpointer user_data)
{
 GtkWidget *window;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Hello World");
 gtk_window_set_default_size (GTK_WINDOW (window), 200, 100);
 gtk_widget_show_all (window);
}
GtkApplication initializes GTK+. It also connects the
We can start building our first window. We do this by creating a variable called
The window title can be any string you want it to be. To be on the safe side, it's best to stick to UTF-8 encoding.
Now we have a window which has a title and a working "close" button. Let's add the actual "Hello World" text.
Label for the window
GtkWidget *label;

 label = gtk_label_new ("Hello World!");
 gtk_container_add (GTK_CONTAINER (window), label);
Finally, we create and run the application:
int
main (int argc,
 char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new (NULL, G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}
GtkApplicationWindow can only hold one widget at a time. To construct more elaborate programs you need to create a holder widget like GtkGrid inside the window, and then add all the other widgets to it.
hello-world.c
The complete file:
#include &lt;gtk/gtk.hgt;

static void
activate (GtkApplication* app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *label;

 window = gtk_application_window_new (app);
 label = gtk_label_new ("Hello GNOME!");
 gtk_container_add (GTK_CONTAINER (window), label);
 gtk_window_set_title (GTK_WINDOW (window), "Welcome to GNOME");
 gtk_window_set_default_size (GTK_WINDOW (window), 200, 100);
 gtk_widget_show_all (window);
}

int
main (int argc,
 char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new (NULL, G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}
Running the application from terminal
To run this application, first save it as hello-world.c. Then open Terminal, go to the folder where your application is stored.
Compile the program:
gcc
Run the program:
./
The
Running applications from the Terminal is useful at the beginning of the application making process. To have fully working
The example shows you the minimum requirements for a
[Desktop Entry]
Version=1.0
Encoding=UTF-8
Name=Hello World
Comment=Say Hello
Exec=@prefix@/bin/hello-world
Icon=application-default-icon
Terminal=false
Type=Application
StartupNotify=true
Categories=GNOME;GTK;Utility;
Now let's go through some parts of the
Name
The application name.
Comment
A short description of the application.
Exec
Specifies a command to execute when you choose the application from the menu. In this example exec just tells where to find the
Terminal
Specifies whether the command in the Exec key runs in a terminal window.
To put your application into the appropriate category, you need to add the necessary categories to the Categories line. More information on the different categories can be found in the
In this example we use an existing icon. For a custom icon you need to have a .svg file of your icon, stored in
The build system
To make your application truly a part of the GNOME 3 system you need to install it with the help of autotools. The autotools build will install all the necessary files to all the right places.
For this you need to have the following files:
autogen.sh
#!/bin/sh

set -e

test -n "$srcdir" || srcdir=`dirname "$0"`
test -n "$srcdir" || srcdir=.

olddir=`pwd`
cd "$srcdir"

# This will run autoconf, automake, etc. for us
autoreconf --force --install

cd "$olddir"

if test -z "$NOCONFIGURE"; then
 "$srcdir"/configure "$@"
fi
After the

Makefile.am
# The actual runnable program is set to the SCRIPTS primitive.
# # Prefix bin_ tells where to copy this
bin_PROGRAMS = hello-world
hello_world_CFLAGS = $(gtk_CFLAGS)
hello_world_LDADD = $(gtk_LIBS)
hello_world_SOURCES = hello-world.c

desktopdir = $(datadir)/applications
desktop_DATA = \\
 hello-world.desktop
configure.ac
# This file is processed by autoconf to create a configure script
AC_INIT([Hello World], 1.0)
AM_INIT_AUTOMAKE([1.10 no-define foreign dist-xz no-dist-gzip])
AC_PROG_CC
AM_PROG_VALAC([0.16])
PKG_CHECK_MODULES(gtk, gtk+-3.0)
AC_CONFIG_FILES([Makefile hello-world.desktop])

AC_OUTPUT
README
Information users should read first. This file can be blank.
When you have the
To build and install this program:

./autogen.sh --prefix=/home/your_username/.local
make
make install

-------------
Running the first line above creates the following files:

aclocal.m4
autom4te.cache
config.log
config.status
configure
depcomp
hello-world
hello-world.desktop
hello_world-hello-world.o
install-sh
missing
Makefile.in
Makefile

Running "make" links all the appropriate libraries.

Running "make install", installs the application in /home/your_username/.local/bin
and installs the hello-world.desktop file in /home/your_username/.local/share/applications

You can now run the application by typing "Hello World" in the Overview.

----------------
To uninstall, type:

make uninstall

----------------
To create a tarball type:

make distcheck

This will create hello-world-1.0.tar.xz
Hello World (JavaScript)
create a small "Hello, World" application using JavaScript and GTK+
This needs to be the first line of your script:
#!/usr/bin/gjs
It tells the script to use
const Lang = imports.lang;
const Gtk = imports.gi.Gtk;
In order for our script to work with GNOME, we need to import GNOME libraries via GObject Introspection. Here we import the language bindings and GTK+, the library which contains the graphical widgets used to make GNOME applications.
const Application = new Lang.Class({
 //A Class requires an explicit Name parameter. This is the Class Name.
 Name: 'Application',

 //create the application
 _init: function() {
 this.application = new Gtk.Application();

 //connect to 'activate' and 'startup' signals to handlers.
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 //create the UI
 _buildUI: function() {
 this._window = new Gtk.ApplicationWindow({ application: this.application,
 title: "Hello World!" });
 },

 //handler for 'activate' signal
 _onActivate: function() {
 //show the window and all child widgets
 this._window.show_all();
 },

 //handler for 'startup' signal
 _onStartup: function() {
 this._buildUI();
 }
});
We can start building our first window. We do this by creating a variable called
We give the window a property called
// Add a label widget to your window
this.label = new Gtk.Label({ label: "Hello World" });
this._window.add(this.label);
this._window.set_default_size(200, 200);
A text label is one of the GTK+ widgets we can use, on account of having imported the GTK+ library. To use it, we create a new variable called label, and assign it a new Gtk.Label. Then we give it properties inside the curly braces {}. In this case, we're setting the text that the label will hold. Finally, we create and run the application:
//run the application
let app = new Application();
app.application.run(ARGV);
Gtk.ApplicationWindow can only hold one widget at a time. To construct more elaborate programs you need to create a holder widget like Gtk.Grid inside the window, and then add all the other widgets to it.
hello-world.js
#!/usr/bin/gjs

const Lang = imports.lang;
const Gtk = imports.gi.Gtk;

const Application = new Lang.Class({
 //A Class requires an explicit Name parameter. This is the Class Name.
 Name: 'Application',

 //create the application
 _init: function() {
 this.application = new Gtk.Application();

 //connect to 'activate' and 'startup' signals to handlers.
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 //create the UI
 _buildUI: function() {
 this._window = new Gtk.ApplicationWindow({ application: this.application,
 title: "Hello World!" });
 this._window.set_default_size(200, 200);
 this.label = new Gtk.Label({ label: "Hello World" });
 this._window.add(this.label);
 },

 //handler for 'activate' signal
 _onActivate: function() {
 //show the window and all child widgets
 this._window.show_all();
 },

 //handler for 'startup' signal
 _onStartup: function() {
 this._buildUI();
 }
});

//run the application
let app = new Application();
app.application.run(ARGV);
To run this application, first save it as hello-world.js. Then open Terminal, go to the folder where your application is stored and run:

Before continuing, resave

# The actual runnable program is set to the SCRIPTS primitive.
# # Prefix bin_ tells where to copy this
bin_SCRIPTS = hello-world
# # List of files to be distributed
EXTRA_DIST = \\
 $(bin_SCRIPTS)
#
# # The desktop files
desktopdir = $(datadir)/applications
desktop_DATA = \\
 hello-world.desktop
# This file is processed by autoconf to create a configure script
AC_INIT([Hello World], 1.0)
AM_INIT_AUTOMAKE([1.10 no-define foreign dist-xz no-dist-gzip])
AC_CONFIG_FILES([Makefile hello-world.desktop])
AC_OUTPUT
When you have the
To build and install this program:

./autogen.sh --prefix=/home/your_username/.local
make install

-------------
Running the first line above creates the following files:

aclocal.m4
autom4te.cache
config.log
config.status
configure
hello-world.desktop
install-sh
missing
Makefile.in
Makefile

Running "make install", installs the application in /home/your_username/.local/bin
and installs the hello-world.desktop file in /home/your_username/.local/share/applications

You can now run the application by typing "Hello World" in the Overview.

----------------
To uninstall, type:

make uninstall

----------------
To create a tarball type:

make distcheck

This will create hello-world-1.0.tar.xz
Hello World (Python)
create a small "Hello, World" application using Python and GTK+
from gi.repository import Gtk
import sys
class MyWindow(Gtk.ApplicationWindow):

 # constructor for a Gtk.ApplicationWindow
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Hello World!", application=app)
 self.set_default_size(200, 100)

class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)
Gtk.Application initializes GTK+. It also connects the
We can start building our first window. We do this by creating a class called
# Add a label widget to your window

 # create a label
 label = Gtk.Label()

 # set the text of the label
 label.set_text("Hello GNOME!")

 # add the label to the window
 self.add(label)
A text label is one of the GTK+ widgets we can use, on account of having imported the GTK+ library. To use it, we create a variable called
#run the application

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
hello-world.py
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # constructor for a Gtk.ApplicationWindow

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)
 self.set_default_size(200, 100)

 # create a label
 label = Gtk.Label()
 # set the text of the label
 label.set_text("Hello GNOME!")
 # add the label to the window
 self.add(label)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
To run this application, first save it as hello-world.py. Then open Terminal, go to the folder where your application is stored and run:

# The actual runnable program is set to the SCRIPTS primitive.
# # Prefix bin_ tells where to copy this
bin_SCRIPTS = hello-world.py
# # List of files to be distributed
EXTRA_DIST= \\
 $(bin_SCRIPTS)
#
# # The desktop files
desktopdir = $(datadir)/applications
desktop_DATA = \\
 hello-world.desktop
Hello World (Vala)
class MyApplication : Gtk.Application {
 protected override void activate () {
 var window = new Gtk.ApplicationWindow (this);
 window.set_title ("Welcome to GNOME");
 window.set_default_size (200, 100);
 window.show_all ();
 }
}
We can start building our first window. We do this by creating a variable called
We give the window a title using
var label = new Gtk.Label ("Hello GNOME!");
 window.add (label);
int main (string[] args) {
 return new MyApplication ().run (args);
}
hello-world.vala
public class MyApplication : Gtk.Application {
 protected override void activate () {
 var window = new Gtk.ApplicationWindow (this);
 var label = new Gtk.Label ("Hello GNOME!");
 window.add (label);
 window.set_title ("Welcome to GNOME");
 window.set_default_size (200, 100);
 window.show_all ();
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}
To run this application, first save it as hello-world.vala. Then open Terminal, go to the folder where your application is stored.
valac --pkg gtk+-3.0
# The actual runnable program is set to the SCRIPTS primitive.
# # Prefix bin_ tells where to copy this
bin_PROGRAMS = hello-world
hello_world_CFLAGS = $(gtk_CFLAGS)
hello_world_LDADD = $(gtk_LIBS)
hello_world_VALAFLAGS = --pkg gtk+-3.0
hello_world_SOURCES = hello-world.vala

desktopdir = $(datadir)/applications
desktop_DATA = \\
 hello-world.desktop
To build and install this program:

./autogen.sh --prefix=/home/your_username/.local
make
make install

-------------
Running the first line above creates the following files:

aclocal.m4
autom4te.cache
config.log
config.status
configure
depcomp
hello-world
hello-world.c
hello-world.desktop
hello_world-hello-world.o
hello_world_vala.stamp
install-sh
missing
Makefile.in
Makefile

Running "make" links all the appropriate libraries.

Running "make install", installs the application in /home/your_username/.local/bin
and installs the hello-world.desktop file in /home/your_username/.local/share/applications

You can now run the application by typing "Hello World" in the Overview.

----------------
To uninstall, type:

make uninstall

----------------
To create a tarball type:

make distcheck

This will create hello-world-1.0.tar.xz
external ref='media/image.png' md5='9416aa74d9d6a857783f7a36338e7a02'
Image (C)
A widget displaying an image
Image
This GtkApplication displays an image file from the current directory.
If the image file isn't loaded successfully, the image will contain a "broken image" icon. The
#include &lt;gtk/gtk.hgt;



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *image;

 /*Create a window with a title and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Welcome to GNOME");
 gtk_window_set_default_size (GTK_WINDOW (window), 300, 300);

 image = gtk_image_new_from_file ("gnome-image.png");

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (image));

 gtk_widget_show_all (GTK_WIDGET (window));
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example",G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}

Image (JavaScript)
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ImageExample = new Lang.Class ({
 Name: 'Image Example',

 /* Create the application itself
 This boilerplate code is needed to build any GTK+ application. */
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jsimage',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal initializes menus and builds the UI
 _onStartup: function () {
 this._buildUI ();
 },




 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Welcome to GNOME",
 default_height: 300,
 default_width: 300 });

 // Create the label
 this.jsimage = new Gtk.Image ({file: "gnome-image.png"});
 this._window.add (this.jsimage);

 // Show the window and all child widgets
 this._window.show_all();
 }


});

// Run the application
let app = new ImageExample ();
app.application.run (ARGV);

Image (Python)
Sindhu S
2014
If the image file is not loaded successfully, the image will contain a "broken image" icon.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # create a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)
 self.set_default_size(300, 300)

 # create an image
 image = Gtk.Image()
 # set the content of the image as the file filename.png
 image.set_from_file("gnome-image.png")
 # add the image to the window
 self.add(image)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Another way to obtain what we have in the example is to create the image as an instance of another class and add it to the instance of
# a class to create a window
 class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)
 self.set_default_size(300, 300)

 # a class to create an image
 class MyImage(Gtk.Image):
 def __init__(self):
 Gtk.Image.__init__(self)
 self.set_from_file("gnome-image.png")

 class MyApplication(Gtk.Application):
 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 # create an instance of MyWindow
 win = MyWindow(self)
 # create an instance of MyImage and add it to the window
 win.add(MyImage())
 # show the window and everything on it
 win.show_all()
To use this code snippet, you will need to add the code that imports
Useful methods for an Image widget
To load an image over a network use
from gi.repository import Gtk
 from gi.repository import GdkPixbuf
 import sys

 class MyWindow(Gtk.ApplicationWindow):
 # create a window
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)
 self.set_default_size(300, 300)

 # create a pixbuf from file filename="gnome-image.png", with width=32
 # and height=64 amd boolean preserve_aspect_ratio=False.
 pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_scale("gnome-image.png", 64, 128, False)

 # create an image
 image = Gtk.Image()
 # set the content of the image as the pixbuf
 image.set_from_pixbuf(pixbuf)
 # add the image to the window
 self.add(image)
If
For loading from an input stream, see


Image (Vala)
public class MyWindow : Gtk.ApplicationWindow {
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Welcome to GNOME");

 var image = new Gtk.Image ();
 image.set_from_file ("gnome-image.png");
 this.add (image);
 this.set_default_size (300, 300);
 }
}

public class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show_all ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}



external ref='media/image-viewer.png' md5='7720360611243b14283b83527be968c2'
Image viewer (C)
A little bit more than a simple "Hello world" Gtk application.
Image viewer
In this tutorial, you will learn:
Some basic concepts of C/GObject programming
How to write a Gtk application in C
Choose
Make sure that
C is a rather verbose language, so don't be surprised that the file contains quite a lot of code. Most of it is template code. It loads an (empty) window and shows it. More details are given below; skip this list if you understand the basics:
The
Creating the user interface
Now we will bring life into the empty window. GTK organizes the user interface with
static GtkWidget*
create_window (void)
{
 GtkWidget *window;
 GtkWidget *button;
 GtkWidget *image;
 GtkWidget *box;

 /* Set up the UI */
 window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
 gtk_window_set_title (GTK_WINDOW (window), "image-viewer-c");

 box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 5);
 button = gtk_button_new_with_label (_("Open image"));
 image = gtk_image_new ();

 gtk_box_pack_start (GTK_BOX (box), image, TRUE, TRUE, 0);
 gtk_box_pack_start (GTK_BOX (box), button, FALSE, FALSE, 0);

 gtk_container_add (GTK_CONTAINER (window), box);

 /* Connect signals */

 /* Show open dialog when opening a file */
 g_signal_connect (button, "clicked", G_CALLBACK (on_open_image), image);

 /* Exit when the window is closed */
 g_signal_connect (window, "destroy", G_CALLBACK (gtk_main_quit), NULL);

 return window;
}
The first lines create the widgets we want to use: a button for opening up an image, the image view widget itself and the box we will use as a container. The macros like
The calls to
We need to define what happens when the user clicks on the button. GTK uses the concept of
The last
As a last step, make sure to replace the
Showing the image
We will now define the signal handler for the
static void
on_open_image (GtkButton* button, gpointer user_data)
{
 GtkWidget *image = GTK_WIDGET (user_data);
 GtkWidget *toplevel = gtk_widget_get_toplevel (image);
 GtkFileFilter *filter = gtk_file_filter_new ();
 GtkWidget *dialog = gtk_file_chooser_dialog_new (_("Open image"),
 GTK_WINDOW (toplevel),
 GTK_FILE_CHOOSER_ACTION_OPEN,
 GTK_STOCK_OK, GTK_RESPONSE_ACCEPT,
 GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
 NULL);

 gtk_file_filter_add_pixbuf_formats (filter);
 gtk_file_chooser_add_filter (GTK_FILE_CHOOSER (dialog),
 filter);

 switch (gtk_dialog_run (GTK_DIALOG (dialog)))
 {
 case GTK_RESPONSE_ACCEPT:
 {
 gchar *filename =
 gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
 gtk_image_set_from_file (GTK_IMAGE (image), filename);
 break;
 }
 default:
 break;
 }
 gtk_widget_destroy (dialog);
}
This is a bit more complicated than anything we've attempted so far, so let's break it down:
The first argument of the signal is always the widget that sent the signal. Sometimes other arguments related to the signal come after that, but
The next interesting line is where the dialog for choosing the file is created using
Notice that we are using
The next two lines restrict the

Assuming that the user did click
In the final line of this method, we destroy the
If you haven't already done so, choose the
If you run into problems with the tutorial, compare your code with this
Have the user select a directory rather than a file, and provide controls to cycle through all of the images in a directory.
Apply random filters and effects to the image when it is loaded and allow the user to save the modified image.

Allow the user to load images from network shares, scanners, and other more complicated sources.
You can use
A little bit more than a simple "Hello world" GTKmm application.
Some basic concepts of C++/GObject programming
How to write a Gtk application in C++
Choose
Make sure that
Click
#include &lt;gtkmm.hgt;
#include &lt;iostreamgt;

#include "config.h"gt;
The three
The
The
Now we will bring life into the empty window. GTKmm organizes the user interface with
int
main (int argc, char *argv[])
{
 Gtk::Main kit(argc, argv);

 Gtk::Window main_win;
 main_win.set_title ("image-viewer-cpp");

 Gtk::Box* box = Gtk::manage(new Gtk::Box());
 box-gt;set_orientation (Gtk::ORIENTATION_VERTICAL);
 box-gt;set_spacing(6);
 main_win.add(*box);

 image = Gtk::manage(new Gtk::Image());
 box-gt;pack_start (*image, true, true);

 Gtk::Button* button = Gtk::manage(new Gtk::Button("Open Image…"));
 button-gt;signal_clicked().connect (
 sigc::ptr_fun(amp;on_open_image));
 box-gt;pack_start (*button, false, false);

 main_win.show_all_children();
 kit.run(main_win);

 return 0;
}
The first lines create the widgets we want to use: a button for opening up an image, the image view widget itself and the box we will use as a container.
The calls to
We need to define what happens when the user clicks on the button. GTKmm uses the concept of
The last step is to show all widgets in the window using
We will now define the signal handler for the
Gtk::Image* image = 0;

static void
on_open_image ()
{
 Gtk::FileChooserDialog dialog("Open image",
 Gtk::FILE_CHOOSER_ACTION_OPEN);
 dialog.add_button (Gtk::Stock::OPEN,
 Gtk::RESPONSE_ACCEPT);
 dialog.add_button (Gtk::Stock::CANCEL,
 Gtk::RESPONSE_CANCEL);

 Glib::RefPtrlt;Gtk::FileFiltergt; filter =
 Gtk::FileFilter::create();
 filter-gt;add_pixbuf_formats();
 filter-gt;set_name("Images");
 dialog.add_filter (filter);

 const int response = dialog.run();
 dialog.hide();

 switch (response)
 {
 case Gtk::RESPONSE_ACCEPT:
 image-gt;set(dialog.get_filename());
 break;
 default:
 break;
 }
}
The dialog for choosing the file is created using the
The next two lines add an
The second argument to the
The next two lines restrict the


We hide the
Assuming that the user did click
If you run into problems with the tutorial, compare your code with this
Image viewer (JavaScript)
A little bit more than a simple "Hello world" application - write an image viewer in GTK+. Includes an introduction to the JavaScript language.
Jonh Wendell
In this tutorial, we're going to write a very simple GTK application that loads and displays an image file. You will learn how to:
Write a basic GTK user interface in JavaScript
Deal with events by connecting signals to signal handlers
Lay out GTK user interfaces using containers
Load and display image files
An installed copy of the
Basic knowledge of any object-orientated programming language
Choose
Click
JavaScript basics: Hello World
Before we start writing the image viewer, let's find out more about the way JavaScript is used in GNOME. Of course, your very first contact with any programming language should be the Hello World program which can already be found in
print ("Hello world!");
This should look quite natural if you're familiar with almost any other programming language. The function
Classes in JavaScript
This is the standard way to define a class in JavaScript:
function MyClass () {
 this._init ();
}

MyClass.prototype = {

 _init: function () {
 this.propertyA = "This is an object's field";
 this.propertyB = 10;
 },

 aMethod: function (arg1, arg2) {
 print ("inside aMethod: " + arg1 + " " + arg2);
 },

 dumpProperties: function () {
 print (this.propertyA);
 print (this.propertyB);
 }

}
This defines a class called

The
The first method defined here is called
_init: function ()
We write the function inside some curly braces. Two fields are defined here,
The next method is called
Note how the class definition (prototype) is arranged; each function definition is separated by a comma.
Now that MyClass has been defined, we can play with it:
var o = new MyClass ();
o.aMethod ("Hello", "world");
o.propertyA = "Just changed its value!";
o.dumpProperties ();
This code creates a new instance of the class called
Save the code in the
A first Gtk application
Let's see what a very basic Gtk application looks like in JavaScript:
const Gtk = imports.gi.Gtk;

Gtk.init (null, null);

var w = new Gtk.Window ({title: "Image Viewer Demo"});
w.show ();

Gtk.main ();
Let's take a look at what's happening:
The first line imports the Gtk namespace (that is, it includes the Gtk library). The libraries are provided by GObject Introspection (gi), which provides language bindings for many GNOME libraries.

The next line creates the main window by creating a new
The next line explicitly shows the window. In Gtk, every widget is hidden by default.
Finally,
Save the code in
Adding classes
The proper way of doing Gtk programming is by using classes. Let's rewrite the simple code you just wrote using classes:
const Gtk = imports.gi.Gtk;

function ImageViewer () {
 this._init ();
}

ImageViewer.prototype = {
 _init: function () {
 this.window = new Gtk.Window ({title: "Image Viewer Demo"});
 this.window.show ();
 }
}

Gtk.init (null, null);
var iv = new ImageViewer ();
Gtk.main ();
Notice that the program is the same; we just moved the window creation code to our own
This code is modular and can be split into multiple files easily. This makes it cleaner and easier to read.
Signals
Signals are one of the key concepts in Gtk programming. Whenever something happens to an object, it emits a signal; for example, when a button is clicked it gives off the
function button_clicked () {
 print ("you clicked me!");
}
var b = new Gtk.Button ({label:"Click me"});
b.connect ("clicked", button_clicked);
The last two lines create a
The syntax for connecting any signal to a function is:
object.connect (lt;signal_namegt;, &lt;function_to_be_calledgt;);
You can find signal definitions for any object in the
You can simplify the code by making use of an inline function definition:
b.connect ("clicked", function () { print ("you clicked me!"); });
Closing the window
When you close a Gtk window it's not really closed, it's hidden. This allows you to keep the window around (which is useful if you want to ask the user if they really want to close the window, for example).
In our case, we really do just want to close the window. The simplest way of doing this is by connecting the
this.window.connect ("hide", Gtk.main_quit);
This connects the
Containers: Laying-out the user interface
Widgets (controls, such as buttons and labels) can be arranged in the window by making use of
A
There is a graphical user interface designer called
Let's add the box and widgets to the window. Insert the following code into the
var main_box = new Gtk.Box ({orientation: Gtk.Orientation.VERTICAL, spacing: 0});
this.window.add (main_box);
The first line creates a
So far the window only contains an empty
Packing: Adding widgets to the container
To add some widgets to the
this.image = new Gtk.Image ();
main_box.pack_start (this.image, true, true, 0);
The first line creates a new

Gtk containers (and widgets) dynamically expand to fill the available space, if you let them. You don't position widgets by giving them a precise x,y-coordinate location in the window; rather, they are positioned relative to one another. This makes handling window resizing much easier, and widgets should automatically take a sensible size in most situations.
Also note how the widgets are organized in a hierarchy. Once packed in the
Now insert these two lines, below the two you just added:
var open_button = new Gtk.Button ({label: "Open a picture..."});
main_box.pack_start (open_button, false, false, 0);
These lines are similar to the first two, but this time they create a
Finally, we must change the
this.window.show_all ();
This will show the child of the Gtk window, and all of its children, and its children's children, and so on. (Remember that Gtk widgets are all hidden by default.)
Loading the image: Connecting to the button's
When the user clicks on the
The first step is to connect the
open_button.connect ("clicked", Lang.bind (this, this._openClicked));
We are using the
const Lang = imports.lang;
Loading the image: Writing the signal's callback
Now we can create the
_openClicked: function () {
 var chooser = new Gtk.FileChooserDialog ({title: "Select an image",
 action: Gtk.FileChooserAction.OPEN,
 transient_for: this.window,
 modal: true});
 chooser.add_button (Gtk.STOCK_CANCEL, 0);
 chooser.add_button (Gtk.STOCK_OPEN, 1);
 chooser.set_default_response (1);

 var filter = new Gtk.FileFilter ();
 filter.add_pixbuf_formats ();
 chooser.filter = filter;

 if (chooser.run () == 1)
 this.image.file = chooser.get_filename ();

 chooser.destroy ();
 }
The line beginning with
The next two lines add

The next three lines restrict the

Assuming that the user did click
In the final line of this method, we destroy the
All of the code you need should now be in place, so try running the code. That should be it; a fully-functioning image viewer (and a whistlestop tour of JavaScript and Gtk) in not much time at all!
If you run into problems with the tutorial, compare your code with this
Image viewer (Python)
A little bit more than a simple "Hello world" application - write an image viewer in GTK.
Write a basic GTK user interface in Python
Basic knowledge of the python programming language
Choose
Be sure to disable
Click
Let's see what a very basic Gtk application looks like in Python:
from gi.repository import Gtk, GdkPixbuf, Gdk
import os, sys

class GUI:
 def __init__(self):
 window = Gtk.Window()
 window.set_title ("Hello World")
 window.connect_after('destroy', self.destroy)

 window.show_all()

 def destroy(window, self):
 Gtk.main_quit()

def main():
 app = GUI()
 Gtk.main()

if __name__ == "__main__":
 sys.exit(main())
In the
Next,
The rest of the file does initialisation for Gtk and displays the GUI.
This code is ready to run, so try it using
def button_clicked () :
 print "you clicked me!"

b = new Gtk.Button ("Click me")
b.connect_after ('clicked', button_clicked)
Let's add the box and widgets to the window. Insert the following code into the
box = Gtk.Box()
box.set_spacing (5)
box.set_orientation (Gtk.Orientation.VERTICAL)
window.add (box)
The first line creates a
To add some widgets to the
self.image = Gtk.Image()
box.pack_start (self.image, False, False, 0)
The first line creates a new

button = Gtk.Button ("Open a picture...")
box.pack_start (button, False, False, 0)
These lines are similar to the first two, but this time they create a
When the user clicks on the
The first step is to connect the
button.connect_after('clicked', self.on_open_clicked)
This will connect the
Now we can create the
def on_open_clicked (self, button):
 dialog = Gtk.FileChooserDialog ("Open Image", button.get_toplevel(), Gtk.FileChooserAction.OPEN);
 dialog.add_button (Gtk.STOCK_CANCEL, 0)
 dialog.add_button (Gtk.STOCK_OK, 1)
 dialog.set_default_response(1)

 filefilter = Gtk.FileFilter ()
 filefilter.add_pixbuf_formats ()
 dialog.set_filter(filefilter)

 if dialog.run() == 1:
 self.image.set_from_file(dialog.get_filename())

 dialog.destroy()
The line beginning with

All of the code you need should now be in place, so try running the code. That should be it; a fully-functioning image viewer (and a whistlestop tour of Python and Gtk) in not much time at all!
If you run into problems with the tutorial, compare your code with this
Image viewer (Vala)
A little bit more than a simple "Hello world" GTK+ application.
Philip Chimento
In this tutorial you will create an application which opens and displays an image file. You will learn:
How to set up a basic project using the
How to write a
Some basic concepts of
You may find the
From the
Make sure that
You will learn how to use the interface builder in the
Click
using GLib;
using Gtk;

public class Main : Object
{

 public Main ()
 {
 Window window = new Window();
 window.set_title ("Hello World");
 window.show_all();
 window.destroy.connect(on_destroy);
 }

 public void on_destroy (Widget window)
 {
 Gtk.main_quit();
 }

 static int main (string[] args)
 {
 Gtk.init (ref args);
 var app = new Main ();

 Gtk.main ();

 return 0;
 }
}
The code loads an (empty) window from the user interface description file and shows it. More details are given below; skip this list if you understand the basics:
The two
The constructor of the
The
Change the
Now we will bring life into the empty window. GTK organizes the user interface with
Add the following lines to the top of the
private Window window;
private Image image;
Now replace the current constructor with the one below:
public Main () {

 window = new Window ();
 window.set_title ("Image Viewer in Vala");

 // Set up the UI
 var box = new Box (Orientation.VERTICAL, 5);
 var button = new Button.with_label ("Open image");
 image = new Image ();

 box.pack_start (image, true, true, 0);
 box.pack_start (button, false, false, 0);
 window.add (box);

 // Show open dialog when opening a file
 button.clicked.connect (on_open_image);

 window.show_all ();
 window.destroy.connect (main_quit);
}
The first two lines are the parts of the GUI that we will need to access from more than one method. We declare them up here so that they are accessible throughout the class instead of only in the method where they are created.
The first lines of the constructor create the empty window. The next lines create the widgets we want to use: a button for opening up an image, the image view widget itself and the box we will use as a container.
The calls to
We need to define what happens when the user clicks on the button. GTK uses the concept of
When the
This is done using the
In the callback, we need to access the
The last
We will now define the signal handler for the
public void on_open_image (Button self) {
 var filter = new FileFilter ();
 var dialog = new FileChooserDialog ("Open image",
 window,
 FileChooserAction.OPEN,
 Stock.OK, ResponseType.ACCEPT,
 Stock.CANCEL, ResponseType.CANCEL);
 filter.add_pixbuf_formats ();
 dialog.add_filter (filter);

 switch (dialog.run ())
 {
 case ResponseType.ACCEPT:
 var filename = dialog.get_filename ();
 image.set_from_file (filename);
 break;
 default:
 break;
 }
 dialog.destroy ();
}
This is a bit complicated, so let's break it down:
A signal handler is a type of callback method that is called when a signal is emitted. Here the terms are used interchangeably.
The first argument of the callback method is always the widget that sent the signal. Sometimes other arguments related to the signal come after that, but
In this case the
button.clicked.connect (on_open_image);
The
public void on_open_image (Button self)
The next interesting line is where the dialog for choosing the file is created.
Notice that we are using
The next two lines restrict the

Assuming that the user did click
Destroying automatically hides the dialog.
If you haven't already done so, choose the
If you run into problems with the tutorial, compare your code with this
Set it up so that when the window opens it is of a specific size to start off with. For example, 200 X 200 pixels.
GNOME Documentation Team
2010, 2011
Shaun McCance
2010
GNOME Developer Platform Demos
How to set up your development environment
Tutorials, code samples, platform demos and more
Get Involved
JavaScript
Ekaterina Gerasimova
Tutorials, code samples and platform demos in JavaScript
Code samples and tutorials
external ref='media/label.png' md5='734975c18653d88379f983e4501c3fc0'
Label (C)
A widget which displays text
Label
A simple label
#include &lt;gtk/gtk.hgt;



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *label;

 /*Create a window with a title and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_application (GTK_WINDOW (window), GTK_APPLICATION (app));
 gtk_window_set_title (GTK_WINDOW (window), "Welcome to GNOME");
 gtk_window_set_default_size (GTK_WINDOW (window), 200,100);
 
 /*Create a label and set its alignment. Setting the line wrap to TRUE makes 
 the label break lines if the text exceeds the widget's size. When set to 
 FALSE the text gets cut off by the edge of the widget*/
 label = gtk_label_new ("Hello GNOME!");
 gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_CENTER);
 gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (label));

 gtk_widget_show_all (GTK_WIDGET (window));
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example",G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}

Label (JavaScript)
A label which can contain text
A label displaying a friendly message.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const LabelExample = new Lang.Class ({
 Name: 'Label Example',

 /* Create the application itself
 This boilerplate code is needed to build any GTK+ application. */
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jslabel',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal initializes menus and builds the UI
 _onStartup: function () {
 this._buildUI ();
 },




 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Welcome to GNOME",
 default_height: 100,
 default_width: 200 });

 // Create the label
 this.label = new Gtk.Label ({label: "Hello GNOME!"});
 this._window.add (this.label);

 // Show the window and all child widgets
 this._window.show_all();
 }


});

// Run the application
let app = new LabelExample ();
app.application.run (ARGV);

Label (Python)
A widget that displays a small to medium amount of text
Another way to obtain what we have in the example is to create the label as an instance of another class and add it to the instance of
The highlighted lines indicate code that is different from the previous snippet.
# a class to define a window
class MyWindow(Gtk.ApplicationWindow):
 def __init__(self, app):
 Gtk.Window.__init__(self, title="Welcome to GNOME", application=app)
 self.set_default_size(200, 100)

# a class to define a label
Useful methods for a Label widget
An explanation of how to work with strings in GTK+ can be found in


For decorated text we can use
label.set_markup("Text can be &lt;smallgt;smalllt;/smallgt;, &lt;biggt;biglt;/biggt;, "
 "lt;bgt;boldlt;/bgt;, &lt;igt;italiclt;/igt; and even point to somewhere "
 "in the &lt;a href=\\"http://www.gtk.org\\" "
 "title=\\"Click to find out more\\"gt;internetslt;/agt;.")
Label (Vala)
public class MyWindow : Gtk.ApplicationWindow {
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Welcome to GNOME");

 var label = new Gtk.Label ("Hello GNOME!");

 this.add (label);
 this.set_default_size (200, 100);
 this.show_all ();
 }
}

public class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}
Legal information.
License
This work is distributed under a CreativeCommons Attribution-Share Alike 3.0 Unported license.
You are free:

To copy, distribute and transmit the work.

To adapt the work.
Under the following conditions:

You must attribute the work in the manner specified by the author or licensor (but not in any way that suggests that they endorse you or your use of the work).

If you alter, transform, or build upon this work, you may distribute the resulting work only under the same, similar or a compatible license.
For the full text of the license, see the
As a special exception, the copyright holders give you permission to copy, modify, and distribute the example code contained in this documentation under the terms of your choosing, without restriction.
external ref='media/linkbutton.png' md5='3712eae8953e87c65a6aa74503b8e32b'
LinkButton (C)
Create buttons bound to a URL
LinkButton
This button links to the GNOME live webpage.
#include &lt;gtk/gtk.hgt;

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *linkbutton;

 window = gtk_application_window_new (app);

 gtk_window_set_title (GTK_WINDOW (window), "GNOME LinkButton");
 gtk_window_set_default_size (GTK_WINDOW (window), 250, 50);

 linkbutton = gtk_link_button_new ("Link to GNOME live!");
 gtk_link_button_set_uri (GTK_LINK_BUTTON(linkbutton), "http://live.gnome.org");

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (linkbutton));

 gtk_widget_show_all (window);
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

LinkButton (JavaScript)
A button that links to a web page
A button that links to live.gnome.org.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const LinkButtonExample = new Lang.Class ({
 Name: 'LinkButton Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jslinkbutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal initializes menus and builds the UI
 _onStartup: function () {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "GNOME LinkButton",
 default_height: 50,
 default_width: 250 });

 // Create the LinkButton and have it link to live.gnome.org
 this.LinkButton = new Gtk.LinkButton ({label: "Link to GNOME live!",
 uri: "http://live.gnome.org"});
 this._window.add (this.LinkButton);

 // Show the window and all child widgets
 this._window.show_all();
 },
});

// Run the application
let app = new LinkButtonExample ();
app.application.run (ARGV);

LinkButton (Python)
A button bound to an URL
A button that links to a web page.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="GNOME LinkButton", application=app)
 self.set_default_size(250, 50)

 # a linkbutton pointing to the given URI
 button = Gtk.LinkButton(uri="http://live.gnome.org")
 # with given text
 button.set_label("Link to GNOME live!")

 # add the button to the window
 self.add(button)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a LinkButton widget


Each time the button is clicked, the signal

LinkButton (Vala)
This button links to GNOME live.
/* This is the application. */
public class MyApplication : Gtk.Application {
 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {

 /* Create the window of this application and child widget and show all the things. */
 var window = new Gtk.ApplicationWindow (this);
 window.set_default_size (250, 50);
 window.title = "GNOME LinkButton";

 var linkbutton = new Gtk.LinkButton.with_label ("http://live.gnome.org", "Link to GNOME live!");

 window.add (linkbutton);
 window.show_all ();
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/magic-mirror.png' md5='8171faea6ed3b6ddac0da084c29e4e22'
Magic mirror (Vala)
Use your webcam as a mirror using the GStreamer framework and GTK+
Daniel G. Siegel
Magic mirror

In this tutorial, we're going to make a program which lets you use your webcam as a mirror. You will learn how to:
Create a GTK+ application
Access your webcam using GStreamer and embed the result into a window
Grab photos off your webcam
Installed copies of GTK, GStreamer, and a Vala compiler
Basic knowledge of an object-oriented programming language
Choose
Disable
Make sure that
Click
The code loads an (empty) window and shows it. More details are given below; skip this list if you understand the basics:
The constructor of the
The static
Access the webcam video stream with GStreamer
The GStreamer multimedia framework is able to handle video from webcams. Let's add GStreamer to our application and so we can access the video stream.
using GLib;
using Gtk;

public class Main : Object
{
 private Gst.Element camerabin;

 public Main () {
 this.camerabin = Gst.ElementFactory.make ("camerabin", "camera");
 this.camerabin.set_state (Gst.State.PLAYING);
 }

 static int main (string[] args) {
 Gtk.init (ref args);
 Gst.init (ref args);
 var app = new Main ();

 Gtk.main ();

 return 0;
 }
}
First we remove the window we created before because GStreamer will take care of showing the picture on screen.
Now we are creating a GStreamer element which accesses our webcam. We are using the Camerabin element, which is an all-in-one camera element and is capable of taking photos, videos, applying effects and much more. Perfect for our use case! With
Of course it is also possible to integrate the video more tighly into other windows but that is an advanced topic that includes some details of the X Window System we will omit here.
Compile and run it again. You will end up with two windows. In the next step we will integrate the video into the GTK+ window.
If you run into problems with the tutorial, compare your code with this
To find out more about the Vala programming language you might want to check out the
Conclusion
That's it, you have managed to create a full-featured webcam photo application in 15 minutes. Now you can shave your beard off or add some makeup to your beautiful face, right before having a beautiful day at your workplace, where you can impress your friends and colleagues with an awesome application you just made in 15 minutes.
external ref='media/menubar.png' md5='7b642aaa1628d5e43ab85ac230ac1c78'
MenuBar (C)
A widget which holds GtkMenuItem widgets
MenuBar
A MenuBar created using XML and GtkBuilder.
For a more in-depth look at this sample, please do not hesitate to check out the
#include &lt;gtk/gtk.hgt;



/* Callback function for the "copy" action */
static void
copy_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("\\"Copy\\" activated\
");
}



/* Callback function for the "paste" action */
static void
paste_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("\\"Paste\\" activated\
");
}



/* Callback function for the "shape" action */
static void
shape_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 /* We first gather the value of the GVariant instance with a string type.
 * The overall goal here is to see if shape is set to line, triangle, etc,
 * and put that value within the variable "answer".
 */
 const gchar *answer = g_variant_get_string (parameter, NULL);
 g_printf ("Shape is set to %s.\
", answer);
 /* Note that we set the state of the action */
 g_simple_action_set_state (simple, parameter);
}



/* Callback function in which closes the about_dialog created below */
static void
on_close (GtkDialog *dialog,
 gint response_id,
 gpointer user_data)
{
 gtk_widget_destroy (GTK_WIDGET (dialog));
}



/* Callback function for the about action (see aboutdialog.c example) */
static void
about_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GtkWidget *about_dialog;

 about_dialog = gtk_about_dialog_new ();

 const gchar *authors[] = {"GNOME Documentation Team", NULL};
 const gchar *documenters[] = {"GNOME Documentation Team", NULL};

 /* Fill in the about_dialog with the desired information */
 gtk_about_dialog_set_program_name (GTK_ABOUT_DIALOG (about_dialog), "AboutDialog Example");
 gtk_about_dialog_set_copyright (GTK_ABOUT_DIALOG (about_dialog), "Copyright \\xc2\\xa9 2012 GNOME Documentation Team");
 gtk_about_dialog_set_authors (GTK_ABOUT_DIALOG (about_dialog), authors);
 gtk_about_dialog_set_documenters (GTK_ABOUT_DIALOG (about_dialog), documenters);
 gtk_about_dialog_set_website_label (GTK_ABOUT_DIALOG (about_dialog), "GNOME Developer Website");
 gtk_about_dialog_set_website (GTK_ABOUT_DIALOG (about_dialog), "http://developer.gnome.org");

 /* The "response" signal is emitted when the dialog receives a delete event,
 * therefore we connect that signal to the on_close callback function
 * created above.
 */
 g_signal_connect (GTK_DIALOG (about_dialog), "response",
 G_CALLBACK (on_close), NULL);

 /* Show the about dialog */
 gtk_widget_show (about_dialog);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;

 GSimpleAction *copy_action;
 GSimpleAction *paste_action;
 GSimpleAction *shape_action;
 GSimpleAction *about_action;

 /* Create a window with a title and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "MenuBar Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);

 /* Begin creating the "copy" action.
 * Note that it is an action without a state.
 */
 copy_action = g_simple_action_new ("copy", NULL);
 /* Connected to a callback function */
 g_signal_connect (copy_action, "activate", G_CALLBACK (copy_callback),
 GTK_WINDOW (window));
 /* Added to the window */
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (copy_action));

 /* Begin creating the "paste" action.
 * Note that it is an action without a state.
 */
 paste_action = g_simple_action_new ("paste", NULL);
 /* Connect the action to a callback function */
 g_signal_connect (paste_action, "activate", G_CALLBACK (paste_callback),
 GTK_WINDOW (window));
 /* Add it to the window */
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (paste_action));

 /* Begin creating the "shape" action.
 * Note that it is an action with a state.
 * First we state that the parameter type of the simple action is a string.
 * When using g_variant_type_new, it is appropriate to free the return value
 * once you're done with it.
 */
 GVariantType *type_string = g_variant_type_new ("s");
 /* parameters for the g_simple_action_new_stateful are: (name, parameter type,
 * initial state).
 */
 shape_action = g_simple_action_new_stateful ("shape", type_string,
 g_variant_new_string ("line"));
 /* Connect the action to a callback function */
 g_signal_connect (shape_action, "activate", G_CALLBACK (shape_callback),
 GTK_WINDOW (window));
 /* Add it to the window */
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (shape_action));
 g_variant_type_free (type_string);

 /* Begin creating the "about" action.
 * Note that it is an action without a state.
 */
 about_action = g_simple_action_new ("about", NULL);
 /* Connect the action to a callback function */
 g_signal_connect (about_action, "activate", G_CALLBACK (about_callback),
 GTK_WINDOW (window));
 /* Add it to the window */
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (about_action));

 gtk_widget_show_all (window);
}



/* Callback function for the "new" action */
static void
new_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"New\\"\
");
}



/* Callback function for the "quit" action */
static void
quit_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GApplication *application = user_data;

 g_print ("You clicked \\"Quit\\"\
");
 g_application_quit (application);
}



/* Callback function for the "state" action */
static void
state_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 /* The two possibilies in this case for the "answer" variable are either
 * "on" or "off".
 */
 const gchar *answer = g_variant_get_string (parameter, NULL);
 /* We print the information to the user */
 g_printf ("State is set to %s.\
", answer);
 /* Note that we set the state of the action */
 g_simple_action_set_state (simple, parameter);
}



/* Callback function for the "awesome" action */
static void
awesome_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GVariant *action_state = g_action_get_state (G_ACTION (simple));
 gboolean active = g_variant_get_boolean (action_state);
 GVariant *new_state = g_variant_new_boolean (!active);
 /* Set the new state for the action.
 * (Keeps track of whether it was last checked or unchecked).
 */
 g_simple_action_set_state (simple, new_state);

 if (active)
 g_print ("You unchecked \\"Awesome\\"\
");
 else
 g_print ("You checked \\"Awesome\\"\
");
}



/* Startup function for the menu we are creating in this sample */
static void
startup (GApplication *app,
 gpointer user_data)
{
 /* Initialize variables */
 GSimpleAction *new_action;
 GSimpleAction *quit_action;
 GSimpleAction *state_action;
 GSimpleAction *awesome_action;

 GtkBuilder *builder;

 GError *error = NULL;

 /* Begin creating the "new" action.
 * Note that it is an action without a state.
 */
 new_action = g_simple_action_new ("new", NULL);
 g_signal_connect (new_action, "activate", G_CALLBACK (new_callback), app);
 /* It is added to the overall application */
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (new_action));

 /* Begin creating the "quit" action.
 * Note that it is an action without a state.
 */
 quit_action = g_simple_action_new ("quit", NULL);
 g_signal_connect (quit_action, "activate", G_CALLBACK (quit_callback), app);
 /* It is added to the overall application */
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (quit_action));

 /* Begin creating the "state" action.
 * Note that it is an action with a state.
 */
 GVariantType *type_string2 = g_variant_type_new ("s");
 state_action = g_simple_action_new_stateful ("state", type_string2,
 g_variant_new_string ("off"));
 g_signal_connect (state_action, "activate", G_CALLBACK (state_callback), app);
 /* It is added to the overall application */
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (state_action));
 g_variant_type_free (type_string2);

 /* Begin creating the "awesome" action.
 * Note that it is an action with a state.
 */
 awesome_action = g_simple_action_new_stateful ("awesome", NULL, g_variant_new_boolean (FALSE));
 g_signal_connect (awesome_action, "activate", G_CALLBACK (awesome_callback), app);
 /* It is added to the overall application */
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (awesome_action));

 /* A builder to add the User Interface designed with GLADE to the grid: */
 builder = gtk_builder_new ();
 /* Get the file (if it is there):
 * Note: you must make sure that the file is in the current directory for
 * this to work. The function used here returns a non-null value within
 * our variable "error" if an error is indeed found.
 */
 gtk_builder_add_from_file (builder, "menubar.ui", &error);
 if (error != NULL) {
 g_print ("%s\
", error-gt;message);
 g_error_free (error);
 }

 /* Extract the menubar */
 GObject *menubar = gtk_builder_get_object (builder, "menubar");
 gtk_application_set_menubar (GTK_APPLICATION (app), G_MENU_MODEL (menubar));

 /* Extract the appmenu */
 GObject *appmenu = gtk_builder_get_object (builder, "appmenu");
 gtk_application_set_app_menu (GTK_APPLICATION (app), G_MENU_MODEL (appmenu));
}



/* Startup function for the application */
int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 g_signal_connect (app, "startup", G_CALLBACK (startup), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}



external ref='media/menubar_choices.png' md5='47cdfa12caf85ba20dd3e835bd7f893f'
MenuBar (Python)
MenuBar created using XML and GtkBuilder
Create a MenuBar using XML
To create the menubar using XML:
Create
Enter the following line at the top of the file:
&lt;?xml version="1.0"? encoding="UTF-8"?gt;
We want to create the interface which will contain our menubar and its submenus. Our menubar will contain
&lt;?xml version="1.0" encoding="UTF-8"?gt;
&lt;interfacegt;
 &lt;menu id="menubar"gt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Filelt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Editlt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Choiceslt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Helplt;/attributegt;
 &lt;/submenugt;
 &lt;/menugt;
&lt;/interfacegt;
Now we will create the .py file and use GtkBuilder to import the
Add the MenuBar to the window using GtkBuilder
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="MenuBar Example", application=app)
 self.set_default_size(200, 200)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 # a builder to add the UI designed with Glade to the grid:
 builder = Gtk.Builder()
 # get the file (if it is there)
 try:
 builder.add_from_file("menubar_basis.ui")
 except:
 print "file not found"
 sys.exit()

 # we use the method Gtk.Application.set_menubar(menubar) to add the menubar
 # to the application (Note: NOT the window!)
 self.set_menubar(builder.get_object("menubar"))

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Now run the python application. It should look like the picture at the top of this page.
Add items to the menus
We start off by adding 2 menuitems to the
menubar.ui
&lt;?xml version="1.0" encoding="UTF-8"?gt;
&lt;interfacegt;
 &lt;menu id="menubar"gt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Filelt;/attributegt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Newlt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name ="label"gt;Quitlt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Editlt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Choiceslt;/attributegt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Helplt;/attributegt;
 &lt;/submenugt;
 &lt;/menugt;
&lt;/interfacegt;
Following this pattern, you can now add a
Setup actions
We now create the actions for "New" and "Quit" connected to a callback function in the Python file; for instance we create "new" as:
new_action = Gio.SimpleAction.new("new", None)
new_action.connect("activate", self.new_callback)
And we create the callback function of "new" as
def new_callback(self, action, parameter):
 print "You clicked \\"New\\""
Now, in the XML file, we connect the menu items to the actions in the XML file by adding the "action" attribute:
&lt;itemgt;
 &lt;attribute name="label"gt;Newlt;/attributegt;
 &lt;attribute name="action"gt;app.newlt;/attributegt;
&lt;/itemgt;
Note that for an action that is relative to the application, we use the prefix
Finally, in the Python file, we add the action to the application or to the window - so for instance
self.add_action(new_action)
See
Actions: Application or Window?
Above, we created the "new" and "open" actions as part of the MyApplication class. Actions which control the application itself, such as "quit" should be created similarly.
Some actions, such as "copy" and "paste" deal with the window, not the application. Window actions should be created as part of the window class.
The complete example files contain both application actions and window actions. The window actions are the ones usually included in the
Choices submenu and items with state
Lines 30 to 80 inclusive of the
The actions created so far are
shape_action = Gio.SimpleAction.new_stateful("shape", GLib.VariantType.new('s'), GLib.Variant.new_string('line'))
where the variables of the method are: name, parameter type (in this case, a string - see
After creating the stateful SimpleAction we connect it to the callback function and we add it to the window (or the application, if it is the case), as before:
shape_action.connect("activate", self.shape_callback)
self.add_action(shape_action)
Complete XML UI file for this example
&lt;?xml version="1.0" encoding="UTF-8"?gt;
&lt;interfacegt;
 &lt;menu id="menubar"gt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Filelt;/attributegt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Newlt;/attributegt;
 &lt;attribute name="action"gt;app.newlt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Quitlt;/attributegt;
 &lt;attribute name="action"gt;app.quitlt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Editlt;/attributegt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Copylt;/attributegt;
 &lt;attribute name="action"gt;win.copylt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Pastelt;/attributegt;
 &lt;attribute name="action"gt;win.pastelt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Choiceslt;/attributegt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Shapeslt;/attributegt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Linelt;/attributegt;
 &lt;attribute name="action"gt;win.shapelt;/attributegt;
 &lt;attribute name="target"gt;linelt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Trianglelt;/attributegt;
 &lt;attribute name="action"gt;win.shapelt;/attributegt;
 &lt;attribute name="target"gt;trianglelt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Squarelt;/attributegt;
 &lt;attribute name="action"gt;win.shapelt;/attributegt;
 &lt;attribute name="target"gt;squarelt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Polygonlt;/attributegt;
 &lt;attribute name="action"gt;win.shapelt;/attributegt;
 &lt;attribute name="target"gt;polygonlt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Circlelt;/attributegt;
 &lt;attribute name="action"gt;win.shapelt;/attributegt;
 &lt;attribute name="target"gt;circlelt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/submenugt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Onlt;/attributegt;
 &lt;attribute name="action"gt;app.statelt;/attributegt;
 &lt;attribute name="target"gt;onlt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Offlt;/attributegt;
 &lt;attribute name="action"gt;app.statelt;/attributegt;
 &lt;attribute name="target"gt;offlt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Awesomelt;/attributegt;
 &lt;attribute name="action"gt;app.awesomelt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/submenugt;
 &lt;submenugt;
 &lt;attribute name="label"gt;Helplt;/attributegt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Aboutlt;/attributegt;
 &lt;attribute name="action"gt;win.aboutlt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/submenugt;
 &lt;/menugt;
 &lt;menu id="appmenu"gt;
 &lt;sectiongt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Newlt;/attributegt;
 &lt;attribute name="action"gt;app.newlt;/attributegt;
 &lt;/itemgt;
 &lt;itemgt;
 &lt;attribute name="label"gt;Quitlt;/attributegt;
 &lt;attribute name="action"gt;app.quitlt;/attributegt;
 &lt;/itemgt;
 &lt;/sectiongt;
 &lt;/menugt;
&lt;/interfacegt;
Complete Python file for this example
from gi.repository import Gtk
from gi.repository import GLib
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="MenuBar Example", application=app)
 self.set_default_size(200, 200)

 # action without a state created (name, parameter type)
 copy_action = Gio.SimpleAction.new("copy", None)
 # connected with the callback function
 copy_action.connect("activate", self.copy_callback)
 # added to the window
 self.add_action(copy_action)

 # action without a state created (name, parameter type)
 paste_action = Gio.SimpleAction.new("paste", None)
 # connected with the callback function
 paste_action.connect("activate", self.paste_callback)
 # added to the window
 self.add_action(paste_action)

 # action with a state created (name, parameter type, initial state)
 shape_action = Gio.SimpleAction.new_stateful(
 "shape", GLib.VariantType.new('s'), GLib.Variant.new_string('line'))
 # connected to the callback function
 shape_action.connect("activate", self.shape_callback)
 # added to the window
 self.add_action(shape_action)

 # action with a state created
 about_action = Gio.SimpleAction.new("about", None)
 # action connected to the callback function
 about_action.connect("activate", self.about_callback)
 # action added to the application
 self.add_action(about_action)

 # callback function for copy_action
 def copy_callback(self, action, parameter):
 print "\\"Copy\\" activated"

 # callback function for paste_action
 def paste_callback(self, action, parameter):
 print "\\"Paste\\" activated"

 # callback function for shape_action
 def shape_callback(self, action, parameter):
 print "Shape is set to", parameter.get_string()
 # Note that we set the state of the action!
 action.set_state(parameter)

 # callback function for about (see the AboutDialog example)
 def about_callback(self, action, parameter):
 # a Gtk.AboutDialog
 aboutdialog = Gtk.AboutDialog()

 # lists of authors and documenters (will be used later)
 authors = ["GNOME Documentation Team"]
 documenters = ["GNOME Documentation Team"]

 # we fill in the aboutdialog
 aboutdialog.set_program_name("MenuBar Example")
 aboutdialog.set_copyright(
 "Copyright \\xc2\\xa9 2012 GNOME Documentation Team")
 aboutdialog.set_authors(authors)
 aboutdialog.set_documenters(documenters)
 aboutdialog.set_website("http://developer.gnome.org")
 aboutdialog.set_website_label("GNOME Developer Website")

 # to close the aboutdialog when "close" is clicked we connect the
 # "response" signal to on_close
 aboutdialog.connect("response", self.on_close)
 # show the aboutdialog
 aboutdialog.show()

 # a callback function to destroy the aboutdialog
 def on_close(self, action, parameter):
 action.destroy()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 # FIRST THING TO DO: do_startup()
 Gtk.Application.do_startup(self)

 # action without a state created
 new_action = Gio.SimpleAction.new("new", None)
 # action connected to the callback function
 new_action.connect("activate", self.new_callback)
 # action added to the application
 self.add_action(new_action)

 # action without a state created
 quit_action = Gio.SimpleAction.new("quit", None)
 # action connected to the callback function
 quit_action.connect("activate", self.quit_callback)
 # action added to the application
 self.add_action(quit_action)

 # action with a state created
 state_action = Gio.SimpleAction.new_stateful(
 "state", GLib.VariantType.new('s'), GLib.Variant.new_string('off'))
 # action connected to the callback function
 state_action.connect("activate", self.state_callback)
 # action added to the application
 self.add_action(state_action)

 # action with a state created
 awesome_action = Gio.SimpleAction.new_stateful(
 "awesome", None, GLib.Variant.new_boolean(False))
 # action connected to the callback function
 awesome_action.connect("activate", self.awesome_callback)
 # action added to the application
 self.add_action(awesome_action)

 # a builder to add the UI designed with Glade to the grid:
 builder = Gtk.Builder()
 # get the file (if it is there)
 try:
 builder.add_from_file("menubar.ui")
 except:
 print "file not found"
 sys.exit()

 # we use the method Gtk.Application.set_menubar(menubar) to add the menubar
 # and the menu to the application (Note: NOT the window!)
 self.set_menubar(builder.get_object("menubar"))
 self.set_app_menu(builder.get_object("appmenu"))

 # callback function for new
 def new_callback(self, action, parameter):
 print "You clicked \\"New\\""

 # callback function for quit
 def quit_callback(self, action, parameter):
 print "You clicked \\"Quit\\""
 sys.exit()

 # callback function for state
 def state_callback(self, action, parameter):
 print "State is set to", parameter.get_string()
 action.set_state(parameter)

 # callback function for awesome
 def awesome_callback(self, action, parameter):
 action.set_state(GLib.Variant.new_boolean(not action.get_state()))
 if action.get_state().get_boolean() is True:
 print "You checked \\"Awesome\\""
 else:
 print "You unchecked \\"Awesome\\""


app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Mnemonics and Accelerators
Labels may contain mnemonics. Mnemonics are underlined characters in the label, used for keyboard navigation. Mnemonics are created by placing an underscore before the mnemonic character. For example "_File" instead of just "File" in the menubar.ui label attribute.
The mnemonics are visible when you press the
Accelerators can be explicitly added in the UI definitions. For example, it is common to be able to quit an application by pressing

&lt;itemgt;
 &lt;attribute name="label"gt;_Quitlt;/attributegt;
 &lt;attribute name="action"gt;app.quitlt;/attributegt;
 &lt;attribute name="accel"gt;amp;lt;Primaryamp;gt;qlt;/attributegt;
&lt;/itemgt;
Translatable strings
Since GNOME applications are being translated into
&lt;attribute name="label" translatable="yes"gt;Quitlt;/attributegt;


MenuBar (Vala)
Now we will create the .vala file and use GtkBuilder to import the
public class MyWindow : Gtk.ApplicationWindow {
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "MenuBar Example");
 this.set_default_size (200, 200);
 }
}

class MyApplication: Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }
 protected override void startup () {
 base.startup ();

 /* Setup menubar. */
 /* Get the UI file. */
 var builder = new Gtk.Builder ();
 try {
 builder.add_from_file ("menubar_basis.ui");
 /* Handle the exception. */
 } catch (Error e) {
 error ("Unable to load file: %s", e.message);
 }

 /* Get the menubar from the builder. */
 this.menubar = builder.get_object ("menubar") as MenuModel;
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}
Now, compile the vala file, and run it. The application should look like the picture at the top of this page.
Following this pattern, you can now add a
You do not need to recompile the vala program if you only made changes to the UI file. Just run your previously compiled application, and the UI changes will be reflected.
This is a three step process.
First we create the ActionEntry array in the MyApplication class. An ActionEntry consists of:
the "action name" (mandatory)
the callback function to connect to the "activate" signal of the action (if applicable)
the type of the parameter that must be passed to the activate function for the action (if applicable)
the initial state for this action (if applicable)
the callback to connect to "change-state" signal (if applicable)
const ActionEntry[] actions = {
 { "new", new_cb }, // {"action name", callback_function}
 { "quit", quit_cb }
};
Second, we create the callback functions the actions are connected to.
void new_cb (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"New\\"\
");
 //new MyWindow (this).show ();
}

void quit_cb (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"Quit\\"\
");
 this.quit ();
}
And lastly, we connect the menu items to the actions in the XML file by adding the "action" attribute:
&lt;itemgt;
 &lt;attribute name="label"gt;Newlt;/attributegt;
 &lt;attribute name="action"gt;app.newlt;/attributegt;
&lt;/itemgt;
&lt;itemgt;
 &lt;attribute name="label"gt;Quitlt;/attributegt;
 &lt;attribute name="action"gt;app.quitlt;/attributegt;
&lt;/itemgt;
Lines 30 to 80 inclusive of the
The complete example files contain both application actions and window applications. The window actions are the ones usually included in the
Complete Vala file for this example
public class MyWindow : Gtk.ApplicationWindow {

 /* Callback functions for the window actions. */
 void copy_cb (SimpleAction action, Variant? parameter) {
 print ("\\"Copy\\" activated\
");
 }

 void paste_cb (SimpleAction action, Variant? parameter) {
 print ("\\"Paste\\" activated\
");
 }

 void shape_cb (SimpleAction action, Variant? parameter) {
 print ("shape is set to %s\
", parameter.get_string(null));
 action.set_state (parameter);
 }

 /* Create the window actions. */
 const ActionEntry[] actions = {
 /*{ "action name", cb to connect to "activate" signal, parameter type,
 initial state, cb to connect to "change-state" signal } */
 { "copy", copy_cb },
 { "paste", paste_cb },
 { "shape", shape_cb, "s", "'line'"}
 };

 internal MyWindow (MyApplication app) {
 Object (application: app, title: "MenuBar Example");
 this.set_default_size (200, 200);

 /* Setup window actions. */
 this.add_action_entries (actions, this);
 }
}

class MyApplication: Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }

 /* Callback functions for the application actions. */
 void new_cb (SimpleAction action, Variant? parameter) {
 //new MyWindow (this).show ();
 print ("You clicked \\"New\\"\
");
 }

 void quit_cb (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"Quit\\"\
");
 this.quit ();
 }

 void awesome_cb (SimpleAction action, Variant? parameter) {
 var active = action.get_state ().get_boolean ();
 action.set_state (new Variant.boolean (!active));
 if (active)
 print ("You unchecked \\"Awesome\\"\
");
 else
 print ("You checked \\"Awesome\\"\
");
 }

 void state_cb (SimpleAction action, Variant? parameter) {
 print ("state is set to %s\
", parameter.get_string(null));
 action.set_state (parameter);
 }

 /* Create the application actions. */
 const ActionEntry[] actions = {
 { "new", new_cb },
 { "quit", quit_cb },
 { "awesome", awesome_cb, null, "false" },
 { "state", state_cb, "s", "'off'" }
 };

 protected override void startup () {
 base.startup ();

 /* Setup application actions. */
 this.add_action_entries (actions, this);

 /* Setup menubar and app_menu. */
 /* Get the UI file. */
 var builder = new Gtk.Builder ();
 try {
 builder.add_from_file ("menubar.ui");
 } catch (Error e) {
 error ("Unable to load file: %s", e.message);
 }

 /* Get the menubar from the builder. */
 this.menubar = builder.get_object ("menubar") as MenuModel;

 /* Get the app_menu from the builder. */
 this.app_menu = builder.get_object ("appmenu") as MenuModel;
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}
Mnemonics
Accelerators



external ref='media/menubutton.png' md5='99eedc5ef2d6c56d32ca9ae7f3f3320f'
MenuButton
A widget that shows a menu when clicked on
The GtkMenuButton widget is used to display a menu when clicked on. This menu can be provided either as a GtkMenu, or an abstract GMenuModel. The GtkMenuButton widget can hold any valid child widget. That is, it can hold almost any other standard GtkWidget. The most commonly used child is the provided GtkArrow.
You need to be running GNOME 3.6 or later for the MenuButton to work.
#include &lt;gtk/gtk.hgt;

/* Callback function for the undo action */
static void
about_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"About\\"\
");
}

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GMenu *submenu;
 GtkWidget *grid;
 GMenu *menumodel;
 GtkWidget *window;
 GtkWidget *menubutton;
 GSimpleAction *about_action;

 window = gtk_application_window_new (app);
 grid = gtk_grid_new ();

 gtk_window_set_title (GTK_WINDOW (window), "MenuButton Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 600, 400);

 menubutton = gtk_menu_button_new ();
 gtk_widget_set_size_request (menubutton, 80, 35);

 gtk_grid_attach (GTK_GRID (grid), menubutton, 0, 0, 1, 1);
 gtk_container_add (GTK_CONTAINER (window), grid);

 menumodel = g_menu_new ();
 g_menu_append (menumodel, "New", "app.new");
 g_menu_append (menumodel, "About", "win.about");

 submenu = g_menu_new ();
 g_menu_append_submenu (menumodel, "Other", G_MENU_MODEL (submenu));
 g_menu_append (submenu, "Quit", "app.quit");
 gtk_menu_button_set_menu_model (GTK_MENU_BUTTON (menubutton), G_MENU_MODEL (menumodel));

 about_action = g_simple_action_new ("about", NULL);
 g_signal_connect (about_action, "activate", G_CALLBACK (about_callback),
 GTK_WINDOW (window));
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (about_action));

 gtk_widget_show_all (window);
}


static void
new_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"New\\"\
");
}

static void
quit_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GApplication *application = user_data;

 g_application_quit (application);
}

static void
startup (GApplication *app,
 gpointer user_data)
{
 GSimpleAction *new_action;
 GSimpleAction *quit_action;

 new_action = g_simple_action_new ("new", NULL);
 g_signal_connect (new_action, "activate", G_CALLBACK (new_callback), app);
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (new_action));

 quit_action = g_simple_action_new ("quit", NULL);
 g_signal_connect (quit_action, "activate", G_CALLBACK (quit_callback), app);
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (quit_action));
}


int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 g_signal_connect (app, "startup", G_CALLBACK (startup), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}




MenuButton (JavaScript)
Anna Zacchi
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const Application = new Lang.Class ({
 Name: 'Application',

 //create the application
 _init: function() {
 this.application = new Gtk.Application ({ application_id: 'org.example.myapp',
 flags: Gio.ApplicationFlags.FLAGS_NONE });

 //connect to 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 //create the UI (in this case it's just the ApplicationWindow)
 _buildUI: function() {
 this._window = new Gtk.ApplicationWindow({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "MenuButton Example" });
 this._window.set_default_size(600, 400);
 this.grid = new Gtk.Grid();
 this._window.add(this.grid);


 this._menuButton = new Gtk.MenuButton();
 this.grid.attach(this._menuButton, 0, 0, 1, 1 );
 this.menu = new Gtk.Menu.new_from_model(this.menuModel);

 this.menu.show();
 this._menuButton.set_menu_model (this.menuModel);
 this._menuButton.set_size_request(80, 35);
 this._menuButton.show();

 this._window.show_all();
 },

 _showNew: function() {
 print("You clicked \\"New\\"");
 },

 _showAbout: function() {
 print("You clicked \\"About\\"");
 },

 //create the menu items and connect the signals to the callback functions.
 _initMenus: function() {
 let newAction = new Gio.SimpleAction({ name: 'new' });
 newAction.connect('activate', Lang.bind(this,
 function() {
 this._showNew();
 }));
 this.application.add_action(newAction);

 let aboutAction = new Gio.SimpleAction({ name: 'about' });
 aboutAction.connect('activate', Lang.bind(this,
 function() {
 this._showAbout();
 }));
 this.application.add_action(aboutAction);

 let quitAction = new Gio.SimpleAction({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);

 this.menuModel = new Gio.Menu();

 this.menuItemNew = Gio.MenuItem.new("New", 'app.new');
 this.menuItemAbout = Gio.MenuItem.new("About", 'app.about');
 this.fileMenuItem = Gio.MenuItem.new("Other", null);

 this.menuModel.append_item(this.menuItemNew);
 this.menuModel.append_item(this.menuItemAbout);

 //submenu
 this.subMenu = new Gio.Menu();
 this.fileMenuItem.set_submenu(this.subMenu);
 this.menuItemQuit = Gio.MenuItem.new("Quit", 'app.quit');
 this.subMenu.append_item(this.menuItemQuit);
 this.menuModel.append_item(this.fileMenuItem);
 },

 //callback function for 'activate' signal
 _onActivate: function() {
 this._window.present();
 },

 //callback function for 'startup' signal
 _onStartup: function() {
 //You must call _initMenus() before calling _buildUI().
 this._initMenus();
 this._buildUI();
 }
});

//run the application
let app = new Application();
app.application.run(ARGV);

You need to be running GNOME 3.6 for the MenuButton to work.
from gi.repository import Gtk
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Menubutton Example", application=app)
 self.set_default_size(600, 400)

 grid = Gtk.Grid()

 # a menubutton
 menubutton = Gtk.MenuButton()
 menubutton.set_size_request(80, 35)

 grid.attach(menubutton, 0, 0, 1, 1)

 # a menu with two actions
 menumodel = Gio.Menu()
 menumodel.append("New", "app.new")
 menumodel.append("About", "win.about")

 # a submenu with one action for the menu
 submenu = Gio.Menu()
 submenu.append("Quit", "app.quit")
 menumodel.append_submenu("Other", submenu)

 # the menu is set as the menu of the menubutton
 menubutton.set_menu_model(menumodel)

 # the action related to the window (about)
 about_action = Gio.SimpleAction.new("about", None)
 about_action.connect("activate", self.about_callback)
 self.add_action(about_action)

 self.add(grid)

 # callback for "about"
 def about_callback(self, action, parameter):
 print "You clicked \\"About\\""


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 # the actions related to the application
 new_action = Gio.SimpleAction.new("new", None)
 new_action.connect("activate", self.new_callback)
 self.add_action(new_action)

 quit_action = Gio.SimpleAction.new("quit", None)
 quit_action.connect("activate", self.quit_callback)
 self.add_action(quit_action)

 # callback functions for the actions related to the application
 def new_callback(self, action, parameter):
 print "You clicked \\"New\\""

 def quit_callback(self, action, parameter):
 print "You clicked \\"Quit\\""
 self.quit()

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a MenuButton widget
In line 33 the signal
The positioning of the menu is determined by the "direction" property of the menu button and the "halign" or "valign" properties of the menu. For example, when the direction is
In the case of vertical alignment, the possible ArrowType directions are


MenuButton (Vala)
public class MyWindow : Gtk.ApplicationWindow {

 internal MyWindow (MyApplication app) {
 Object (application: app, title: "MenuButton Example");
 this.set_default_size (600, 400);
 var grid = new Gtk.Grid ();

 var menubutton = new Gtk.MenuButton();
 menubutton.set_size_request (80, 35);

 var menumodel = new Menu ();
 menumodel.append ("New", "app.new");
 menumodel.append ("About", "win.about");

 /* We create the last item as a MenuItem, so that
 * a submenu can be appended to this menu item.
 */
 var submenu = new Menu ();
 menumodel.append_submenu ("Other", submenu);
 submenu.append ("Quit", "app.quit");
 menubutton.set_menu_model (menumodel);

 var about_action = new SimpleAction ("about", null);
 about_action.activate.connect (this.about_cb);
 this.add_action (about_action);

 this.add(grid);
 grid.attach(menubutton, 0, 0, 1, 1);
 }

 void about_cb (SimpleAction simple, Variant? parameter) {
 print ("You clicked \\"About\\"\
");
 }
}

public class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show_all ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }

 /* Override the 'startup' signal of GLib.Application. */
 protected override void startup () {
 base.startup ();

 var new_action = new SimpleAction ("new", null);
 new_action.activate.connect (this.new_cb);
 this.add_action (new_action);

 var quit_action = new SimpleAction ("quit", null);
 quit_action.activate.connect (this.quit);
 this.add_action (quit_action);
 }

 void new_cb (SimpleAction simple, Variant? parameter) {
 print ("You clicked \\"New\\"\
");
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}
external ref='media/message-board.ogv' md5='beb80c4538776dc2cdd26c95abea5027'
Message board (C)
A simple program using WebKitGTK+ and the DOM.
Message board
How to display a web page with WebKit.
How to manipulate the contents of a web page using WebKit's DOM functions.
This tutorial assumes you are familiar with the C programming language and have a basic understanding of GTK+, including how to create and place widgets and how to connect callback functions to signals. See
The GNOME platform includes WebKitGTK+, built on top of the powerful WebKit HTML framework. WebKit is used throughout GNOME, not just to view web pages on the Internet, but also to create rich user interfaces that can be easily styled with CSS.
In this tutorial, you will create a simple message board using WebKit. The message board will allow you to enter some text and have it added to a list of messages in HTML. Before you begin, you need to set up a project in Anjuta.
In Anjuta, click
Select
Fill out your details on the
Disable the
You need to tell Anjuta you're using WebKitGTK+ on this project. On the
After you finish the new project assistant, open the file
#include &lt;webkit/webkit.hgt;
Verify that everything works by building what you have so far. Click
You should now be able to run the program. Click
Lay out your window and web view
Now that you can show a window, it's time to start working with WebKit. For this tutorial, you'll create a text entry and a web view and pack them both into a window. Find the function
static GtkWidget*
create_window (void)
{
 GtkWidget *window, *box, *scroll, *view, *entry;

 window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
 gtk_window_set_default_size (GTK_WINDOW (window), 400, 400);
 gtk_window_set_title (GTK_WINDOW (window), "Message Board");
 g_signal_connect (window, "delete-event", G_CALLBACK (gtk_main_quit), NULL);

 box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 6);
 gtk_container_set_border_width (GTK_CONTAINER (box), 6);
 gtk_container_add (GTK_CONTAINER (window), box);

 entry = gtk_entry_new ();
 gtk_box_pack_start (GTK_BOX (box), entry, FALSE, FALSE, 0);

 scroll = gtk_scrolled_window_new (NULL, NULL);
 g_object_set (scroll, "shadow-type", GTK_SHADOW_IN, NULL);
 gtk_box_pack_start (GTK_BOX (box), scroll, TRUE, TRUE, 0);

 view = webkit_web_view_new ();
 gtk_container_add (GTK_CONTAINER (scroll), view);
 webkit_web_view_load_string (WEBKIT_WEB_VIEW (view),
 "lt;htmlgt;lt;bodygt;lt;/bodygt;lt;/htmlgt;",
 "text/html",
 "UTF-8",
 NULL);

 gtk_widget_show_all (GTK_WIDGET (box));
 return window;
}
You first create a
You then create a vertical box and add it to the window. A window can only hold a single child widget, so you need to use a box to add multiple widgets. The second argument to
You next create a
Before you add a web view, you have to create a scrolled window to put it inside of. The scrolled window will place scrollbars on the right and bottom when necessary, and prevent your web view from filling your entire screen. This time, you pass
Finally, you create a

The view itself. Because

The simplest HTML file you could possibly write.

The MIME type of the content you provided. In this case, you're using plain HTML.

The character encoding of the content you provided. Although you only used ASCII characters, it's a good idea to specify UTF-8. UTF-8 is used as the default encoding throughout the GNOME platform.

The base URI. You don't need it in this simple example, but you might want to provide a
Every time you add a widget, you have to call
Finally, you have to call
Build and run the message board again. You should see a window with a text entry and a web view. It doesn't do anything yet because the text entry and the web view don't know anything about each other.
Hook up signals
Now you want to make the message board actually
g_signal_connect (entry, "activate", G_CALLBACK (entry_activate_cb), view);
You then have to actually define
static void
entry_activate_cb (GtkEntry *entry, WebKitWebView *view)
{
 WebKitDOMDocument *document;
 WebKitDOMElement *body, *div;

 document = webkit_web_view_get_dom_document (view);
 body = webkit_dom_document_query_selector (document, "body", NULL);
 div = webkit_dom_document_create_element (document, "div", NULL);
 webkit_dom_node_set_text_content (WEBKIT_DOM_NODE (div),
 gtk_entry_get_text (entry),
 NULL);
 webkit_dom_node_append_child (WEBKIT_DOM_NODE (body),
 WEBKIT_DOM_NODE (div),
 NULL);
 gtk_entry_set_text (entry, "");
}
The first thing you do is get a
Once you have the document, you want to get the
Next, you create a new
Finally, you append the new
Make it look better with CSS
At this point, your program is completely functional, but not very pretty. You can style the message display with CSS, just like you can with any other HTML page. There are many ways you could attach some CSS to the page: You could add it in the initial HTML document. You could inline it in the
In this tutorial, you'll attach the CSS using the
static const guchar CSS[] =
"body { margin: 0; padding: 0; }\
"
"div { "
" -webkit-border-radius: 2px;"
" background: -webkit-gradient(linear, 0% 100%, 0% 0%,"
" from(#f1f1f1), to(white));"
" border: solid 1px #c6c6c6;"
" -webkit-box-shadow: 0px 0px 2px #c6c6c6;"
" margin: 12px; padding: 6px;"
"}";
All you have in this example are
To apply the CSS, you set the
tmp = g_base64_encode (CSS, strlen((gchar *) CSS));
css = g_strconcat ("data:text/css;charset=utf-8;base64,",
 tmp, NULL);
g_object_set (webkit_web_view_get_settings (WEBKIT_WEB_VIEW (view)),
 "user-stylesheet-uri", css, NULL);
g_free (css);
g_free (tmp);
Also, make sure to add variable declarations for
gchar *tmp, *css;
A data URI starts with
The code above first encodes your CSS definitions in Base64, then combines that with a fixed string to create a data URI. The
Build and run the program again. It should now work exactly the same as at the end of the last section, except the messages will be nicely styled with a border and a subtle background gradient.
Learn more
This tutorial showed you how to create a basic application using GTK+ and WebKit, including showing a document and manipulating its contents. To create a real application, you probably want to do a little bit more. Try adding features on your own. Here are a few ideas:
If you're comfortable with CSS, try changing the style of the message display. CSS is easy to get started with, but increasingly more powerful. There is a wealth of CSS tutorials on the Internet, and just about everything you can do on the web, you can do in this application.
Right now, you lose all your messages whenever you close the message board. Try saving the HTML contents after each post, and loading the saved file (if it exists) on startup.
If you keep your messages around for a long time, you'll start wondering when you posted them. Add a timestamp to each message when it's posted. You'll probably want to create some additional child
This program keeps messages around forever. Think about ways you could allow the user to delete messages. Perhaps you want messages to disappear automatically after they're too old, or after there are a certain number of messages before them. Or you could add a link in each message to delete it. You could even override the context menu when you right-click on a message. These features involve exploring WebKit's DOM API more.
external ref='media/messagedialog.png' md5='1956288274018e2386d9cba96a2101de'
MessageDialog (C)
A message window
MessageDialog
A modal message dialog which can cause the world to explode.
To test out the application once it has started running, you can click on the "Message Dialog" tab that appears in the top menubar of the screen.
#include &lt;gtk/gtk.hgt;



/* Callback function in which reacts to the "response" signal from the user in
 * the message dialog window.
 * This function is used to interact with the user in the terminal.
 */
static void
on_response (GtkDialog *dialog,
 gint response_id,
 gpointer user_data)
{
 /* If the button clicked gives response OK (response_id being -5) */
 if (response_id == GTK_RESPONSE_OK) 
 g_print ("*boom*\
");

 /* If the button clicked gives response CANCEL (response_id being -6) */
 else if (response_id == GTK_RESPONSE_CANCEL)
 g_print ("good choice\
");

 /* If the message dialog is destroyed (for example by pressing escape) */
 else if (response_id == GTK_RESPONSE_DELETE_EVENT)
 g_print ("dialog closed or cancelled\
");

 /* Destroy the dialog after one of the above actions have taken place */
 gtk_widget_destroy (GTK_WIDGET (dialog));

}



/* Callback function for the response signal "activate" related to the SimpleAction
 * message_action.
 * This function is used to cause the message dialog window to popup.
 */
static void
message_cb (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 /* the parent variable in this case represents the window */
 GtkWidget *message_dialog;
 GtkWindow *parent = user_data;
 
 /* Create a new message dialog, and set the parameters as follows:
 * Dialog Flags - make the constructed dialog modal 
 * (modal windows prevent interaction with other windows in the application)
 * Message Type - nonfatal warning message
 * Buttons Type - use the ok and cancel buttons
 * message_format - text that you want the user to see in the window 
 */
 message_dialog = gtk_message_dialog_new (parent, GTK_DIALOG_MODAL, 
 GTK_MESSAGE_WARNING, 
 GTK_BUTTONS_OK_CANCEL, 
 "This action will cause the universe to stop existing.");

 gtk_widget_show_all (message_dialog);

 g_signal_connect (GTK_DIALOG (message_dialog), "response", 
 G_CALLBACK (on_response), NULL);

}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *label;

 GSimpleAction *message_action;

 /* Create a window with a title and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "GMenu Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 400, 200);

 /* Create a label and add it to the window */
 label = gtk_label_new ("This application goes boom!");
 gtk_container_add (GTK_CONTAINER (window), label);

 /* Create a new simple action, giving it a NULL parameter type. It will 
 * always be NULL for actions invoked from a menu. (e.g clicking on an "ok" 
 * or "cancel" button)
 */
 message_action = g_simple_action_new ("message", NULL); 

 /* Connect the "activate" signal to the appropriate callback function */
 g_signal_connect (message_action, "activate", G_CALLBACK (message_cb), 
 GTK_WINDOW (window));

 /* Adds the message_action to the overall action map. An Action map is an 
 * interface that contains a number of named GAction instances 
 * (such as message_action) 
 */
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (message_action));

 gtk_widget_show_all (window);
}



/* Callback function for the response signal "activate" from the "quit" action 
 * in the function directly below.
 */ 
static void
quit_cb (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GApplication *application = user_data;

 g_application_quit (application);
}



/* Startup function for the menu we are creating in this sample */
static void
startup (GApplication *app,
 gpointer user_data)
{
 GMenu *menu;
 GSimpleAction *quit_action;

 /* Initialize the GMenu, and add a menu item with label "Message" and action 
 * "win.message". Also add another menu item with label "Quit" and action 
 * "app.quit" 
 */
 menu = g_menu_new ();
 g_menu_append (menu, "Message", "win.message");
 g_menu_append (menu, "Quit", "app.quit");

 /* Create a new simple action for the application. (In this case it is the 
 * "quit" action.
 */
 quit_action = g_simple_action_new ("quit", NULL);

 /* Ensure that the menu we have just created is set for the overall application */
 gtk_application_set_app_menu (GTK_APPLICATION (app), G_MENU_MODEL (menu));

 g_signal_connect (quit_action, 
 "activate", 
 G_CALLBACK (quit_cb), 
 app);

 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (quit_action));

}



/* Startup function for the application */
int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 g_signal_connect (app, "startup", G_CALLBACK (startup), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}



MessageDialog (JavaScript)
A popup message attached to a window
A MessageDialog is a modal message dialog, which means a popup that you have to respond to before you get back to what you were doing in the window that it's attached to. This one can cause the world to explode (or at least it says that it can). To make the popup appear when you run this sample, click on "Message" inside of its application menu -- that's the menu that appears when you click on an application's name in the upper-left screen corner, next to Activities.
The difference between a MessageDialog and a
const MessageDialogExample = new Lang.Class ({
 Name: 'MessageDialog Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jsmessagedialog',
 flags: Gio.ApplicationFlags.FLAGS_NONE });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal initializes menus and builds the UI
 _onStartup: function () {
 this._initMenus();
 this._buildUI ();
 },
Before we call _buildUI to create the window and the widgets inside it, we need to call _initMenus, which tells GNOME to create the menu. We can put the actual code for _initMenus after the code for _buildUI, since it doesn't matter what order we put them in so long as _initMenus is called first in _onStartup.
// Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Gtk.MessageDialog Example",
 default_height: 200,
 default_width: 400 });
// Create a silly warning message and add it to the window
 this.warningLabel = new Gtk.Label ({
 label: "This application goes boom! (Not really.)"});
 this._window.add (this.warningLabel);
For this example, all that we have in the window the popup comes out of is a silly warning
Creating the application's menu
// Build the application menu, including the button that calls the dialog
 _initMenus: function() {
 let menu = new Gio.Menu();
 menu.append("Message",'app.message');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 // This pops up a MessageDialog when "Message" is clicked in the menu
 let messageAction = new Gio.SimpleAction ({ name: 'message' });
 messageAction.connect('activate', Lang.bind(this,
 function() {
 this._showMessageDialog();
 }));
 this.application.add_action(messageAction);

 // This closes the window when "Quit" is clicked in the menu
 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },
Here, we build the
Creating the MessageDialog
_showMessageDialog: function () {

 // Create a modal MessageDialog whose parent is the window
 this._messageDialog = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 buttons: Gtk.ButtonsType.OK_CANCEL,
 message_type: Gtk.MessageType.WARNING,
 text: "This action will cause the universe to stop existing." });

 this._messageDialog.connect ('response', Lang.bind(this, this._response_cb));
 this._messageDialog.show();
 },
To make our MessageDialog a popup attached to the main window, we set its modal property to true and set it to be "transient_for" _window. After that, we can set what kind of buttons it has and what kind of message it is (which determines what icon appears next to the message), and write out the text inside it, before connecting its "response" signal to the callback function which handles it.
Here are some resources for making your own MessageDialogs:


// Callback function (aka signal handler) for the response signal
 _response_cb: function (messagedialog, response_id) {

 // A simple switch that changes the main window's label
 switch (response_id) {
 case Gtk.ResponseType.OK:
 this.warningLabel.set_label ("*BOOM*\
");
 break;
 case Gtk.ResponseType.CANCEL:
 this.warningLabel.set_label ("Good choice!\
");
 break;
 case Gtk.ResponseType.DELETE_EVENT:
 this.warningLabel.set_label ("Dialog closed or cancelled.\
");
 break;
 }

 this._messageDialog.destroy();

 }

});
This function takes two parameters, the MessageDialog and its response_id, both of which are automatically supplied (you don't have to manually pass them to it for it to work). Here we use a simple switch to change the "warning label"'s text, depending on which option you select. The DELETE_EVENT occurs if you press Escape to cancel the MessageDialog, instead of clicking OK or Cancel. Whatever you select, the popup is destroyed afterwards.
// Run the application
let app = new MessageDialogExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished MessageDialogExample class, and set the application running.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const MessageDialogExample = new Lang.Class ({
 Name: 'MessageDialog Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jsmessagedialog',
 flags: Gio.ApplicationFlags.FLAGS_NONE });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal initializes menus and builds the UI
 _onStartup: function () {
 this._initMenus();
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Gtk.MessageDialog Example",
 default_height: 200,
 default_width: 400 });

 // Create a silly warning message and add it to the window
 this.warningLabel = new Gtk.Label ({
 label: "This application goes boom! (Not really.)"});
 this._window.add (this.warningLabel);

 // Show the window and all child widgets
 this._window.show_all();
 },



 // Build the application menu, including the button that calls the dialog
 _initMenus: function() {
 let menu = new Gio.Menu();
 menu.append("Message",'app.message');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 // This pops up a MessageDialog when "Message" is clicked in the menu
 let messageAction = new Gio.SimpleAction ({ name: 'message' });
 messageAction.connect('activate', Lang.bind(this,
 function() {
 this._showMessageDialog();
 }));
 this.application.add_action(messageAction);

 // This closes the window when "Quit" is clicked in the menu
 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },



 _showMessageDialog: function () {

 // Create a modal MessageDialog whose parent is the window
 this._messageDialog = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 buttons: Gtk.ButtonsType.OK_CANCEL,
 message_type: Gtk.MessageType.WARNING,
 text: "This action will cause the universe to stop existing." });

 this._messageDialog.connect ('response', Lang.bind(this, this._response_cb));
 this._messageDialog.show();
 },



 // Callback function (aka signal handler) for the response signal
 _response_cb: function (messagedialog, response_id) {

 // A simple switch that changes the main window's label
 switch (response_id) {
 case Gtk.ResponseType.OK:
 this.warningLabel.set_label ("*BOOM*\
");
 break;
 case Gtk.ResponseType.CANCEL:
 this.warningLabel.set_label ("Good choice!\
");
 break;
 case Gtk.ResponseType.DELETE_EVENT:
 this.warningLabel.set_label ("Dialog closed or cancelled.\
");
 break;
 }

 this._messageDialog.destroy();

 }

});

// Run the application
let app = new MessageDialogExample ();
app.application.run (ARGV);
MessageDialog (Python)
A message dialog which prints messages on the terminal, depending on your choices.
from gi.repository import Gtk
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 # constructor for a window (the parent window) with a label
 def __init__(self, app):
 Gtk.Window.__init__(self, title="GMenu Example", application=app)
 self.set_default_size(400, 200)
 label = Gtk.Label()
 label.set_text("This application goes boom!")
 self.add(label)

 # create the message_action (a Gio.SimpleAction) - for the window
 message_action = Gio.SimpleAction.new("message", None)
 # connect the signal from the action to the function message_cb()
 message_action.connect("activate", self.message_cb)
 # add the action to the application
 app.add_action(message_action)

 # callback function for the signal "activate" from the message_action
 # in the menu of the parent window
 def message_cb(self, action, parameter):
 # a Gtk.MessageDialog
 messagedialog = Gtk.MessageDialog(parent=self,
 flags=Gtk.DialogFlags.MODAL,
 type=Gtk.MessageType.WARNING,
 buttons=Gtk.ButtonsType.OK_CANCEL,
 message_format="This action will cause the universe to stop existing.")
 # connect the response (of the button clicked) to the function
 # dialog_response()
 messagedialog.connect("response", self.dialog_response)
 # show the messagedialog
 messagedialog.show()

 def dialog_response(self, widget, response_id):
 # if the button clicked gives response OK (-5)
 if response_id == Gtk.ResponseType.OK:
 print "*boom*"
 # if the button clicked gives response CANCEL (-6)
 elif response_id == Gtk.ResponseType.CANCEL:
 print "good choice"
 # if the messagedialog is destroyed (by pressing ESC)
 elif response_id == Gtk.ResponseType.DELETE_EVENT:
 print "dialog closed or cancelled"
 # finally, destroy the messagedialog
 widget.destroy()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def quit_cb(self, action, parameter):
 self.quit()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 # create a menu (a Gio.Menu)
 menu = Gio.Menu()
 # append a menu item with label "Message" and action "app.message"
 menu.append("Message", "app.message")
 # append a menu item with label "Quit" and action "app.quit"
 menu.append("Quit", "app.quit")
 # set menu as the menu for the application
 self.set_app_menu(menu)

 # a new simpleaction - for the application
 quit_action = Gio.SimpleAction.new("quit", None)
 quit_action.connect("activate", self.quit_cb)
 self.add_action(quit_action)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a MessageDialog widget
In line 18 the signal
In the constructor of MessageDialog we could set flags as
In the constructor of MessageDialog we could set type as any of
In the constructor of MessageDialog we could set buttons as any of
We could substitute the default image of the MessageDialog with another image using
image = Gtk.Image()
image.set_from_stock(Gtk.STOCK_CAPS_LOCK_WARNING, Gtk.IconSize.DIALOG)
image.show()
messagedialog.set_image(image)
where



MessageDialog (Vala)
//A window in the application
public class Window : Gtk.ApplicationWindow {
 public Window (Application app) {
 Object (application: app, title: "Gtk.MessageDialog Example");

 var label = new Gtk.Label ("This application goes boom!");
 this.add (label);

 var message_action = new SimpleAction ("message", null);
 message_action.activate.connect (message);
 this.add_action (message_action);

 this.set_default_size (400, 200);
 this.show_all ();
 }

 void dialog_response (Gtk.Dialog dialog, int response_id) {
 switch (response_id) {
 case Gtk.ResponseType.OK:
 print ("*boom*\
");
 break;
 case Gtk.ResponseType.CANCEL:
 print ("good choice\
");
 break;
 case Gtk.ResponseType.DELETE_EVENT:
 print ("dialog closed or cancelled\
");
 break;
 }
 dialog.destroy();
 }

 void message (SimpleAction simple, Variant? parameter) {
 var messagedialog = new Gtk.MessageDialog (this,
 Gtk.DialogFlags.MODAL,
 Gtk.MessageType.WARNING,
 Gtk.ButtonsType.OK_CANCEL,
 "This action will cause the universe to stop existing.");

 messagedialog.response.connect (dialog_response);
 messagedialog.show ();
 }
}

//This is the Application
public class Application : Gtk.Application {
 protected override void activate () {
 new Window (this);
 }

 protected override void startup () {
 base.startup ();

 var menu = new Menu ();
 menu.append ("Message", "win.message");
 menu.append ("Quit", "app.quit");
 this.app_menu = menu;

 var quit_action = new SimpleAction ("quit", null);
 //quit_action.activate.connect (this.quit);
 this.add_action (quit_action);
 }

 public Application () {
 Object (application_id: "org.example.application");
 }
}

//main function creates Application and runs it
int main (string[] args) {
 return new Application ().run (args);
}





The Model/View/Controller design (Python)
The Model/View/Controller design
Overview
Both the
The Model
The main difference between the two main implementations of
The data in the Model can be retrieved or modified using the tree iter and column index, or
As with Python's built-in list object you can use
As
Useful methods for a





Useful methods for a


Useful methods for a

The View: the TreeView case
A Treeview shows the structure of children and parent items as a tree. See for instance
The
Useful methods for a




Useful methods for a






The View: the ComboBox case
A
Useful methods for a
The static method




Useful methods for a
The static method


The View: the Cellrenderers
The View makes use of
Implementations of












The Controller: the Selection
Most applications will need to not only deal with displaying data, but also receiving input events from users. To do this, simply get a reference to a selection object and connect to the
select = tree.get_selection()
select.connect("changed", on_tree_selection_changed)
Then to retrieve data for the row selected:
def on_tree_selection_changed(selection):
 model, treeiter = selection.get_selected()
 if treeiter != None:
 print "You selected", model[treeiter][0]
Useful methods for a






References




external ref='media/paned.png' md5='8c7e1df065395c9aafcd65036a293d8a'
Paned (C)
A widget with two adjustable panes
Paned
Two images in two adjustable panes, horizontally aligned.
#include &lt;gtk/gtk.hgt;

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *paned;
 GtkWidget *window;
 GtkWidget *image1;
 GtkWidget *image2;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Paned Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 450, 350);

 paned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
 image1 = gtk_image_new_from_file ("gnome-image.png");
 image2 = gtk_image_new_from_file ("tux.png");

 gtk_paned_add1 (GTK_PANED (paned), image1);
 gtk_paned_add2 (GTK_PANED (paned), image2);

 gtk_container_add (GTK_CONTAINER (window), paned);

 gtk_widget_show_all (window);
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}


Paned (JavaScript)
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const PanedExample = new Lang.Class ({
 Name: 'Paned Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application({ application_id: 'org.example.panedexample' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this.window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function() {
 // Create the application window
 this.window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Paned Window Example",
 default_width: 450,
 default_height: 350,
 border_width: 10 });

 // a new widget with two adjustable panes,
 // one on the left and one on the right
 this.paned = Gtk.Paned.new(Gtk.Orientation.HORIZONTAL);

 // two images
 this.image1 = new Gtk.Image();
 this.image1.set_from_file("gnome-image.png");
 this.image2 = new Gtk.Image();
 this.image2.set_from_file("tux.png");

 // add the first image to the left pane
 this.paned.add1(this.image1);
 // add the second image to the right pane
 this.paned.add2(this.image2)

 // add the panes to the window
 this.window.add(this.paned)
 this.window.show_all();
 }
});

// Run the application
let app = new PanedExample();
app.application.run (ARGV);


Paned (Python)
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Paned Example", application=app)
 self.set_default_size(450, 350)

 # a new widget with two adjustable panes,
 # one on the left and one on the right
 paned = Gtk.Paned.new(Gtk.Orientation.HORIZONTAL)

 # two images
 image1 = Gtk.Image()
 image1.set_from_file("gnome-image.png")
 image2 = Gtk.Image()
 image2.set_from_file("tux.png")

 # add the first image to the left pane
 paned.add1(image1)
 # add the second image to the right pane
 paned.add2(image2)

 # add the panes to the window
 self.add(paned)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Paned widget
To have two vertically aligned panes, use
Paned (Vala)
/* This is the application. */
public class MyApplication : Gtk.Application {
 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {

 var window = new Gtk.ApplicationWindow (this);
 window.title = "Paned Example";
 window.set_default_size (450,350);

 // a new widget with two adjustable panes,
 // one on the left and one on the right
 var paned = new Gtk.Paned (Gtk.Orientation.HORIZONTAL);

 /* two images */
 var image1 = new Gtk.Image ();
 image1.set_from_file ("gnome-image.png");
 var image2 = new Gtk.Image ();
 image2.set_from_file ("tux.png");

 /* add the first image to the left pane */
 paned.add1 (image1);

 /* add the second image to the right pane */
 paned.add2 (image2);

 /* add the panes to the window */
 window.add (paned);
 window.show_all ();
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/photo-wall.png' md5='f19590d97e8ec029cda3c44b769c11cd'
external ref='media/photo-wall-focused.png' md5='9f1ceecf3a28c1e468597b093a10cbae'
Photo wall (C)
A Clutter image viewer
Chris Kühl
Photo wall
For this example we will build a simple image viewer using Clutter. You will learn:
How to size and position
How to place an image in a
How to do simple transitions using Clutter's animation framework
How to make
How to get file names from a directory
Introduction
Clutter is a library for creating dynamic user interfaces using OpenGL for hardware acceleration. This example demonstates a small, but central, part of the Clutter library to create a simple but attractive image viewing program.
To help us reach our goal we will be utilising a few other common pieces of GLib as well. Most importantly, we'll use one
Choose
Make sure that
Enable
A look at Photo Wall
Our image viewer presents the user with a wall of images.
When an image is clicked, it is animated to fill the viewing area. When the image having focus is clicked it is returned to its original position using an animation with the same duration of 500 milliseconds.
Initial setup
The following code segment contains many of the defines and variables we will be using in the following sections. Use this as a reference for later sections. Copy this code to the beginning of
#include &lt;gdk-pixbuf/gdk-pixbuf.hgt;
#include &lt;clutter/clutter.hgt;

#define STAGE_WIDTH 800
#define STAGE_HEIGHT 600

#define THUMBNAIL_SIZE 200
#define ROW_COUNT (STAGE_HEIGHT / THUMBNAIL_SIZE)
#define COL_COUNT (STAGE_WIDTH / THUMBNAIL_SIZE)
#define THUMBNAIL_COUNT (ROW_COUNT * COL_COUNT)

#define ANIMATION_DURATION_MS 500

#define IMAGE_DIR_PATH "./berlin_images/"

static GPtrArray *img_paths;

static ClutterPoint unfocused_pos;
Jumping into the code
We will start by taking a look at the
int
main(int argc, char *argv[])
{
 ClutterColor stage_color = { 16, 16, 16, 255 };
 ClutterActor *stage = NULL;

 if (clutter_init (amp;argc, &argv) != CLUTTER_INIT_SUCCESS)
 return 1;

 stage = clutter_stage_new();
 clutter_actor_set_size(stage, STAGE_WIDTH, STAGE_HEIGHT);
 clutter_actor_set_background_color(stage, &stage_color);
 clutter_stage_set_title(CLUTTER_STAGE (stage), "Photo Wall");
 g_signal_connect(stage, "destroy", G_CALLBACK(clutter_main_quit), NULL);

 load_image_path_names();

 guint row = 0;
 guint col = 0;
 for(row=0; row &lt; ROW_COUNT; ++row)
 {
 for(col=0; col &lt; COL_COUNT; ++col)
 {
 const char *img_path = g_ptr_array_index(img_paths, (row * COL_COUNT) + col);
 GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file_at_size(img_path, STAGE_HEIGHT, STAGE_HEIGHT, NULL);
 ClutterContent *image = clutter_image_new ();
 ClutterActor *actor = clutter_actor_new ();

 if (pixbuf != NULL)
 {
 clutter_image_set_data(CLUTTER_IMAGE(image),
 gdk_pixbuf_get_pixels(pixbuf),
 gdk_pixbuf_get_has_alpha(pixbuf)
 ? COGL_PIXEL_FORMAT_RGBA_8888
 : COGL_PIXEL_FORMAT_RGB_888,
 gdk_pixbuf_get_width(pixbuf),
 gdk_pixbuf_get_height(pixbuf),
 gdk_pixbuf_get_rowstride(pixbuf),
 NULL);
 }

 clutter_actor_set_content(actor, image);
 g_object_unref(image);
 g_object_unref(pixbuf);

 initialize_actor(actor, row, col);
 clutter_actor_add_child(stage, actor);
 }
 }

 /* Show the stage. */
 clutter_actor_show(stage);

 /* Start the clutter main loop. */
 clutter_main();

 g_ptr_array_unref(img_paths);

 return 0;
}
Line 4:
Line 7: You must initialize Clutter. If you forget to do this, you will get very strange errors. Be warned.
Lines 10‒14: Here we create a new
A
Line 16: Here we call our function for getting the image file paths. We'll look at this in a bit.
Lines 18‒49: This is where we set up the
Line 52: Show the stage and
Line 55: Start the Clutter main loop.
Setting up our image actors
In Clutter, an actor is the most basic visual element. Basically, everything you see is an actor.
In this section, we are going to take a closer look at the loop used for setting up the
guint row = 0;
guint col = 0;
for(row=0; row &lt; ROW_COUNT; ++row)
{
 for(col=0; col &lt; COL_COUNT; ++col)
 {
 const char *img_path = g_ptr_array_index(img_paths, (row * COL_COUNT) + col);
 GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file_at_size(img_path, STAGE_HEIGHT, STAGE_HEIGHT, NULL);
 ClutterContent *image = clutter_image_new ();
 ClutterActor *actor = clutter_actor_new ();

 if (pixbuf != NULL)
 {
 clutter_image_set_data(CLUTTER_IMAGE(image),
 gdk_pixbuf_get_pixels(pixbuf),
 gdk_pixbuf_get_has_alpha(pixbuf)
 ? COGL_PIXEL_FORMAT_RGBA_8888
 : COGL_PIXEL_FORMAT_RGB_888,
 gdk_pixbuf_get_width(pixbuf),
 gdk_pixbuf_get_height(pixbuf),
 gdk_pixbuf_get_rowstride(pixbuf),
 NULL);
 }

 clutter_actor_set_content(actor, image);
 g_object_unref(image);
 g_object_unref(pixbuf);

 initialize_actor(actor, row, col);
 clutter_actor_add_child(stage, actor);
 }
}
Line 7: Here we want to get the path at the
Line 8‒23: This is where we actually create the
Line 47: This adds the
Loading the images
Let's take a short break from Clutter to see how we can get the file names from our image directory.
static void
load_image_path_names()
{
 /* Ensure we can access the directory. */
 GError *error = NULL;
 GDir *dir = g_dir_open(IMAGE_DIR_PATH, 0, &error);
 if(error)
 {
 g_warning("g_dir_open() failed with error: %s\
", error-gt;message);
 g_clear_error(amp;error);
 return;
 }

 img_paths = g_ptr_array_new_with_free_func (g_free);

 const gchar *filename = g_dir_read_name(dir);
 while(filename)
 {
 if(g_str_has_suffix(filename, ".jpg") || g_str_has_suffix(filename, ".png"))
 {
 gchar *path = g_build_filename(IMAGE_DIR_PATH, filename, NULL);
 g_ptr_array_add (img_paths, path);
 }
 filename = g_dir_read_name(dir);
 }
}
Lines 5 and 12: This opens our directory or, if an error occured, returns after printing an error message.
Lines 16‒25: The first line gets another file name from the
Set up the actors
We now take a look at the sizing and positioning of
/* This function handles setting up and placing the rectangles. */
static void
initialize_actor(ClutterActor *actor, guint row, guint col)
{
 clutter_actor_set_size(actor, THUMBNAIL_SIZE, THUMBNAIL_SIZE);
 clutter_actor_set_position(actor, col * THUMBNAIL_SIZE, row * THUMBNAIL_SIZE);
 clutter_actor_set_reactive(actor, TRUE);

 g_signal_connect(actor,
 "button-press-event",
 G_CALLBACK(actor_clicked_cb),
 NULL);
}
Line 7: Setting an actor reactive means that it reacts to events, such as
Line 9‒12: Now we connect the
At this point we've got a wall of images that are ready to be viewed.
Reacting to the clicks
static gboolean
actor_clicked_cb(ClutterActor *actor,
 ClutterEvent *event,
 gpointer user_data)
{
 /* Flag to keep track of our state. */
 static gboolean is_focused = FALSE;
 ClutterActorIter iter;
 ClutterActor *child;

 /* Reset the focus state on all the images */
 clutter_actor_iter_init (amp;iter, clutter_actor_get_parent(actor));
 while (clutter_actor_iter_next(amp;iter, &child))
 clutter_actor_set_reactive(child, is_focused);

 clutter_actor_save_easing_state(actor);
 clutter_actor_set_easing_duration(actor, ANIMATION_DURATION_MS);

 if(is_focused)
 {
 /* Restore the old location and size. */
 clutter_actor_set_position(actor, unfocused_pos.x, unfocused_pos.y);
 clutter_actor_set_size(actor, THUMBNAIL_SIZE, THUMBNAIL_SIZE);
 }
 else
 {
 /* Save the current location before animating. */
 clutter_actor_get_position(actor, &unfocused_pos.x, &unfocused_pos.y);
 /* Only the currently focused image should receive events. */
 clutter_actor_set_reactive(actor, TRUE);

 /* Put the focused image on top. */
 clutter_actor_set_child_above_sibling(clutter_actor_get_parent(actor), actor, NULL);

 clutter_actor_set_position(actor, (STAGE_WIDTH - STAGE_HEIGHT) / 2.0, 0);
 clutter_actor_set_size(actor, STAGE_HEIGHT, STAGE_HEIGHT);
 }

 clutter_actor_restore_easing_state(actor);

 /* Toggle our flag. */
 is_focused = !is_focused;

 return TRUE;
}
Lines 1‒4: We have to make sure our callback function matches the signature required for the
A few words on the arguments we are not using in this example. The
The
Line 7: We set up a static flag to track which state we are in: wall mode or focus mode. We start out in wall mode so no image has focus. Thus, we set the flag to
Line 12‒14: These set the image actors to receive events if they are focused.
Line 16‒17: Here we set the animation duration and save the current state.
Lines 21‒23: Reaching this code means that one image currently has focus and we want to return to wall mode. Setting a position on a
Line 24: Reaching this line of code means we are currently in the wall state and are about to give a
Line 25: Setting the
Lines 27‒36: This is where we save the current position of the image, set it to receive events and then make it appear above the other images and start animating it to fill the stage.
Line 39: Here we restore the easing state to what was set before we changed it in line 16.
Line 42: Here we toggle the
As mentioned previously, the
Remember, however, that to receive events the
All of the code should now be ready to go. All you need now is some pictures to load. By default, the pictures are loaded from a
When you have done that, click
If you haven't already done so, choose the
If you run into problems with the tutorial, compare your code with this
external ref='media/progressbar_fill.ogv' md5='287763d1d3f4a328212ea2243910f5e4'
ProgressBar (C)
A widget which indicates progress visually
ProgressBar
This ProgressBar "fills in" by a fraction of the bar until it is full.
#include &lt;gtk/gtk.hgt;


static gboolean
fill (gpointer user_data)
{
 GtkWidget *progress_bar = user_data;

 /*Get the current progress*/
 gdouble fraction;
 fraction = gtk_progress_bar_get_fraction (GTK_PROGRESS_BAR (progress_bar));

 /*Increase the bar by 10% each time this function is called*/
 fraction += 0.1;

 /*Fill in the bar with the new fraction*/
 gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (progress_bar), fraction);

 /*Ensures that the fraction stays below 1.0*/
 if (fraction &lt; 1.0) 
 return TRUE;
 
 return FALSE;
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *progress_bar;

 gdouble fraction = 0.0;

 /*Create a window with a title, and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "ProgressBar Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 220, 20);
 
 /*Create a progressbar and add it to the window*/
 progress_bar = gtk_progress_bar_new ();
 gtk_container_add (GTK_CONTAINER (window), progress_bar);

 /*Fill in the given fraction of the bar. Has to be between 0.0-1.0 inclusive*/
 gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (progress_bar), fraction);

 /*Use the created fill function every 500 milliseconds*/
 g_timeout_add (500, fill, GTK_PROGRESS_BAR (progress_bar));
 
 gtk_widget_show_all (window);
}
 


int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;
 
 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 
 return status;
}

external ref='media/progressbar.ogv' md5='36deab3dd4b5be968828fa2ef416d612'
ProgressBar (JavaScript)
A bar which animates to indicate progress
Pressing any key stops and starts this ProgressBar.
This ProgressBar is stopped and started by pressing any key.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ProgressBarExample = new Lang.Class({
 Name: 'ProgressBar Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsprogressbar',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 20,
 default_width: 220,
 title: "ProgressBar Example"});

 // Create the progress bar
 this.progressBar = new Gtk.ProgressBar ();
 this._window.add(this.progressBar);

 // Start the function that pulses the bar every 100 milliseconds
 this.sourceID = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, Lang.bind(this, this._barPulse));

 // Connect a keypress event to the function that toggles the bar to start or stop pulsing
 this._window.connect("key-press-event", Lang.bind(this, this._onKeyPress));

 // Show the window and all child widgets
 this._window.show_all();
 },



 // Pulse the progressbar (unless it has been disabled by a keypress)
 _barPulse: function() {
 this.progressBar.pulse();
 return true;
 },

 // Start or stop the progressbar when a key is pressed
 _onKeyPress: function() {
 if (this.sourceID == 0)
 this.sourceID = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, Lang.bind(this, this._barPulse));
 else {
 GLib.source_remove(this.sourceID);
 this.sourceID = 0;
 }
 }

});

// Run the application
let app = new ProgressBarExample ();
app.application.run (ARGV);

ProgressBar (Python)
A widget which indicates progress visually.
from gi.repository import GLib
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="ProgressBar Example", application=app)
 self.set_default_size(220, 20)

 # a progressbar
 self.progress_bar = Gtk.ProgressBar()
 # add the progressbar to the window
 self.add(self.progress_bar)

 # the method self.pulse is called each 100 milliseconds
 # and self.source_id is set to be the ID of the event source
 # (i.e. the bar changes position every 100 milliseconds)
 self.source_id = GLib.timeout_add(100, self.pulse)

 # event handler
 # any signal from the keyboard controls if the progressbar stops/starts
 def do_key_press_event(self, event):
 # if the progressbar has been stopped (therefore source_id == 0 - see
 # "else" below), turn it back on
 if (self.source_id == 0):
 self.source_id = GLib.timeout_add(100, self.pulse)
 # if the bar is moving, remove the source with the ID of source_id
 # from the main context (stop the bar) and set the source_id to 0
 else:
 GLib.source_remove(self.source_id)
 self.source_id = 0
 # stop the signal emission
 return True

 # source function
 # the progressbar is in "activity mode" when this method is called
 def pulse(self):
 self.progress_bar.pulse()
 # call the function again
 return True


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a ProgressBar widget
Instead of
To set a text and show it (superimposed over the bar) use



ProgressBar (Vala)
public class MyApplication : Gtk.Application {

 Gtk.ProgressBar progress_bar;

 protected override void activate () {
 var window = new Gtk.ApplicationWindow (this);
 window.set_title ("ProgressBar Example");
 window.set_default_size (220, 20);

 progress_bar = new Gtk.ProgressBar ();
 window.add (progress_bar);
 window.show_all ();

 double fraction = 0.0;
 progress_bar.set_fraction (fraction);
 GLib.Timeout.add (500, fill);
 }

 bool fill () {
 double fraction = progress_bar.get_fraction (); //get current progress
 fraction += 0.1; //increase by 10% each time this function is called

 progress_bar.set_fraction (fraction);

 /* This function is only called by GLib.Timeout.add while it returns true; */
 if (fraction &lt; 1.0)
 return true;
 return false;
 }
}

public int main (string[] args) {
 var progress_bar_application = new MyApplication ();
 int status = progress_bar_application.run (args);
 return status;
}


Properties (Python)
An explanation of properties, getters and setters.
Properties

label = Gtk.Label(label="Hello World", angle=25, halign=Gtk.Align.END)
Alternatively, you can define these properties separately by using the method associated with it.
label = Gtk.Label()
label.set_label("Hello World")
label.set_angle(25)
label.set_halign(Gtk.Align.END)
Once you have created such a label, you can get the text of the label with
Instead of using getters and setters you can also get and set the properties with

Python
Tutorials, code samples and platform demos in Python
Tutorial for beginners
external ref='media/radiobutton.png' md5='d115460280d8e41493dd98054b5822a5'
RadioButton (C)
A choice from multiple checkbuttons
RadioButton
These radiobuttons report their activity in the terminal.
#include &lt;gtk/gtk.hgt;



/*Signal handler for the "toggled" signal of the RadioButton*/
static void
button_toggled_cb (GtkWidget *button,
 gpointer user_data)
{
 char *b_state;
 const char *button_label;

 if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (button)))
 b_state = "on";
 else {
 b_state = "off";
 g_print ("\
");
 }

 button_label = gtk_button_get_label (GTK_BUTTON (button));

 g_print ("%s was turned %s\
", button_label, b_state);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *grid;
 GtkWidget *window;

 GtkWidget *button1;
 GtkWidget *button2;
 GtkWidget *button3;

 /*Create a window with a set title and default size.
 Also, set a border width for the amount of space to leave
 inside the window*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "RadioButton Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 250, 100);
 gtk_container_set_border_width (GTK_CONTAINER(window), 20);


 /*Create an initial radio button*/
 button1 = gtk_radio_button_new_with_label (NULL, "Button 1");

 /*Create a second radio button, and add it to the same group as Button 1*/
 button2 = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (button1), 
 "Button 2");

 /*Create a third button, and add it to the same group as Button 1*/
 button3 = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (button1), 
 "Button 3");


 /*Create a grid, attach the buttons, and position them accordingly*/
 grid = gtk_grid_new ();
 gtk_grid_attach (GTK_GRID (grid), button1, 0, 0, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), button2, 0, 1, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), button3, 0, 2, 1, 1);

 /*Be sure to set the initial state of each button*/
 gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button2), TRUE);
 gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button1), FALSE);
 gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button3), FALSE);

 /*Connect the signal handlers (aka Callback functions) to the buttons*/
 g_signal_connect (GTK_TOGGLE_BUTTON (button1), "toggled", 
 G_CALLBACK (button_toggled_cb), window);
 g_signal_connect (GTK_TOGGLE_BUTTON (button2), "toggled", 
 G_CALLBACK (button_toggled_cb), window);
 g_signal_connect (GTK_TOGGLE_BUTTON (button3), "toggled", 
 G_CALLBACK (button_toggled_cb), window);

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (grid));

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

external ref='media/radiobuttontravel.png' md5='0c5f01ee160bb42716ccf5dccbd080c0'
RadioButton (JavaScript)
Only one can be selected at a time
RadioButtons are named after old-style car radios, which had buttons for switching between channel presets. Because the radio could only be tuned to one station at a time, only one button could be pressed in at a time; if you pressed a new one, the one that was already pressed in would pop back out. That's how these buttons work, too.
Each RadioButton needs a text label and a group. Only one button in a group can be selected at a time. You don't name each group; you just set new RadioButtons to be part of the same group as an existing one. If you create a new one outside of a group, it automatically creates a new group for it to be part of.
const RadioButtonExample = new Lang.Class({
 Name: 'RadioButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsradiobutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
All the code for this sample goes in the RadioButtonExample class. The above code creates a
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Travel Planning"});
Creating the radiobuttons
// Create a label for the first group of buttons
 this._placeLabel = new Gtk.Label ({label: "Where would you like to travel to?"});
We use a
// Create three radio buttons three different ways
 this._place1 = new Gtk.RadioButton ({label: "The Beach"});

 this._place2 = Gtk.RadioButton.new_from_widget (this._place1);
 this._place2.set_label ("The Moon");

 this._place3 = Gtk.RadioButton.new_with_label_from_widget (this._place1, "Antarctica");
 // this._place3.set_active (true);
Here are three different ways to create RadioButtons. The first is the usual way, where we create a new Gtk.RadioButton and assign its properties at the same time. The second and third use functions which automatically handle some of the properties; new_from_widget takes a single argument, the RadioButton that you want to put this new one in the same group as. Meanwhile, new_with_label_from_widget takes that and the RadioButton's label at the same time.
The first RadioButton in a group is the one that's selected by default. Try uncommenting the last line in this sample code to see how you can set a different one to be the default selection.
// Create a label for the second group of buttons
 this._thingLabel = new Gtk.Label ({label: "And what would you like to bring?" });

 // Create three more radio buttons
 this._thing1 = new Gtk.RadioButton ({label: "Penguins" });
 this._thing2 = new Gtk.RadioButton ({label: "Sunscreen", group: this._thing1 });
 this._thing3 = new Gtk.RadioButton ({label: "A spacesuit", group: this._thing1 });
Here we create the label for the second group of buttons, and then create them all the same way.
Creating the rest of the user interface
// Create a stock OK button
 this._okButton = new Gtk.Button ({
 label: 'gtk-ok',
 use_stock: 'true',
 halign: Gtk.Align.END });

 // Connect the button to the function which handles clicking it
 this._okButton.connect ('clicked', Lang.bind (this, this._okClicked));
This code creates a
To make sure the button's "OK" label shows up properly in every language that GNOME is translated into, remember to use one of Gtk's
// Create a grid to put the "place" items in
 this._places = new Gtk.Grid ();

 // Attach the "place" items to the grid
 this._places.attach (this._placeLabel, 0, 0, 1, 1);
 this._places.attach (this._place1, 0, 1, 1, 1);
 this._places.attach (this._place2, 0, 2, 1, 1);
 this._places.attach (this._place3, 0, 3, 1, 1);

 // Create a grid to put the "thing" items in
 this._things = new Gtk.Grid ({ margin_top: 50 });

 // Attach the "thing" items to the grid
 this._things.attach (this._thingLabel, 0, 0, 1, 1);
 this._things.attach (this._thing1, 0, 1, 1, 1);
 this._things.attach (this._thing2, 0, 2, 1, 1);
 this._things.attach (this._thing3, 0, 3, 1, 1);

 // Create a grid to put everything in
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_left: 40,
 margin_right: 50 });

 // Attach everything to the grid
 this._grid.attach (this._places, 0, 0, 1, 1);
 this._grid.attach (this._things, 0, 1, 1, 1);
 this._grid.attach (this._okButton, 0, 2, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);
We use a separate
After we've organized them, we put them into a third, master Grid, along with the OK button. Then we attach that to the window.
Finally, we tell the window and everything inside it to become visible when the application is run.
_okClicked: function () {

 // Create a popup that shows a silly message
 this._travel = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 message_type: Gtk.MessageType.OTHER,
 buttons: Gtk.ButtonsType.OK,
 text: this._messageText() });

 // Show the popup
 this._travel.show();

 // Bind the OK button to the function that closes the popup
 this._travel.connect ("response", Lang.bind (this, this._clearTravelPopUp));

 },
When you click OK, a
_messageText: function() {

 // Create a silly message for the popup depending on what you selected
 var stringMessage = "";

 if (this._place1.get_active()) {

 if (this._thing1.get_active())
 stringMessage = "Penguins love the beach, too!";

 else if (this._thing2.get_active())
 stringMessage = "Make sure to put on that sunscreen!";

 else stringMessage = "Are you going to the beach in space?";

 }

 else if (this._place2.get_active()) {

 if (this._thing1.get_active())
 stringMessage = "The penguins will take over the moon!";

 else if (this._thing2.get_active())
 stringMessage = "A lack of sunscreen will be the least of your problems!";

 else stringMessage = "You'll probably want a spaceship, too!";
 }

 else if (this._place3.get_active()) {

 if (this._thing1.get_active())
 stringMessage = "The penguins will be happy to be back home!";

 else if (this._thing2.get_active())
 stringMessage = "Antarctic sunbathing may be hazardous to your health!";

 else stringMessage = "Try bringing a parka instead!";
 }

 return stringMessage;

 },
The get_active() method is how we can tell which RadioButton's pressed in. This function returns a different silly message depending on which set of buttons was pressed. Its return value is used as the MessageDialog's text property.
_clearTravelPopUp: function () {

 this._travel.destroy();

 }

});
This function is called when the MessageDialog's OK button is pressed. It simply makes the popup go away.
// Run the application
let app = new RadioButtonExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished RadioButtonExample class, and set the application running.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const RadioButtonExample = new Lang.Class({
 Name: 'RadioButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsradiobutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Travel Planning"});

 // Create a label for the first group of buttons
 this._placeLabel = new Gtk.Label ({label: "Where would you like to travel to?"});

 // Create three radio buttons three different ways
 this._place1 = new Gtk.RadioButton ({label: "The Beach"});

 this._place2 = Gtk.RadioButton.new_from_widget (this._place1);
 this._place2.set_label ("The Moon");

 this._place3 = Gtk.RadioButton.new_with_label_from_widget (this._place1, "Antarctica");
 // this._place3.set_active (true);

 // Create a label for the second group of buttons
 this._thingLabel = new Gtk.Label ({label: "And what would you like to bring?" });

 // Create three more radio buttons
 this._thing1 = new Gtk.RadioButton ({label: "Penguins" });
 this._thing2 = new Gtk.RadioButton ({label: "Sunscreen", group: this._thing1 });
 this._thing3 = new Gtk.RadioButton ({label: "A spacesuit", group: this._thing1 });

 // Create a stock OK button
 this._okButton = new Gtk.Button ({
 label: 'gtk-ok',
 use_stock: 'true',
 halign: Gtk.Align.END });

 // Connect the button to the function which handles clicking it
 this._okButton.connect ('clicked', Lang.bind (this, this._okClicked));

 // Create a grid to put the "place" items in
 this._places = new Gtk.Grid ();

 // Attach the "place" items to the grid
 this._places.attach (this._placeLabel, 0, 0, 1, 1);
 this._places.attach (this._place1, 0, 1, 1, 1);
 this._places.attach (this._place2, 0, 2, 1, 1);
 this._places.attach (this._place3, 0, 3, 1, 1);

 // Create a grid to put the "thing" items in
 this._things = new Gtk.Grid ({ margin_top: 50 });

 // Attach the "thing" items to the grid
 this._things.attach (this._thingLabel, 0, 0, 1, 1);
 this._things.attach (this._thing1, 0, 1, 1, 1);
 this._things.attach (this._thing2, 0, 2, 1, 1);
 this._things.attach (this._thing3, 0, 3, 1, 1);

 // Create a grid to put everything in
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_left: 40,
 margin_right: 50 });

 // Attach everything to the grid
 this._grid.attach (this._places, 0, 0, 1, 1);
 this._grid.attach (this._things, 0, 1, 1, 1);
 this._grid.attach (this._okButton, 0, 2, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _okClicked: function () {

 // Create a popup that shows a silly message
 this._travel = new Gtk.MessageDialog ({
 transient_for: this._window,
 modal: true,
 message_type: Gtk.MessageType.OTHER,
 buttons: Gtk.ButtonsType.OK,
 text: this._messageText() });

 // Show the popup
 this._travel.show();

 // Bind the OK button to the function that closes the popup
 this._travel.connect ("response", Lang.bind (this, this._clearTravelPopUp));

 },



 _messageText: function() {

 // Create a silly message for the popup depending on what you selected
 var stringMessage = "";

 if (this._place1.get_active()) {

 if (this._thing1.get_active())
 stringMessage = "Penguins love the beach, too!";

 else if (this._thing2.get_active())
 stringMessage = "Make sure to put on that sunscreen!";

 else stringMessage = "Are you going to the beach in space?";

 }

 else if (this._place2.get_active()) {

 if (this._thing1.get_active())
 stringMessage = "The penguins will take over the moon!";

 else if (this._thing2.get_active())
 stringMessage = "A lack of sunscreen will be the least of your problems!";

 else stringMessage = "You'll probably want a spaceship, too!";
 }

 else if (this._place3.get_active()) {

 if (this._thing1.get_active())
 stringMessage = "The penguins will be happy to be back home!";

 else if (this._thing2.get_active())
 stringMessage = "Antarctic sunbathing may be hazardous to your health!";

 else stringMessage = "Try bringing a parka instead!";
 }

 return stringMessage;

 },




 _clearTravelPopUp: function () {

 this._travel.destroy();

 }

});

// Run the application
let app = new RadioButtonExample ();
app.application.run (ARGV);




RadioButton (Python)
Mutually exclusive buttons.
Three RadioButtons. You can see in the terminal if they are turned off or on.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="RadioButton Example", application=app)
 self.set_default_size(250, 100)
 self.set_border_width(20)

 # a new radiobutton with a label
 button1 = Gtk.RadioButton(label="Button 1")
 # connect the signal "toggled" emitted by the radiobutton
 # with the callback function toggled_cb
 button1.connect("toggled", self.toggled_cb)

 # another radiobutton, in the same group as button1
 button2 = Gtk.RadioButton.new_from_widget(button1)
 # with label "Button 2"
 button2.set_label("Button 2")
 # connect the signal "toggled" emitted by the radiobutton
 # with the callback function toggled_cb
 button2.connect("toggled", self.toggled_cb)
 # set button2 not active by default
 button2.set_active(False)

 # another radiobutton, in the same group as button1,
 # with label "Button 3"
 button3 = Gtk.RadioButton.new_with_label_from_widget(
 button1, "Button 3")
 # connect the signal "toggled" emitted by the radiobutton
 # with the callback function toggled_cb
 button3.connect("toggled", self.toggled_cb)
 # set button3 not active by default
 button3.set_active(False)

 # a grid to place the buttons
 grid = Gtk.Grid.new()
 grid.attach(button1, 0, 0, 1, 1)
 grid.attach(button2, 0, 1, 1, 1)
 grid.attach(button3, 0, 2, 1, 1)
 # add the grid to the window
 self.add(grid)

 # callback function
 def toggled_cb(self, button):
 # a string to describe the state of the button
 state = "unknown"
 # whenever the button is turned on, state is on
 if button.get_active():
 state = "on"
 # else state is off
 else:
 state = "off"
 # whenever the function is called (a button is turned on or off)
 # print on the terminal which button was turned on/off
 print button.get_label() + " was turned " + state


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a RadioButton widget
In line 16 the signal
As seen in
button1 = Gtk.RadioButton()
button1.set_label("Button 1").
Yet another way to create a new RadioButton with a label is

RadioButton (Vala)
A choice from multiple CheckButtons.
These RadioButtons report their activity in the terminal.
public class MyWindow : Gtk.ApplicationWindow {
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "RadioButton Example");

 this.border_width = 20;
 this.set_default_size (250, 100);

 /* We demonstrate 3 different RadioButton creation methods */

 //Create a Radio Button
 var button1 = new Gtk.RadioButton (null);
 button1.set_label ("Button 1");

 //Create a RadioButton with a label, and add it to the same group as button1.
 var button2 = new Gtk.RadioButton.with_label (button1.get_group(),"Button 2");

 //Create a RadioButton with a label, adding it to button1's group.
 var button3 = new Gtk.RadioButton.with_label_from_widget (button1, "Button 3");

 //Attach the buttons to a grid.
 var grid = new Gtk.Grid ();
 grid.attach (button1, 0, 0, 1, 1);
 grid.attach (button2, 0, 1, 1, 1);
 grid.attach (button3, 0, 2, 1, 1);

 //Add the button to the window.
 this.add (grid);

 //Connect the signal handlers (aka. callback functions) to the buttons.
 button1.toggled.connect (button_toggled_cb);
 button2.toggled.connect (button_toggled_cb);
 button3.toggled.connect (button_toggled_cb);
 }

 void button_toggled_cb (Gtk.ToggleButton button)
 {
 var state = "unknown";

 if (button.get_active ())
 state = "on";
 else {
 state = "off";
 print ("\
");
 }
 print (button.get_label() + " was turned " + state + "\
");
 }
}

public class MyApplication : Gtk.Application {
 protected override void activate () {

 //Show all of the things.
 new MyWindow (this).show_all ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.MyApplication");
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/record-collection.png' md5='2d645997687ed5aacd36aafafc16e072'
Record collection (JavaScript)
Create a small database application for ordering your music collection
Record collection
How to connect to a database using libgda
How to insert and browse records in a database table
This demo uses the Javascript language. We are going to demonstrate how to connect and use a database from a GTK program, by using the GDA (GNOME Data Access) library. Thus you also need this library installed.
GNOME Data Access (GDA) is library whose purpose is to provide universal access to different kinds and types of data sources. This goes from traditional relational database systems, to any imaginable kind of data source such as a mail server, a LDAP directory, etc. For more information, and for a full API and documentation, visit the
Although a big part of the code is related to user interface (GUI), we are going to focus our tutorial on the database parts (we might mention other parts we think are relevant though). To know more about Javascript programs in GNOME, see the
Choose
Click
Program Structure
This demo is a simple GTK application (with a single window) capable of inserting records into a database table as well as browsing all records of the table. The table has two fields:
Starting the fun
Let's start by examining the skeleton of the program:
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Gda = imports.gi.Gda;
const Lang = imports.lang;

function Demo () {
 this._init ();
}

Demo.prototype = {

 _init: function () {
 this.setupWindow ();
 this.setupDatabase ();
 this.selectData ();
 }
}

Gtk.init (null, null);

var demo = new Demo ();

Gtk.main ();
Lines 1‒4: Initial imports. Pay special attention to line 3, which tells Javascript to import the GDA library, our focus in this tutorial.
Lines 6‒17: Define our
Lines 19‒23: Start the application.
Designing the application
Let's take a look at the
setupWindow: function () {
 this.window = new Gtk.Window ({title: "Data Access Demo", height_request: 350});
 this.window.connect ("delete-event", function () {
 Gtk.main_quit();
 return true;
 });

 // main box
 var main_box = new Gtk.Box ({orientation: Gtk.Orientation.VERTICAL, spacing: 5});
 this.window.add (main_box);

 // first label
 var info1 = new Gtk.Label ({label: "lt;bgt;Insert a recordlt;/bgt;", xalign: 0, use_markup: true});
 main_box.pack_start (info1, false, false, 5);

 // "insert a record" horizontal box
 var insert_box = new Gtk.Box ({orientation: Gtk.Orientation.HORIZONTAL, spacing: 5});
 main_box.pack_start (insert_box, false, false, 5);

 // ID field
 insert_box.pack_start (new Gtk.Label ({label: "ID:"}), false, false, 5);
 this.id_entry = new Gtk.Entry ();
 insert_box.pack_start (this.id_entry, false, false, 5);

 // Name field
 insert_box.pack_start (new Gtk.Label ({label: "Name:"}), false, false, 5);
 this.name_entry = new Gtk.Entry ({activates_default: true});
 insert_box.pack_start (this.name_entry, true, true, 5);

 // Insert button
 var insert_button = new Gtk.Button ({label: "Insert", can_default: true});
 insert_button.connect ("clicked", Lang.bind (this, this._insertClicked));
 insert_box.pack_start (insert_button, false, false, 5);
 insert_button.grab_default ();

 // Browse textview
 var info2 = new Gtk.Label ({label: "lt;bgt;Browse the tablelt;/bgt;", xalign: 0, use_markup: true});
 main_box.pack_start (info2, false, false, 5);
 this.text = new Gtk.TextView ({editable: false});
 var sw = new Gtk.ScrolledWindow ({shadow_type:Gtk.ShadowType.IN});
 sw.add (this.text);
 main_box.pack_start (sw, true, true, 5);

 this.count_label = new Gtk.Label ({label: "", xalign: 0, use_markup: true});
 main_box.pack_start (this.count_label, false, false, 0);

 this.window.show_all ();
 },
Lines 22 and 27: Create the 2 entries (for the two fields) in which users will type something to get inserted in the database.
Lines 31‒34: Create the Insert button. We connect its
Line 39: Create the widget (
Line 44: Create the label where we will show the number of records in the table. Initially it's empty, it will be updated later.
Connecting to and initializing the database
The code which makes the connection to the database is in the
setupDatabase: function () {
 this.connection = new Gda.Connection ({provider: Gda.Config.get_provider("SQLite"),
 cnc_string:"DB_DIR=" + GLib.get_home_dir () + ";DB_NAME=gnome_demo"});
 this.connection.open ();

 try {
 var dm = Gda.execute_select_command (this.connection, "select * from demo");
 } catch (e) {
 Gda.execute_non_select_command (this.connection, "create table demo (id integer, name varchar(100))");
 }
 },
Lines 2‒3: Create the GDA's


If the provider is not supported by GDA, or if the connection string is missing some element, line 2 will raise an exception. So, in real life we should handle it with JavaScript's statement
Line 4: Open the connection. In the SQLite provider, if the database does not exist, it will be created in this step.
Lines 6‒10: Try to do a simple select to check if the table exists (line 7). If it does not exist (because the database was just created), this command will raise an exception, which is handled by the
In order to run the SQL commands above we are using global GDA functions,
At this point we have the database set up, and are ready to use it.
Selecting
After connecting to the database, our demo's constructor calls the
selectData: function () {
 var dm = Gda.execute_select_command (this.connection, "select * from demo order by 1, 2");
 var iter = dm.create_iter ();

 var text = "";

 while (iter.move_next ()) {
 var id_field = Gda.value_stringify (iter.get_value_at (0));
 var name_field = Gda.value_stringify (iter.get_value_at (1));

 text += id_field + "\ =gt;\ " + name_field + '\
';
 }

 this.text.buffer.text = text;
 this.count_label.label = "lt;igt;" + dm.get_n_rows () + " record(s)lt;/igt;";
 },
Line 2: The
Line 3: Create an
Line 7: Loop through all the records, fetching them with the help of the
Lines 8‒9: We do two things in each line:
Use
The method
Line 11: Concatenate the two fields to make one text line, separated by
Line 14: After the loop is finished, we have all the records formatted in the
Line 15: Display the number of records in the table, making use of the
Inserting
OK, we know how to connect to a database and how to select rows from a table. Now it's time to do an
_insertClicked: function () {
 if (!this._validateFields ())
 return;

 // Gda.execute_non_select_command (this.connection,
 // "insert into demo values ('" + this.id_entry.text + "', '" + this.name_entry.text + "')");

 var b = new Gda.SqlBuilder ({stmt_type:Gda.SqlStatementType.INSERT});
 b.set_table ("demo");
 b.add_field_value_as_gvalue ("id", this.id_entry.text);
 b.add_field_value_as_gvalue ("name", this.name_entry.text);
 var stmt = b.get_statement ();
 this.connection.statement_execute_non_select (stmt, null);

 this._clearFields ();
 this.selectData ();
 },
We have learned how to use GDA's convenience functions
Lines 2‒3: Check if the user filled all the fields. The code for the private method
Line 5: The faster way of doing the
Line 7: Create the
Line 8: Set the name of the table on which the built statement will operate (it will generate
Lines 9‒10: Set the fields and its values that will be part of the statement. The first argument is the field name (as in the table). The second one is the value for that field.
Line 11: Get the dynamically generated
Line 12: Finally, execute the SQL statement (
Line 14: Clear the id and name fields on the screen. The code for the private method
Line 15: Refresh the view on the screen by doing another
You can also make use of parameters while building the statement. By using the
All of the code you need should now be in place, so try running the code. You now have a database for your record collection!
If you run into problems with the tutorial, compare your code with this
enum ResponseType
ResponseType.NONE = -1
Returned if an action widget has no response id, or if the dialog gets programmatically hidden or destroyed
ResponseType.REJECT = -2
Generic response id, not used by GTK+ dialogs
ResponseType.ACCEPT = -3
ResponseType.DELETE_EVENT = -4
Returned if the dialog is deleted
ResponseType.OK = -5
Returned by OK buttons in GTK+ dialogs
ResponseType.CANCEL = -6
Returned by Cancel buttons in GTK+ dialogs
ResponseType.CLOSE = -7
Returned by Close buttons in GTK+ dialogs
ResponseType.YES = -8
Returned by Yes buttons in GTK+ dialogs
ResponseType.NO = -9
Returned by No buttons in GTK+ dialogs
ResponseType.APPLY = -10
Returned by Apply buttons in GTK+ dialogs
ResponseType.HELP = -11
Returned by Help buttons in GTK+ dialogs
external ref='media/scale2.png' md5='ae2ba0a6675f3d9cdcd961cdf32f1a5c'
Scale (C)
A slider widget for selecting a value from a range
Scale
Slide the scales!
#include &lt;gtk/gtk.hgt;



/* This is the callback function. 
 * It is a handler function which reacts to the signal. 
 * In this case, it will notify the user the value of their scale as a label.
 */
static void
hscale_moved (GtkRange *range,
 gpointer user_data)
{
 GtkWidget *label = user_data;

 /* Get the value of the range, and convert it into a string which will be
 * used as a new label for the horizontal scale.
 * %.0f - stands for a double that will have 0 decimal places.
 */
 gdouble pos = gtk_range_get_value (range);
 /* Note: Using g_strdup_printf returns a string that must be freed. 
 * (In which is done below)
 */
 gchar *str = g_strdup_printf ("Horizontal scale is %.0f", pos);
 gtk_label_set_text (GTK_LABEL (label), str);

 g_free(str);
}



/* This is the second callback function. It is a handler function which 
 * reacts to the signal. It does the same thing as the function above, except with
 * the vertical scale.
 */
vscale_moved (GtkRange *range,
 gpointer user_data)
{
 GtkWidget *label = user_data;
 
 gdouble pos = gtk_range_get_value (range);
 /* %.1f - stands for a double that will have 1 decimal place */
 gchar *str = g_strdup_printf ("Vertical scale is %.1f", pos);
 gtk_label_set_text (GTK_LABEL (label), str);

 
 g_free (str);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 /* Declare variables */
 GtkWidget *window;
 GtkWidget *h_scale;
 GtkWidget *v_scale;
 GtkWidget *hlabel;
 GtkWidget *vlabel;
 GtkWidget *grid;

 /* The Adjustment object represents a value 
 * which has an associated lower and upper bound.
 */
 GtkAdjustment *hadjustment;
 GtkAdjustment *vadjustment;

 /* Create a window with a title and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Scale Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 400, 300);
 gtk_container_set_border_width (GTK_CONTAINER (window), 5);

 /* Two labels to be shown in the window */
 hlabel = gtk_label_new ("Move the scale handle...");
 vlabel = gtk_label_new ("Move the scale handle...");

 
 /* gtk_adjustment_new takes six parameters, three of which 
 * may be difficult to understand:
 * step increment- move the handle with the arrow keys on your keyboard to see.
 * page increment - move the handle by clicking away from it 
 * on the scale to see.
 * page size - not used here.
 */
 hadjustment = gtk_adjustment_new (0, 0, 100, 5, 10, 0);
 vadjustment = gtk_adjustment_new (50, 0, 100, 5, 10, 0); 

 /* Create the Horizontal scale, making sure the 
 * digits used have no decimals.
 */
 h_scale = gtk_scale_new (GTK_ORIENTATION_HORIZONTAL, hadjustment);
 gtk_scale_set_digits (GTK_SCALE (h_scale), 0); 

 /* Allow it to expand horizontally (if there's space), and 
 * set the vertical alignment
 */
 gtk_widget_set_hexpand (h_scale, TRUE);
 gtk_widget_set_valign (h_scale, GTK_ALIGN_START);
 
 /* Connecting the "value-changed" signal for the horizontal scale 
 * to the appropriate callback function. 
 * take note that GtkRange is part of GtkScale's Object Hierarchy.
 */
 g_signal_connect (h_scale, 
 "value-changed", 
 G_CALLBACK (hscale_moved), 
 hlabel);



 /* Create the Vertical scale. This time, we will see what happens 
 * when the digits arent initially set.
 */
 v_scale = gtk_scale_new (GTK_ORIENTATION_VERTICAL, vadjustment);
 gtk_widget_set_vexpand (v_scale, TRUE);

 /* Connecting the "value-changed" signal for the vertical scale to 
 * the appropriate callback function.
 */
 g_signal_connect (v_scale, 
 "value-changed", 
 G_CALLBACK (vscale_moved), 
 vlabel);

 /* Create a grid and arrange everything accordingly */
 grid = gtk_grid_new ();
 gtk_grid_set_column_spacing (GTK_GRID (grid), 10);
 gtk_grid_set_column_homogeneous (GTK_GRID (grid), TRUE);
 gtk_grid_attach (GTK_GRID (grid), h_scale, 0, 0, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), v_scale, 1, 0, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), hlabel, 0, 1, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), vlabel, 1, 1, 1, 1);
 

 gtk_container_add (GTK_CONTAINER (window), grid);

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}




external ref='media/scalepenguins.png' md5='2dbe6a833fec86fde71a5ddb421e2cd5'
Scale (JavaScript)
A slider which corresponds to a numerical value
A Scale is a horizontal or vertical slider, that represents a value inside a numerical range. When you create a new Scale, you set what its default position is, what the numbers at the top and bottom of the range are, and things like how much it moves up or down when you click on the Scale to either side of the knob. To keep from having to type all that in every time you create a new Scale, you can create an object called an Adjustment which keeps track of all that, then tell each new Scale to use that Adjustment.
This scale is a simple widget that lets you adjust the size of an iceberg that penguins live on. The number of penguins on the iceberg is the product of the values of the two sliders. Try playing with them and seeing what happens.
const ScaleExample = new Lang.Class({
 Name: 'Scale Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsscale'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
All the code for this sample goes in the ScaleExample class. The above code creates a
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Birds on a Floe"});
Creating the scales
// Create the horizontal scale
 this._hScale = Gtk.Scale.new_with_range (Gtk.Orientation.HORIZONTAL, 0.0, 100.0, 5.0);
 this._hScale.set_valign (Gtk.Align.START);
 this._hScale.set_value (50);
 this._hScale.set_digits (0);
 // this._hScale.set_draw_value (false);
The new_with_range method is one way to create a new Scale widget. The parameters it takes are a
We can use the set_draw_value method to tell it whether or not to show the number next to the sliding scale. It's commented out in this example.
// Create a master adjustment to use for the vertical (or any other) scale
 this._adjustment = new Gtk.Adjustment ({
 value: 95,
 lower: 0,
 upper: 100,
 step_increment: 5,
 page_increment: 10 });
An Adjustment is an object we can use to simplify things when creating a new Scale. The Adjustment's "value" property is what the Scale's default value is, while "upper" and "lower" make the high and low ends of the numerical range. Meanwhile, the increment values show how much the slider moves when you do things like click on it.
// Create a vertical scale using the adjustment we just made
 this._vScale = new Gtk.Scale ({
 orientation: Gtk.Orientation.VERTICAL,
 adjustment: this._adjustment,
 digits: 0,
 // draw_value: false,
 margin_left: 10 });
Here we create a new Scale object using _adjustment as its "adjustment" property. This is a great shortcut. We still have to tell it to round off the decimal place, though. Note that the draw_value property is commented out; this is how you tell it not to show the number next to the Scale when you're creating one this way.
// Create the label that shows the product of the two values
 this._product = (this._hScale.get_value() * this._vScale.get_value());
 this._label = new Gtk.Label ({
 label: (String(this._product) + " penguins on the iceberg."),
 height_request: 200,
 width_request: 200,
 wrap: true});

 // Connect the two scales to functions which recalculate the label
 this._hScale.connect ("value-changed", Lang.bind (this, this._recalc));
 this._vScale.connect ("value-changed", Lang.bind (this, this._recalc));
We can use the get_value method to find out the numerical value a Scale is set at. We can then do whatever we want with it, including multiply the two Scales' values together and have a
After we create the Label, we connect the two Scales' "value-changed" signals to _recalc, a function that will recalculate the number of penguins on the iceberg and come up with a new message.
// Create a grid to arrange things in
 this._UIGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_top: 20,
 margin_left: 20});

 // Attach everything to the grid
 this._UIGrid.attach (this._label, 0, 0, 1, 1);
 this._UIGrid.attach (this._hScale, 0, 1, 1, 1);
 this._UIGrid.attach (this._vScale, 1, 0, 1, 1);
Here we create a
// Add the grid to the window
 this._window.add (this._UIGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },
Finally, we add the Grid to the window, then tell the window to show itself and all the widgets inside of it.
Function which handles the scales' values changing
_recalc: function() {

 // Figure out what the product of the two scales' values is
 var product = (this._hScale.get_value() * this._vScale.get_value());

 // Create a blank comment line in case there isn't a silly comment to make
 var comment = "";

 // Make a silly comment based on the number of penguins
 if (product &gt; 9000) {
 comment = "It's over 9000!";
 }
 else if (product &lt; 1000 &amp; product &gt; 0) {
 comment = "They're getting lonely.";
 }
 else if (product == 0) {
 comment = "They're all gone ...";
 }
 else comment = "";

 // Set ._label's new text
 this._label.set_label (String (product) + " penguins on the iceberg. " + comment);

 }

});
Remember, we can get a Scale's value using its get_value method. Here we simply recalculate what the product of the two values is after one of the Scales is moved, add in a silly message depending on how many penguins are left, and change the wording on _label to show the new number and message.
// Run the application
let app = new ScaleExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished ScaleExample class, and set the application running.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ScaleExample = new Lang.Class({
 Name: 'Scale Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsscale'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Birds on a Floe"});

 // Create the horizontal scale
 this._hScale = Gtk.Scale.new_with_range (Gtk.Orientation.HORIZONTAL, 0.0, 100.0, 5.0);
 this._hScale.set_valign (Gtk.Align.START);
 this._hScale.set_value (50);
 this._hScale.set_digits (0);
 // this._hScale.set_draw_value (false);

 // Create a master adjustment to use for the vertical (or any other) scale
 this._adjustment = new Gtk.Adjustment ({
 value: 95,
 lower: 0,
 upper: 100,
 step_increment: 5,
 page_increment: 10 });

 // Create a vertical scale using the adjustment we just made
 this._vScale = new Gtk.Scale ({
 orientation: Gtk.Orientation.VERTICAL,
 adjustment: this._adjustment,
 digits: 0,
 // draw_value: false,
 margin_left: 10 });

 // Create the label that shows the product of the two values
 this._product = (this._hScale.get_value() * this._vScale.get_value());
 this._label = new Gtk.Label ({
 label: (String(this._product) + " penguins on the iceberg."),
 height_request: 200,
 width_request: 200,
 wrap: true});

 // Connect the two scales to functions which recalculate the label
 this._hScale.connect ("value-changed", Lang.bind (this, this._recalc));
 this._vScale.connect ("value-changed", Lang.bind (this, this._recalc));

 // Create a grid to arrange things in
 this._UIGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_top: 20,
 margin_left: 20});

 // Attach everything to the grid
 this._UIGrid.attach (this._label, 0, 0, 1, 1);
 this._UIGrid.attach (this._hScale, 0, 1, 1, 1);
 this._UIGrid.attach (this._vScale, 1, 0, 1, 1);

 // Add the grid to the window
 this._window.add (this._UIGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _recalc: function() {

 // Figure out what the product of the two scales' values is
 var product = (this._hScale.get_value() * this._vScale.get_value());

 // Create a blank comment line in case there isn't a silly comment to make
 var comment = "";

 // Make a silly comment based on the number of penguins
 if (product &gt; 9000) {
 comment = "It's over 9000!";
 }
 else if (product &lt; 1000 &amp; product &gt; 0) {
 comment = "They're getting lonely.";
 }
 else if (product == 0) {
 comment = "They're all gone ...";
 }
 else comment = "";

 // Set ._label's new text
 this._label.set_label (String (product) + " penguins on the iceberg. " + comment);

 }

});

// Run the application
let app = new ScaleExample ();
app.application.run (ARGV);


external ref='media/scale.png' md5='462c52a53b773cb9e8c62c646bf88452'
Scale (Python)
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Scale Example", application=app)
 self.set_default_size(400, 300)
 self.set_border_width(5)

 # two adjustments (initial value, min value, max value,
 # step increment - press cursor keys to see!,
 # page increment - click around the handle to see!,
 # page size - not used here)
 ad1 = Gtk.Adjustment(0, 0, 100, 5, 10, 0)
 ad2 = Gtk.Adjustment(50, 0, 100, 5, 10, 0)

 # an horizontal scale
 self.h_scale = Gtk.Scale(
 orientation=Gtk.Orientation.HORIZONTAL, adjustment=ad1)
 # of integers (no digits)
 self.h_scale.set_digits(0)
 # that can expand horizontally if there is space in the grid (see
 # below)
 self.h_scale.set_hexpand(True)
 # that is aligned at the top of the space allowed in the grid (see
 # below)
 self.h_scale.set_valign(Gtk.Align.START)

 # we connect the signal "value-changed" emitted by the scale with the callback
 # function scale_moved
 self.h_scale.connect("value-changed", self.scale_moved)

 # a vertical scale
 self.v_scale = Gtk.Scale(
 orientation=Gtk.Orientation.VERTICAL, adjustment=ad2)
 # that can expand vertically if there is space in the grid (see below)
 self.v_scale.set_vexpand(True)

 # we connect the signal "value-changed" emitted by the scale with the callback
 # function scale_moved
 self.v_scale.connect("value-changed", self.scale_moved)

 # a label
 self.label = Gtk.Label()
 self.label.set_text("Move the scale handles...")

 # a grid to attach the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing(10)
 grid.set_column_homogeneous(True)
 grid.attach(self.h_scale, 0, 0, 1, 1)
 grid.attach_next_to(
 self.v_scale, self.h_scale, Gtk.PositionType.RIGHT, 1, 1)
 grid.attach(self.label, 0, 1, 2, 1)

 self.add(grid)

 # any signal from the scales is signaled to the label the text of which is
 # changed
 def scale_moved(self, event):
 self.label.set_text("Horizontal scale is " + str(int(self.h_scale.get_value())) +
 "; vertical scale is " + str(self.v_scale.get_value()) + ".")


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Scale widget
A Gtk.Adjustment is needed to construct the Gtk.Scale. This is the representation of a value with a lower and upper bound, together with step and page increments, and a page size, and it is constructed as
In line 28 the signal

Use
To highlight the part of the scale between the origin and the current value:
self.h_scale.set_restrict_to_fill_level(False)
self.h_scale.set_fill_level(self.h_scale.get_value())
self.h_scale.set_show_fill_level(True)
in the callback function of the "value-changed" signal, so to have the new filling every time the value is changed. These are methods of the class Gtk.Range.





Scale (Vala)
/* This is the application. */
public class MyApplication : Gtk.Application {
 Gtk.Scale h_scale;
 Gtk.Scale v_scale;
 Gtk.Label label;

 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {
 var window = new Gtk.ApplicationWindow (this);
 window.title = "Scale Example";
 window.set_default_size (400, 300);
 window.set_border_width (5);

 h_scale = new Gtk.Scale.with_range (Gtk.Orientation.HORIZONTAL, 0.0, 100.0, 5.0);
 h_scale.set_digits (0); //number of decimal places displayed
 h_scale.set_valign (Gtk.Align.START); //horizontal alignment

 var adjustment = new Gtk.Adjustment (42.0, 0.0, 100.0, 5.0, 10.0, 0.0);
 v_scale = new Gtk.Scale (Gtk.Orientation.VERTICAL, adjustment);
 v_scale.set_vexpand(true);

 label = new Gtk.Label ("Move the scale handles...");

 var grid = new Gtk.Grid ();
 grid.set_column_spacing (10); //amount of space between columns
 grid.set_column_homogeneous (true); //all columns same width
 grid.attach (h_scale, 0, 0, 1, 1);
 grid.attach_next_to (v_scale, h_scale, Gtk.PositionType.RIGHT, 1, 1);
 grid.attach (label, 0, 1, 2, 1);

 h_scale.value_changed.connect (scale_moved);
 v_scale.value_changed.connect (scale_moved);

 window.add (grid);
 window.show_all ();
 }

 /* Callback function for "value-changed" signal.
 * The paramter refers to the scale which emitted the signal.
 * Since we are accessing the values of not one, but two scales,
 * we made the ranges instance variables, and ignore the
 * parameter.
 */
 void scale_moved (Gtk.Range range) {
 label.set_text ("Horizontal scale is %.1f; vertical scale is %.1f.".printf (h_scale.get_value (), v_scale.get_value ()));
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}




external ref='media/scrolledwindow.png' md5='697bb3205d5c4fb0b4ea8db435843157'
ScrolledWindow (C)
Adds scrollbars to its child widget
ScrolledWindow
An image in a scrolled window.
#include &lt;gtk/gtk.hgt;



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 /* Declare variables */
 GtkWidget *window;
 GtkWidget *scrolled_window;
 GtkWidget *image;

 /* Create a window with a title, and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "ScrolledWindow Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 220, 200);

 /* Create the scrolled window. Usually NULL is passed for both parameters so
 * that it creates the horizontal/vertical adjustments automatically. Setting
 * the scrollbar policy to automatic allows the scrollbars to only show up
 * when needed.
 */
 scrolled_window = gtk_scrolled_window_new (NULL, NULL);
 /* Set the border width */
 gtk_container_set_border_width (GTK_CONTAINER (scrolled_window), 10);
 /* Extract our desired image from a file that we have */
 image = gtk_image_new_from_file ("gnome-image.png");
 /* And add it to the scrolled window */
 gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW (scrolled_window), image);
 /* Set the policy of the horizontal and vertical scrollbars to automatic.
 * What this means is that the scrollbars are only present if needed.
 */
 gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window),
 GTK_POLICY_AUTOMATIC,
 GTK_POLICY_AUTOMATIC);

 gtk_container_add (GTK_CONTAINER (window), scrolled_window);

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

ScrolledWindow (JavaScript)
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ScrolledWindowExample = new Lang.Class ({
 Name: 'ScrolledWindow Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application({ application_id: 'org.example.jscrolledwindow' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this.window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function() {
 // Create the application window
 this.window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "ScrolledWindow Example",
 default_width: 200,
 default_height: 200,
 border_width: 10 });
 // the scrolledwindow
 this.scrolledWindow = new Gtk.ScrolledWindow();
 this.scrolledWindow.set_border_width(10);
 // there is always the scrollbar (otherwise: AUTOMATIC - only if needed - or NEVER)
 this.scrolledWindow.set_policy(Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS);
 // an image - slightly larger than the window
 this.image = new Gtk.Image();
 this.image.set_from_file("gnome-image.png");

 // add the image to the scrolledwindow
 this.scrolledWindow.add_with_viewport(this.image);

 // add the scrolledwindow to the window
 this.window.add(this.scrolledWindow);
 this.window.show_all();
 }
});

// Run the application
let app = new ScrolledWindowExample();
app.application.run (ARGV);

ScrolledWindow (Python)
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(
 self, title="ScrolledWindow Example", application=app)
 self.set_default_size(200, 200)

 # the scrolledwindow
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(10)
 # there is always the scrollbar (otherwise: AUTOMATIC - only if needed
 # - or NEVER)
 scrolled_window.set_policy(
 Gtk.PolicyType.ALWAYS, Gtk.PolicyType.ALWAYS)

 # an image - slightly larger than the window...
 image = Gtk.Image()
 image.set_from_file("gnome-image.png")

 # add the image to the scrolledwindow
 scrolled_window.add_with_viewport(image)

 # add the scrolledwindow to the window
 self.add(scrolled_window)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a ScrolledWindow widget





ScrolledWindow (Vala)
/* This is the application. */
public class MyApplication : Gtk.Application {
 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {
 /* Create the window of this application. */
 var window = new Gtk.ApplicationWindow (this);
 window.title = "ScrolledWindow Example";
 window.set_default_size (200, 200);

 var scrolled_window = new Gtk.ScrolledWindow (null, null);
 scrolled_window.set_border_width (10);
 scrolled_window.add_with_viewport (new Gtk.Image.from_file ("gnome-image.png"));
 scrolled_window.set_policy (Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC);

 window.add (scrolled_window);
 window.show_all ();
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}


external ref='media/separator.png' md5='8769b27662ce5c77f99e9ce33751a21a'
Separator (C)
A separator widget
Separator
A horizontal and a vertical separator divide some labels.
#include &lt;gtk/gtk.hgt;

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *grid;
 GtkWidget *window;
 GtkWidget *label1;
 GtkWidget *label2;
 GtkWidget *label3;
 GtkWidget *hseparator;
 GtkWidget *vseparator;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Separator Example");

 label1 = gtk_label_new ("Below, a horizontal separator.");
 label2 = gtk_label_new ("On the right, a vertical separator.");
 label3 = gtk_label_new ("On the left, a vertical separator.");

 vseparator = gtk_separator_new (GTK_ORIENTATION_VERTICAL);
 hseparator = gtk_separator_new (GTK_ORIENTATION_HORIZONTAL);

 grid = gtk_grid_new ();

 gtk_grid_attach (GTK_GRID (grid), label1, 0, 0, 3, 1);
 gtk_grid_attach (GTK_GRID (grid), hseparator, 0, 1, 3, 1);
 gtk_grid_attach (GTK_GRID (grid), label2, 0, 2, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), vseparator, 1, 2, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), label3, 2, 2, 1, 1);

 gtk_grid_set_column_homogeneous (GTK_GRID (grid), TRUE);

 gtk_container_add (GTK_CONTAINER (window), grid);

 gtk_widget_show_all (window);
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}
API Reference

Seperator (Python)
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Separator Example", application=app)

 # three labels
 label1 = Gtk.Label()
 label1.set_text("Below, a horizontal separator.")

 label2 = Gtk.Label()
 label2.set_text("On the right, a vertical separator.")

 label3 = Gtk.Label()
 label3.set_text("On the left, a vertical separator.")

 # a horizontal separator
 hseparator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
 # a vertical separator
 vseparator = Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)

 # a grid to attach labels and separators
 grid = Gtk.Grid()
 grid.attach(label1, 0, 0, 3, 1)
 grid.attach(hseparator, 0, 1, 3, 1)
 grid.attach(label2, 0, 2, 1, 1)
 grid.attach(vseparator, 1, 2, 1, 1)
 grid.attach(label3, 2, 2, 1, 1)
 grid.set_column_homogeneous(True)
 # add the grid to the window
 self.add(grid)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Separator (Vala)
/* This is the application. */
public class Application : Gtk.Application {

 public Application () {
 Object (application_id: "org.example.window");
 }

 /* Override the 'activate' signal of GLib.Application,
 * which is inherited by Gtk.Application. */
 public override void activate () {

 var window = new Gtk.Window ();
 window.title = "Separator Example";

 var label1 = new Gtk.Label ("Below, a horizontal separator.");
 var label2 = new Gtk.Label ("On the right, a vertical separator.");
 var label3 = new Gtk.Label ("On the left, a vertical separator.");

 var hseparator = new Gtk.Separator (Gtk.Orientation.HORIZONTAL);
 var vseparator = new Gtk.Separator (Gtk.Orientation.VERTICAL);

 var grid = new Gtk.Grid();

 grid.attach (label1, 0, 0, 3, 1);
 grid.attach (hseparator, 0, 1, 3, 1);
 grid.attach (label2, 0, 2, 1, 1);
 grid.attach (vseparator, 1, 2, 1, 1);
 grid.attach (label3, 2, 2, 1, 1);

 grid.set_column_homogeneous(true);

 window.add (grid);
 this.add_window (window);

 window.show_all ();
 }
}

/* The main function creates the application and runs it.*/
int main (string[] args) {
 var app = new Application ();
 return app.run (args);
}




external ref='media/geditview.png' md5='f1438295662d95f56fcd1d8200efaaf2'
external ref='media/gediteditor.png' md5='50db1ee8f2c545744879ee9fba5b4b24'
Set up gedit for JavaScript development
This tutorial will show you how to set up
Making code clearer
Click on
Here are the options you want to make sure are turned on.



Making editing easier
In gedit's
Here, you want to have
If you want to share code with other people who write GNOME JavaScript applications, you'll also want to set
Signals and callbacks (Python)
An explanation of signals and callbacks in GTK+.
Signals and callbacks
Like most GUI toolkits, GTK+ uses an event-driven programming model. When the user is doing nothing, GTK+ sits in the main loop and waits for input. If the user performs some action - say, a mouse click - then the main loop "wakes up" and delivers an event to GTK+.
When widgets receive an event, they frequently emit one or more signals. Signals notify your program that "something interesting happened" by invoking functions you have connected to the signal. Such functions are commonly known as callbacks. When your callbacks are invoked, you would typically take some action. After a callback finishes, GTK+ will return to the main loop and await more user input.
A generic example is:
The function returns a number (the


external ref='media/spinbutton.png' md5='993cbb7d9bd271a329727a926195712a'
SpinButton (C)
Retrieve an integer or floating point number
SpinButton
Choose a number, by entering it or by clicking on the -/+ buttons!
#include &lt;gtk/gtk.hgt;



/* This is the callback function. 
 * It is a handler function which reacts to the signal. 
 * In this case, it will notify the user the value of their spinbutton 
 * as a label.
 */
static void
spin_clicked (GtkSpinButton *spinbutton,
 gpointer user_data)
{
 GtkWidget *label = user_data;
 gint value = gtk_spin_button_get_value_as_int (spinbutton);

 /* %d - Is used when printing integers.
 * Note: Using g_strdup_printf returns a string that must be freed. 
 * (In which is done below)
 */
 gchar *str = g_strdup_printf ("The number you selected is %d.", value);
 gtk_label_set_text (GTK_LABEL (label), str);

 g_free(str);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 /* Declare variables */
 GtkWidget *window;
 GtkWidget *label;
 GtkWidget *grid;
 GtkWidget *spin_button;
 GtkAdjustment *adjustment;


 /* Create a window with a title, a border width, and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "SpinButton Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 210, 70);
 gtk_container_set_border_width (GTK_CONTAINER (window), 5);

 /* Create a label to be shown in the window */
 label = gtk_label_new ("Choose a number");

 /* Create an adjustment representing an adjustable bounded value */
 adjustment = gtk_adjustment_new (0, 0, 100, 1, 0, 0);


 /* Create a spin button that is to be as wide as possible */
 spin_button = gtk_spin_button_new (adjustment, 1, 0);
 gtk_widget_set_hexpand (spin_button, TRUE);
 
 /* Connecting the "value-changed" signal for the spinbutton 
 * to the appropriate callback function. 
 */
 g_signal_connect (spin_button, 
 "value-changed", 
 G_CALLBACK (spin_clicked), 
 label);


 /* Create a grid and arrange everything accordingly */
 grid = gtk_grid_new ();
 gtk_grid_set_column_spacing (GTK_GRID (grid), 10);
 gtk_grid_set_column_homogeneous (GTK_GRID (grid), TRUE);
 gtk_grid_attach (GTK_GRID (grid), spin_button, 0, 0, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), label, 0, 1, 1, 1);
 

 gtk_container_add (GTK_CONTAINER (window), grid);

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

external ref='media/spinbuttonkittens.png' md5='577cce8a902140aacbab73fe8a76a010'
SpinButton (JavaScript)
A number entry field that has + and - buttons
A SpinButton is not related to a
It's best used when it's obvious that only a number can be entered into it. In this example, two SpinButtons are used for the number of kittens and number of cans of tuna to give them.
const SpinButtonExample = new Lang.Class({
 Name: 'SpinButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsspinbutton'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
All the code for this sample goes in the SpinButtonExample class. The above code creates a