# language_name_wals:	English
# language_name_glotto:	English
# ISO_6393:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

@@image: 'images/desktop-applications-menu.png'; md5=0b08c5d6354feb1bd601a68d88999c1b
@@image: 'images/desktop-applications-menu.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-titlebar.png'; md5=f3a539fb45f96afd16cde4280ec48582
@@image: 'images/windows-titlebar.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-primary.png'; md5=672a3e9cd994d9ba67d4386ec760cf6a
@@image: 'images/windows-primary.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-sdi.png'; md5=9cdd500c143b3e2622e16724f88038d8
@@image: 'images/windows-sdi.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-mdi.png'; md5=d3ec40c245185fd1f4c6b8ee88dd0283
@@image: 'images/windows-mdi.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-explicit-apply.png'; md5=b7562529cbf3254eaebdd23e0e7d3c6d
@@image: 'images/windows-explicit-apply.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-properties.png'; md5=ce2487375f69fb434771bca22979f14c
@@image: 'images/windows-properties.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-preferences.png'; md5=2bb39dde595f2617eba290f8a767c468
@@image: 'images/windows-preferences.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-toolbox-small.png'; md5=6f5478378f88650eba33719f2eee3d92
@@image: 'images/windows-toolbox-small.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-toolbox-large.png'; md5=d641055d9b6630c3584b5d45dd34435e
@@image: 'images/windows-toolbox-large.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-information.png'; md5=804b2f55edb07a2e489f5dd20a5df005
@@image: 'images/windows-alert-information.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-text.png'; md5=4677ef5fc0f7428c80232f70eebdf396
@@image: 'images/windows-alert-text.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-buttons.png'; md5=50dfa03bfdf2b821f1fe148704e2d9ee
@@image: 'images/windows-alert-buttons.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-spacing.png'; md5=4d87f8ba4f0841efa33a6edec624e38f
@@image: 'images/windows-alert-spacing.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-error.png'; md5=23d4c72f86b98b3842b9074cfb763cec
@@image: 'images/windows-alert-error.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-confirmation.png'; md5=e0f9ba107457bf0dbfbc5907c71b5065
@@image: 'images/windows-alert-confirmation.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-save.png'; md5=2fbcd004a3466633e6c9a184c4b888b0
@@image: 'images/windows-alert-save.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-alert-authentication.png'; md5=60d23bd30e719e9602387a2f2ee6a7cc
@@image: 'images/windows-alert-authentication.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-progress.png'; md5=40f92a53a000c95d51410d11daf75b61
@@image: 'images/windows-progress.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-progress-copy-file.png'; md5=858fda0649fd3017b875be2ca234e1da
@@image: 'images/windows-progress-copy-file.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-progress-checklist-start.png'; md5=c2b79b969b2ab626e81e2bc97a632d58
@@image: 'images/windows-progress-checklist-start.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-progress-checklist.png'; md5=4c79589f4213ccd28984dd793cae31c2
@@image: 'images/windows-progress-checklist.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-progress-checklist-done.png'; md5=aa397ad0c09ee31c92a18ba78f0a536a
@@image: 'images/windows-progress-checklist-done.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-dialog-tabbed.png'; md5=94955ac084850a624ea1cfe46ae7995d
@@image: 'images/windows-dialog-tabbed.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/windows-assistant-first-page.png'; md5=1d0487a69947157334ad7fb65c19759c
@@image: 'images/windows-assistant-first-page.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-application.png'; md5=878fb4c0eb7c8712b2ce713a27d3d6ae
@@image: 'images/menus-application.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-dropdown.png'; md5=cc95412f124a671295e35eb33b97d544
@@image: 'images/menus-dropdown.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-submenu.png'; md5=d334b8f143e16dfe6f69593fe03ff8b6
@@image: 'images/menus-submenu.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-popup.png'; md5=8b1c90e5243d93a85aab5ec7fa64da52
@@image: 'images/menus-popup.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-command-group.png'; md5=4f77edca4a7de9811fe74f6351fb3d7e
@@image: 'images/menus-command-group.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-checkbox-group.png'; md5=94df0c26dd33ff005f1bf89254c45350
@@image: 'images/menus-checkbox-group.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-radiobutton-group.png'; md5=29de7d97b34deb625e9d819dd05f7594
@@image: 'images/menus-radiobutton-group.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-file.png'; md5=87f44d3a8a861422e0e249b50424de03
@@image: 'images/menus-file.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-edit.png'; md5=0f4108bb19572acfb3de098c804723b2
@@image: 'images/menus-edit.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-view.png'; md5=2f96a74d9ac6462a45fea5113c855d9d
@@image: 'images/menus-view.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-insert.png'; md5=590f877042877d9143519c677a79f5eb
@@image: 'images/menus-insert.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-format.png'; md5=bb156ef3ea70f819a608e4021cc0e122
@@image: 'images/menus-format.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-bookmarks.png'; md5=c7305a7704a000c2021353ce2b45b25b
@@image: 'images/menus-bookmarks.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-go-browser.png'; md5=f16ad9524f5a1610f9b48edf5303b3ac
@@image: 'images/menus-go-browser.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-go-document.png'; md5=04a33fc0bdb0762ec1475ea624db68e7
@@image: 'images/menus-go-document.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-windows.png'; md5=2b96821a7bc0e901e3194c5047ea6b2e
@@image: 'images/menus-windows.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/menus-help.png'; md5=eb22ed9bdc5eae58f67d0dd98517463a
@@image: 'images/menus-help.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/toolbars-mail.png'; md5=993771b5743ec8dfa63330d19949f3e0
@@image: 'images/toolbars-mail.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/toolbars-configure-menu.png'; md5=4d041474e15f00b6fc4afe46cdac0abc
@@image: 'images/toolbars-congfigure-menu.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/toolbars-labels-below.png'; md5=7b9ca621f5ddabc60bf4da69f285f9d7
@@image: 'images/toolbars-labels-below.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/toolbars-labels-beside.png'; md5=c4711d0199c45bf2cdfaaedbd8ada6e8
@@image: 'images/toolbars-labels-beside.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-sensitivity.png'; md5=01dcfdb304506c3878363f3006a1e02b
@@image: 'images/controls-sensitivity.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-locked.png'; md5=15a27cfa0232e7380241ebf2e80343e5
@@image: 'images/controls-locked.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-text.png'; md5=22285125f26d3e88d7a253cb51c801dc
@@image: 'images/controls-text.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-text-prompt.png'; md5=c10613a3895fc13f36da8d05b42d435e
@@image: 'images/controls-text-prompt.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-text-choose.png'; md5=0466bf7bab8ca2786694b43cc2ad42a1
@@image: 'images/controls-text-choose.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-spin-box.png'; md5=73f0f75b595a9a77dca33b7710d91f90
@@image: 'images/controls-spin-box.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-slider.png'; md5=1f198d71d76849b2359afd23e173866a
@@image: 'images/controls-slider.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-slider-spinbox.png'; md5=52ea8960de8994a0ea4a182f93d32106
@@image: 'images/controls-slider-spinbox.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-buttons.png'; md5=e3dbc2f42f81622d8727b14080bd864d
@@image: 'images/controls-buttons.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-check-boxes.png'; md5=bb3046c5c9ef1b5e29f1fec2b5168acd
@@image: 'images/controls-check-boxes.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-check-box-ambiguous.png'; md5=5a3044f6a3459f659ef8eb5c5fde77a1
@@image: 'images/controls-check-box-ambiguous.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-check-boxes-mixed.png'; md5=277f2ca5af306d658a86d50becaef546
@@image: 'images/controls-check-boxes-mixed.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-radio-buttons.png'; md5=ec28b9c1cb8cb87593ff2d6221eff04b
@@image: 'images/controls-radio-buttons.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-radio-button-mixed.png'; md5=116e0580acaa3d0930957eb0243246f1
@@image: 'images/controls-radio-button-mixed.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-toggle-buttons.png'; md5=c4bfef144e2729188dae3cc681e9aa46
@@image: 'images/controls-toggle-buttons.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-toggle-button-mixed.png'; md5=7c70eb13f09b73c9d0b30c322300eff0
@@image: 'images/controls-toggle-button-mixed.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-option-menu.png'; md5=5932cb4b8e6aca709125013d60342906
@@image: 'images/controls-option-menu.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-combo.png'; md5=4233c534d42bfaee7e8c9f5f31733edd
@@image: 'images/controls-combo.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-list.png'; md5=bd5d307dc0954d0ced39f5ba75cb6d13
@@image: 'images/controls-list.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-list-checkbox.png'; md5=4d8907ee462f15f039f6bddf48cf21ec
@@image: 'images/controls-list-checkbox.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-tree.png'; md5=ec56f1d0c2b4f5e8b9c6617e74a5d5ba
@@image: 'images/controls-tree.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-tree-checkbox.png'; md5=589bd301913fae3b2390e7500471340e
@@image: 'images/controls-tree-checkbox.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-notebook.png'; md5=d6ea5d7a6733d80ff427b9b8af507226
@@image: 'images/controls-notebook.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-notebook-tabs.png'; md5=582ca97735ff27f477c95ead601dc2bb
@@image: 'images/controls-notebook-tabs.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-notebook-list.png'; md5=2adbb8efa7fbdb3e8e0b60d42141d253
@@image: 'images/controls-notebook-list.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-progress-time.png'; md5=c3881dabfb3fb9146851a538876232de
@@image: 'images/controls-progress-time.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-progress-typical.png'; md5=d5c9f406bad0f9897df89c934fcedd1b
@@image: 'images/controls-progress-typical.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-progress-indeterminate.png'; md5=85b3d6c1a9cda019a493bb378c770fbd
@@image: 'images/controls-progress-indeterminate.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-status-bar.png'; md5=ac95bb22a4e4cf322e07ab72afc41be9
@@image: 'images/controls-status-bar.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-status-bar-interactive.png'; md5=436090c7b51322685b503834bb317f82
@@image: 'images/controls-status-bar-interactive.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-frames.png'; md5=1b313b64c359cc35a9b976c6cc34ea6a
@@image: 'images/controls-frames.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/controls-old-frames.png'; md5=b7e49c49025bdb2b600516d868043825
@@image: 'images/controls-old-frames.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/feedback-pointers-busy.png'; md5=f7d205efe629ac152f0f2f21b54139cf
@@image: 'images/feedback-pointers-busy.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/feedback-checklist-running.png'; md5=4c79589f4213ccd28984dd793cae31c2
@@image: 'images/feedback-checklist-running.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette.png'; md5=ec1e5572528e0d3c35c92be26ebbdc35
@@image: 'images/visdes-palette.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-1.png'; md5=d0476064588b8852ae3c659a8490e46a
@@image: 'images/visdes-palette-1.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-2.png'; md5=92436b9e487c4bc48c43d3be0a8362a7
@@image: 'images/visdes-palette-2.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-3.png'; md5=76390ce6cd9c480439e93a7353d1d4b3
@@image: 'images/visdes-palette-3.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-4.png'; md5=87633be380812ed57a2dc875a1bca3b8
@@image: 'images/visdes-palette-4.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-5.png'; md5=4b4ce16b1570b5026b1f18bcfb91a985
@@image: 'images/visdes-palette-5.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-6.png'; md5=768f75e4022472370e8f036d6de5a3b2
@@image: 'images/visdes-palette-6.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-7.png'; md5=1bdc0153b8eff03a8b59f530792660f4
@@image: 'images/visdes-palette-7.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-8.png'; md5=d8828c449320c56b20620abe8a086f64
@@image: 'images/visdes-palette-8.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-9.png'; md5=824ed9598bb93a46b69d99bb7e86763a
@@image: 'images/visdes-palette-9.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-10.png'; md5=7df2a82cd906b01a885b2ab9b3a7bab1
@@image: 'images/visdes-palette-10.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-11.png'; md5=f94df320c814a8145c2c237ebd20af22
@@image: 'images/visdes-palette-11.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-12.png'; md5=61d87e3af3c968219ce91eacb181d0e3
@@image: 'images/visdes-palette-12.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-13.png'; md5=db2797d6f263a941d99844a85ffff35e
@@image: 'images/visdes-palette-13.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-14.png'; md5=2d788c2d5918278e616cd204775d96d7
@@image: 'images/visdes-palette-14.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-15.png'; md5=7441ade4d7509f4d7cf34b8c7766baa8
@@image: 'images/visdes-palette-15.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-16.png'; md5=0163677eef7560f3e23718fc1ce39d55
@@image: 'images/visdes-palette-16.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-17.png'; md5=7f09f59d049fb4f81dbae01b24f0c446
@@image: 'images/visdes-palette-17.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-18.png'; md5=bdce8ae7e2abc7fb2dc344805bc3a505
@@image: 'images/visdes-palette-18.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-19.png'; md5=2aa6890de8447f6fcd89faacd7a010a8
@@image: 'images/visdes-palette-19.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-20.png'; md5=eb1b1924017587856c86b2ffc0390b21
@@image: 'images/visdes-palette-20.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-21.png'; md5=4d3342f84efffa7a88972c8506027ad3
@@image: 'images/visdes-palette-21.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-22.png'; md5=db3190ba8389410fa79aef9518b1207e
@@image: 'images/visdes-palette-22.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-23.png'; md5=cfc60f3e7dbdddf46b996fb9fd22f2e4
@@image: 'images/visdes-palette-23.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-24.png'; md5=d4be2d43ebd64c55606af49b32a4eeef
@@image: 'images/visdes-palette-24.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-25.png'; md5=0e44125317e3f5f565e5760cd159b26a
@@image: 'images/visdes-palette-25.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-26.png'; md5=49891fd697ea33b6ae8d0b7490592ebe
@@image: 'images/visdes-palette-26.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-27.png'; md5=2a79c5dd94b6a7cb7aff41ab3a1e21ca
@@image: 'images/visdes-palette-27.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-28.png'; md5=8fdfac92622b9ac7e882243d3e68e2dd
@@image: 'images/visdes-palette-28.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-29.png'; md5=83719b5a2f99301498e74d050c8a26cb
@@image: 'images/visdes-palette-29.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-30.png'; md5=3d738a9b91f8c8954345c0623ddfbb8b
@@image: 'images/visdes-palette-30.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-31.png'; md5=f68951b759954bf1fa48a359eca6ccdb
@@image: 'images/visdes-palette-31.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-palette-32.png'; md5=a302292b206b4680c34108feeae6ca99
@@image: 'images/visdes-palette-32.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-colorblind-normal.png'; md5=361c3d9fc1695d5d0bfd08cf5b27423c
@@image: 'images/visdes-colorblind-normal.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-colorblind-deutan.png'; md5=cbc231a22304dc763a3e59015e17913c
@@image: 'images/visdes-colorblind-deutan.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-colorblind-tritan.png'; md5=3fb526c707d5c7cba6458c1e70fb44a7
@@image: 'images/visdes-colorblind-tritan.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-layout-poor.png'; md5=729c10ae647f3eca913f1b3f36a4a991
@@image: 'images/visdes-layout-poor.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-layout-good.png'; md5=d97c4e85599051f8a2f707057a8a250b
@@image: 'images/visdes-layout-good.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-layout-annotated.png'; md5=011c0438510bdda72fc5d899c9f55137
@@image: 'images/visdes-layout-annotated.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-large-icon-label.png'; md5=0af28bd662c5779c907f6df7f1902633
@@image: 'images/visdes-large-icon-label.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-small-icon-label.png'; md5=56ed4e60aaf964ee9818dba8d5685951
@@image: 'images/visdes-small-icon-label.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-list-label.png'; md5=57121e38c62b1b562e03b6ee713a418c
@@image: 'images/visdes-list-label.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-radiobutton-label.png'; md5=bccfcab32f08677cdd1315e61a067fa2
@@image: 'images/visdes-radiobutton-label.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-textbox-label.png'; md5=58d0c94c3331c41b35385b7bb908b267
@@image: 'images/visdes-textbox-label.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-button-label.png'; md5=e3dbc2f42f81622d8727b14080bd864d
@@image: 'images/visdes-button-label.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/visdes-other-labels.png'; md5=d4ef35dec77dad0be5e66800ec617f13
@@image: 'images/visdes-other-labels.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-style-java.png'; md5=203ce0cb6c37566b090b87af873b15f2
@@image: 'images/icons-style-java.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-style-aqua.png'; md5=eb7c8ee70d7591615238af769153811f
@@image: 'images/icons-style-aqua.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-style-gnome.png'; md5=11a91f9b6481d1ade08c0b26afa6bd46
@@image: 'images/icons-style-gnome.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-perspective-table.png'; md5=0a902de1c55f850e00f844083fe301eb
@@image: 'images/icons-perspective-table.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-perspective-shelf.png'; md5=8b645b2b7da026e05886f0ad9e37b324
@@image: 'images/icons-perspective-shelf.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-objects.png'; md5=76ed1cf3dbc387e29f1eee35e8e85a2b
@@image: 'images/icons-objects.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-applications.png'; md5=25688fe9fb83be2e6a46afc94010ecad
@@image: 'images/icons-applications.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-toolbar.png'; md5=abd3494470c56e0f0fa679556fc0b40a
@@image: 'images/icons-toolbar.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-menu.png'; md5=aeb12266386315040c14fb5590591d16
@@image: 'images/icons-menu.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-word-processor.png'; md5=e71c8b25d4ee56eac31c55dcc01fc619
@@image: 'images/icons-word-processor.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-underline-text.png'; md5=05c78ac429598e81e3f4a1c18701e719
@@image: 'images/icons-underline-text.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-silhouette.png'; md5=7d088a0efe8958154da391b7b875424e
@@image: 'images/icons-silhouette.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-1.png'; md5=6da37f4b24fe2f094f3df3915c85a129
@@image: 'images/icon-design-process-1.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-2.png'; md5=380ef73df7e1c8945466a13db600dfbf
@@image: 'images/icon-design-process-2.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-3.png'; md5=456e03c633b57ee9a8925b2c92fb3f5c
@@image: 'images/icon-design-process-3.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-4.png'; md5=410ba496fe326b8bfbc970a2709e24ed
@@image: 'images/icon-design-process-4.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-5.png'; md5=1ca9f93e87a1f8e45ad6360c678c3649
@@image: 'images/icon-design-process-5.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-6.png'; md5=d1ef7a45524a4a83544a5a1305329eb8
@@image: 'images/icon-design-process-6.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-7.png'; md5=ea95a15ab4d47f6ede19491886f3186c
@@image: 'images/icon-design-process-7.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-8.png'; md5=a6f1342a683f130149841d455fa3a8bd
@@image: 'images/icon-design-process-8.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-9.png'; md5=44e04598e1f0292dd6c9d9f73bb3e4d7
@@image: 'images/icon-design-process-9.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-10.png'; md5=68eaae24c8406eb2b8dcd82808dfe637
@@image: 'images/icon-design-process-10.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-11.png'; md5=2067c1bc72e323aa9b2915e1bd300845
@@image: 'images/icon-design-process-11.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icon-design-process-12.png'; md5=fdc7d527591f43a642d62a2b0cfe9f85
@@image: 'images/icon-design-process-12.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-nautilus.png'; md5=42d5ebf8d3e192483452063ad345c48d
@@image: 'images/icons-nautilus.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-gedit.png'; md5=6697f62b09e3d66c73349c94cea703dd
@@image: 'images/icons-gedit.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-sodipodi.png'; md5=74de2416ee67c2371bb14486308f3a32
@@image: 'images/icons-sodipodi.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-evolution.png'; md5=8d04c8271c4018b59d7aa03c56dd6d64
@@image: 'images/icons-evolution.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-gnumeric.png'; md5=83bf833c01249562333726d0439e14fd
@@image: 'images/icons-gnumeric.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-font-selection-poor.png'; md5=1a3a8e59c319b83a2fc68c7f24241b32
@@image: 'images/icons-font-selection-poor.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-font-selection-good.png'; md5=560347e5dc0027a26151fc6760319615
@@image: 'images/icons-font-selection-good.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-system-log.png'; md5=5af0c5586169e75a03b3cceb75ee3f9d
@@image: 'images/icons-system-log.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-shut-down.png'; md5=4a43ae07dcbed286be7bcf14529b3a9f
@@image: 'images/icons-shut-down.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-hc-book.png'; md5=c0cf8f12c9052aa6295f4ee9775689ae
@@image: 'images/icons-hc-book.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-hc-book-blur.png'; md5=ad3a0882d8bd5d541e5df2c01d9dcf8a
@@image: 'images/icons-hc-book-blur.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-hc-cdrom.png'; md5=45c47355dd51b1d88960fe497b9df92e
@@image: 'images/icons-hc-cdrom.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-hc-cdrom-blur.png'; md5=6950e7342bdcae306998d249cbe249cd
@@image: 'images/icons-hc-cdrom-blur.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-hc-copy.png'; md5=dd07ed9497a0e7c86d88bab54acb27bf
@@image: 'images/icons-hc-copy.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-hc-copy-blur.png'; md5=3199063df45853f826d6d351eb417d27
@@image: 'images/icons-hc-copy-blur.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-hc-metaphors.png'; md5=20c6b2ced6eb6c9d69796f54e334ed8b
@@image: 'images/icons-hc-metaphors.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-floppy-dissected.png'; md5=a3261de8f798f9a838c56e8824ec1a24
@@image: 'images/icons-floppy-dissected.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/icons-lowcontrast-levels.png'; md5=12c3ffd6bcd0eaa88aabc52e2904093e
@@image: 'images/icons-lowcontrast-levels.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-pointing-devices.png'; md5=272785a9c2d60097225dd4ba1d172a51
@@image: 'images/input-pointing-devices.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-select-files.png'; md5=0752f823000b7a31b7c180db370dd9e4
@@image: 'images/input-drag-select-files.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-select-graphics.png'; md5=6893d2970a32ef45cd195949a8482224
@@image: 'images/input-drag-select-graphics.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-cursor.png'; md5=9e52436dba6a5118f59dbcc92fb74532
@@image: 'images/input-drag-cursor.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-cursor-move.png'; md5=733d2e7b3da0d7340b477ec502eedf13
@@image: 'images/input-drag-cursor-move.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-cursor-copy.png'; md5=5ef91f518352bf23f8493343ec87ee0e
@@image: 'images/input-drag-cursor-copy.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-cursor-link.png'; md5=392ce6d298a4e22df7a463618160c0b0
@@image: 'images/input-drag-cursor-link.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-cursor-query.png'; md5=82389009e8a72b8dbce754cd1a4acd61
@@image: 'images/input-drag-cursor-query.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-drag-cursor-nodrop.png'; md5=447e7e62e00f3494d7736ffb1a04f6c5
@@image: 'images/input-drag-cursor-nodrop.eps'; md5=THIS FILE DOESN'T EXIST
@@image: 'images/input-accesskeys-shortcuts.png'; md5=b37a7c064ef46bc321c54eae57524dd2
@@image: 'images/input-accesskeys-shortcuts.eps'; md5=THIS FILE DOESN'T EXIST
The GNOME Usability Project
2002-2010
Calum Benson, Adam Elman, Seth Nickell, colin z robertson
2010-03-02
2.2.1
This document tells you how to create applications that look right, behave properly, and fit into the GNOME user interface as a whole. It is written for interface designers, graphic artists and software developers who will be creating software for the GNOME environment. Both specific advice on making effective use of interface elements, and the philosophy and general design principles behind the GNOME interface are covered.
Permission is granted to copy, distribute and/or modify this document under the terms of the
Many of the names used by companies to distinguish their products and services are claimed as trademarks. Where those names appear in any GNOME documentation, and those trademarks are made aware to the members of the GNOME Documentation Project, the names have been printed in caps or initial caps.
GNOME Human Interface Guidelines 2.2.1
What's new?
This section highlights recent changes to the HIG that may affect your application.
The following changes were made in HIG v2.2.1:
Mention in
Replace guidance in
The following sections were added in HIG v2.0:
New or revised guidelines were added to these sections in HIG v2.0:
The following terminology changes were introduced in HIG v2.0:
"Option menus" are now called "Drop-down lists"
"Combo boxes" are now called "Drop-down combination boxes"
Introduction
Users will learn to use your program faster, because interface elements will look and behave the way they are used to.
Novice and advanced users alike will be able accomplish tasks quickly and easily, because the interface won't be confusing or make things difficult.
Your application will have an attractive look that fits in with the rest of the desktop.
Your application will continue to look good when users change desktop themes, fonts and colors.
Your application will be accessible to all users, including those with disabilities or special needs.
These guidelines are meant to help you design and write applications that are easy to use and consistent with the GNOME desktop. Following these guidelines will have many benefits:
To help you achieve these goals, these guidelines will cover basic interface elements, how to use them and put them together effectively, and how to make your application integrate well with the desktop.
The recommendations here build on design aspects that have worked well in other systems, including Mac OS, Windows, Java and KDE. At the same time they retain a uniquely GNOME flavor.
Remember...
Following the guidelines will make your job easier, not harder!
Usability Principles
This section explains some of the basic principles behind the more specific technical guidelines recommended in this document. We believe that these principles are important for all application development.
Design for People
Remember that the purpose of any software application is to enable some group of people to accomplish a specific set of tasks. So, the first things to establish when designing your application are:
who your users are
what you want to enable them to do
For example, you may be designing an application that will enable engineers (software, electrical, or mechanical) to create diagrams. You may be designing an application that will enable system administrators to configure and monitor a web server. You may be designing an application that will help elementary school students to learn math.
The important thing is that you know your audience, and you understand both their goals and the tasks necessary to achieve those goals. There are a large number of professional interaction designers who write books and teach courses on design methods that can help with this process, many of which are extremely useful— see the
Don't Limit Your User Base
If you are designing an application for use by engineers, or by children, or by system administrators, be sure to create an application that can be used by
Accessibility
Accessibility (sometimes called
Color-blind users may not be able to use your application if you rely only on color-coding to distinguish different types of information
Users with hearing impairments may not be able to use your application if you rely on sounds to indicate critical information
Users with limited movement may not be able to use your application if you don't provide keyboard equivalents for commands
Your software should also be usable with voice interfaces, screen readers such as
GNOME has excellent inbuilt support for accessibility by means of the ATK and GAIL libraries, which in many cases can do most of the work for you. More information on accessibility in GNOME can be found at the
Internationalization and Localization
Internationalization means designing software so that it can function in different language environments. Localization is the process of actually translating the messages, labels, and other interface elements of an application into another language.
GNOME has excellent support for both internationalization (also referred to as i18n) and localization (also referred to as l10n). In most cases, simply using standard GNOME APIs for displaying text and messages will allow you or others to localize your application for other locales. For more information on how to make your application localizable, see the
Sensitivity to cultural and political issues is also an important consideration. Designing icons and sounds, and even choosing colors requires some understanding of the connotations they might have to a user from a different part of the world.
Examples of elements it is best to avoid for these reasons include:
Pictures of flags or money
Maps showing political boundaries or contentious location names
Lists of countries or cities in non-alphabetical order (unless specifically requested or required by the context)
Icons depicting animals
Icons depicting only hands or feet
Create a Match Between Your Application and the Real World
Always use words, phrases, and concepts that are familiar to the user rather than terms from the underlying system. Use terms that relate to the user's knowledge of the tasks your application supports. For example, in medicine, the paper folder that contains all information about a specific patient is called a "chart." Hence, a medical application might refer to a patient record that contains the same information as a paper chart as a "patient chart" rather than as a "patient database record."
You can often take advantage of your users' knowledge of the real world by using metaphor— that is, a familiar concept from the outside world— to represent elements within your application. For example:
an image of a file folder suggests a container into which documents can be placed
a waste basket suggests a container into which items can be placed when they are no longer needed
When using metaphors, however, it is important to neither take the metaphor too literally, nor to extend the metaphor beyond its reasonable use. For example, the capacity of a file folder should not be limited to the capacity of a physical file folder, which presumably could contain only a few documents before becoming unwieldy. On the other hand, a waste basket should not be used for anything other than holding discarded files. It should not be used, for example, to eject a removable disk such as a floppy or CD.
Make Your Application Consistent
Make your application consistent with itself and with other applications, in both its appearance and its behavior. This is one of the most important design principles, and probably the most famous, but it is also frequently ignored. While this document serves as the basis for consistency between GNOME applications, you are encouraged to look at and follow other application's conventions where this document provides no guidelines.
Consistency enables users to apply their existing knowledge of their computing environment and other applications to understanding a new application. This not only allows users to become familiar with new applications more quickly, but also helps create a sense of comfort and trust in the overall environment. Most of the recommendations in the GNOME HI Guidelines are designed to help you create applications that are consistent with the GNOME environment and other GNOME applications.
A word of caution: a mis-applied or incomplete consistency is often worse than inconsistency. If your application includes an
Keep the User Informed
Always let the user know what is happening in your application by using appropriate feedback at an appropriate time. The user should never have to guess about the status of the system or of your application. When the user performs an action, provide feedback to indicate that the system has received the input and is operating on it. Feedback can be visual, audio, or both. If the system will take a long time to process the request, provide as much feedback as possible about how lengthy the operation will be. Types of helpful feedback include but are not limited to: cursor changes, animated "throbbers", progress indicators, audio feedback such as a beep, and error messages. Error messages should use simple language, clearly state the problem, and provide solutions or tell the user how to get out of the current situation if possible.
It is critical that feedback be
See
Keep It Simple and Pretty
Your application should enable the user to concentrate on the task at hand. So, design your application to show only useful and relevant information and interface elements. Every extra piece of information or interface control competes with the truly relevant bits of information and distracts the user from important information. Hence, don't clutter your interface, and don't overload the user with buttons, menu options, icons, or irrelevant information. Instead, use progressive disclosure and other techniques to limit what the user sees at any given moment.
Finally, present your information and interface elements in an aesthetically pleasing manner. A disorganized, cluttered-looking interface with a few elements can be just as distracting as an organized interface with too much information. Make sure that dialog elements are cleanly-aligned, and do not overuse or misuse color or graphics. If you know a graphic designer, seek their advice if possible— the guidelines in this document will help you with the basics, but there is no substitute for a trained eye.
See
Put the User in Control
Remember that computers exist to serve humans. A user should always feel in control, able to do what they want when they want. This means you should generally avoid modes; users should be able to switch between different tasks (and specifically, different windows) at any time. See
The user should also be able to tailor aspects of their environment to fit personal preferences. It is very important, however, to avoid the trap of allowing too much configuration, or allowing the configuration of parameters that most users will not understand or find useful to modify. Wherever possible, inherit visual and behavioral parameters from global preferences and settings such as the current GTK+ theme.
Forgive the User
We all make mistakes. Whether we're exploring and learning how to use the system, or we're experts who just hit the wrong key, we are only human. Your application should therefore allow users to quickly undo the results of their actions.
If an action is very dangerous, and there is no way to undo the result, warn the user and ask for confirmation. Only do this in extreme cases, though; if frequently faced with such confirmation messages, users begin to ignore them, making them worse than useless.
In all cases, the user's work is sacrosanct. Nothing your application does should lose or destroy user's work without explicit user action. Among other techniques, this can be achieved by auto-saving backups of documents, and allowing multiple levels of undo.
Provide Direct Manipulation
Wherever possible, allow users to act on objects and data directly, rather than through dialogs or explicit commands. For example, it is more intuitive to drag a circle object around in a diagram rather than selecting a "Move" command from a menu while the circle is selected. Simlarly, in an email application, allow the user to attach files by dragging them from the file manager and dropping them onto the message composition window if they wish.
See
Desktop Integration
Place an entry for your application in the
If your application can open and save files, place entries for those file types in the application database and the document type (MIME) database. This allows the file manager and other applications to automatically launch your application when they encounter files your application can handle.
There are two elements to basic integration with the user environment of the GNOME Desktop.
Placing Entries in the Applications Menu
The Applications menu
Screenshot of the open Applications menu on the GNOME menu panel
The
The menu is arranged into a set of categories, such as Accessories and Games. Applications are placed in particular categories by the set of keywords they include in their
Guidelines
Assign your application to only one category on the
For application suites that wrap a number of smaller sub-applications into a single window, such as Evolution or OpenOffice.org, add a menu item for each sub-application. For example, the mail, calendar, and tasklist in Evolution should each have their own menu item.
Technical details can be found in the freedesktop.org
Menu Item Names
Include a functional description in the menu name
In the menu item name, include a description of functionality in addition to the proper name of the application. This is especially useful novice users, and to users of systems where numerous applications are installed by default. Users are more likely to find your application if the name that appears in the menu includes a description of its functionality.
For example,
Including functional description in menu names
Original menu item
Revised menu item
Epiphany
Epiphany Web Browser
Only put useful information in the menu name
Do not include words like "GNOME", "X Window System", "GTK+" or other platform details in
Removing non-essential information from menu names
GNOME Image Viewer
Image Viewer
GTK Blog Editor
Blog Editor
Do not include technical details when the user does not need to know them, or can infer them from context. Avoid technical jargon unless the application is to be used only by a technical audience.
For example, when both a client and a server for something are listed in the menus, remove the word "Client" from the menu name for the client.
Removing technical jargon from menu names
Gnome Batalla Naval Client
Batalla Naval
Gnome Batalla Naval Server
Batalla Naval Multiplayer Server
Gnome VideoLAN Client
VideoLAN Movie Player
Providing the right information
Try to imagine what words users will be looking for when they select your application from the
Menu name formats
If your application's proper name is already descriptive of its functionality, and not just suggestive, use the format:
Using application's name as menu name
Application name
Menu name
Dictionary
Search Tool
If there is a succinct functional description of your application, use the format:
Using functional description in menu names
Menu item name
The GIMP
GIMP Image Editor
Evolution email sub-application
Evolution Email
AbiWord
AbiWord Word Processor
Galeon
Galeon Web Browser
Gramps
Gramps Genealogy
AisleRiot
AisleRiot Solitaire
A few applications, particularly games, do not have appropriate functional descriptions (but note that many games do). In this case, use
Using applicaton's name as menu name where no functional description exists
Bomber Maze
Menu Item Tooltips
Tooltips help provide users with enough information to run the right application. Many users use tooltips to explore a new environment.
Provide a tooltip for each
Phrase the tooltip as an imperative verb, for example "design", "write" or "check".
Describe the most important tasks users can accomplish with your application.
While tooltips should not be verbose, they should be longer and more descriptive than the item's name.
Example tooltips for GNOME applications
Application
Menu item tooltip
Character Map
Insert special characters into documents
Memprof
Check your applications for memory leaks
Same Gnome
Arrange long chains of similarly-colored balls to eliminate them
Find and sink enemy ships in this networked version of Battleship
GConf Keys
GConf keys are required to have long and short descriptions for each key. Many keys have no interface through the application, so for someone administering the key values from another application each description field will be the only interface available to them.
Short Descriptions should be short, less than 8 words, describing the purpose of the key
Long Description should be complete in describing the possible values of the key and the effects that those values have on the application
Example descriptions for GConf Keys from gnome-terminal
Key
Short Description
Long Description
background_type
Background type
Type of terminal background. May be "solid" for a solid color, "image" for an image, or "transparent" for pseudo-transparency.
delete_binding
Effect of the Delete key
Sets what code the delete key generates. Possible values are "ascii-del" for the ASCII DEL character, "control-h" for Control-H (AKA the ASCII BS character), "escape-sequence" for the escape sequence typically bound to backspace or delete. "escape-sequence" is normally considered the correct setting for the Delete key.
Mapping Document Types to Applications
The document type (MIME) database allows users to specify their preferred applications for opening different types of document. This is the mechanism by which Nautilus, Evolution and other applications decide which application to run when they encounter a document they cannot open themselves.
It is important for users to be able to double-click on documents they see on the desktop, such as files and email messages, and have them launch in their favorite application. Therefore, your GNOME application should associate itself at install-time with all the document types it can handle. Technical details on doing this can be found in the
Using the Status Notification Area
Using the status notification area applications can notify the user of non-critical events (for example, arrival of new email, or a chat 'buddy' having logged on), and expose the status of active system processes (for example, a printing document, or a laptop's battery charging).
Following the guidelines in this section will help to clarify the difference in the user's mind between information presented in the notification area, and controls and information presented on other parts of the panel.
The utility of the notification area decreases rapidly when more than about four icons are always present. For this reason, icons that appear only temporarily in response to events are preferable.
Notification Area or Panel Applet?
You should probably write an applet instead of using the notification area if:
clicking your notification area icon does anything other than opening a window directly associated with the icon (e.g. a mail folder window for a new mail icon, or a print queue window for printer notification icon), or
there are icon-specific options on its context menu for doing anything other than that
your application would ever need to display more than one notification icon at the same time
Icon Appearance
Use table perspective for icons representing physical devices, with the light source above and to the left of the represented object. For example, a printer icon during printing. See
Use shelf perspective, with overhead lighting, for all other icons. For example, an envelope shown when new mail arrives. See
For monitors or progress bars that change over time, such as a battery charge monitor, clearly delimit the border of the area.
Only core GNOME programs may perpetually display an icon in the status area.
Non-core programs for which a perpetual icon may be useful must default to not perpetually showing the icon. Users may select to enable a perpetual icon for the application as a preference.
Animation
Icons should not usually appear animated. They may change to indicate a change of state, but should not do so when that change is occurs regularly rapidly. A battery status indicator would usually change slowly, therefore an icon is appropriate. By contrast, a load meter would always be changing, therefore it should use a flat image.
Any icon may blink to indicate an error in deference to showing an alert. For example, a printing-in-progress icon may blink when there is a paper jam, but not when the printer is on fire - that should show an alert.
Do not rely on blinking or animation as a means of alerting the user to any particular event.
Interaction
Icons should respond to the these user actions. (Keypresses apply only when the icon has focus, of course)
the printer queue for a printing-in-progress icon.
the inbox for an incoming email iconi
the message for an incoming message
Double-click or
Right-click or
If the icon's properties may be altered, it should have a menu item
Icons should obey normal tooltip conventions.
Windows
Parts of Windows and System Interaction
Titles
Give every window a title (with the exception of
Example of a window title
Screenshot showing a window title bar with title "Parts of Windows and System Interaction - Mozilla Firefox"
See the description of each particular window type for title formats.
Borders and Window Commands
Most windows have borders, except certain shaped windows and some torn-off windows. Do not attempt to draw your own window borders, but instead provide hints to the window manager for the desired border type.
Different window commands are appropriate to different types of window. See the description of each particular window type for a list of appropriate window commands. These are the possible window commands:
Close
Closes the window.
Maximize
Causes the window to use all unused screen space.
Minimize
Causes the window to be temporarily hidden. It will continue to appear on the desktop window list.
Roll-up/Unroll
Shows only the title bar of the window, as if it has been "rolled up".
Modality
A
An
A
Use an application modal window only if allowing interaction with other parts of the application while the window is open could cause data loss or some other serious problem. Provide a clear way of leaving the modal window, such as a
Do not use system modal windows.
Focus
Focus is the means by which the user designates which window should receive data from the keyboard, mouse or other input device. If using a screen reader or similar assistive technology, focus may also designate the window that the user wants to receive information about. The focused window is considered the window the user is currently "working with".
Ensure your application functions properly with the three different mechanisms by which windows can receive focus in GNOME:
Click-to-focus
A window is focused by clicking in it.
Point-to-focus
A window is focused by moving the mouse pointer into it. Sometimes known as "sloppy focus".
Keyboard focus
A window is focused by using a keyboard shortcut such as
Special restrictions for point to focus
Note that point-to-focus places a number of restrictions on GNOME applications that are not present in environments such as MacOS or Windows. For example, utility windows shared between multiple document windows, like the toolbox in the GIMP Image Editor, cannot be context-sensitive— that is, they cannot initiate an action such as
Showing and Hiding Windows
How your application shows and hides windows can greatly affect the user's perception of your application, particularly its performance.
Always show a window as soon as possible, but make sure your window is the correct size before displaying it. Resizing a window after it is visible is disorienting and gives an unpolished look to your application.
If a window contains information that takes a few seconds to compute or display, it is often better not to fill it in completely before displaying the window. For example, a window containing a large text area can be shown quickly, and then the text can be filled in afterwards (provided this does not result in the window resizing). This will make your application feel more responsive than if you had not shown the window until its content was complete.
Hide a window as soon as possible after it is closed. Unless an alert might be shown, immediately hide a window that the user has closed by clicking the Close button in the window border-- your application can still perform any internal clean-up operations afterwards. Besides making the system appear slow, not doing this can cause the window manager to think the application is not responding, and display an unnecessary alert to the user.
Primary Windows
A primary window usually presents a view of the user's data, such as a text document in a word processor application, an image in a drawing program, or calculations in a calculator or spreadsheet application. It may also be a view of something more abstract, like a game. A single instance of an application may have more than one primary window, and more than one kind of primary window.
A primary window is always shown on the panel window list.
A typical primary window (gedit)
A typical primary window: the gedit document view
A primary application window normally has a border, a menubar and a statusbar, and may also contain one or more toolbars.
Title
The most important element of a document-based application's window title is the name of the open document. For other applications, it usually the name of the application.
Use
Using document names as window titles
Example window title
My Report.abw
Evolution
Inbox
Music player
U2 - Better Than the Real Thing
If the pathname is important, for example the user has opened two documents with the same name from different directories in the same application, show the full pathname in the statusbar.
Before a new document has been saved for the first time, set the window title to
When a document has pending changes, insert an asterisk (*) at the beginning of the window title. For example,
For non-document-based applications, use
Using application names as window titles
Window title
Calculator
Do not place version numbers, company names, or other information that is of no immediate use to the user in the window title. These consume space, making titles in limited spaces such as the system window list less useful, and add more text the user has to scan to find useful information. In a "beta" product, where version numbers are critical for bug information, placing version numbers can be useful, but remove them from stable releases. Place version information in the about box instead.
While document names are most pertinent to users, we understand that application developers may want to increase recognition of their application. If you plan to include your application's name in the title of a primary window, use the following format:
Including the application name in the title of a document-based application is
Think about naming windows in the context of the panel window list. On a typical screen with a relatively small number of windows open, a window will have 20-30 characters of text and an icon. Consider which text will provide the most immediately obvious clues to a user looking for a particular window.
Window Commands
Close, Maximize/Restore, Minimize, Roll-up/Unroll
Relation between Documents and Windows
Single Document Interface (SDI)
A single document interface places each document in its own primary window. Toolboxes and other utility windows may be shared between multiple SDI documents, but closing them should have no effect on the document windows. Use SDI for your GNOME application unless there is a compelling reason not to.
A typical SDI application (Eye of GNOME)
A typical SDI application: Eye of GNOME being used to inspect an icon
Multiple Document Interface (MDI)
A multiple document interface presents a paned, tabbed or similar presentation of two documents within a single window.
A typical MDI application (gedit) showing three open documents on tabbed pages
A typical MDI application: gedit with three open documents in the same window
MDI has several inherent usability problems, so its use is discouraged in applications. It is better to open each document in a new primary window, with its own menubar, toolbars and statusbar, or allow multiple instances of your application to be run simultaneously. In either case, this leaves it for the window manager (acting on the user's preferences) rather than your application to decide how to group and present document windows from the same application.
Controlled Single Document Interface (CSDI)
In a typical SDI application, document windows are treated as primary. For example, when all document windows have been closed, the application (including utility windows) exits as well. In CSDI a utility window is treated as the primary window. For example, closing this utility window will close all document windows and exit the application.
Using CSDI is
CSDI is sometimes used because document windows might be too small to have menu bars. Typically this is not the normal use case for the application, but does represent a significant minority use case. For example, an image editor being used to edit small web page elements will often result in very small document windows that cannot accomodate a title bar.
We should really have a way of doing overflow automatically in GTK+.
A better way to address this problem is to allow menu bars to "collapse" into an overflow button, in much the same way toolbars operate when the window shrinks to below the toolbar width. This allows for small windows, but also provides an opportunity for people to figure out where their menus have gone.
Note that if very small documents are the
Utility Windows
Utility windows, such as palettes and toolboxes, normally have borders. They do not contain a menu bar, a toolbar, or a statusbar.
A utility window should not appear in the panel window list unless it is, or may be, the only window shown by an application. Otherwise, the utility window should be raised above the application when the application window itself is selected from the window list.
Instant apply windows
For windows that allow the user to change values or settings, such as property and preference windows, update those values or settings immediately to reflect the changes made in the window. This is known as "instant apply". Do not make the user press an
the change will take more than about one second to apply, in which case applying the change immediately could make the system feel slow or unresponsive, or
the changes in the window have to be applied simultaneously to prevent the system entering a potentially unstable state. For example, the hostname and proxy fields in a network properties window.
If either these conditions affect only a few of the controls in your window, arrange those controls together into one or more groups, each with its own
FIXME: screenshot of such a window here
Do not attempt to validate or apply changes caused by editing a text field control until the user has moved focus to a different control in the window, or the window is closed. Validating after each keypress is usually annoying and unnecessary. Exception: if the field accepts only a fixed number of characters, such as a hexadecimal color code, validate and apply the change as soon as that number of characters have been entered.
When the user moves focus to a different control, do not indicate an invalid entry by displaying an alert or undoing the change the user made. Both of these methods are particularly disruptive for focus-follows-mouse users, for whom focus may leave the control more often than it does for a click-to-focus user.
We need to suggest what to do here, instead of just saying what not to do.
Explicit apply windows
If most of the controls in your window are not suitable for instant apply, consider making the whole window "explicit apply". An explicit apply window has these three buttons in its button box, plus an optional
Apply
Applies all the settings in the window, but does not close the window in case the user wishes to change their mind.
Cancel
Resets all settings in the window to those that were in force when the window was opened. Note: this must undo the effects of all applications of the
OK
Applies all settings in the window, and closes the window.
Buttons in an explicit apply window
Screenshot showing correct positions for Help, Apply, Cancel and OK buttons in a dialog
FIXME: better example of such a window here
Default Buttons
When designing a dialog or utility window, you can assign the
Choose the default button to be the most likely action, such as a confirmation action or an action that applies changes in a utility window. Do not make a button the default if its action is irreversible, destructive or otherwise inconvenient to the user. If there is no appropriate button in your window, to designate as the default button, do not set one.
In particular, it is currently
Property Windows
Property windows allow the user to view and change the characteristics of an object such as a document, file, drawing, or application launcher.
Example of a property window
Screenshot showing the "file properties" window from Nautilus
Title Format:

Window Commands:
Close, Minimize, Roll-up/Unroll
Buttons:
Place a
Preferences Windows
Preferences windows allow the user to change the way an application looks or behaves.
Much more information needed here!
Example of a preferences window
Screenshot showing the Gnibbles preferences window

Customizing Fonts and Colors
If your preferences window allows the user to customize fonts or colors, use the following wording and layout as a guide for these controls:
Recommended wording for overriding theme elements- replace with screenshot
 (o) Use font from theme
 (o) Use this font: [ Font selector ]

 (o) Use colors from theme
 (o) Use these colors:
 Background: [ color selector ]
 Foreground: [ color selector ]
 
The wording of the radio buttons may be more specific where required, for example, "Use monospace font from theme", or "Use background color from theme".
Toolboxes
A toolbox provides convenient access to a set of actions and toggles through a set of small toolbar-like buttons. Toolboxes can be used to provide a specialized group of tools to augment a toolbar containing more universal items such as
An example of a toolbox
A screenshot of a toolbox with eight buttons arranged into two rows
Toolboxes have no title
How then does a screenreader user differentiate between toolboxes? --Calum.
ATK hints? How does Windows do this (or does it) ? There's not room for a title bar. Maybe we can have apps set the title bar but teach the WM to not draw it or something. In any case, for sighted users there's not even *room* for a titlebar in a toolbox. -Seth
A toolbox still needs to have an appropriate accessible description, so a screenreader user hears some information about its content when they focus it. -Calum
I think having the title set but having the WM ignore it might be the best way to do this? I'll talk to Havoc. -Seth
Close, Roll-up/Unroll
Toolboxes have no buttons
Resizing:
Make toolboxes resizable, but only resize by discrete toolbox item widths. In other words, the user can resize the toolbox to be one item wide, two items wide, three items wide, etc. but not one and a half items wide.
Only place buttons in a toolbox that do not open another window.
Toolboxes are best used for modal toggle buttons that affect the operation of the mouse on the document, such as a set of buttons for choosing between paintbrush, eraser, and fill modes in a drawing application. Buttons that initiate actions upon clicking (such as a save button) are better placed in toolbars.
Ensure that closing a toolbox does not close or otherwise alter any primary window with which it is associated.
Do not place toolboxes in the system window list. Toolboxes should always remain above all primary windows with which they are associated.
If all primary windows associated with a toolbox are closed or minimized, hide the toolbox as well. Show the toolbox again when one of the primary windows is opened or restored.
Make a toolbox two items wide by default, unless it is broken into
Toolbox Categories
While categories may not be as visually appealing as a toolbox homogenously filled with beautiful icons, they make an unwieldy large toolbox more managable. Picking a small icon from more than fifteen other items is a difficult task. Additionally, categories allow users to hide sets of tool items that are not relevant to their current task.
A large toolbox broken into categories
Break toolboxes with more than sixteen items into categories. The best size for a category is between four and ten items.
Give each category a label (in title caps) and a collapsing arrow. Clicking the label or the arrow toggles the category between a collapsed and uncollapsed state.
Alerts
An alert provides information about the state of the application system, or asks for essential information about how to proceed with a particular task. It is distinct from other types of window in that it is not directly requested by the user, and usually contains a message or a question rather than editable controls. Since alerts are an unwelcome intrusion into the user's work, do not use them except where necessary to avoid potential data loss or other serious problems.
An alert has a border similar to that of a dialog, and is object modal.
An alert should not appear in the panel window list unless it is, or may be, the only window shown by an application. For example, an appointment reminder alert may be shown after the main calendar application window has been closed.
Otherwise, an alert should be raised above the application when the application window itself is selected from the window list.
An example of an alert
An example of an alert, showing the text "You have an appointment with George Wells in 15 minutes", and with an OK button to dismiss the window.
Title Format
Alert windows have no titles, as the title would usually unnecessarily duplicate the alert's primary text. This way, users can read and respond to alerts more quickly as there is less visual noise and confounding text.
Without a title, how does a screenreader user identify an alert window? -Calum
The screen-reader finds out its an alert (do we need a WM mechanism for this?) and reads the primary text to identify the alert. The whole point for removing the title is that its redundant with the primary text, and puts more crap on the screen to be read. This problem applies double to users with screenreaders (i.e. reducing extra crap helps them even more). -Seth
An alert still needs to have an appropriate accessible description (perhaps the primary text of the alert itself?), so a screenreader user hears some information about its content when they focus it. -Calum
I'll talk to Havoc about this. -Seth
Resizing
Alert windows are not resizable. If the user needs to resize your alert, the text is probably not concise enough.
None
Alerts must stay above their parent
Alerts do not appear in the system window list. Consequently, take care to ensure that alerts stay above their parent window. Otherwise, users will be likely to lose the alert and find your application unresponsive for no apparent reason. Modal windows should always stay above the window(s) they block.
Alert Text
An alert may contain both primary and secondary text. The primary text briefly summarizes the situation. The secondary text provides additional information.
Make both the primary and secondary text selectable. This makes it easy for the user to copy and paste the text to another window, such as an email message.
Primary and Secondary Text Placement
Screenshot of an alert showing example of primary text in bold, and secondary text in a smaller font underneath.
Primary Text
The primary text provides the user with a one sentence summary of the information or suggested action. This summary should concisely contain the essential details of the problem or suggestion. Every alert has primary text, displayed in a bold font slightly larger than the default. The primary text is punctuated in 'newspaper headline' style, that is, it has no terminating period, but it may have a terminating question mark.
&lt;span weight="bold"
 size="larger"gt;
Denote primary text with the pango markup:
Secondary Text
Secondary text provides a more in-depth description of the problem and suggested action, including possible side effects. Secondary text can also provide information that may be helpful in allowing the user to make an informed decision. In most situations the user should only need the primary text to make a quick decision, but they may read the secondary text if they are unsure of the proper course of action, or require extra details. Secondary text is optional, but if used, place it one text line height beneath the primary text using the default font size and weight.
Alert Buttons
Give all alerts an affirmative button that dismisses the alert and performs the action suggested in the primary text. Provide a
Button ordering and placement for alerts
Screenshot showing ordering and placement of alert buttons: Help button in bottom left, and Alternate, Cancel and Affirmative buttons in bottom right.
Button Phrasing
Write button labels as imperative verbs, for example
Affirmative Button
Place the affirmative button in the lower right corner of the alert. The affirmative button accepts the action proposed by the alert, or simply dismisses the alert if no action is suggested (as is the case with an
Cancel Button
If the alert was produced in response to a user action, place a
Help Button
A
Alternate Buttons
Extra buttons may be used to provide alternates to the primary action proposed by the alert text. Place these buttons to the left of the
Spacing and Positioning Inside Alerts
Using clear, consistent spacing in alerts makes the message easier to digest and the available responses more obvious.
Spacing inside an alert
Diagram showing correct spacing to use between controls and buttons in an alert window. This is detailed in the guidelines below.
The border around all edges of the alert, and the space between the icon and the text, is 12 pixels.
The horizontal spacing between the buttons is 6 pixels.
Add one line break at the standard font size below both the primary and secondary text, or 24 pixels if you are using Glade.
Align the top of the icon with the top of the primary text.
Left-align the message text, for western locales.
Technical Details for Proper Layout
Create a new GtkDialog window specifying the number of buttons you wish the alert to contain (and a help button if appropriate). The GtkDialog will contain a GtkVBox with an empty upper row, and a lower row containing a GtkButtonBox with buttons in it. In the empty upper row, place a new GtkHBox. In the left column of the GtkHBox place a GtkImage. In the right column of the GtkHBox place a GtkLabel. Inside the GtkLabel place
Properties for the GtkDialog
Property
Value
(none)
Border Width
6
Type
Top Level
Resizable
No
Has Seperator
Properties for the GtkVBox (included in the dialog by default)
Spacing
12
Properties for the GtkHBox
Properties for the GtkImage
Y Align
0.00
Icon Size
Dialog
Properties for the GtkLabel
Use Markup
Yes
Wrap Text
Information Alerts
Use an information alert when the user must know the information presented before continuing, or has specifically requested the information. Present less important information by other means such as a statusbar message.
An information alert
An information alert...
uses the stock information icon.
presents a selectable message and an
may present a convenience button to give access to a relevant object. For example, a
Roll-up/Unroll, Minimize (if the alert has no parent window), Close
Error Alerts
Display an error alert when a user-requested operation cannot be sucessfully completed. Present errors caused by operations not requested by the user by another means, unless the error could result in data loss or other serious problems. For example, an error encountered during an email check initiated by the user clicking a toolbar button should present an error alert. However, an error encountered in an automated periodic email check would more appropriately report failure with a statusbar message.
An error alert
An error alert...
uses the stock error icon.
presents a selectable message and an
may present a convenience button to allow immediate handling of the error. For example, a
Confirmation Alerts
Present a confirmation alert when the user's command may destroy their data, create a security risk, or take more than 30 seconds of user effort to recover from if it was selected in error.
A confirmation alert
A confirmation alert...
uses the stock warning icon.
presents a selectable message and a button labelled with a verb or verb phrase describing the action to be confirmed, or labelled
presents a
may present an alternate action button or a convenience button. Place this button to the left of the
Save Confirmation Alerts
Save confirmation alerts help ensure that users do not lose document changes when they close applications. This makes closing applications a less dangerous operation.
A save confirmation alert
Save confirmation alert: "[ Close without Saving] [ Cancel ] [[ Save ]] "
Save changes to document
You may replace
If you close without saving, changes from the last
The secondary text provides the user with some context about the number of changes that might be unsaved.
Buttons

When a confirmation alert is needed, present it immediately. If the user confirms closing without saving, hide the alert and the document or application window immediately, before doing any necessary internal clean-up. If the user chooses to save before closing, hide the alert immediately but show the document window until the document is saved, in case an error occurs. Then hide the document window immediately after it has been saved successfuly.
Authentication Alerts
Authentication alerts prompt the user for information necessary to gain access to protected resources, such as their username or password. Authentication alerts are a special kind of alert because they are both routine and largely unavoidable. Every attempt should be made to retain information entered into an authentication alert as long as is possible within security constraints.
An authentication alert
Use the stock authentication icon.
Show a labelled field for each required item of information. Suggested fields are
If it is secure to retain the username longer than the password, pre-fill the username field and give focus to the password field when the alert is displayed.
Show a button labelled with a verb or verb phrase describing the authentication action, or
Do not enable the
Show a
Place any alternative action or convenience button to the left of the
When the user presses
Progress Windows
A progress window can be used to provide
A progress window should always appear as an independent window in a window list. If progress of a task makes a window temporarily unusable, do not present a modal dialog-like progress window in front of it. Instead, present progress somewhere in the original window, making all its other elements temporarily insensitive. This helps reduce visual clutter.
An example of a progress window
Progress windows should have a title representing the overall operation: for example
Progress windows should be resizable if they contain non-static information the user may want to copy (for example, the source URL in a download progress window). Otherwise they should not be resizable.
It is often better to use the progress bar contained in many primary windows' statusbar rather than a progress window. See
Progress windows should use primary and secondary text like an alert. See
The progress bar text should provide an idea of how much work has been completed. It is better to provide specific information rather than a unitless percentage. For example, "13 of 19 images rotated" or "12.1 of 30 MB downloaded" rather than "13% complete".
If possible, an estimate of the time left until the operation is complete should also be included in the progress bar text. Indicate that the "time left" is an estimate using the word "about".
Immediately beneath the progress bar, place italicized text indicating the current sub-operation being performed. This might be a step in a sequence, "Contacting control tower for permission to land", or it could be the current object being operated on in a bulk operation, "Rotating MonaLisa.png", "Rotating StarryNight.png".
If the operation in progress is potentially hazardous (destructive, costly, etc) or heavily taxes a limited resource for more than ten seconds (network bandwidth, hard disk, CPU, etc), consider placing a
A progress window for a file copy operation
A progress window for a copy operation
Checklist Windows
Occasionally a procedure is comprised of a series of user performable actions. In these cases, particularly when it is desirable that the user acquire some familiarity with the actions involved in a procedure, checklist windows may be used.
Firewall Setup Wizard
A personal firewall setup wizard might install the firewall package, add entries for the firewall to /etc/xinetd.conf, restart the internet super-daemon, and configure the user's web browser to operate through the firewall. It may be desirable that the user is exposed the series of actions involved in setting up the firewall to increase the chances that they will be sucessful in making modifications later, if they so desire.
An example checklist window (Ready to Start)
A checklist window
An example checklist window (In Progress)
An example checklist window (Completed)
If knowing the series of steps in an operation isn't that useful to the user, just use a regular progress window. Remember that you are probably more interested in the information than most users, many of whom will find the technical steps confusing rather than helpful.
Unlike regular progress windows, checklist windows should not close automatically when the operation is complete and should require explicit user input before they begin. This is because one of their purposes is to inform the user concerning an operation's contingent steps.
The progress bar indicates progress in the overall operation, not each step. While this is more difficult to program, it is the information most useful to the user. Just estimate how long each of the steps takes relative to each other and assign each step a fixed ratio of the progress bar's progress accordingly.
Do
Dialogs
A dialog provides an exchange of information, or dialog, between the user and the application. Use a dialog to obtain additional information from the user that is needed to carry out a particular command or task.
A dialog should not appear in the panel window list. Any open dialogs should be raised above the application when the application window itself is selected from the window list.
An example of a dialog
An example of a tabbed dialog: the GNOME print dialog

Minimize, Roll-up/Unroll
Follow the guidelines for Alert buttons, see
Your dialog may specify a default button, that is activated when the user presses the
Additional Buttons
You can include other buttons in a dialog's main button area in addition to the affirmative button and
Place buttons that apply to the dialog as a whole in the main button area row at the bottom of the dialog, to the left of the
Place buttons that apply to one or a few controls next to their associated controls. For instance, place a
Layout
A clean, logical dialog layout helps the user to quickly understand what information is required from them.
Arrange controls in your dialog in the direction that people read. In western locales, this is generally left-to-right, top-to-bottom. Position the main controls with which the user will interact as close to the upper left corner as possible. Follow similar guidelines for arranging controls within groups in the dialog, and for specifying the order in which controls are traversed using the
When opening a dialog, provide initial keyboard focus to the component that you expect users to operate first. This focus is especially important for users who must use a keyboard to navigate your application.
Provide and show sensible default values for as many of the controls in your dialog as possible when it is opened, so the user does not have to generate the information from scratch. These defaults may come from system settings (for example, hostname or IP address), or from information that the user has previously entered in this or another application (for example, email address or network proxy).
See
See
Common Dialogs
The gtk and GNOME libraries provide standard dialogs for many common tasks, including opening and saving files, choosing fonts and colors, and printing. Always use these when the user is performing one of these tasks. You may modify the dialogs to reflect the needs of your particular application (for example, adding preview
Assistants
An assistant is a secondary window that guides the user through an operation by breaking it into sequential steps. Assistants are useful for making complex operations less intimidating, as they restrict the information visible to the user at any given moment.
Because assistants provide a relatively small number of controls on the screen at any given time, they have sufficient space for inline documentation. Therefore, do not include a
Assistants do have major downsides. After using an assistant it is often hard to figure out where the individual settings aggregated into the assistant are stored. Often people will resort to re-running the assistant, re-entering many settings that they don't want to change.
Assistants are often used in situations where a better solution would be to simplify, or even better automate, the process. Before using an assistant to step people through a complex operation, consider if the operation can be fundamentally simplified so an assistant is unnecessary.
Close, Minimize/Unminimize, Roll-up/Unroll
Introductory Page
The first page provides the user with the "big picture". Place the title of the assistant in the window's title bar and the assistant's title area, along with an optional picture. Beneath this, state the goal of the assistant, and, if it is not obvious, where the user can find the information the assistant will be asking for.
Assistant Title

Example of the first page of an assistant
Screenshot showing the first page of an assistant for creating a new email account
Content Pages
Content pages contain the actual settings of the assistant. Summarize the type of setting present on each content page in its title area. For example,


Last Page
The last page should summarize the settings that will be changed by the assistant, and how the user can modify them later.
Finish

Menus
Tear| off menus? (These are controlled by gconf in 2.0, so nothing app developer needs to do?)
Menu bar position
Menu bar hiding
Menus present the whole range of an application's commands to the user, and often a subset of its preferences. When designing a new application, place common menu items in the same locations as they appear in other applications, as this makes it much easier for the user to learn.
In most applications, only primary windows should have a menubar.
Occasionally, however, a utility window or dialog is so complex that there would be too many such controls. In this case, you may use a menubar provided that:
the menus follow the same standard layout as described in
the window does not include a dialog button area or any buttons that dismiss it, such as
Label menu items with verbs for commands and adjectives for settings, according to the rules in
Make a menu item insensitive when its command is unavailable. For example, the
Provide an access key for every menu item. You may use the same access key on different menus in your application, but avoid duplicating access keys on the same menu. Note that unlike other controls, once a menu is displayed, its access keys may be used by just typing the letter; it is not necessary to press the
Design your menu structure to avoid more than one level of submenus. Deep menu hierarchies are harder to memorize and physically difficult to navigate.
Do not have menus with less than three items on them (except the standard
The Menubar
A typical menubar
A typical application menubar, showing File, Edit, View, Insert, Format, Go, Bookmarks, Tools, Windows and Help menus
The menubar provides a number of drop-down menus. Only the menu titles are displayed, until the user clicks on one of them.
The menubar is normally visible at all times and is always accessible from the keyboard, so make all the commands available in your application available on the menubar.
Full screen mode
When your application is running in full screen mode, hide the menubar by default. However, make its menus and items accessible from the keyboard as usual. Pressing
Provide a menubar in each primary application window, containing at least a
Organize menu titles in the standard order— see
Do not disable menu titles. Allow the user to explore the menu, even though there might be no available items on it at that time.
Menu titles on a menubar are single words with their first letter capitalized. Do not use spaces in menu titles, as this makes them easily-mistaken for two separate menu titles. Do not use compound words (such as
Do not provide a mechanism for hiding the menubar, as this may be activated accidentally. Some users will not be able to figure out how to get the menu bar back in this case.
Types of Menu
Drop-down Menus
A typical drop-down menu
Screenshot of a typical drop-down menu
A drop-down menu appears when the user clicks on its title in a menubar, or focuses the title and presses
CB-Ed/Fig: Define "post," as no-brainer-ish as it may seem, and also add a figure to show what it means. A simple menu being shown at the user clicking on a menu title on a menubar, or "posted," makes sense.
CFB: I've just reworded everything to avoid the use of "post"
Only place items on a menu that relate to that menu's title.
Organize menu items in the standard order— see
Limit top-level menus to a maximum of about 15 items. If you have any more items than this, consider moving a functionally-related subset of the items into a submenu or a new top-level menu.
Do not add or remove individual menu items while the application is running, make them insensitive instead. Entire menus may be added or removed from the menubar at runtime, however, for example in component-based applications.
Immediately update menu items that are edited directly or indirectly by the user, such as those on the
CB-Ed: As in JLFDG AT p. 33, perhaps provide a table of common access keys, or "mnemonics."
CFB: the keyboard navigation chapter already does so
Submenus
A drop-down menu with a submenu
Screenshot of a drop-down menu with a submenu
A submenu appears when the user clicks its title, which is indicated by a small arrow symbol beside its label. You can save space on long menus by grouping related commands onto a single submenu.
Use submenus sparingly, as they are physically difficult to navigate and make it harder to find and reach the items they contain.
Do not create submenus with fewer than three items, unless the items are added dynamically (for example the
Do not nest submenus within submenus. More than two levels of hierarchy are difficult to memorize and navigate.
CB-Ed/Fig: In JLFDG AT, p. 41, the Most Recently Used (MRU) list is recommended to contain no more than 10 items. Add a figure here, with callouts to point out this rule, among others, if any are developed.
Popup Menus
A popup menu for a mail folder
Screenshot of a popup menu for a mail folder, listing the actions that can be performed on that folder
Popup menus provide shortcuts to those menu items that are applicable only to the currently selected object. As such, they are sometimes known as "context menus" or "shortcut menus". A popup menu is shown when the user right-clicks on an object, or selects the object and presses
Be aware that popup menus are used primarily by intermediate and advanced users. Even some users who have used graphical desktops for many years do not know about popup menus until somebody shows them.
Provide a popup menu for every object, selectable part, and text input target such as entry fields.
Provide an access key for each item. However, to enhance their spatial efficiency and readability, do not show keyboard shortcuts in popup menus.
Since the user may not be aware of their presence, do not provide functions that are only accessible from popup menus unless you are confident that your target users will know how to use popup menus.
But see http://bugzilla.mozilla.org/show_bug.cgi?id=34357
Order items on a popup menu as follows:
the double-click action for object, when it exists
other commands and settings in expected frequency-of-use order
transfer commands such as

Popup menus need to be as simple as possible to maximize their efficiency. Do not place more than about ten items on a popup menu, and do avoid submenus.
CB-Ed: In the previous note, define the Input Methods menu and why it is an exception, for scalability reasons (other items may fall into the same category). It also sounds like a pretty low-level command; should this be exposed to the user?
SN-Ed: No, it should not be exposed to the user. I'm not really sure what possessed the GTK guys to put this in every right click menu for text boxes. I suppose in this case having it be a submenu is good (if they insist on it existing) because it makes it maximally invisible
GJM: To make this worse, they've added "Insert Unicode control character".
Designing a Menu
Grouping Menu Items
Items grouped on a menu with separators
Screenshot of a menu divided into five logical groups with menu separators
Menu separators are the horizontal dividing lines that visually separate groups of related items on a drop-down menu, submenu, or popup menu. For example, the separators in
The best size for a group is around 2-5 items. Single-item groups are best placed at the top or bottom of a menu, otherwise try to group them with other single items of the same type on the same menu.
Order items within a group logically, numerically, in task order or by expected frequency of use, as appropriate.
Only place one type of menu item in each group—
Types of menu item
Command Items
A group of command items on a menu
Screenshot of a group on a menu containing only command items: Save, Save As, and Revert
Command items are menu items that initiate a command or perform an action, such as
Provide a keyboard shortcut for standard or frequently used command items. See
Do not remove command items from the menu when they are unavailable, make them insensitive instead. This allows the user to infer what functionality the application provides even if it is not currently available, and keeping the menu structure static makes it easier to memorize.
Label the menu item with a trailing ellipsis ("...") only if the command requires further input from the user before it can be performed. Do not add an ellipsis to items that only present a confirmation dialog (such as
Alt
Should we reserve
CB-Ed/Fig: Figure would be nice here.
Mutable Command Items
A mutable command item changes its label when selected. For example,
Note that mutable menu items can be problematic because the user never sees the menu item changing, so it is not obvious that a different function has become available.
If your mutable menu items are
Do not use mutable menu items to toggle a two-state setting (for example,
Checkbox Items
A group of check box items on a menu
Screenshot of group on a View menu containing four check box items: Main Toolbar, Side Pane, Location Bar and Status Bar
A check box menu item shows the current state of a two-state setting, and allows the user to toggle it by selecting the menu item.
Use a check box menu item only when it is obvious from the label what the set and unset states mean. This usually means that the two states are logical or natural opposites, such as "on" and "off". If this is not the case, use two
Never change the label of a check box menu item in response to the user selecting the item.
Radio Button Items
A group of radiobutton items on a menu
Screenshot of group on a menu containing three radiobutton items: view as icons, view as list and view details
Radio button menu items show which of two or more mutually-exclusive settings are currently selected, and allow the user to choose a different setting by selecting its menu item.
If you need to offer a choice of two mutually-exclusive settings to the user, use a group of two radio button items instead of a single check box menu item if the settings are not clearly opposites. For example, represent
Never change the label of a radio button menu item in response to the user selecting or deselecting the item.
Adam notes that this whole section can be a significant source of nastiness in a UI. We need explicit recommendations here on how to represent different states of a toggled menu item via icons in the UI. We also need to make recommendations to avoid some common mistakes, including: * Confusing menu items acting as radio buttons in a group with menu items acting as check boxes. * Ambiguous names for check box/toggle menu items which make it difficult to establish the current system state by looking at the menu.
Standard Menus
Most applications have many functions in common, such as
This section details the most common menus, menu items and their behaviors. You will not need all of these menus or menu items in every application you write, but do preserve the order of the menu titles and of the menu items that you do use.
Place application-specific menus after the
Place application-specific menu items towards the middle of a standard menu, unless they logically fit with one of the standard groups already on the menu.
What is the best way to present menus given the known variants? Multiple shots? Segments?
A menubar showing all the standard menu titles in their correct order
F

E

V

I

m
For
G

B

W

H

File
The
The items on the
If your application does not operate on documents, name this item for the type of object it displays. For example, many games should have a
GJM: Quit should be deprecated. Close is often sufficient; especially when the application saves state as it should.
A generic File menu
N

O

S

A
Save
v
Sa
R

u
Page Set
w
Print Previe
P


t
Proper
1

2
3
4
C

Q


Creation and Opening Operations
Adam noted in the last review that we don't make any suggestions for applications that do not edit document/files. In an OOUI, the Game menu would have items such as (modulo phraeseology) Open New Game, Open Game Settings, High Scores.
&gt;For non-game UI there would be at the very least, Open as ... and Open Settings.
Creation and Opening operation menu items
Label
Shortcut
Description

Ctrl
Document name
If your application can create a number of different types of document, you can make the
Note: A blank document will not necessarily be completely blank. For example, a document created from a template may already contain some data.
Creates a new document. Open a new primary window, with the title

If your application provides more than two ways to open an object, place all the Open ... items in a submenu, including Recent Files. This keeps the menu less cluttered and in some ways presents a better inteface as the list of recent files is presented in the same menu, and near, the regular open commands. Users hate having to go to the bottom of the file menu to open recent files; the cause of this is that, in the workplace, it is far more common to sort out other peoples already written and saved crap than it is to have to write your own. Most of the users of office application, surveyed in both card sorts and online presentations of speculative menus, do not want or do not even notice when the New... items are absent.
&gt;Problem to be solved. It may be desirable to open a second read-only view of the same document. How should this be provided? Non-OOUI are particularly nasty in this regard, as in many others. A "Clone Window" command seems quite nasty.
&gt;As I noted in the first review, the blank window should be kept available; in an OOUI this is a more obvious a way of working.
Opens an existing document in a new window. Present the user with a standard Open File dialog from which they can choose an existing file. If the chosen file is already open in the application, raise that window instead of opening a new one.
Saved State Operations
This section needs a review with an eye to what can actually be done programmatically.
Saved State Operation menu items

If the document has no current filename or is read-only, selecting this item should be the same as selecting
Saves the document with its current filename. If the document already has a filename associated with it, save the document immediately without any further interaction from the user. If there are any additional options involved in saving a file (eg. DOS or UNIX-style line endings in a text file), prompt for these first time the document is saved, but subsequently use the same values each time until the user changes them.
Save
Shift
Saves the document with a new filename. Present the user with the standard Save As dialog, and save the file with the chosen file name.
a
S
Save As
Like the
Prompts the user to enter a filename, with which a copy of the document is then saved. Do not alter either the view or the filename of the original document. All subsequent changes are still made to the original document until the user specifies otherwise, for example by choosing the
Reverts the document to the last saved state. Present the user with a warning that all changes will be lost, and offer the option of cancelling before reloading the file.
Save
Save a Copy
Restore Version
Unless we can describe exactly what this ought to do, should we remove it for now?
An alternative to the
e
R
Save Version
Prompts the user for a version of the current document to be restored. Present the user with with a warning that all changes will be lost, and offer the option of cancelling before restoring the version. Only use this item in conjunction with the

An alternative to the
Export Operations
Export Operation menu items
We should have a standard dialog for this.
Allows the user to control print-related settings. Present the user with a dialog allowing the user to set such options as portrait or landscape format, margins, and so on.
Print Previe
Shows the user what the printed document will look like. Present a new window containing an accruate represenation of the appearance of the document as it would be printed. The libgnomeprintui library provides a standard Print Preview window that you should use if possible.

Print
libgnomeprintui
Prints the current document. Present the user with a dialog allowing them to set options like the page range to be printed, the printer to be used, and so on. The dialog must contain a button labelled
S
M
You may provide more than one
Provides the user a means to attach or send the current document as an email or email attachment, depending on its format.
File Properties
Properties menu items
Return
Properties
Opens the document's
Closing Operations
Closing Operation menu items

confirmation alert
If the window you are closing is the last open document in the application, the correct action depends on your application type:
Single document interface: close the application
Controlled single document interface: leave only the control window open
Multiple document interface: close the current document and create a new blank document
http://bugzilla.gnome.org/show_bug.cgi?id=76761
As mentioned on the usability list, Control+W is an Emacs shortcut for Cut. This has already proven deleterious for some users so we should consider dropping the shortcut. But see also
Closes the current document. If it has unsaved changes, present the user with a

Closes the application. If there are unsaved changes in any open documents, present the user with a
In particular, non-document based applications, for example a game or a calculator, should save their state and exit immediately. This state should be restored the next time the application is started.
Kathy had suggested not providing a shortcut key to Quit. I can find no discussion of this. (And I think it should go away.)
Edit
The
most applications' preferences windows are accessed via a single menu item, and single-item menus offer poor usability
most applications already contain a suitable
I think we should move to a MacOS/X concept of having an "AppName" menu that contains things like preferences, about, quit, etc. -Seth
A generic Edit menu
U


Cu


Paste
D


p
Du
l
Dese

x
Find Ne
Find Pre
R

Pr

Modification History
Document-based applications should maintain a history of modifications to a document and the state of the document between each action. The
We'd like to see the action name included on the Undo/Redo menu items, but this is currently not easy to do in gtk.
Modification History menu items
action

Z
Note: provide a separate
Undoes the effect of the previous action in the undo history list. Revert the document to its state before the previous action was performed. If your application supports undo, and the user undoes all changes since it was last saved, treat the document as unmodified.

Undo
Performs the next action in the undo history list, after the user has moved backwards through the list with the
Manipulating Selected Data
Selected Data Manipulation menu items
Cu
X

Removes the selected content and places it onto the clipboard. Visually, remove the content from the document in the same manner as

Copies the selected content onto the clipboard.

Inserts the contents of the clipboard into the document. If there is no current selection, use the caret as the insertion point. If there is a current selection, replace it with the clipboard contents.
Paste
Inserts a non-default representation of the clipboard contents into the document. Open a dialog presenting a list of the available formats from which the user can select. For example, if the clipboard contains a PNG file copied from a file manager, the image may be embedded in the document, or a link to the file inserted so that changes to the image on disk are always reflected in the document.
Du
Copy of ShoppingList.abw
Creates a duplicate copy of the selected object. Do not prompt for a name for the duplicate object, but give it a sensible default (for example,
Delete
Should Delete be provided on a menu? The command is as obvious as using the arrow keys to move about.
Removes the selected content without placing it on the clipboard.
Select
Selects all content in the current document.

Note: Do not provide
Deselects all content in the current document. Only provide this item in situations when no other method of undoing selection is possible or apparent to the user. For example, in complex graphics applications where selection and deselection is not usually possible simply by using the cursor keys.
Searching and Replacing
Search and Replace menu items
Find...
If the command allows the user to search for content in places other than the current document, for example other open documents, other documents on disk, or a remote network location, label this item
Opens a window or dialog allowing the user to search for specific content in the current document. Highlight each match in-place.
Find Ne
What to do if there is no next instance? Disable the menu item, which could be confusing, or pop up an annoying alert saying 'no matches found'?
Selects the next instance of the last Find term in the current document.
Find Pre
Selects the previous instance of the last Find term in the current document.

Replace is not always descriptive of what the user may do with the utility window. Formatting a section is also a possibility. Ideally, these would all be merged into a simple utility window
Opens a window or dialog allowing the user to search for specific content in the current document, and replace each occurrence with new content.
Inserting Special Objects
Where applicable, provide items on the
If you have up to three types of object that can be inserted, add them as individual items to this menu, for example
User Preferences
User Preferences menu items
preferences window
Opens a
View
The
A generic View menu
T



L





Zoom




Toolbar and Statusbar
Toolbar and Statusbar menu items
check box menu item
Shows or hides the application's toolbar. This is a
Content Presentation
Content Presentation menu items
radio button menu item
Shows the contents of the selected container as rows and columns of large icons, each with its name underneath. This is a
Shows the contents of the selected container as a list of small icons, possibly in multiple columns, each with its name on its right-hand side. This is a
If your application has no need for both
Shows the contents of the selected container as single column of small icons, each with its name on its right-hand side. Additional columns give extra information about the object each icon represents, for example the size and modification date of files in a file manager. This is a
o
S
Sorts the contents of an container by user-specified criteria. Open a dialog allowing the user to choose from pre-defined sort keys (for example, Name, Size, or Modification Date in a file manager), or to specify their own if applicable.
Hides objects that are not of interest to the user. Open a dialog allowing the user to choose from a list of types of object they want to display, or to enter their own criteria (for example, a regular expression matched against a particular property of the objects).

+
Should probably encourage apps to support Ctrl+= as well.
Zooms into the document. Make the center of the new view the same as the center of the previous view.
Zoom
-
Zooms out of the document. Make the center of the new view the same as the center of the previous view.

Resets the zoom level back to the default value, normally 100%. Make the center of the new view the same as the center of the previous view.
Makes the document fill the window. Show the document, or the current page of the document, at as high a zoom level as will fit in the window whilst allowing the whole document or page to be visible without scrolling.

Redraws the current view of the document from local storage. For example, in a web browser application, this would redraw the page from the browser page cache.

If your application requires both
Redraws the current view of the document, checking the data source for changes first. For example, checks the web server for updates to the page before redrawing it.
Insert
The
A generic Insert menu









E

The types of object will vary between applications, but the table below shows some common types that may be applicable.
Insert menu items
Inserts a page break at the caret position. Show the page break visually, for example as a dotted line across the page, unless the user has specifically requested not to see them.
Inserts the current date and/or time at the caret position. Open a dialog giving a choice of date and time formats. If applicable, also offer the choice to insert either as plain text, so the specified date and time will always appear in the document, or as a special field that will updated every time the document is opened, refreshed or printed.
Sy
Inserts a special symbol, such as a mathematical symbol or foreign character, at the caret position. Open a dialog showing all the available symbols as a table, from which the user can choose. The user must be able to add multiple symbols to the document at one time without having to close and re-open the dialog.
Sheet-2
Adds a new sheet to the current workbook. Do not prompt for a name, but choose a sensible default (such as
Adds new rows to a table in which one or more rows or cells are currently selected. Open a dialog asking whether to insert rows above or below the current selection, and for any other required information. Copy the row format from the last or first row of the current selection respectively, unless the user specifies otherwise.
Adds new columns to a table in which one or more columns or cells are currently selected. Open a dialog asking whether to insert columns to the left or right of the current selection, and for any other required information. Copy the column format from the right- or left-most column of the current selection respectively, unless the user specifies otherwise.
Inserts an image into the document from a file. Present a standard Open File dialog filtered on acceptable file types, from which the user can choose an image file to insert.
Inserts a graph into the document. Open a dialog or assistant that allows the user to build (or open from a file) a graph of their choice, using the current selection as an indication of which values, axis labels and data labels to use.

Inserts an object from any acceptable file type, for example plain text, formatted text, or an image. Present a standard Open File dialog filtered on acceptable file types, from which the user can choose a file to insert.
Inserts a link to an object stored in a different file, or on a remote system. The object is not embedded in or saved with the document, only a link to it. Open a dialog in which the user can type or choose the name of the object, for example a filename or a webpage URL. Show the link in the document in as informative way as possible. For example, show a link to an image as a thumbnail of that image, unless the user specifies otherwise.
Format
A
The difference between these commands and those on the
A generic Format menu








ayer
L
P

Items found on the
Format menu items
Sets the style attributes of the selected text or objects either individually or to a named, predefined style. Open a dialog allowing the user to set attributes such as bold, italic, size and spacing individually, and to create their own named styles where applicable.
Sets the font properties of the selected text or objects. Open a dialog allowing the user to choose font, size, style, color, or whatever other attributes are applicable.
Sets the properties of the selected paragraph. Open a dialog allowing the user to choose style, line spacing, tabulation, or whatever other attributes are applicable.

Toggles the boldness of the current text selection on or off. If some of the selection is currently bold and some is not, this command should bolden the selected text.

Toggles the italicisation of the current text selection on or off. If some of the selection is currently italicised and some is not, this command should italicise the selected text.

Toggles underlining of the current text selection. If some of the selection is currently underlined and some is not, this command should underline the selected text.
Sets the properties of the selected table cells. Open a dialog allowing the user to choose alignment, borders, shading, text style, number format, or whatever other attributes are applicable.
Sets the properties of the selected list, or turns the selected paragraphs into a list if they are not already formatted as such. Open a dialog allowing the user to choose number or bullet style, spacing, tabulation, or whatever other attributes are applicable.
r
Laye
Sets the properties of all or selected layers of a multi-layered document. Open a dialog allowing the user to choose name, size, visibility, opacity, z-ordering, or whatever other attributes are applicable.
Sets the properties of all or selected pages of the document. Open a dialog allowing the user to choose paper size, orientation, columns, margins, or whatever other attributes are applicable.
Bookmarks
Provide a
Icons
Show icons for bookmark entries on the Bookmarks menu that indicate the type of the bookmark, even if the user has globally turned off icons for other menu items on the desktop.
A generic Bookmarks menu


Bookmark menu items
Edit Bookmarks
Adds a bookmark for the current document to the default bookmark list. Do not pop up a dialog asking for a title or location for the bookmark, instead choose sensible defaults (such as the document's title or filename as the bookmark name) and allow the user to change them later using the
Allows the user to edit the application's bookmark list. Open a window in which the user can arrange bookmarks into a hierarchy, move, copy, and delete bookmarks, and change their properties.
Bookmark List
The user's current list of bookmarks for the application.
Go
A
The contents of the menu will vary depending on the type of application. Different standard menus are presented here for browser-based and document-based applications , but your application may require a combination of both.
A generic Go menu for a browser application






Go menu items for a browser application

Left
Navigates to the previous document in the browser's history list.

Right
Navigates to the next document in the browser's history list.

Up
Navigates to the current document's (or folder's) parent document (or folder). For a document browser, such as an online help viewer, this usually means navigating to the enclosing sub-section, section, chapter or contents page.

Home
Navigates to a starting page defined by the user or the application.

Navigates to a user-specified URI. Open a dialog into which the user can type a suitable URI, or select one from a list where applicable (for example, a file selection dialog for applications that can handle file:// URIs).
A generic Go menu for document-based applications






Go menu items for a document-based application

PageUp
Navigates to the previous page in the document.

PageDown
Navigates to the next page in the document.
Text-based applications may also include a
Navigates to a user-specified page number. Open a dialog into which the user can type a page number.

Navigates to the first page in the document.

End
Navigates to the last page in the document.
The Windows menu contains commands that apply to all of the application's open windows. Only use a Windows menu in
MDI Applications
The use of MDI is discouraged, as they have a number of inherent usability problems.
You may also label this menu
The last items on this menu are a numbered list of the application's primary windows, for example
A generic Windows menu


Windows menu items
Saves all open documents. If any documents have no current filename, prompt for a filename for each one in turn using the standard Save dialog.
Closes all open documents. If there are any unsaved changes in any documents, post a
first open window title

second open window title
etc.
Raises the corresponding window to the top of the window stack.
Help
The
A generic Help menu


Help menu items

F1
Opens the default help browser on the contents page for the application.
Opens the About dialog for the application. Use the standard dialog provided by the GNOME libraries, which contains the name and version number of the application, a short description of the application's functionality, author contact details, copyright message and a pointer to the licence under which the application is made available.
We originally wanted a Search item on here too, but it's not technically possible to implement it right now.
Toolbars
A toolbar is a strip of controls that allows convenient access to commonly-used functions. Most toolbars only contain graphical buttons, but in more complex applications, other types of controls such as dropdown lists, can also be useful.
Example toolbar from a simple mail application
Example mail application toolbar
Careful and consistent toolbar design speeds up the user's task by giving direct access to functions that would otherwise be hidden on a menu. Use them only for the most important functions, however. Having too many toolbar controls reduces their efficiency by making them harder to find, and too many rows of toolbars reduces the amount of screen space available to the rest of the application.
Appearance and Content
The effectiveness of toolbars is increased by maintaining a level of consistency between different applications. The toolbar is one of the first parts of your application that a user will see the first time they run it, so by providing a toolbar that looks familiar to them, you can immediately make them feel comfortable about using your application.
As well as following the recommendations and examples given in this section, look at the toolbars in other well-designed GNOME 2.0 applications for guidance when deciding what— and what not— to put on your application's toolbar.
However many toolbars or
For example, the main toolbar in an office application will nearly always have
Place only the most commonly-used application functions on your toolbars. Don't just add buttons for every menu item.
By default, have your toolbars appear directly below the main menu bar.
Allow toolbars to be turned on and off in your application's
All functions that appear on your toolbars must also accessible via the main menu bar, either directly (i.e. an equivalent menu item) or indirectly (e.g. in the
Arrange toolbar buttons in the same order and groupings as their equivalents on the main menu bar. In particular, always group sets of mutually-exclusive toolbar buttons.
Don't add buttons for
Provide options to show toolbar buttons as text, graphics or both— see
Allow users to configure toolbars to contain their own selection of commands, in whatever order they choose. Provide an option in the configuration dialog to return the toolbars to their default configuration.
Save your application's toolbar position and contents as part of the application configuration, and restore them when the application is restarted.
Vertical Toolbars
In general, don't use vertical toolbars. The eye does not scan vertically as well as it does horizontally, groups of mutually exclusive buttons are less obvious when arranged vertically, and showing button labels is more awkard and less space-efficient. Also, some toolbar controls just cannot be used vertically, such as dropdown lists.
Only consider using a vertical toolbar if:
the configuration of the application window means there would be a lot of wasted space if a horizontal toolbar was used instead, or
your application would otherwise require three or more rows of toolbars to appear below the main menu bar by default. Note however that in this situation, the better alternative is usually to display fewer toolbars by default.
If you must use a vertical toolbar, ensure the user can configure it to appear horizontally if they prefer.
Media Player Toolbars
Many applications are able to play sound or video clips. For consistency, always present the buttons that control playback in the same order and with the same stock icons.
Show separate Stop and Pause buttons. Do not change Play to Pause while the clip is playing.
Suggested order: prev,rew,rec,play,stop,pause,fwd,next,eject.
gtk still doesn't have stock media icons, but CD player, sound recorder etc. all register icons with media-* IDs, should mention that here.
Should maybe also suggest here how to show volume and timeline controls.
Controlling Display and Appearance
For each toolbar in your application, the user should be able to choose whether or not to show that toolbar, and whether to show its contents as icons only, text only or both.
Allow the user to override the control center toolbar defaults for your particular application in the application's
separately choose to show each toolbar in your application as icons only, text only, or both
return the icon/text/both status for all toolbars in your applicaton to the system default
choose to show text labels either to the side of some or below all toolbar icons, and to return this setting to the system default
return the layout and ordering of all toolbars in your application to the application default
If your application has a single toolbar, allow the user to turn it on or off with a
If your application has two or three toolbars, allow the user to turn them on or off individually by placing a menu item for each one on the application's
If your application has more than three toolbars, allow the user to turn them on or off individually by placing a menu item for each one in a
Example View menu fragments for applications with one toolbar (left), two or three toolbars (middle), or four or more toolbars (right)
Example View menu for application with single toolbar
Labels and Tooltips
Most controls that appear on your toolbar will require a text label that appears on, below or beside it. Keep this description as short as possible, preferably a single verb. For example,
Every control that appears on your toolbar should have a tooltip, whether or not that control has an associated text label. The tooltip should be a concise description of the control, but should provide more information than its text label where possible. For example,
For buttons that correspond directly to menu items, make the text label the same as the menu item, but without any trailing ellipsis. For example,
Do not provide access keys for toolbar buttons. Since toolbars are in the same keyboard focus context as the menubar, it would be too difficult to provide unique access keys for every menu title and toolbar control. Toolbars are primarily intended as a shortcut for mouse users, although they are keyboard-navigable for accessibility reasons.
If your toolbar is configured to show labels below button icons, show a label for every control on the toolbar. For example:
Toolbar with labels under all buttons
Toolbar showing labels under all controls
If your toolbar is configured to show labels beside button icons rather than below them (using the "priority text" setting), do not show labels for every button. Show labels only for the buttons that will be most-frequently used. Choose no more than four such icons on any one toolbar, otherwise the effect will be diluted and the toolbar will become very wide. For example:
Toolbar with "priority text" labels beside the first few buttons only
Toolbar with "priority text" labels beside the first few items only
If you are unsure which buttons will be most frequently used, choose the first few buttons on your toolbar and provide labels for those only.
Ensure all toolbar controls have tooltips. The tooltip should be more descriptive than the corresponding menu item, if it has one, but still concise. For example,
Controls
Using Controls Effectively
GNOME provides a set of controls, also known as widgets, which allow users to interact with your applications. Using these controls appropriately and not altering their standard behavior is important. This allows users to predict the effects of their actions, and thus learn to use your application more quickly and efficiently. Controls that behave in non-standard ways break the user's mental model of how your application works, and dilute the meaning of the interface's visual language.
Terminology
Although they are known as "widgets" in the GNOME APIs and developer documentation, do not use this term in your user interface or user documentation. Refer to them by their specific names (for example, "buttons" or "menus"), or by the generic name "controls".
Sensitivity
Sometimes it does not make sense to allow the user to interact with a control in the current context, for example, to press a
It is usually better to make a control insensitive than to hide it altogether. This way, the user can learn about functionality they may be able to use later, even if it is not available right now.
Two check boxes: sensitive (top) and insensitive (bottom)
Screenshot showing the visual appearance of sensitive and insensitive check box controls
Locked Controls
In a network-managed environment, like a computer lab, system administrators usually want to "lock down" the values of certain settings, or remove them from the user interface altogether. This makes it easier for them to troubleshoot any problems that their users may encounter. In GNOME, the correct way for the system administrator to do this is by restricting write access to the GConf keys corresponding to those settings.
When you are designing your application, consider which settings a system administrator might want to make unavailable to users. These may typically include:
Settings that, if set wrongly, could prevent the application from functioning at all. For example, proxy settings in a network application.
Settings that could refer to networked resources. For example, the Templates directory in an office application, where shared stationery such as fax cover sheets might be stored.
Settings that customize the user interface, other than those required for accessibility. For example, certain menu, keyboard or toolbar customization options.
Your application needs to decide every time these controls are displayed whether or not they are available for editing, depending on the writeable state of the GConf key that holds its value. In the simplest case, your code for each control could look like that in the example below.
Sample code fragment showing how to make a GConf-locked control insensitive
if (!gconf_key_is_writable (http_proxy))
 gtk_widget_set_sensitive (http_proxy_field, FALSE);
Include a section for system administrators in your user guide, explaining which settings they can lock, and their corresponding GConf keys.
Explain to the user why these controls cannot be edited at this time. You can do this with static text, tooltips or online help, depending on the situation. For example:
Example of a dialog with locked controls
Screenshot showing disabled proxy controls in a web browser's property dialog, under the caption "Only the system administrator can change these settings"
Note that although they cannot be edited, the settings are still visible and selectable, and may be copied to the clipboard.
Text Entry Fields
Text entry fields are used for entering one or more lines of plain text. In GTK 2, the
Single and multi-line entry fields
Screenshot of part of a dialog, containing both single and multi-line entry fields
Label the entry field with a text label above it or to its left, using
Right-justify the contents of entry fields that are used only for numeric entry, unless the convention in the user's locale demands otherwise. This is useful in windows where the user might want to compare two numerical values in the same column of controls. In this case, ensure the right edges of the relevant controls are also aligned.
When the user gives focus to an entry field using the keyboard, place the text cursor at the end of the existing text and highlight its contents (but don't overwrite the existing PRIMARY clipboard selection). This makes it easy to immediately overtype or append new text, the two most common operations performed on entry fields.
Size text entry fields according to the likely size of the input. This gives a useful visual cue to the amount of input expected, and breaks up the dialog making it easier to scan. Don't make all the fields in the dialog the same width just to make everything line up nicely.
In an instant-apply
Provide a static text prompt for text boxes that require input in a particular format or in a particular unit of measurement. For example:
Text entry field with static text prompt
A text entry field in which the user must input a time, with the label "hh:mm" beside it to indicate the required format
Where possible, provide an additional or alternative control that limits the required input to the valid range. For example, provide a
Text entry field requiring a date as input, with a button beside it to pop up a GtkCalendar control to simplify the task
A text entry field in which the user must input a date, with a button labelled "Choose" beside it that opens a GtkCalendar control to simplify the task
This is less error-prone than expecting the user to format their text input in some arbitrary format. You may still want to provide the entry field control as well, however, for expert users who are familiar with the required format.
If you implement an entry field that accepts only keystrokes valid in the task context, such as digits, play the system warning beep when the user tries to type an invalid character. If the user types three invalid characters in a row, display an
The cursor blink rate is globally defined by the XSettings "gtk-cursor-blink" and "gtk-cursor-blink-time". Standard toolkit controls use these and they must not be altered in applications by any means. New controls with text cursors must respect these global values.
Behavior of Return key
Normally, pressing
However, if your dialog contains several entry fields that are usually filled out in order, for example
As a further safeguard, remember not to set the default button in a dialog until the minimum amount of required information has been entered, for example, both a username and a password in a login dialog. Again, in this case you should move focus to the next control when the user presses
If you need to provide a keyboard shortcut that activates the default button while a GtkTextView control has focus, use
Note
Gtk does not currently move focus to the next control when
Behavior of Tab key
Normally, pressing
If you need to provide a keyboard shortcut that inserts a tab character into a single line entry field, use
53763
allow_tab_characters
Tab
There is a patch in bugzilla (bugid=
Spin Boxes
A spin box is a text box that accepts a range of values. It incorporates two arrow buttons that allow the user to increase or decrease the current value by a fixed amount.
Example of a spin box
A simple spin box used to specify the spacing between applets on a panel
Use spin boxes for numerical input only. Use a list or option menu when you need the user to select from fixed data sets of other types.
Use a spin box if the numerical value is meaningful or useful for the user to know, and the valid input range is unlimited or fixed at one end only. For example, a control for specifying the number of iterations of some action, or a timeout value. If the range is fixed at both ends, or the numerical values are arbitrary (for example, a volume control), use a slider control instead.
Label the spin box with a text label above it or to its left, using
Right-justify the contents of spin boxes, unless the convention in the user's locale demands otherwise. This is useful in windows where the user might want to compare two numerical values in the same column of controls. In this case, ensure the right edges of the relevant controls are also aligned.
Sliders
A slider allows the user to quickly select a value from a fixed, ordered range, or to increase or decrease the current value. The control looks like the type of slider that you might find on an audio mixing desk or a hi-fi's graphic equalizer. In gtk, you implement a slider using the GtkHScale or GtkVScale controls, for horizontal or vertical sliders respectively.
A simple slider control
A slider control used to change the stereo audio balance between left and right speakers
Use a slider when:
adjusting the value relative to its current value is more important than choosing an absolute value. For example, a volume control: the average user will usually think about turning the volume up or down to make a sound louder or quieter, rather than setting the peak output to a specific decibel value.
it is useful for the user to control the rate of change of the value in real time. For example, to monitor the effects of a color change in a live preview window as they drag the RGB sliders.
Label the slider with a text label above it or to its left, using
Mark significant values along the length of the slider with text or tick marks. For example the left, right and center points on an audio balance control in
For large ranges of integers (more than about 20), and for ranges of floating point numbers, consider providing a text box or spin box that is linked to the slider's value. This allows the user to quickly set or fine-tune the setting more easily than they could with the slider control alone.
Slider controls with linked spin boxes
Three slider controls used to change RGB values, each with a spinbox beside them to facilitate direct numeric entry
A button initiates an action when the user clicks it.
Typical buttons in a modal dialog
OK and Cancel buttons as found in a modal dialog
Label all buttons with imperative verbs, using
After pressing a button, the user should expect to see the result of their action within 1 second. For example, closing the window or opening another. See
Use an ellipsis (...) at the end of the label if the action requires further input from the user before it can be carried out. For example,
Once a dialog is displayed, do not change its default button from one button to another. You may add or remove default status from the same button if it helps prevent user error, however. Changing the default from one button to another can be confusing and inefficent, especially for users relying on assistive technologies.
If your button can display text, an icon, or both, choose which label to display at runtime according to the user's preference in the GNOME Menus and Toolbars Preferences dialog. However, you may over-ride this preference when there is no suitable icon to describe the button's action graphically, for example.
Do not use more than one or two different widths of button in the same window, and make all of them the same height. This will help give a pleasing uniform visual appearance to your window that makes it easier to use.
Do not assign actions to double-clicking or right-clicking a button. Users are unlikely to discover these actions, and if they do, it will distort their expectations of other buttons on the desktop.
Make invalid buttons insensitive, rather than popping up an error message when the user clicks them.
In a dialog, one button may be made the default button, which is shown with a different border and is activated by pressing
If it does not make sense to have a default button until several fields in the dialog have been correctly completed—for example, both the
Check Boxes
Check boxes are used to show or change a setting. Its two states, set and unset, are shown by the presence or absence of a checkmark in the labelled box.
A typical group of check boxes
A typical group of five check boxes in a dialog
Do not initiate an action when the user clicks a check box. However, if used in an instant-apply
Clicking a check box should not affect the values of any other controls. It may sensitize, insensitize, hide or show other controls, however.
If toggling a check box affects the sensitivity of other controls, place the check box immediately above or to the left of the controls that it affects. This helps to indicate that the controls are dependent on the state of the check box.
Use
Label check boxes to clearly indicate the effects of both their checked and unchecked states, for example,
Ambiguous check box (top), radio buttons work better in this case (bottom)
Two images: one showing a single check box ambiguously labelled "Progress bar in left of statusbar", the other making the choice explicit with radio buttons labelled "Left" and "Right" under the heading "Status bar progress indicator position:"
The single check box in this example is ambiguous, as it is not clear where the "progress indicator" will go if the box is unchecked. Two radio buttons are better in this case, as they make the options clear.
Provide an access key in all check box labels that allows the user to set or unset the check box directly from the keyboard.
If the check box represents a setting in a multiple selection that is set for some objects in the selection and unset for others, show the check box in its mixed state. For example:
Check boxes (right) showing properties for a multiple selection of files in Nautilus (left)
Check boxes showing the Hidden, Readable and Writeable states of two selected files in Nautilus. Both files are hidden, neither are writeable, but one is readable. The Readable check box is therefore shown in its mixed state.
In this example, both selected files are hidden (since their filenames start with "."), and the emblems on their icons show that neither file is writeable, but one is readable. The
When a check box is in its mixed state:
clicking the box once should check the box, applying that setting (when confirmed) to all the selected objects
clicking the box a second time should uncheck the box, removing that setting (when confirmed) to all the selected objects
clicking the box a third time should return the box to its mixed state, restoring each selected object's original value for that setting (when confirmed)
Label a group of check boxes with a descriptive heading above or to the left of the group.
Use a frame around the group if necessary, but remember that blank space often works just as well and results in a less visually-cluttered dialog.
Do not place more than about eight check boxes under the same group heading. If you need more than eight, try to use blank space, heading labels or frames to divide them into smaller groups. Otherwise, consider using a check box list instead— but you probably also need to think about how to simplify your user interface.
Try to align groups of check boxes vertically rather than horizontally, as this makes them easier to scan visually. Use horizontal or rectangular alignments only if they greatly improve the layout of the window.
Radio Buttons
Radio buttons are used in groups to select from a mutually exclusive set of options. Only one radio button within a group may be set at any one time. As with check boxes, do not use radio buttons to initiate actions.
A typical group of radio buttons
A typical group of three radio buttons in a dialog
Only use radio buttons in groups of at least two, never use a single radio button on its own. To represent a single setting, use a check box or two radio buttons, one for each state.
Exactly one radio button should be set in the group at all times. The only exception is when the group is showing the properties of a multiple selection, when one or more of the buttons may be in their mixed state.
Do not initiate an action when the user clicks a radio button. However, if used in an instant-apply
Clicking a radio button should not affect the values of any other controls. It may sensitize, insensitize, hide or show other controls, however.
If toggling a radio button affects the sensitivity of other controls, place the radio button immediately to the left of the controls that it affects. This helps to indicate that the controls are dependent on the state of the radio button.
Use
If the radio button represents a setting in a multiple selection that is set for some objects in the selection and unset for others, show the radio button in its mixed state. For example:
Radio buttons (right) showing properties for a multiple selection of shapes in a drawing application (left)
Radio buttons showing the Thick, Thin and Dashed drawing styles of two selected shapes in a drawing application. One shape is drawn in the thick style, the other in the dashed style. The Thick and Dashed radio buttons are therefore shown in their mixed state, and the Thin radio button is unset.

Label a group of radio buttons with a descriptive heading above or to the left of the group.
Do not place more than about eight radio buttons under the same group heading. If you need more than eight, consider using a single-selection
Try to align groups of radio buttons vertically rather than horizontally, as this makes them easier to scan visually. Use horizontal or rectangular alignments only if they greatly improve the layout of the window.
Toggle Buttons
Toggle buttons look similar to regular
A typical group of toggle buttons
A group of four toggle buttons representing a choice of measurement units: inches, centimeters, feet and meters
Do not use groups of toggle buttons in dialogs unless space constraints force you to do so, or you need to provide consistency with a toolbar in your application.
Only use toggle buttons in groups, so they are not mistaken for regular buttons. Make the group behave like either a group of check boxes or a group of radio buttons, as required.
Provide an access key in the label of all toggle buttons that allows the user to set or unset the button directly from the keyboard.
Label a group of toggle buttons with a descriptive heading above or to the left of the group, as you would with a group of check boxes or radio buttons.
Use a frame around the group of buttons if necessary, but remember that blank space often works just as well and results in a less visually-cluttered dialog.
Try to align groups of toggle buttons horizontally rather than vertically. This is how toggle buttons normally appear on a toolbar, so the user will be more familiar with this arrangement.
Do not leave any space between toggle buttons in a group, otherwise they may look unrelated or may be mistaken for regular buttons.
Use
If your toggle button can display text, an icon, or both, choose which to display at runtime according to the user's setting in the GNOME Menus and Toolbars preference dialog.
Use the same text or graphical label for a toggle button whether it is set or unset.
If the toggle button represents a setting in a multiple selection that is set for some objects in the selection and unset for others, show the button in its mixed state. For example:
Toggle buttons (right) showing properties for a multiple selection of shapes in a drawing application (left)
Toggle buttons showing the Thick, Thin and Dashed drawing styles of two selected shapes in a drawing application. One shape is drawn in the thick style, the other in the dashed style. The Thick and Dashed toggle buttons are therefore shown in their mixed state, and the Thin toggle button is unset.
At time of writing, the exact visual appearance of mixed state toggle buttons was undecided. A mixed state toggle button should behave exactly as a mixed state check box or radio button, depending on whether the toggle button choices are independent or mutually exclusive, respectively.
Drop-down Lists
Drop-down lists are used to select from a mutually exclusive set of options. They can be useful when there is insufficient space in a window to use a group of radio buttons or a single-selection list, with which they are functionally equivalent.
A drop-down list showing current selection (left) and the list of available choices when clicked on (right)
Two images, one of a drop-down list displaying its current setting, and the other showing its popup menu of available choices when clicked on
Recommendations:
Do not use drop-down lists with fewer than three items, or more than about ten. To offer a choice of two options, use
Do not initiate an action when the user selects an item from an drop-down list. However, if used in an instant-apply
Selecting an item from a drop-down list should not affect the values of any other controls. It may sensitize, insensitize, hide or show other controls, however.
Label the drop-down list with a text label above it or to its left, using
Use
Assign an access key to every drop-down list item. Ensure each access key is unique within the enclosing window or dialog, not just within the menu.
Do not assign shortcut keys to drop-down list items by default. The user may assign their own shortcut keys in the usual way if they wish, however.
Do not use a drop-down list in a situation where it may have to show a property of a multiple selection, as drop-down lists have no concept of mixed state. Use a group of radio or toggle buttons instead, as these can show set, unset or mixed states.
Do not use submenus on a drop-down list.
You should normally use
there is little available space
the list of options may change over time
the contents of the hidden part of the menu are obvious from its label and the one selected item. For example, if you have an option menu labelled "Month:" with the item "January" selected, the user might reasonably infer that the menu contains the 12 months of the year without having to look.
Drop-down lists can also be useful on toolbars, to replace a group of several mutually-exclusive toggle buttons.
Drop-down Combination Boxes
Drop-down combination boxes combine a text entry field and a dropdown list of pre-defined values. Selecting one of the pre-defined values sets the entry field to that value.
A drop-down combination box before and after its dropdown list is displayed
Two images, one of a drop-down combination box entry field displaying its current selection, and the other showing its dropdown list of available choices when clicked on
Only use a drop-down combination box instead of a list, drop-down list or radio button group when it is important that the user be able to enter a new value that is not already amongst the list of pre-defined choices.
Do not initiate an action when the user selects an item from the list in a drop-down combination box. If used in an instant-apply
If the user types a value into the drop-down combination box that is not already in the drop-down list, add it to the list when the drop-down combination box loses focus so they can select it next time.
Interpret user input into a drop-down combination box in a case-insensitive way. For example, if the user types
Label the drop-down combination box with a text label above it or to its left, using
Use
Scrollbars
Often an object (such as a document or a list) will not be fit within the confines of its viewer control. In these cases a scrollbar can be affixed to the viewer control. The scrollbar alters which part of the object is currently visible inside the viewer control: it slides the view across the object in one axis (horizontal or vertical).
Only display scrollbars when they are required for sliding the view. If an object fits inside the viewer control, don't draw scrollbars. If you are using a GtkScrolledWindow, call
Do
Affix scrollbars to the right side of a viewer control (to slide the view vertically), or to the bottom side (to slide the view horizontally). Do
Scrollbars should be aligned in both directions with the view they are affixed to on the axis they control. In other words, horizontal scrollbars should span the full length of the viewer control, and vertical scrollbars should span the full height of the viewer control.
If both horizontal and vertical scrollbars are acting upon a view, alignment will require that small rectangle in the lower right corner where the horizontal and vertical scrollbars meet will be blank. This is OK.
Scrollbars should affect the view to which they are affixed in realtime: as the user drags or clicks the view should change. Time lag will be disconcerting and negatively impact a users ability to navigate content inside the view.
Lists
A list control allows the user to inspect, manipulate or select from a list of items. Lists may have one or more columns, and contain text, graphics, simple controls, or a combination of all three.
A simple two column list
Picture of list control containing two unsorted columns of text
Always give list controls a label, positioned above or to the left of the list, in
Make the list control large enough that it can show at least four items at a time without scrolling. For lists of ten or more items, increase this minimum size as appropriate.
If the list appears in a dialog or utility window, consider making the window and the list within it resizable so that the user can choose how many list items are visible at a time without scrolling. Each time the user opens this dialog, set its dimensions to those that the user last resized it to.
Do not use lists with less than about five items, unless the number of items may increase over time. Use
Only use column headers when:
the list has more than one column, or
the list has only one column, but the user may wish to re-order the list. (This is rarely useful with single column lists).
In most other situations, column headers take up unnecessary space, and the extra label adds visual clutter.
Always label column headers when used. If the column is too narrow for a sensible label, provide a tooltip for the column instead. Apart from its obvious use, this will help ensure that assistive technologies can describe the use of the column to visually impaired users.
Consider using a check box list for multiple-selection lists, as these make it more obvious that multiple selection is possible:
A simple check box list
Picture of list control with two columns. The first column consists of check boxes showing whether or not the corresponding item in the second column is selected for further action.
If you do this, you should normally set the list control itself to be single-selection, but this depends on the particular task for which it will be used.
For multiple selection lists, show the number of items currently selected in a static text label below the list, for example,
Consider providing
Sortable Lists
Users often prefer to sort long lists, either alphabetically or numerically, to make it easier to find items. Allow users to sort long or multi-column lists by clicking on the column header they want to sort.
Indicate which column is currently sorted by showing an upward or downward facing arrow in its header:
Sort Order
Arrow Direction
Example
Natural
Down
Alphabetical; smallest number first; earliest date first; checked items first
Reverse
Reverse alphabetical; largest number first; most recent date first; unchecked items first)
Clicking an unsorted column header sorts the column in natural order, indicated by showing a down arrow in its header.
Clicking a column header sorted in natural order re-sorts it in reverse order, indicated by showing an up arrow in its header.
Un-sorting lists
Occasionally, an unsorted state may be useful, for example to show items in the order in which the user added them to the list. In such cases, clicking a column sorted in reverse order should un-sort it, indicated by removing the arrow from the column header.
Usually, however, this is better achieved by adding an extra column that the user can sort in the usual way, such as a sequence number column in this example.
Trees
A tree control allows the user to inspect, manipulate or select from a hierarchichal list of items. Trees may have one or more columns, and contain text, graphics, simple controls, or a combination of all three.
Use trees with care!
Because of their complexity compared to other controls, novice and some intermediate users often have problems using and understanding tree controls. If your application is designed for that type of user, you might want to consider alternative ways of presenting the information, such as the Nautilus list or icon view, or the hierarchical browser lists found in
A simple tree control with one level of hierarchy
Picture of tree control showing months of the year as top level nodes, and public holidays in those months as their children
Always give tree controls a label, positioned above or to the left of the tree, in
Use column headers when:
the tree has more than one column
the tree has only one column, but the user may wish to re-order the tree. This should rarely be true of single column trees.
Consider using a check box tree for multiple-selection trees, as these make it more obvious that multiple selection is possible:
A simple check box tree
Picture of tree control with two columns. The first column consists of check boxes showing whether or not the corresponding item in the second column is selected for further action.
If you do this, you should normally set the tree control itself to be single-selection, but this depends on the particular task for which it will be used.
For multiple selection trees, show the number of items currently selected in a static text label below the tree, for example,
Consider providing
Sortable Trees
As with lists, the user may find it useful to sort long or multi-column trees. See the guidelines in
Tabbed Notebooks
A tabbed notebook control is a convenient way of presenting related information in the same window, without having to display it all at the same time. It is analagous to the divider tabs in a ring binder or a file cabinet.
A typical notebook control with three tabs
Picture of notebook control with three tabs
Do not put too many pages in the same notebook. If you cannot see all the tabs without scrolling or splitting them into multiple rows, you are probably using too many and should use a list control instead. See the
Label tabs with
Do not assign access keys to tab labels, as this means you cannot use those access keys for any other control on
Do not design a notebook such that changing controls on one page affects the controls on any other page. Users are unlikely to discover such dependencies.
If a control affects only one notebook page, place it on that notebook page. If it affects every page in the notebook, place it outside the notebook control, for example beside the window's
Use tabs that are proportional to the width of their labels. Don't just set all the tabs to the same width, as this makes them harder to scan visually, and limits the number of tabs you can fit into the notebook without scrolling. For example:
Fixed- and proportional-width tabs (preferred)
Side-by-side comparison of one notebook whose tabs are all the same width, and one whose tabs are only wide enough to accommodate the tab labels. The latter takes up around 33% less screen space.
Although the contents of each page in a notebook will take up a different amount of space, do not use larger than normal spacing around the controls in the "emptier" pages, and do not center the controls on the page.
If your tab labels include icons, choose whether or not to show the icons at runtime based on the user's preference in the GNOME Menus and Toolbars desktop preferences dialog. Always show the text part of the label, however.
If you have more than about six tabs in a notebook, use a list control instead of tabs to switch between the pages of controls. For example:
Use of list control where there would be too many tabs to fit comfortably in a notebook
Part of a window including a list control with 7 items, each item representing a category of settings such as "Appearance" and "Navigation". The controls in the rest of the window change depending on which item is selected in the list.
As in this example, place the list control on the left-hand side of the window, with the dynamic portion of the window immediately to its right.
Status Indicators
This section needs more concrete recommendations, it's currently (almost) taken verbatim from Sebastian's patch in bug #72101.
In some tabbed windows, such as preference windows, it might be desirable to indicate the status of a particular tab. This can be used to notify the user that a web page that is still loading or has been loaded, a new message is waiting in a particular instant messasing conversation, or that a document has not been saved. Such a status indicator should be an icon that is placed directly to the left of the tab label. Additionally, the tab label's color might be changed to indicate a certain status. Do not simply rely on a different coloring scheme for status indication.
Progress Bars
Progress bars are visual indicators of the progress of a task being carried out by the application, and provide important
You can use two main types of progress bars in your application— measured-progress bars and indeterminate-progress bars (the kind that bounce back and forth). In addition there are are three types of measured progress bars.
Always use a measured progress bar when the length of a task can be precisely or approximately predicted. Otherwise, use an
Ensure that a measured-progress bar measures an operation's total time or total work, not just that of a single step. An exception is a progress bar that measures the total time or work of the current step in a progress checklist.
Time-remaining Progress Indicator
An animation consisting of a bar whose changing length indicates how much time remains in an operation, and text stating how much time remains before the operation will be complete. Time-remaining bars are the most useful type of progress bar.
A simple 'time remaining' progress bar
A simple time-remaining progress dialog
Use a time-remaining bar if your application will display an initial estimate of an operation's remaining time and then periodically display updated estimates. Each updated estimate should be based on changes that have occurred and that will cause the operation to finish more quickly or more slowly. If the operation will finish more slowly, your application can display an updated estimate that is greater than the estimate previously displayed.
Typical-time Progress Indicator
A bar whose changing length indicates how much time remains if an operation takes as long as it typically does. Typical-time bars are the least precise type of measured-progress bar, but they are more useful than indeterminate-progress bars.
A simple 'typical time remaining' progress bar
A simple 'typical time remaining' progress dialog
For some operations, you cannot estimate the time remaining or the proportion of work completed. However, if you can estimate the typical time for that operation, you can provide feedback with a typical-time bar.
If your application overestimates the completed amount of work, the length of the bar can indicate "almost complete" until the operation is complete. If your application underestimates how much work is complete, the application can fill the remaining portion of the bar when the operation is complete.
Indeterminate-progress indicator
An animated bar indicating only that an operation is ongoing, not how long it will take. One example is the "throbber" in a web browser. Indeterminate-progress bars are the least precise type of progress bar.
A simple 'indeterminate time' progress bar; the slider moves from left-to-right and back again until the operation is complete
A simple 'indeterminate time' progress dialog, showing a slider moving back and forth until the operation is complete
Use an indeterminate-progress bar to provide feedback only for operations whose duration you cannot estimate at all.
Statusbars
A statusbar is an area at the bottom of a window that can be used to display brief information about the status of the application.
A simple statusbar
A statusbar at the bottom of a document window, showing current zoom level and a status message indicating that the document has been modified since it was last saved
Use statusbars only in application or document windows. Do not use them in dialogs, alerts or other secondary windows.
Only place a statusbar along the bottom of a window.
Only use statusbars to display non-critical information. This might include:
general information about the document or application. For example, current connection status in a network application, or the size of the current document in a text editor.
information about the task the user is currently performing. For example, while using the selection tool in a drawing application, "Hold Shift to extend the selection"
progress of a background operation. For example, "Sending to printer", "Printing page 10 of 20", "Printing Complete".
a description of the control or area of the window under the mouse pointer. For example, "Drop files here to upload them"
Remember that statusbars are normally in the user's peripheral vision, and can even be turned off altogether using the application's
When there is no interesting status to report, leave a status bar panel blank rather than displaying something uninformative like "Ready". This way, when something interesting does appear in the statusbar, the user is more likely to notice it.
If you want to make all or part of your statusbar interactive, use the following conventions:
Inlaid appearance for areas that respond to a double click
Flat appearance for areas that are not interactive
In
An interactive statusbar
A statusbar with a text panel that responds to a double click, a button that responds to a single click, and a non-interactive progress area
Ensure that double-clicking in the status area does not provide any functionality that is not also available in the main application menu bar, or by some other accessible means.
Provide a drag handle in the bottom right corner of the status bar of resizeable windows. Subclasses of GtkStatusbar should use the drag handle provided by that class. A reimplementation of a status bar, which is discouraged, should also reimplement the GtkStatusbar drag handle in both appearance and function.
Frames and Separators
A frame is a box with a title that you can draw around controls to organise them into functional groups. A separator is a single horizontal or vertical line that you can use to divide windows into functional groups.
Frames with a border around their perimeter have traditionally been used for denoting groups of related controls. This is advantageous because it physically seperates disimilar controls, and also avoids repitition of the frame's label in individual member control labels. Unfortunately, they add visual noise that can both make a window appear more complex than it really is, and reduce the ability to quickly scan window elements.
Rather than using bordered frames, use frames without borders, bold labels to make the categories stand out, and indented contents. This, combined with good layout and spacing, is usually a better alternative to bordered frames.
Preferred frame style, using bold labels, spacing and indentation
Frame showing the preferred style described above
Traditional frame style, using borders (deprecated)
Frame showing the traditional style described above
Before you add a frame with a visible border or separator to any window, consider carefully if you really need it. It is usually better to do without, if the groups can be separated by space alone. Do not use frames and separators to compensate for poor control layout or alignnment.
Do not mix framed and unframed groups in the same window.
Do not nest one frame inside another. This results in visual clutter.
If all the items in a group are disabled, disable the group title too.
Feedback
Characteristics of Responsive Applications
Although highly responsive applications can differ widely from one another, they share the following characteristics:
They give immediate feedback to users, even when they cannot fulfill their requests immediately.
They handle queued requests as users would expect, discarding requests that are no longer relevant and reordering requests according to users' probable priorities.
They let users do other work while long operations proceed to completion— especially operations not requested by users— such as reclaiming unused memory or other "housekeeping" operations.
They provide enough feedback for users to understand what they are doing, and organize feedback according to users' abilities to comprehend and react to it.
They let users know when processing is in progress.
They let users know or estimate how long lengthy operations will take.
They let users set the pace of work, when possible, and they let users stop requested tasks that have started but not finished.
Highly responsive applications put users in control by quickly acknowledging each user request, by providing continuous feedback about progress toward fulfilling each request, and by letting users complete tasks without unacceptable delays.
Even applications with attractive, intuitive user interfaces can lack responsiveness. Typically, unresponsive applications have at least one of the following problems:
They provide late feedback— or no feedback— for users' requests, leaving users wondering what the application has done or is doing.
When performing extended operations, they prevent users from doing other work or cancelling the extended operation.
They fail to display estimates of how long extended operations will last, forcing users to wait for unpredictable periods.
They ignore users' requests while doing unrequested "housekeeping", forcing users to wait at unpredictable times— often without feedback.
You can sometimes possible to improve an application's responsiveness without speeding up the application's code. For tips on how to make such improvements, see
Acceptable Response Times
Some user interface events require shorter response delays than others. For example, an application's response to a user's mouse click or key press needs to be much faster than its response to a request to save a file. The table below shows the maximum acceptable response delay for typical interface events.
Maximum acceptable response times for typical events
UI Event
Maximum Acceptable Response Time
Mouse click, pointer movement, window movement or resizing, keypress, button press, drawing gesture, other UI input event involving hand-eye co-ordination
0.1 second
Displaying progress indicators, completing ordinary user commands (e.g. closing a window), completing background tasks (e.g. reformatting a table)
1.0 second
Displaying a graph or anything else a typical user would expect to take time (e.g. displaying a new list of all a company's financial transactions for an accounting period)
10.0 seconds
Accepting and processing all user input to any task
Make each response delay in your application as short as possible, unless users need time to see the displayed information before it is erased. The acceptable response delay for each event is based on a typical user's sense that the event is a logical point at which to stop or pause. The greater that sense is, the more willingly the user will wait for a response. Verify that your application responds to users' requests within the limits listed in the table above. If your application cannot respond within those limits, it probably has one or more general problems caused by a particular algorithm or module.
Verify that your application provides feedback within 100 milliseconds (0.1 second) after each key press, movement of the mouse, or other physical input from the user.
Verify that your application provides feedback within 100 milliseconds (0.1 second) after each change in the state of controls that react to input from the user— for example, displaying menus or indicating drop targets.
Verify that your application takes no longer than 1 second to display each progress indicator, complete each ordinary user command, or complete each background task.
Verify that your application takes no longer than 10 seconds to accept and process all user input to any task—including user input to each step of a multistep task, such as a wizard.
Responding to User Requests
If your application takes too long to respond, users will become frustrated. Use these techniques to improve the responsiveness of your application.
Display feedback as soon as possible.
If you cannot display all the information that a user has requested, display the most important information first.
Save time by displaying approximate results while calculating finished results.
If users are likely to repeat a time-consuming command in rapid succession, save time by faking the command's effects instead of repeatedly processing the command. For example, if a user adds several rows to a table stored in a database, you might display each new row immediately but delay actually creating each new row in the database until the user finished adding all the rows.
Work ahead. Prepare to perform the command that is most likely to follow the current command. That is, use idle time to anticipate users' probable next requests. For example, as the user of an email application reads the currently displayed new message, the application might prepare to display the next new message.
Use background processing. Perform less important tasks —such as housekeeping— in the background, enabling users to continue working.
Delay work that is not urgent. Perform it later, when more time is available.
Discard unnecessary operations. For example, to move back several pages in a web browser, a user might click the browser's
Use dynamic time management. At run time, change how your application prioritizes user input and other processing, based on the application's current state. For example, if a user is typing text in one word-processing document while printing another, the word-processing application might delay the printing task if the user shifts to an editing task (such as cutting and pasting text) that requires greater resources.
In your application, display an estimate of how long each lengthy operation will take.
If a command might take longer than 5 seconds to complete its work on an object, allow users to interact with any parts of the object and parts of the application that are not directly affected by the command.
If a command provides lengthy output, show partial results as they become available. Scroll the results (if necessary) until the user moves input focus to a component (e.g. a scrollbar or text area) involved in the scrolling.
Types of Visual Feedback
You can use two types of visual feedback for operations in your application— pointer feedback and progress animations.
Pointer Feedback
Pointer feedback changes the shape of the pointer. For example, a busy pointer indicates that an operation is in progress and that the user cannot do other tasks. A busy-interactive pointer indicates that an operation is in progress but the window is still interactive.
Busy pointer (left) and Busy-Interactive pointer (right)
Busy pointer (left) and busy-interactive pointer (right)
Progress Animations
Progress animations show either how much of an operation is complete, or only that an operation is ongoing. Normally, these take the form of either a progress bar or a progress checklist.
When displaying a progress animation, open it as soon as possible after you know it is required, and close it automatically as soon as the associated operation is complete.
Use a measured-progress bar if your application can estimate either how long the operation will take, or what proportion of the operation is complete.
If your application can make neither estimate, and the operation only has one step, use an
For information on different types of progress bars and when to use them see
Progress Windows vs. the Statusbar
In an application where the
Opening a new window, particularly when an operation is short, can needlessly disrupt the user's workflow.
Progress windows can convey more information.
Multiple progress windows can be open at once, whereas only a single operation can be presented in a statusbar.
Progress windows provide a
A Checklist Window
A checklist window showing a sequence of steps
A checklist window shows the sequence of stages in an operation. See
Choosing Appropriate Feedback
To determine which type of visual feedback to provide for a particular operation, consider these factors:
Whether your application can provide an estimate of the operation's progress.
Whether the operation blocks the user from issuing further commands in your application.
Whether your application has a dedicated space, such as a status bar, for indicating the status of operations.
The table below shows which type of feedback to provide for operations that usually take at least 1 second to finish. In the "Appropriate Feedback" column, "Internal progress animations" means progress animations displayed in an application's dedicated status area, and "External progress animations" means progress animations displayed somewhere other than in a dedicated status area— typically, in an alert box.
Visual feedback types for operations that take at least 1 second
Typical Duration &gt; 5 seconds?
User blocked from issuing further commands?
Application has dedicated status area?
Appropriate feedback
Internal animation plus pointer feedback
Pointer feedback
Internal animation
External animation plus pointer feedback
External animation
Use a busy pointer whenever users are blocked from interaction with your application for 1 second or longer. Display the busy pointer less than 1 second after the operation begins.
If a command will likely take 10 seconds or longer to finish, provide a
When using an external animation, leave the window containing the animation on-screen for at least 1 second after the operation has completed, with a successful completion message. Change the
Allowing Interruptions
Users sometimes need to stop a command— for example, because it is taking too long. Your application should let users stop commands in progress, even if stopping a command cannot undo or "roll back" all the command's effects.
Place a
Label the button
Label the button
Alternatively, you can place the
There is no progress animation for the command, or
The progress animation is in a window's status area or in another location that lacks space for a
In the alert box that appears after pressing a
[Continue Deleting]
[Stop Deleting]
Continue deleting files?
rather than
[Yes]
[No]
Operation interrupted, continue?
since in the latter example, it is not clear whether pressing
Visual Design
Visual design is not just about making your application look pretty. Good visual design is about communication. A well-designed application will make it easy for the user to understand the information that is being presented, and show them clearly how they can interact with that information. If you can achieve all that, your application
Color
Color is a good tool for communicating information in a user interface. For example, it can be used to:
strengthen a desktop's look and feel by enhancing a theme
accent a dynamic alert in a system management application
emphasize an element in a long list to expedite scanning
add aesthetically pleasing details to an icon
However, color should always be regarded as a useful addition to your design, not as a necessity. Never depend upon colors alone to display important information, and keep in mind that if colors cannot be perceived correctly (for example, the user has an 8-bit system, or is color-blind), your application should still be usable.
Palette
A 32-color palette has been developed for the GNOME desktop. The palette may be downloaded from
The basic GNOME 32-color palette
RGB and hexadecimal values for the basic palette
RGB
Hex
Basic 3D Hilight
234 232 227
#EAE8E3
Basic 3D Medium
186 181 171
#BAB5AB
Basic 3D Dark
128 125 116
#807D74
3D Shadow
86 82 72
#565248
Green Hilight
197 210 200
#C5D2C8
Green Medium
131 166 127
#83A67F
Green Dark
93 117 85
#5D7555
Green Shadow
68 86 50
#445632
Red Hilight
224 182 175
#E0B6AF
Red Medium
193 102 90
#C1665A
Red Dark
136 70 49
#884631
Red Shadow
102 56 34
#663822
Purple Hilight
173 167 200
#ADA7C8
Purple Medium
136 127 163
#887FA3
Purple Dark
98 91 129
#625B81
Purple Shadow
73 64 102
#494066
Blue Hilight
157 184 210
#9DB8D2
Blue Medium
117 144 174
#7590AE
Blue Dark
75 105 131
#4B6983
Blue Shadow
49 78 108
#314E6C
Face Skin Hilight
239 224 205
#EFE0CD
Face Skin Medium
224 195 158
#E0C39E
Face Skin Dark
179 145 105
#B39169
Face Skin Shadow
130 102 71
#826647
Accent Red
223 66 30
#DF421E
Accent Red Dark
153 0 0
#990000
Accent Yellow
238 214 128
#EED680
Accent Yellow Dark
209 148 12
#D1940C
Accent Green
70 160 70
#46A046
Accent Green Dark
38 199 38
#267726
White
255 255 255
#ffffff
Black
0 0 0
#000000
Hue, Brightness, Contrast
Users with vision disorders, such as color-blindness or low vision, require alternatives to default settings. A good user interface anticipates these needs by providing customizable preferences and support for accessible themes. Even better is an application that is already configured with carefully-chosen color and contrast defaults.
An estimated 11% of the world population has some sort of color-blindness. Those affected typically have trouble distinguishing between certain hues such as red and green (deuteranopia or protanopia), or blue and yellow (tritanopia). Therefore it is necessary to allow the user to customize colors in any part of your application that conveys important information. This means that your application must effectively convey information using just the colors from any theme that the user chooses.
A useful tool for reviewing information about color-blindness and checking legibility of images for color-blind users is
How the earth looks to a user with normal color vision (left), deuteranopia (middle), and tritanopia (right). (Images from
Photo of earth as a normally-sighted user would see it
Photo of earth as a user with red-green color-blindness would see it
Photo of earth as a user with blue-yellow color-blindness would see it
Other users have more problems with contrast levels rather than hue on their screen. Some users require a high level of contrast between background and foreground colors, such as black on white, white on black, or some other high-contrast combination. Others can experience discomfort unless they use low-contrast settings, such as gray text on a lighter gray background.
You can meet these needs by ensuring your application supports the accessible GNOME themes (found in the gnome-themes module in cvs), which include high and low contrast themes, and large print themes. This means you must supply default and large sizes of high-, low- and regular-contrast icon sets with your application.
Use the GNOME color palette. If you need a darker or lighter shade, start from one of the colors from the palette and darken or lighten as needed.
Do not use color as the only means to distinguish items of information. All such information should be provided by at least one other method, such as shape, position or textual description.
Ensure your application is not dependent on a particular theme. Test it with different themes, especially high and low contrast accessibility themes, which use fewer colors, to ensure your application respects the settings. For example, all text should appear in the foreground color against the background color specified in the chosen theme.
Select colors carefully. When they need to be recognizably different, select the light colors from orange, yellow, green or blue-green, and darker colors from blue, violet, purple or red, as most people affected by color-blindness already see blue, violet, purple and red as darker than normal.
Window Layout
General
Placement of visual components in an application is important because relationships between elements are indicated by their positions. This is called "layout" in interface design.
A clean layout is crucial to creating a smooth visual flow of information for the user. This section describes the proper component placement and spacing to use in GNOME applications. The major components discussed will be labels, icons, radio buttons and check boxes, text fields, command buttons, and drop-down menus.
When a user is scanning a complex preferences dialog consisting of many labels and corresponding check boxes, text fields, and drop-down combination boxes, it is easy to see how she can quickly become hindered by poor layout in the visual design. For information on laying out Alerts, see
Improved window layout
Initial layout with poor alignment and limited use of white space
Improved layout with fewer alignment points, frames removed to relieve clutter, and clearer grouping with use of white space
In
As the labels are all similar in length, they should be left-aligned. Now the user has a firm left margin to anchor the eye and scan the list of items vertically more easily. If most of the labels in a group greatly differ in length, right-align them instead, so that the controls do not end up too far away from their corresponding labels.
Using frames with visible borders to separate groups within a window is deprecated. Use spacing and bold headers instead. This is more effective because there are fewer gratuitous lines to distract the user from the main content in the window. See
Try to keep components consonant with each other in terms of size and alignment. This is particularly important within a group of controls, so that the user's ability to quickly scan information is not sacrificed. Minimize as much as possible the need for the user's eye to jump around when scanning a layout.
Layout specifications
Leave a 12-pixel border between the edge of the window and the nearest controls.
Leave a 12-pixel horizontal gap between a control and its label. (The gap may be bigger for other controls in the same group, due to differences in the lengths of the labels.)
Labels must be concise and make sense when taken out of context. Otherwise, users relying on screenreaders or similar assistive technologies will not always be able to immediately understand the relationship between a control and those surrounding it.
Assign access keys to all editable controls. Ensure that using the access key focuses its associated control.
Spacing and Alignment
Provide adequate space between controls and groups of controls. This white space will make it easier for the user to find the information they need.
As a basic rule of thumb, leave space between user interface components in increments of 6 pixels, going up as the relationship between related elements becomes more distant. For example, between icon labels and associated graphics within an icon, 6 pixels are adequate. Between labels and associated components, leave 12 horizontal pixels. For vertical spacing between groups of components, 18 pixels is adequate. A general padding of 12 pixels is recommended between the contents of a dialog window and the window borders.
Break long lists of choices into smaller groups. For lists of less than about eight items, use radio buttons or check boxes. For longer lists, use a list control or drop-down list.
Try to keep elements of the same type left-aligned with each other. For instance, in
Indent group members 12 pixels to denote hierarchy and association.
Minimize the number of alignment points in your window. An alignment point is an imaginary vertical or horizontal line through your window that touches the edge of one or more labels or controls in the window.
Right-justification within groups or the overall window (as indicated by the line labelled "justification" in
Lay out components left-to-right, top-to-bottom. Generally, the first element the user is meant to encounter should be in the top-left, and the last in the bottom right. Keep in mind that when localized for non-western locales, interfaces may be reversed so that they read from right to left.
Using "white" or blank spacing and indentation to delineate groups is cleaner and preferable to using graphical separators such as frames.
Align controls in your layout
Be consistent. Use the same spacing, alignment, and component sizes in all dialogs appearing in your application. The
Ensure that light and dark areas as well as spacing are equally distributed around the window. Keep in mind that every control or group of controls in your window has a visual "weight," depending on its overall size, color, and how much white space it includes. Darker, larger areas are "heavier," while paler, smaller areas are "lighter."
Do not design windows that are more than 50% longer in one dimension than in the other. People are more comfortable looking at windows and dialogs whose dimensions stay within the golden ratio (about 1.6 to 1), a ratio that artists and architects have used to create aesthetically-pleasing paintings and buildings for thousands of years.
Text Labels
To a user with normal vision, textual output provides the majority of the information and feedback in most applications. To a visually-impaired user who may not be able to see or understand any additional graphical output, clear textual output is critical. You must therefore choose and position text carefully on the screen, and leave the choice of fonts and sizes to the user, to ensure that all users are able to use your application effectively.
Use spacing and alignment of text uniformly throughout your application. A basic rule of thumb is to put space between user interface components in increments of 6 pixels, going up as the relationship between related elements becomes more distant.
Alignment and spacing for different Text elements
Element
Placement
Large Icons (file browser)
Horizontally centered with and (6 pixels, if specification necessary)below large icon
Large icon with text label centered below
Small icons (toolbar)
Vertically centered with and (6 pixels, if specification necessary) to the right of small icons
Small icon with text label to the right
List control label
6 pixels above and horizontally left aligned with list control or 12 pixels to the left of and horizontally top aligned with list control
List control with text label horizontally aligned above
Radio button and check box labels
6 pixels to the right of and vertically center aligned with radio button
Radio button with text label to its right
Text field labels
6 pixels to the left of and vertically center aligned with textfield control
Textbox with text label to its left
Button labels
12 pixels of padding to either side of centered text (and any accompanying graphic). If appearing in a group of buttons, longest button label sets button size, center all other button labels and accompanying graphics in same-sized buttons
Buttons with centered text
Other component labels (e.g., spin boxes, text fields
12 pixels between the longest text label and its associated component, all other text labels in component grouping left aligned with the longest label. All labels vertically center aligned with associated components
Drop-down list with label to its left
If the label precedes the control it is labelling, end the label with a colon. For example,
Ensure that a label with a mnemonic is associated with the control it labels.
Left-align components and labels, unless all the labels in a group have very different lengths. If they do, right-align the labels instead, to ensure that no controls end up too far away from their corresponding labels.
Choose label names carefully. Label objects with names that make sense when taken out of context. Users relying on screenreaders or similar assistive technologies will not always be able to immediately understand the relationship between a control and those surrounding it.
Be consistent with label usage and semantics. For example, if you use the same label in different windows, it will help if it means the same thing in both windows. Equally, don't use labels that are spelled differently but sound the same, e.g., "Read" and "Red", as this could be confusing for users relying on screenreaders.
Don't use the same label more than once in the same window. This makes life difficult for users relying on tools like magnifiers or screen readers, which cannot always convey surrounding context to the user.
Do not hard-code font styles and sizes. The user should be able to adjust all sizes and typefaces.
Do not use more than two or three different fonts and sizes in your application, and choose visually distinct rather than similar-looking fonts in one window. Too many font sizes and styles will make the interface look cluttered and unprofessional, and be harder to read. In general, always use fonts from the current theme, and specify relative rather than absolute sizes.
Do not use graphical backdrops or "watermarks" behind text, other than those specified by the user's chosen theme. These interfere with the contrast between the text and its background. This can cause difficulty for users with visual impairments, who will therefore normally choose themes that always use plain backdrops.
Capitalization
Header capitalization
Articles:
Conjunctions:
Prepositions of three or fewer letters:
Capitalize all words in the element, with the following exceptions:
Sentence capitalization
Capitalize the first letter of the first word, and any other words normally capitalized in sentences, such as application names.
Two styles of capitalization are used in GNOME user interface elements:
The following table indicates the capitalization style to use for each type of user interface element.
Capitalization Style Guidelines for User Interface Elements
Style
Check box labels
Sentence
Command button labels
Header
Column heading labels
Desktop background object labels
Dialog messages
Drop-down combination box labels
Drop-down list box labels
Field labels
Filenames
Graphic equivalent text: for example, Alt text on web pages
Group box or frame labels
Items in drop-down combination boxes, drop-down list boxes, and list boxes
List box labels
Menu items
Menu items in applications
Menu titles in applications
Radio button labels
Slider labels
Spin box labels
Tabbed section titles
Text box labels
Titlebar labels
Toolbar button labels
Tooltips
Webpage titles and navigational elements
Capitalization guidelines for other languages
Languages other than English may have different rules about capitalization. For example, Swedish has no concept of Header capitalization. Contact the
Fonts
Only use the fonts that the user has specified in their theme, and in sizes relative to the default size specified in their theme. This will ensure maximum legibility and accessibility for all users.
Do not mix more than two or three font sizes and styles (underlined, bold, italicized) in one window, as this will look unprofessional and distract the user from the information being conveyed.
Provide alternatives to WYSIWYG where applicable. Some users may need to print text in a small font but edit in a larger screen font, for example. Possible alternatives include displaying all text in the same font and size (both of which are chosen by the user); a "wrap-to-window" option that allows you to read all the text in a window without scrolling horizontally; a single column view that shows the window's contents in a single column even if they will be printed in multiple columns; and a text-only view, where graphics are shown as placeholders or text descriptions.
Icons are a graphical metaphor presenting a visual image that the user associates with a particular object, state or operation. When a user sees a good icon they are immediately reminded of the item it represents, whether that be an application in the panel menu or the "right aligned" state in a word processor toolbar.
Icons can assist the user in rapidly scanning a large number of objects to select the desired item. Particularly after a user is acustomed to an icon's appearance, they can identify it more rapidly than a text label.
Icons can augment text by providing visual suggestions to accompany the descriptive text. Some things are easier to communicate with a picture, even a very small one.
Icons can compactly represent a large number of objects when there is insufficient space to display textual descriptions (such as in a toolbar).
GNOME uses a soft, three-dimensional look. This style is achieved by using antialiasing, shading and highlighting techniques. The
Components of an icon style can be broken down into several categories such as perspective, dimentionality, lighting effects and palette. These components play an important part in giving a group of icons a collectively distinctive look. For instance, the Java Look and Feel is recognizable by its use of a primary eight-color palette, interior highlighting and diagonal gradients. The Macintosh Aqua style is recognizable by its use of a cool palette based on blue, lighting effects mimicking reflectivity and antialiasing. The GNOME style exhibits a subdued thirty-two color palette, soft drop shadows and a mix between cartoonish and photorealistic graphics.
A globe in different icon styles
Java Metal
MacOS/X Aqua
GNOME
Java globe
Aqua globe
GNOME globe
Perspective
FIXME: need to flesh out a little
Table perspective
Presents objects as if they were sitting on a table or desk in front of the user.
Illustration of the table perspective
illustration of the table perspective
Shelf perspective
Presents objects as if they were propped up on a shelf at eye level. Make it look like a police line-up.
Illustration of the shelf perspective
illustration of the shelf perspective
Lighting
Upper left
Design as if there is lighting coming from the upper left corner, with a soft drop-shadow cast within the icon's 48x48 (original design size) borders (120 degrees, 4 pixel distance, 4 pixel blur).
Overhead
Design as if there is a light source placed above the "camera", casting a shadow down.
FIXME: need to flesh out a little?
Icons should use colors based on the basic thirty-two color palette, darkening or lightening the colours to achieve the desired look. See
Kinds of Icons
Specifications for different kinds of icons used within GNOME
Icon Type
Sizes (pixels)
Light Source
Examples
Object / Document Icons
24x24, 48x48*, 96x96
Table
Upper Left
variety of object icons
Application Icons
24x24, 48x48*
variety of application icons
Toolbar Icons
24x24*, 48x48
Shelf
variety of toolbar icons
Menu Icons
16x16
variety of menu icons
(* denotes the primary size for this kind of icon)
Document Icons
If possible, document icons should convey the type of the file using a physical object. For example a good icon for MPEG video would be a movie reel. Failing the existence of an appropriate object, when a document type corresponds to a specific application, another option is to use a piece of paper with the corresponding application's icon overlayed it as the document icon. This may be appropriate for a document type such as an application's settings files.
Do
Do
Do
Application's that handle documents should reflect the kind of document they handle in the icon. If an application's predominant purpose is to edit a particular kind of document, it should use this document's icon as its icon.
The idea of a toolbar as a shelf filled with tools should be reflected in toolbar icons. Toolbar icons should have the perspective of being viewed head on, as if they were actually sitting on a shelf at eye-level. Some design guides refer to this perspective as "flush".
Ensure that toolbar icons which will be used together are easy to visually distinguish. Try to
While most user's will view toolbar icons at 24x24 pixels, it is important to include a "large print" set of icons at 48x48 pixels for accesibility reasons.
Often, you will not have to design any toolbar icons yourself as GTK provides a wide variety of stock icons. You should use these whenever representing one of their intended items. This establishes consistent language across applications, and makes it easier for users to search for items on the toolbar. Do not use stock toolbar icons for anything other than their intended purpose, however, as this will make your application inconsistent with others, and could easily confuse your users.
To browse the available stock icons, install the development packages for GTK version 2.x and run
Principles of toolbar icon design should be followed with menu icons, just at a smaller size. Where a corresponding toolbar icon exists, a menu icon should mirror its design.
Designing Effective Icons
Rule of Thumb for Icon Metaphors
"If you have to think about an icon to 'get it', the metaphor is too complex"
Design Functionally Suggestive Icons
Icons should be suggestive of the functionality with which they are associated. The best icon will suggest to the user the primary purpose of the program or operation without having to read accompanying text. Users recognize functionally suggestive icons more rapidly than other forms because they directly associate with a physical object or action.
A functionally suggestive icon for a word processor
A document with a pencil writing on it
A functionally suggestive icon for underline
An underlined character
Make Icon Silhouettes Distinct
It is important to make it easy to visually distinguish icons that will be used together, for example toolbar icons and document icons. The human visual system is excellent at making rapid distinctions between items based on shape, thus a good way to help your users sort through a large number of icons is to use different shapes. You can see the shape of an icon most clearly by turning it into a silhouette: blacken all areas of the icon which are not transparent.
Distinct silhouettes from the GNOME icon theme
Silhouettes of various toolbar icons
Suggested Design Process For Toolbar and Menu Icons
For accessibility reasons, you should create high and low contrast and large print versions of all icons, in addition to the regular size and contrast icon. A suggested process for conveniently integrating this into your icon design is as follows:
Draw the basic outline as close to 48x48 pixels as possible:
Fill in with black and white to create detail. Do not add gratuities such as drop shadows or anti-aliasing:
Use the finished image as the large print high contrast icon:
GNOME will automatically scale it down to create the 24x24 high contrast icon:
Or you may hand-create a 24x24 version, which will be superior in contrast and sharpness:
Add color and anti-aliasing to the large print high contrast icon:
Add gradients for a smooth, realistic effect:
Add a drop shadow (120 degree global angle, 4 pixel distance, 4 pixel blur, 40% opacity), and use the finished image as the large print regular contrast icon:
Now you should hand-create create a version of this icon at 24x24. Do
Create a layer with the large print regular contrast icon's same outline and size then overlay that on the color icon. Give the overlay layer 40% opacity, and use the finished image as the large print low contrast icon:
GNOME will automatically scale it down to create the 24x24 low contrast icon:
Problems to Avoid
Avoid name suggestive icons
Some icons, such as the original Nautilus file manager icon, do not suggest the program's purpose, but instead suggest the program's name. This is less desirable than a functionally suggestive icon, because an extra layer of abstraction is added (rather than associating file management with an icon representing files, they have to associate file management with nautilus with an image of a nautilus shell). Additionally it makes it difficult for new users who may not know what "Nautilus" is, and hence will not recognize a shell icon as the file manager.
The original, name suggestive icon for Nautilus
A picture of a nautilus shell
Do
Icons that contain the text of the program name in the icon. They effectively contain no metaphor or picture for the user to identify with, and are probably harder to read than the accompanying caption. Since icons draw the eyes, an icon that is harder to identify than text is potentially worse than no icon at all. Hence "text icons" should not be used. Moreover, text should be avoided in icons because it makes the icons difficult to translate. If there is text in icons it should not form words in your native language, a good metric for ensuring that the particular text is not lending to the meaning of the icon.
Text in the original GEdit icon
The original GEdit icon, a rectangle containing the word "GEdit".
Do
Random icons appear to have no association with the application (except perhaps some odd connection in the mind of the developer). These icons should
The SodiPodi project logo is a squirrel, which is used as the application icon. However, because the logo has no obvious connection
A seemingly random icon for SodiPodi
A squirrel
Do
Remember that icons will often be viewed in a smaller form. Too much information may render the icon unintelligible when it is shrunk in size (e.g. to be placed on a panel, or in the tasklist). Too much information also makes it easier for users confuse the purpose of the application. For example, in user testing many users thought an older version of the Evolution icon (below) would launch a word processor. They were misled by the pencil and the paper, which could be seen as extraneous information: it is implicit that the mail program will allow you to write messages as well as receive them. A better icon might have been a simple envelope. Foremost in the icon designer's mind should be a consideration of the minimal visual elements necessary to express the purpose of the program.
Extraneous information - the Evolution icon
The Evolution icon
This Gnumeric icon (below) is a great icon except for the introduction of extra visual noise. The extra sheet of paper with the 'g' on it behind the spreadsheet and chart adds no significant value to the icon and provides extra visual distraction. In this case the contribution of the extraneous element to the appearance of the icon is negative. Simple, well-balanced icons look more attractive than cluttered icons. An improved icon might contain only the spreadsheet and chart; larger because they can use all of the space in the icon, and hence more visually distinct.
Extraneous information - the old Gnumeric icon
The Gnumeric icon
Do
Because GNOME aims to be an international desktop, it needs to avoid imagery that is potentially offensive or crass to other cultures. A prime source of offensive imagery is various body parts in a number of different configurations. Aside from offensive gestures with the hands, arms or fingers; body parts that are considered "clean" in one culture (such as eyes), will be considered tasteless or gross to another (such as a nose). Based on a survey of icons in GNOME, body parts frequently appear in the least communicative icons (often "pointing" at some element in the icon); they are being used as an ineffective crutch for poor metaphor. In these situations body parts should
Using body parts - the font selector icon
The original Font Selector Icon
A better icon for the Font Selector
A simple replacement icon showing an ornate "Aa"
Do
This should be avoided for a couple reasons, the most obvious of which is that puns do not translate well. For example, representing the "system log monitor" as a log will likely be uncommunicative in languages other than English. Additionally, most users do not comprehend the word play until it is too late for the icon to assist them. Even after being familiar with the "system log monitor" being represented as a log, users do not form the association fast enough for the icon to assist through in scanning through menu entries. A popular instance of this problem was the proliferation of icons representing the "World Wide Web" as a spider web in the mid 1990s. Part of the value of icons is that they bypass linguistic comprehension and hence are complementary to captions, allowing users to utilize more areas of the mind than linguistic recognition (already used in scanning for captions) when they hunt for items.
Word play - System Log Monitor icon
A tree log
Do
Just as words like "kill" and "slay" are inappropriate in interfaces, violent or destructive icons should be avoided. The "shut down" icon uses the image of an explosive detonation switch, presumably trying to convey the idea of ending something abruptly. However, this icon is likely to intimidate some users of the computer who will not want to click on the icon for fear of breaking something.
Destructive-looking Shutdown icon
An explosive detonation button
Designing Accessible Icons
The GNOME desktop includes accessible themes that make the desktop and the applications running on it accessible to users with a range of visual impairments. By default, these are:
a high contrast theme
an inverse high contrast theme
a large print theme
The following accessible themes are also available:
a high contrast large print theme
an inverse high contrast large print theme
a low contrast theme
a low contrast,large print theme
To be considered fully accessible, all icons in your application must be replaced by a suitable alternative when one of these themes is used.
Low Contrast Icons
Low contrast icon themes were deprecated in GNOME 2.22. It is no longer necessary to deliver low contrast icon equivalents.
High Contrast Icons
High contrast icons are greatly simplified versions of an application's existing regular icons. They are drawn with two colors, black and white, and thicker borders. This style allows high contrast icons to be distinguishable when viewed by a user with a visual impairment. Below is an approximation of what well-designed high contrast icons look like when viewed by someone with a visual impairment.
Simulation of low vision user viewing high contrast icons
High Contrast Icon
Simulated Appearance
Book
Book icon
Blurred Book icon
CD-ROM
CD-ROM icon
Blurred CD-ROM icon
Copy
Copy icon
Blurred Copy icon
If a regular icon uses a simple, straightforward metaphor the corresponding high contrast icon can often use the same metaphor. In many cases the same metaphor will need to be drawn differently to create a simplified high contrast icon.
Simplified representation of metaphors for high contrast icons
Comparison of photorealistic style of regular icons with the simpler, line-art style of high contrast icons
High contrast icons are created in a vector drawing program. Black and white shapes are layered to create a simplified icon. The process feels like layering black and white pieces of construction paper, as if you were assembling a collage.
Layered technique for high contrast icons
Exploded view of layers used in high contrast floppy disk icon
Reuse existing shapes
Often shapes from existing high contrast icons can be resized and reused to more quickly build up a new icon.
Don't forget the border!
It is useful to design high contrast icons over a temporary background color so you don't forget to draw the external white border.
The goal of low contrast themes is to eliminate, as much as possible, light values (e.g. a large 'V' value in HSV). To achieve this, the colors in low contrast icons are compressed toward the middle value range, i.e. dark colors are lightened and light colors are darkened.
Low contrast icons are generated from the existing regular icons by adjusting the levels in GIMP. The Input Levels are set to 100, 1.25, 200 and the Output Levels are set to 100, 160, as shown in the Levels dialog below. Large numbers of regular icons can be quickly converted to low contrast by using GIMP's scripting facilities.
Levels dialog in GIMP showing correct levels for generating low contrast icons
Levels dialog in GIMP showing input levels set to 100, 1.25, 200, and output levels set to 100 and 160.
User Input
Mouse Interaction
A plethora of pointing devices: mouse, trackball, foot-operated mouse, joystick, trackpad, and a finger-mounted pointing device.
Pictures of different types of pointing device, including mouse, trackball, foot-operated mouse and joystick.
For most users, the mouse provides the main way of interacting with graphical user interfaces. The term "mouse" is used in this chapter to include other pointing devices that can be used to move the pointer around the screen, such as trackballs, trackpads, spaceballs, graphics tablets, or assistive technology devices that emulate a mouse.
For right-handed users, the left button on a conventional mouse is used for the majority of mouse actions. We therefore call it the
Similarly for right-handed users, the right button on a conventional mouse is used for operations involving pop-up menus. We therefore call it the
A conventional mouse with three buttons normally has its third button (or a scrollwheel that acts as a button when pushed) between the left and right buttons. We therefore call it the
Your application uses left button gestures for selecting, activating components, dragging, and the display of drop-down menus.
Your application uses right button gestures to display and select actions from a popup menu.
Your application uses the middle button to paste the current PRIMARY (usually the last-highlighted) selection at the pointer position, as follows:
Effect of modifier keys on a
Modifier
Function
Unmodified
Copy selection
Move selection
Create link, shortcut or alias to selection
Do not over-ride this functionality in any part of your user interface where the transfer action is likely to be useful. If you do intend to use the middle button for a different purpose somewhere, only do so as a shortcut for experienced users, and only for operations that can also be performed without using the
If present on the mouse, the scrollwheel should scroll the window or control under the pointer, if it supports scrolling. Initiating scrolling in this way should not move keyboard focus to the window or control being scrolled.

Do not depend on input from the middle or right mouse buttons. As well as being physically more difficult to click, some pointing devices and many assistive technology devices only support or emulate the left mouse button. Some assistive technologies may noteven emulate the mouse at all, but generate keyboard events instead.
Ensure that every operation in your application that can be done with the mouse can also be done with the keyboard. The only exceptions to this are actions where fine motor control is an essential part of the task. For example, controlling movement in some types of action games, or freehand painting in an image-editing application.
Do not warp the mouse pointer, or restrict mouse movement to part of the screen. This can interfere with assistive technologies, and is usually confusing even for users who do not rely on assistive technologies.
Do not require the use of chording (pressing multiple mouse buttons simultaneously) for any operations.
Do not require the use of multiple (triple- or quadruple-) clicking actions for any operations, unless you also provide an accessible alternative method of performing the same action.
Allow all mouse operations to be cancelled before their completion. Pressing the Esc key should cancel any mouse operation in progress, such as dragging and dropping a file in a file manager, or drawing a shape in a drawing application.
Do not assign any actions exclusively to the middle button of a three-button mouse, as not all mice have one.
Do not hard-code mouse target sizes, or make them too small. Define any mouse targets to be at least as large as the arrow button in a GtkSpinBox in the current gtk theme. Bear in mind that a user with impaired dexterity or vision may be using a theme that results in considerably larger widgets than the default theme.
Do not refer to particular mouse buttons in your interface unless absolutely necessary. Not everybody will be using a conventional mouse with left, middle and right buttons, so any text or diagrams that refer to those may be confusing.
Selecting Objects
Mouse and keyboard equivalents
For controls or windows that contain a number of objects that the user can select, either singly or multiply, ensure the following mechanisms are in place to allow selections to be made using either the mouse or the keyboard.
Standard mouse and keyboard selection mechanisms
Mouse
Keyboard
Select item, deselect all others
Click
Space
Add/remove item from selection


Extend selection


Move focus
Click appropriate item to select it

Cursor keys,
Select All
Click first item, then
Deselect All
Click container background
Activate selection
Double-click to activate a single selection.

Invert Selection
No mouse equivalent
Bounding Box Selection
For a container whose objects may be arranged in two dimensions, for example the icon view in a file manager, allow multiple selection by dragging a bounding box (sometimes called a "rubber band") around one or more objects.

Within the bounds of the container's background, and
outside the bounds of any another object in the same container that can be dragged.
In a drawing application, for example, this means that a bounding box click and drag could start on a blank area of the canvas, or within a shape that had been locked down to prevent accidental editing, but not in an active shape which would itself be dragged instead.
Select any objects that lie wholly or partly within the bounding box when the mouse button is released.
Use dynamic highlighting during the drag to show which objects will be selected. Do not wait until the mouse button is released. This avoids any uncertainty about which objects will be selected by the bounding box.
When a bounding box is being dragged out within a scrollable window, support automatic scrolling of that window when the box is dragged near the window's edges.
Examples illustrating dynamic selection highlighting during bounding box selection. In the first example, the folder color and label highlighting changes to indicate selection. In the second, selection is indicated by the addition of resizing handles to selected objects.
Example illustrating dynamic selection highlighting during bounding box selection
Drag and Drop
Drag and drop is a direct manipulation technique, where you perform actions on selected objects by moving them around the screen with the mouse. You "drag" an object by clicking it, then holding the button while you move the pointer to the object's target location. The object is "dropped" at that location by releasing the mouse button.
Use drag and drop only where the user can reasonably guess what the effect might be. The most common uses are:
to move or copy objects from one place to another
to link one object to another
to perform an action on the objects by dropping them onto an icon representing that action, such as a trash can or printer icon.
Provide visual feedback throughout a drag and drop operation. Highlight valid targets and change the mouse pointer as it passes over them. Use the "no drop" mouse pointer when passing over invalid drop targets. See also
Augment the mouse pointer with a representation of the objects being dragged. Keep this representation small or make it translucent, so as not to obscure possible drop targets underneath it. See also
Example of copy pointer augmented by an icon representing the file being copied
Copy pointer superimposed on icon representing a file being copied, to form a "copy file" pointer
The pointer shapes shown here aren't actually the current GTK defaults, they're the current KDE (and Windows) defaults. Should we try and persuade GTK to change?
Only allow objects to be copied between applications, not moved. This avoids any confusion about which application's
Allow the user to cancel a drag and drop operation by all of these methods:
pressing
dropping the object back on its original location
performing a
dropping the object on an invalid drop target.
Allow the user to undo the effects a drag and drop operation by selecting
Allow multiple objects to be dragged by
Ensure that keyboard users can replicate all drag and drop actions using only menu items or keyboard shortcuts, such as
When an item is being dragged within or into a scrollable window, support automatic scrolling of that window when the mouse is moved near its edges.
Pop up a menu when the user attemps to drop multiple objects on a target that only accepts single objects. On the menu, list all the objects being dragged, and a
Overriding drag and drop behavior
Keyboard Modifiers
Allow the user to force the behavior of a drag and drop operation by holding the
Effect of modifier keys during a drag and drop operation
Move
Create link, shortcut or alias
Query Drag
Allow the user to drag objects with the
Mouse Pointers to Use for Drag and Drop
Use the default GTK drag and drop pointers for the standard transfer operations listed below. This consistency helps ensure the user will know exactly what to expect when they release the mouse button. If you have to design a pointer for a non-standard transfer action not listed here, follow the style of the standard pointers.
Mouse Pointers for Drag and Drop
Pointer Shape
Meaning
"Move" pointer
Move selection. The dragged selection will be moved to the drop location, removing it from its previous location.
"Copy" pointer
Copy selection. The dragged selection will be copied to the drop location, leaving the original intact.
"Link" pointer
Link selection. A link to the selection will be inserted at the drop location. How the link appears will be application-dependent, it may be a hyperlink, an icon, or a duplicate of the orignal selection, for example.
"Query drop" pointer
Middle button or Alt-left button drag. A pop-up menu will be posted at the drop location to ask whether the user wants to Move, Copy, or Link the selection, or Cancel the operation.
"Can't drop here" pointer
Can't drop here. Show this pointer while the mouse is over an area where the selection cannot be dropped.
Mouse Interaction with Panel Applications (Applets)
All objects on the desktop must behave consistently. Despite their specialized nature, applets are no exception.
The unmodified left mouse button must be sufficient to operate all your applet's controls. Applets are meant to be simple enough that modified clicking, or clicking with other mouse buttons (except to pop up the applet's menu) is never required.
left
drag
Suggestion: Clicking and dragging anywhere within the applet window whilst holding down the
Clicking the right button
Do not use the middle button for anything except dragging the applet to a new location. Middle-clicking and dragging anywhere within the applet window must move the applet, do not require a drag bar or similar device.

Keyboard Interaction
Keyboard Navigation
A well-designed keyboard user interface plays a key role when you are designing applications. Many power-users prefer to perform most operations with the keyboard rather than the mouse. Visually-impaired users can navigate software more effectively using the keyboard, because using the mouse depends on visual feedback of the mouse pointer location. And mobility impairments can prevent a user from successfully navigating using the mouse, because of the fine motor control skills required.
Make all mouse actions available from the keyboard, and include keyboard access to all toolbars, menus, links and buttons. Every function your application provides must be available using the keyboard alone. Hiding your mouse while you test your application is a great way to test this!
Dialog and menu, with some of their access and shortcut keys indicated
Screenshot of a dialog and a menu with some of their access keys and shortcut keys highlighted
Most functionality is easy to make available from the keyboard, by using access keys and shortcut keys, and the toolkit's built-in keyboard navigation features. All controls with labels should have access keys, and frequently-used menu items should be assigned shortcut keys. However, operations that rely on drag-and-drop, for example, may require more thought to make them keyboard accessible.
Provide efficient keyboard access to all application features. In particular, ensure every control on menus and in dialogs are directly focusable using access keys or shortcut keys.
Use a logical keyboard navigation order. When navigating around a window with the Tab key, keyboard focus should move between controls in a predictable order. In Western locales, this is normally left to right and top to bottom.
Ensure correct tab order for controls whose enabled state is dependent on check box, radio button or toggle button state. When such a button is selected, all its dependent controls should be enabled, and all the dependent controls of any other button in the group should be disabled. When the user selects a check box, radio button or toggle button that has dependent controls, do not automatically give focus to the first dependent control, but instead leave the focus on the button.
Do not over-ride existing system-level accessibility features. For example, the MouseKeys feature in the GNOME
Ensure that any text that can be selected with the mouse can also be selected with the keyboard. This is a convenience for all users, but especially for those for whom fine control of the mouse is difficult.
Ensure that objects that can be resized or moved by drag and drop can also be resized or moved with the keyboard. For example, icons and windows on the desktop. Where precision sizing and placement is potentially important, e.g. shapes in a diagram, also consider providing a dialog into which you can type co-ordinates, or a means of snapping objects to a user-definable grid.
Do not use general navigation functions to trigger operations. For example, do not use basic
Show keyboard-invoked menus, windows and tooltips near the object they relate to, but without hiding or obscuring the object to which the menu or tooltip refers,. In GNOME, popup menus are activated with
Provide more than one method to perform keyboard tasks where possible. Users may find some keys and key combinations easier to use than others.
Do not assign awkward reaches to frequently performed keyboard operations. Some people may only be able to use one hand on the keyboard, so shortcuts that can be easily used with one hand are preferable for common operations. In any case, having to frequently perform long or difficult reaches on the keyboard can increase muscle strain for all users, increasing the risk of pain or injury.
Do not require repetitive use of simultaneous keypresses. Some users are only able to press and hold one key at a time. Assistive technologies such as the GNOME
The point about not having Tab initiate any actions effectively rules out tab completion in dialogs, should we consider/recommend a "hands-free" auto-completion method instead, as offered by OpenOffice.org, Explorer etc.? What does our new 2.0 file selection dialog do?
Choosing Access Keys
Give all labelled components an access key (underlined letter), with the exception of toolbar controls which would use up too many access key combinations.
Choose access keys to be as easy to remember as possible. Normally, this means using the first letter of the label. However, in complex windows, the choice can become more difficult. Here are some simple rules:
Assign access keys to the most frequently-used controls first. If it's not clear which controls will be the most frequently used, assign access keys from left to right, top to bottom (for Western locales).
Use the first letter of the label, or of one of its other words if it has more than one. If another letter provides a better association (e.g. "x" in
If the first letter is not available, choose an easy to remember consonant from the label, for example, "p" in
If no such consonants are available, choose any available vowel from the label.
If duplication of access keys in a window is unavoidable, you should still refrain from duplicating the access keys for any of these buttons that appear in the same window:
Also, it is better not to assign access keys to "thin" letters (such as lowercase i or l), or letters with descenders (such as lowercase g or y) unless it is unavoidable. The underline does not show up very well on those characters in some fonts.
Applications using a non-Roman writing system in conjunction with a standard keyboard can have control labels prefixed with Roman characters as access keys.
Choosing Shortcut Keys
The tables in
You will probably want to add your own shortcut keys for functions specific to your application. If so, as well as following the guidelines below, look at any other existing similar applications to see which shortcut keys they have defined. Your users may already be using those or similar applications, so being consistent where it is possible and sensible to do so will provide a better user experience for them when they begin to use yours.
Use

Only assign shortcut keys to the most commonly-used actions in your application. Do not try to assign a shortcut key to everything.
Choose new shortcut keys to be as mnemonic as possible, as these will be easier to learn and remember. For example,
Unicode entry shortcuts
Note that you cannot use
Use
Do not use
Do not use
Do not use symbols that require
Do not assign shortcut keys to menu items that change over time, for example a list of open windows on the
Do not use any of the standard shortcut keys listed in
Standard Application Shortcut Keys
If your application uses any of the standard functions listed in the following tables, use the recommended standard keyboard shortcut for that function.
Standard GNOME application shortcut keys and access keys - File menu
Create a new document

Open a document
Save the current document

Print the current document
Close the current document
Quit the application
Standard GNOME application shortcut keys and access keys - Edit menu

Undo the last operation

Redo the last operation
Cut the selected area and store it in the clipboard
Copy the selected area into the clipboard
Paste contents of clipboard at mouse/cursor position

Duplicate the currently-selected items and add them to the same window, without affecting the clipboard
Select everything in focused control or window
In
Select everything in focused control or window that was previously unselected, and deselect everything that was previously selected
Del
Delete selection

Find matches in the current document, highlighting them in-place


Search for matches in multiple documents, files or other external sources
Find the next match
Find and replace matches
R
F2
Switch the selected item's label into edit mode, allowing user to type in a new name.
Find and Search
If your application requires both
Standard GNOME application shortcut keys and access keys - View menu
Zoom
Plus
Should probably recommend that Ctrl-Equals work too
Zoom in on the document
Minus
Zoom out of the document
Restore to zoom level to normal size (generally 100%)
Redraw current view of document, without checking if content has changed
Reload the current document, updating content from source if necessary
Pr
Enter
Display the selected object's Properties window. May alternatively appear on the
Reload and Refresh
If your application requires both
Standard GNOME application shortcut keys and access keys - Bookmarks menu
Add
Add a bookmark for the current location

Open a window in which the user can edit and organise saved bookmarks
Bold and Edit Bookmarks
If your application requires both
Standard GNOME application shortcut keys and access keys - Go menu
Go to the previous location in the navigation chain
Ne
Go to the next location in the navigation chain
Go up one level in the navigation hierarchy
Go to the starting page defined by the user or application
Present or focus an entry field into which the user can type a new address or location to view
Standard GNOME application shortcut keys and access keys - Format menu
Make selected text bold/regular
Underline/remove underline from selected text
Make selected text italic/regular
Standard GNOME application shortcut keys and access keys - Help menu
Show help contents page for the current application
Standard Window Manager Shortcut Keys
The following shortcut keys are used by many window managers, and should not normally be over-ridden by your application.
Standard window manager shortcut keys and access keys
Switch primary windows

Switch focus to the next or previous top level window on the desktop
Switch panels

Switch focus to the next or previous panel on the desktop
Log out
Open the session logout confirmation dialog
Window menu
Open the window menu
F4
Close the focused window

F5
Restore the focused to its previous size

F6
precise functionality for metacity TBD, see bug 94682
Switch focus to the next or previous secondary window associated with the application (

F7
Move the focused window
s
Re
F8
Resize the focused window
n
Mi
F9
Minimze the focused window
Ma
F10
Maximize the focused window

F11
Show the window in full screen mode, with no border, menubar, toolbar or statusbar
Standard Widget Navigation Shortcut Keys
The following shortcut keys are reserved for keyboard navigation use by the various widgets used in GNOME, and should not normally be over-ridden by your application.
Standard GNOME keyboard navigation keys for widgets

Moves keyboard focus to next/previous control
Moves keyboard focus out of enclosing widget to next/previous control, in those situations where Tab alone has another function (e.g. GtkTextView)
Pop up tooltip for currently-focused control
Show context-sensitive help for currently-focused window or control
Give focus to next/previous pane in a GtkPaned window
Give focus to splitter bar in paned window
Give focus to window's menu bar
Pop up contextual menu for currently-selected objects
Toggle selected state of focused check box, radio button, or toggle button
Activate focused button, menu item etc.

Select/move to first item in selected widget

Scroll selected view by one page up/left/down/right
Additional Widget Navigation Shortcut Keys
The following emacs-style navigation shortcut keys are still available in GNOME 2.0 text entry fields (by selecting the "emacs" scheme in the GNOME
Emacs-style navigation keys for widgets
Move cursor to beginning of line
Delete character following/under cursor
Move cursor to end of line
K
Delete from cursor to end of line
Delete current line
Cut to clipboard
Y
Paste from clipboard
Set mark

Delete from cursor to end of word
Backspace
Delete from cursor to start of word
Delete all whitespace around cursor, reinsert single space
\\
Delete all whitespace around cursor
Keyboard Interaction with Panel Applications (Applets)
Panels have been fully keyboard navigable since GNOME 2.0. Since your panel application can gain keyboard focus, you must ensure that it is also keyboard navigable.
The rules for panel application keyboard navigation are mostly the same as those for any other window. However, there is one imporant difference:
Do
When an object on a panel has focus, the
Language
Consistent labelling creates a familiar environment that the user can navigate comfortably. The more familiar the environment, the easier task of finding information.
Labels
Clear, consistent and concise labelling of controls helps users to work out the purpose of a window or dialog they have never seen before. To a visually-impaired user, clear labels are even more important. A user who relies on a screenreader has no assistance from icons, layout, or spacing to work out what the controls do, so clear labelling is essential.
Reduces the expansion of text when translated, and thus minimizes the effort required to localize the UI. Translated English text can expand up to 30% in some languages.
Facilitates the use of translation engines.
Improves speed of comprehension for the user.
Keep labels short. This:
Do not shorten your labels to the point of losing meaning, however. A three-word label that provides clear information is better than a one-word label that is ambiguous or vague. Try to find the fewest possible words to satisfactorily convey the meaning of your label.
Do not include text in windows that describes
Use standard terms. You can find a list of standard user interface terms in the
Apply standard capitalization rules. See
Toolbar Tooltips
A toolbar tooltip is the short description of a toolbar control's functionality that the user sees when they mouse over it.
Concisely state the purpose of the control. The tooltip should be more descriptive than the corresponding menu item name, if there is one, but not verbose. For example,
Use sentence capitalization rules. See
Application Tooltips
An application tooltip is the short description of your application that the user sees when they mouse over the launcher or menu item for your application. It is stored in the
Create short tooltips. Aim to accurately communicate the functionality of an element with the fewest words possible.
Use standard punctuation rules, with the exception that you do not use a period to end the tooltip.
Use the recommended standard labels for menu items and titles, where they exist. Do not use synonyms such as
Use header capitalization rules for all menu items and titles. See
Warning and Error Messages
A good warning or error message contains two elements:
A brief description of the problem.
A list of ways the user can remedy the problem.
Both of these elements should be presented in non-technical, jargon-free language, unless your target audience is particularly technically-minded.
If your application knows enough about the problem to be able to give all this information to the user, it will often be capable of rectifying the problem itself when the user has decided which course of action they want to take. For example, if the problem is insufficient memory, tell the user which currently-running application is taking up the most memory, and provide a button to close it for them. (Do not offer to launch a graphical process manager, however, which is something most users should never see!)
See
Online Help
Writing online help is a specialized task, and is therefore not covered in any depth here. Refer to the
Checklists
Things You Can Do Yourself
Before You Start
Write down the type of people you expect to use your application. Then write some "scenarios" for each type of user— a little story that describes the typical tasks those users will use your application for. These tasks should be along the lines of:
Fred needs to find an email about widgets that he received last week
Fred clicks on the
This way, you can use the same scenarios to test and compare different interface designs, and to spot any missing functionality.
Include these user descriptions and scenarios with the documentation you commit to CVS. This way, other contributors will get to understand your users too, can help to develop the application with that knowledge, and can provide more scenarios of their own.
Keyboard Access and Focus
When you have started implementing your interface, hide your mouse, and make sure you can still use it to do everything using only the keyboard. Implement keyboard functionality at the same time as mouse functionality— don't leave it until the end.
Using only keyboard commands, move the focus through all menu bars and toolbars in the application. Also confirm that:
Context sensitive menus display correctly (
Tooltips can be popped up and down for all controls that have them (
All functions listed on the toolbar can be performed using the keyboard.
You can fully operate every control in the client area of the application and dialogs.
Text and objects within the client area can be selected.
Any keyboard enhancements or shortcut keys are working as designed.
Verify that when moving among objects, the visual focus indicator is easy to identify at all times.
Theming, Colors and Contrast
Test various GNOME themes to ensure that your application respects all the available settings.
Test your application with black and white, high contrast themes and confirm that all information is still conveyed correctly. If you don't have a suitable high contrast GNOME theme available to test, print off some screenshots in black and white (not greyscale) and make sure all the important information is still visible— this will approximate what a high contrast theme user will see.
Ensure you have implemented an option to turn off any animation in your application (for accessibility reasons), and that it is working as designed. Turn the animation off. Confirm that all information is still conveyed correctly.
Things You Can Do With Other People
Get Early Feedback
It's always tempting, but don't start coding your interface straight away. Sketch out some ideas on paper first, or in Glade or HTML if you prefer. (But don't be tempted add any functionality at this point if you do it this way!)
Show these prototypes to other people— the GNOME mailing lists and IRC are ideal for finding likely candidates. Ask them to use these prototype interfaces to run through some of the scenarios you came up with earlier. You'll probably get questions like "how would I do X", "which menu is Y on"... these questions will help you think about the interface from the user's viewpoint. You'll probably also get a few suggestions about how to do things differently— these ideas may or may not turn out to better than yours, but any idea from a potential user is worth considering!
You should also consider seeking opinions from the
Once you've decided on the basic interface design and have started coding parts of it, find somebody to try it out again— it doesn't have to be the same person. You'll probably find some more problems that were hard to see on your static paper prototype. By finding these now, it's usually not too late to fix them without too much trouble.
If you intend your application to be translated into different languages, show draft designs of your application to the
If possible, try out your application with users from the locales you are targeting. This will help you determine whether users understand how to use the application, if they perceive the graphics and colors the way you intended, and if there are words or images in the application that may cause offence to users of that locale.
Credit
(lists in alphabetical order, if you were accidentally omitted please email the authors or
Active Authors
Calum Benson,
Bryan Clark,
Seth Nickell,
Additional Illustrations
Mihai Anca,
Denis Anisimov,
Wouter Bron,
Retired/Inactive Authors
Coleen Baik
Adam Elman
Colin Z. Robertson
Maciej Stachowiak
Reviewers and Contributors
Chip Alexander
Kathy Fernandes
John Fleck
Andrea Mankoski
Nils Pederson
Sebastian Rittau
Christian Rose
Sharon Snider
Suzanna Smith
Matthew Thomas
Work in progress, more titles needed -David
This bibliography lists books and other resources for software engineers, user interface designers, and human factors specialists, arranged by topic and without a particular ordering. The final section of the bibliography contains information about useful online resources and organizations.
General Design
Dreyfuss
Henry
Designing for People
New York
NY
allworth press
2003
A reprint of the 1960s design classic by the designer of everything from the modern airplane cabin to the Bell telephone. Perhaps the best book for introducing the general concerns and thought patterns of design (industrial, product, or interaction), as well as an entertaining read.

Mandel
Theo
The Elements of User Interface Design
Wiley Computer Publishing
1997
A useful book covering all the basics and a wide scope of environments and new developments like interface agents, wizards, voice interaction, social user interfaces and web design.

Norman
Donald A.
The Design of Everyday Things
Doubleday
1990
An exceptional and entertaining book about the design behind simple daily things.

Graphical Design
Horton
William
The Icon Book: Visual Symbols for Computer Systems and Documentation
John Wiley & Sons
1994
Needs quote for this book -David

Misjksenaar
Paul
Piet
Westendorpp
Open Here: The Art of Instructional Design
London
UK
Thames & Hudson
1999

Mullet
Kevin
Darrell
Sano
Designing Visual Interfaces: Communication Oriented Techniques
Englewood Cliffs
NJ
Prentice Hall
1995

Rubin
Jeffrey
Handbook of Usability Testing: How to Plan, Design and Conduct Effective Tests

Tufte
Edward R.
Envisioning Information
Cheshire
CT
Graphics Press
The second classic work on envisioning information by Tufte.

The Visual Display of Quantitative Information
Reprint ed.
1992
The first classic work on envisioning information by Tufte.

Williams
Robin
The Non-Designer's Design Book: Design and Typographic Principles for the Visual Novice
Berkeley
CA
Peachpit Press
Usability
Arlov
Laura
GUI Design for Dummies
Foster City
IDG Books Worldwide
Cooper
Alan
Reimann
Robert
About Face 2.0 : The Essentials of User Interface Design
Needs quote for this book

The Inmates are Running the Asylum : Why High Tech Products Drive us Crazy and How to Restore the Sanity
SAMS

Isaacs
Ellen
Walendowski
Designing from Both Sides of the Screen
Indianapolis
IN
New Riders Publishing
2001
Nielsen
Jakob
Usability Engineering
San Francisco
Morgan Kauffman
1993
Tognazzini
Bruce
Tog on Interface
Reading
MA
Addison-Wesley
translator-credits