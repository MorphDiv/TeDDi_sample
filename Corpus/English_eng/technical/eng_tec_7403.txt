# language_name_wals:	English
# language_name_glotto:	English
# iso639_3:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

@@image: 'figures/genius_window.png'; md5=726c4fc51539c5898333fa28720f94b3
@@image: 'figures/line_plot.png'; md5=0ce9e28d32f414d68a0958a1c38918fc
@@image: 'figures/line_plot_graph.png'; md5=284ee1a4302f7ce163b72b7d5ce7fb91
@@image: 'figures/parametric.png'; md5=d6be229108fb50a16e8bdbbfde822ba8
@@image: 'figures/parametric_graph.png'; md5=74cbbc455c4fd79de6d0e60d0b54aa4c
@@image: 'figures/surface_graph.png'; md5=45b10d405b4cd88ad07413452e5f68ac
Manual for the Genius Math Tool.
Genius Manual
1997-2013
Jiří (George) Lebl
2004
Kai Willadsen
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License (GFDL), Version 1.1 or any later version published by the Free Software Foundation with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You can find a copy of the GFDL at this
This manual is part of a collection of GNOME manuals distributed under the GFDL. If you want to distribute this manual separately from the collection, you can do so by adding a copy of the license to the manual, as described in section 6 of the license.
Many of the names used by companies to distinguish their products and services are claimed as trademarks. Where those names appear in any GNOME documentation, and the members of the GNOME Documentation Project are made aware of those trademarks, then the names are in capital letters or initial capital letters.
DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS FREE OF DEFECTS MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND PERFORMANCE OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS WITH YOU. SHOULD ANY DOCUMENT OR MODIFIED VERSION PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER; AND
UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE AUTHOR, INITIAL WRITER, ANY CONTRIBUTOR, OR ANY DISTRIBUTOR OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER DAMAGES OR LOSSES ARISING OUT OF OR RELATING TO USE OF THE DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.
DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT ARE PROVIDED UNDER THE TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE FURTHER UNDERSTANDING THAT:
Jiří
Lebl
Oklahoma State University
jirka@5z.com
Kai
Willadsen
University of Queensland, Australia
kaiw@itee.uq.edu.au
0.2
March 2014
Jiri (George) Lebl
This manual describes version 1.0.18 of Genius.
Feedback
To report a bug or make a suggestion regarding the
Introduction
The

This manual describes mostly the graphical version of the calculator, but the language is of course the same. The command line only version lacks the graphing capabilities and all other capabilities that require the graphical user interface.
Getting Started
To Start
You can start

Depending on your operating system and version, the menu item for

Depending on your system installation the menu item may not be available. If it is not, you can open the Run dialog and execute
Command line
To start the GNOME version of
To start the command line only version, execute the following command:
When You Start Genius
When you start the GNOME edition of

Genius Mathematics Tool
File
Edit
Calculator
Settings
Help
Shows
The
Menubar.
The menus on the menubar contain all of the commands that you need to work with files in
The
The other menus have same familiar functions as in other applications.
Toolbar.
The toolbar contains a subset of the commands that you can access from the menubar.
Working area
The working area is the primary method of interacting with the application.
The working area initially has just the
Alternatively you can write longer programs and those can appear in separate tabs and can be stored in files for later retrieval.
Basic Usage
Using the Work Area
Normally you interact with the calculator in the
To evaluate an expression, type it into the
To get a list of functions and commands, type:
Suppose you have previously saved some GEL commands as a program to a file and you now want to execute them. To load this program from the file
To Create a New Program
To start writing a new program, choose
To save the program you've just written, choose
To Open and Run a Program
To open a file, choose
To run a program from a file, choose
Plotting
Plotting support is only available in the graphical GNOME version. All plotting accessible from the graphical interface is available from the
Line Plots
To graph real valued functions of one variable open the
Once you click the
Create Plot Window
Shows the line plotting window.
Type expressions with
Plot Window
The graph produced.
From here you can print out the plot, create encapsulated postscript or a PNG version of the plot or change the zoom. If the dependent axis was not set correctly you can have Genius fit it by finding out the extrema of the graphed functions.
For plotting using the command line see the documentation of the
Parametric Plots
In the create plot window, you can also choose the
Parametric Plot Tab
Create Plot
Parametric plotting tab in the
An example of a parametric plot is given in
Parametric Plot
Parametric plot produced
Slopefield Plots
In the create plot window, you can also choose the
When a slope field is active, there is an extra
The solver uses the standard Runge-Kutta method. The plots will stay on the screen until cleared. The solver will stop whenever it reaches the boundary of the plot window. Zooming does not change the limits or parameters of the solutions, you will have to clear and redraw them with appropriate parameters. You can also use the
Vectorfield Plots
In the create plot window, you can also choose the
By default the direction and magnitude of the vector field is shown. To only show direction and not the magnitude, check the appropriate checkbox to normalize the arrow lengths.
When a vector field is active, there is an extra
The solver uses the standard Runge-Kutta method. The plots will stay on the screen until cleared. Zooming does not change the limits or parameters of the solutions, you will have to clear and redraw them with appropriate parameters. You can also use the
Surface Plots
Genius can also plot surfaces. Select the
The
Surface Plot
Modulus of the complex cosine function.
GEL Basics
GEL stands for Genius Extension Language. It is the language you use to write programs in Genius. A program in GEL is simply an expression that evaluates to a number, a matrix, or another object in GEL.
Values
Values in GEL can be
Numbers
1234
0x123ABC
01234
23\\1234ABCD
Integers are the first type of number in GEL. Integers are written in the normal way.
3/4
1 3/10
The second type of GEL number is rationals. Rationals are simply achieved by dividing two integers. So one could write:
1.315
7.887e77
7.887e-77
.3
0.3
77e5
The next type if number is floating point. These are entered in a similar fashion to C notation. You can use
1+2i
8.01i
77*e^(1.3i)
The final type of number in gel is the complex numbers. You can enter a complex number as a sum of real and imaginary parts. To add an imaginary part, append an
When entering imaginary numbers, a number must be in front of the
In order to use mixed fraction notation with imaginary numbers you must have the mixed fraction in parentheses. (i.e.,
Booleans
Genius also supports native Boolean values. The two Boolean constants are defined as
At any place where a Boolean expression is expected, you can use a Boolean value or any expression that produces either a number or a Boolean. If Genius needs to evaluate a number as a Boolean it will interpret 0 as
( (1 + true) - false ) * true
( (true or true) or not false ) and true
1 == true
In addition, you can do arithmetic with Boolean values. For example:
Strings
a=2+3;"The result is: "+a
The result is: 5
"Slash: \\\\ Quotes: \\" Tabs: \ 1\ 2\ 3"
Slash: \\ Quotes: " Tabs: 1 2 3
Like numbers and Booleans, strings in GEL can be stored as values inside variables and passed to functions. You can also concatenate a string with another value using the plus operator. For example:
string(22)
"22"
In addition, you can use the library function
Null
There is a special value called
x=5;.
x=5;
Example:
Some functions return
Using Variables
VariableName
Syntax:
To evaluate a variable by itself, just enter the name of the variable. This will return the value of the variable. You can use a variable anywhere you would normally use a number or string. In addition, variables are necessary when defining functions that take arguments (see
Using Tab completion
You can use Tab completion to get Genius to complete variable names for you. Try typing the first few letters of the name and pressing
Variable names are case sensitive
The names of variables are case sensitive. That means that variables named
Setting Variables
x = 3
x := 3
Syntax:
a = b = 5
To assign a value to a variable, use the
The
For more information about the scope of variables, that is when are what variables visible, see
Built-in Variables
GEL has a number of built-in ‘variables’, such as
Previous Result Variable
Ans+389
The
Using Functions
FunctionName(argument1, argument2, ...)
Factorial(5)
cos(2*pi)
gcd(921,317)
Syntax:
There are many built-in functions, such as
You can use Tab completion to get Genius to complete function names for you. Try typing the first few letters of the name and pressing
Function names are case sensitive
The names of functions are case sensitive. That means that functions named
Defining Functions
Syntax:
function addup(a,b,c) = a+b+c
A function takes zero or more comma separated arguments, and returns the result of the function body. Defining your own functions is primarily a matter of convenience; one possible use is to have sets of functions defined in GEL files that Genius can load in order to make them available. Example:
Variable Argument Lists
function f(a,b...) = b
If you include
Passing Functions to Functions
In Genius, it is possible to pass a function as an argument to another function. This can be done using either ‘function nodes’ or anonymous functions.
function f(a,b) = a(b)+1;
function b(x) = x*x;
f(b,2)
If you do not enter the parentheses after a function name, instead of being evaluated, the function will instead be returned as a ‘function node’. The function node can then be passed to another function. Example:
function f(a,b) = a(b)+1;
f(`(x) = x*x,2)
To pass functions that are not defined, you can use an anonymous function (see
Operations on Functions
exp(sin*cos+4)
`(x) = exp(sin(x)*cos(x)+4)
f = exp(sin*cos+4)
LinePlot(sin^2)
Some functions allow arithmetic operations, and some single argument functions such as
Not all functions can be used in this way. For example, when you use a binary operation the functions must take the same number of arguments.
Absolute Value / Modulus
|a-b|
You can make an absolute value of something by putting the
In case the expression is a complex number the result will be the modulus (distance from the origin). For example:
Separator
3 ; 5
In GEL if you want to type more than one command you have to use the
This will require some parenthesizing to make it unambiguous sometimes, especially if the
Comments
# This is just a comment
# every line in a comment must have its own pond sign
# in the next line we set x to the value 123
x=123;
GEL is similar to other scripting languages in that
Modular Evaluation
2^(5!) * 3^(6!) mod 5
Genius implements modular arithmetic. To use it you just add "mod &lt;integergt;" after the expression. Example:
10^-1 mod 101
1/10 mod 101
A = [1,2;3,4]
B = A^-1 mod 5
A*B mod 5
You can calculate the inverses of numbers mod some integer by just using rational numbers (of course the inverse has to exist). Examples:
geniusgt; sqrt(4) mod 7
=
[2, 5]
geniusgt; 2*2 mod 7
= 4
Some functions such as
Do not chain mod operators, simply place it at the end of the computation, all computations in the expression on the left will be carried out in mod arithmetic. If you place a mod inside a mod, you will get unexpected results. If you simply want to mod a single number and control exactly when remainders are taken, best to use the
List of GEL Operators
Everything in gel is really just an expression. Expressions are stringed together with different operators. As we have seen, even the separator is simply a binary operator in GEL. Here is a list of the operators in GEL.
a;b
The separator, just evaluates both
a=b
The assignment operator. This assigns
a:=b
The assignment operator. Assigns
|a|
Absolute value or modulus (if
See
a^b
Exponentiation, raises
a.^b
Element by element exponentiation. Raise each element of a matrix
a+b
Addition. Adds two numbers, matrices, functions or strings. If you add a string to anything the result will just be a string. If one is a square matrix and the other a number, then the number is multiplied by the identity matrix.
a-b
Subtraction. Subtract two numbers, matrices or functions.
a*b
Multiplication. This is the normal matrix multiplication.
a.*b
Element by element multiplication if
a/b
Division. When
a./b
Element by element division. Same as
a\\b
Back division. That is this is the same as
a.\\b
Element by element back division.
a%b
The mod operator. This does not turn on the
a.%b
Element by element the mod operator. Returns the remainder after element by element integer
a mod b
Modular evaluation operator. The expression
a!
Factorial operator. This is like
a!!
Double factorial operator. This is like
a==b
Equality operator. Returns
a!=b
Inequality operator, returns
alt;gt;b
Alternative inequality operator, returns
alt;=b
Less than or equal operator, returns
agt;=b
Greater than or equal operator, returns
alt;b
Less than operator, returns
agt;b
Greater than operator, returns
alt;=gt;b
Comparison operator. If
a and b
Logical and. Returns true if both
a or b
Logical or. Returns true if both
a xor b
Logical xor. Returns true exactly one of
not a
Logical not. Returns the logical negation of
-a
Negation operator. Returns the negative of a number or a matrix (works elementwise on a matrix).
&a
Variable referencing (to pass a reference to a variable). See
*a
Variable dereferencing (to access a referenced variable). See
a'
Matrix conjugate transpose. That is, rows and columns get swapped and we take complex conjugate of all entries. That is if the i,j element of
a.'
Matrix transpose, does not conjugate the entries. That is, the i,j element of
a@(b,c)
Get element of a matrix in row
a@(b,)
Get row of a matrix (or multiple rows if
a@(b,:)
Same as above.
a@(,c)
Get column of a matrix (or columns if
a@(:,c)
a@(b)
Get an element from a matrix treating it as a vector. This will traverse the matrix row-wise.
a:b
A@(2:4,)
 
Build a vector from
a:b:c
geniusgt; 1:2:9
=
`[1, 3, 5, 7, 9]
Build a vector from
(a)i
(a)*1i
 
Make a imaginary number (multiply
`a
Quote an identifier so that it doesn't get evaluated. Or quote a matrix so that it doesn't get expanded.
a swapwith b
Swap value of
increment a
Increment the variable
increment a by b
Increment the variable
The @() operator makes the : operator most useful. With this you can specify regions of a matrix. So that a@(2:4,6) is the rows 2,3,4 of the column 6. Or a@(,1:2) will get you the first two columns of a matrix. You can also assign to the @() operator, as long as the right value is a matrix that matches the region in size, or if it is any other type of value.
The comparison operators (except for the &lt;=gt; operator, which behaves normally), are not strictly binary operators, they can in fact be grouped in the normal mathematical way, e.g.: (1lt;xlt;=ylt;5) is a legal boolean expression and means just what it should, that is (1lt;x and x≤y and ylt;5)
The unitary minus operates in a different fashion depending on where it appears. If it appears before a number it binds very closely, if it appears in front of an expression it binds less than the power and factorial operators. So for example
Programming with GEL
Conditionals
Syntax:
if a=5 then a=a-1
if a==5 then a:=a-1
Examples:
Loops
While Loops
Syntax:
For Loops
for i = 1 to 20 by 2 do print(i)
Syntax:
for x = 0 to 1 by 0.1 do print(x)
for x = 0 to 1 by 1/10 do print(x)
When one of the values is a floating point number, then the final check is done to within 2^-20 of the step size. That is, even if we overshoot by 2^-20 times the "by" above, we still execute the last iteration. This way
Foreach Loops
for n in [1,2:3,4] do print(n)
for n in RowsOf ([1,2:3,4]) do print(n)
Syntax:
Break and Continue
You can also use the
Sums and Products
Syntax:
If no body is executed (for example
For floating point numbers the same roundoff error protection is done as in the for loop. See
Comparison Operators
The following standard comparison operators are supported in GEL and have the obvious meaning:
if a=b then c
if a==b then c
Normally
All the comparison operators (except for the
To build up logical expressions use the words
Global Variables and Scope of Variables
GEL is a
function f() = (a:=5; g());
function g() = print(a);
f();
Like most programming languages, GEL has different types of variables. Normally when a variable is defined in a function, it is visible from that function and from all functions that are called (all higher contexts). For example, suppose a function
function f() = (a:=5; g());
function g() = print(a);
a:=10;
f();
If you define a variable inside a function it will override any variables defined in calling functions. For example, we modify the above code and write:
Function arguments are exactly like variables defined inside the function, except that they are initialized with the value that was passed to the function. Other than this point, they are treated just like all other variables defined inside the function.
Functions are treated exactly like variables. Hence you can locally redefine functions. Normally (on the top level) you cannot redefine protected variables and functions. But locally you can do this. Consider the following session:
a=6;
function f() = (a:=5);
f();
set(`a,3)
set("a",3)
Functions and variables defined at the top level are considered global. They are visible from anywhere. As we said the following function
The
So to recap in a more technical language: Genius operates with different numbered contexts. The top level is the context 0 (zero). Whenever a function is entered, the context is raised, and when the function returns the context is lowered. A function or a variable is always visible from all higher numbered contexts. When a variable was defined in a lower numbered context, then setting this variable has the effect of creating a new local variable in the current context number and this variable will now be visible from all higher numbered contexts.
There are also true local variables that are not seen from anywhere but the current context. Also when returning functions by value it may reference variables not visible from higher context and this may be a problem. See the sections
Parameter variables
As we said before, there exist special variables called parameters that exist in all scopes. To declare a parameter called
When you undefine a parameter using the
Some parameters are built-in and modify the behaviour of genius.
Returning
Normally a function is one or several expressions separated by a semicolon, and the value of the last expression is returned. This is fine for simple functions, but sometimes you do not want a function to return the last thing calculated. You may, for example, want to return from a middle of a function. In this case, you can use the
References
It may be necessary for some functions to return more than one value. This may be accomplished by returning a vector of values, but many times it is convenient to use passing a reference to a variable. You pass a reference to a variable to a function, and the function will set the variable for you using a dereference. You do not have to use references only for this purpose, but this is their main use.
When using functions that return values through references in the argument list, just pass the variable name with an ampersand. For example the following code will compute an eigenvalue of a matrix
The details of how references work and the syntax is similar to the C language. The operator
References are best explained by an example:
Lvalues
a
Identifier. Here we would be setting the variable of name
Dereference of an identifier. This will set whatever variable
a@(lt;regiongt;)
A region of a matrix. Here the region is specified normally as with the regular @() operator, and can be a single entry, or an entire region of the matrix.
An lvalue is the left hand side of an assignment. In other words, an lvalue is what you assign something to. Valid lvalues are:
a:=4
*tmp := 89
a@(1,1) := 5
a@(4:8,3) := [1,2,3,4,5]'
Examples:
Advanced Programming with GEL
Error Handling
If you detect an error in your function, you can bail out of it. For normal errors, such as wrong types of arguments, you can fail to compute the function by adding the statement
function f(M) = (
 if not IsMatrix (M) then (
 error ("M not a matrix!");
 bailout
 );
 ...
)
For example if you want to check for arguments in your function. You could use the following code.
Toplevel Syntax
The synatax is slightly different if you enter statements on the top level versus when they are inside parentheses or inside functions. On the top level, enter acts the same as if you press return on the command line. Therefore think of programs as just sequence of lines as if were entered on the command line. In particular, you do not need to enter the separator at the end of the line (unless it is of course part of several statements inside parentheses).
if Something() then
 DoSomething()
else
 DoSomethingElse()
The following code will produce an error when entered on the top level of a program, while it will work just fine in a function.
if Something() then (
 DoSomething()
) else (
 DoSomethingElse()
)
The problem is that after
Returning Functions
function f() = (
 k = 5;
 `(x) = (x+k)
)
g = f();
g(5)
It is possible to return functions as value. This way you can build functions that construct special purpose functions according to some parameters. The tricky bit is what variables does the function see. The way this works in GEL is that when a function returns another function, all identifiers referenced in the function body that went out of scope are prepended a private dictionary of the returned function. So the function will see all variables that were in scope when it was defined. For example, we define a function that returns a function that adds 5 to its argument.
function f() = (
 k := 5;
 function r(x) = (x+k);
 k := 10;
 r
)
One thing to note is that the value of
function f() = (
 k := 5;
 function r(x) [k] = (x+k);
 k := 10;
 r
)
Sometimes it is better to have more control over how variables are copied into the private dictionary. Since version 1.0.7, you can specify which variables are copied into the private dictionary by putting extra square brackets after the arguments with the list of variables to be copied separated by commas. If you do this, then variables are copied into the private dictionary at time of the function definition, and the private dictionary is not touched afterwards. For example
function f() = (
 k := 5;
 function r(x) [] = (x+k);
 r
);
k := 10;
g = f();
g(10)
When you want the function to not have any private dictionary then put empty square brackets after the argument list. Then no private dictionary will be created at all. Doing this is good to increase efficiency when a private dictionary is not needed or when you want the function to lookup all variables as it sees them when called. For example suppose you want the function returned from
True Local Variables
k := 10;
function r(x) = (x+k);
function f(g,x) = (
 k := 5;
 g(x)
);
f(r,1)
When passing functions into other functions, the normal scoping of variables might be undesired. For example:
function f(g,x) = (
 local g,x,k;
 k := 5;
 g(x)
);
But there is another solution. Since version 1.0.7 there are true local variables. These are variables that are visible only from the current context and not from any called functions. We could define
function f(g,x) = (
 local *;
 k := 5;
 g(x)
);
If all variables are to be created as locals you can just pass an asterix instead of a list of variables. In this case the variables will not be initialized until they are actually set of course. So the following definition of
It is good practice that all functions that take other functions as arguments use local variables. This way the passed function does not see implementation details and get confused.
GEL Startup Procedure
First the program looks for the installed library file (the compiled version
If you ever change the library in its installed place, you’ll have to first compile it with
Loading Programs
load program1.gel program2.gel
load "Weird File Name With SPACES.gel"
cd directory_with_gel_programs
ls *.gel
Sometimes you have a larger program that you wrote into a file and want to read in that file. In these situations, you have two options. You can keep the functions you use most inside the
Matrices in GEL
Genius has support for vectors and matrices and a sizable library of matrix manipulation and linear algebra functions.
Entering Matrices
[1,2,3;4,5,6;7,8,9]
[1, 2, 3
 4, 5, 6
 7, 8, 9]
To enter matrixes, you can use one of the following two syntaxes. You can either enter the matrix on one line, separating values by commas and rows by semicolons. Or you can enter each row on one line, separating values by commas. You can also just combine the two methods. So to enter a 3x3 matrix of numbers 1-9 you could do
a = [ 1, 2, 3
 4, 5, 6
 7, 8, 9]
b = [ a, 10
 11, 12]
[1, 2, 3, 10
 4, 5, 6, 10
 7, 8, 9, 10
 11, 11, 11, 12]
You can also use the matrix expansion functionality to enter matricies. For example you can do:
[1, 2, 3
 4, 5
 6]
[1, 2, 3
 4, 5, 0
 6, 0, 0]
Another thing is that non-specified spots are initialized to 0, so
When matrices are evaluated, they are evaluated and traversed row-wise. This is just like the
Be careful about using returns for expressions inside the
Conjugate Transpose and Transpose Operator
[1,2,3]*[4,5,6]'
[1,2,3]*[4,5,6i].'
You can conjugate transpose a matrix by using the
Note that normal transpose, that is the
Linear Algebra
Genius implements many useful linear algebra and matrix manipulation routines. See the
The linear algebra routines implemented in GEL do not currently come from a well tested numerical package, and thus should not be used for critical numerical computation. On the other hand, Genius implements very well many linear algebra operations with rational and integer coefficients. These are inherently exact and in fact will give you much better results than common double precision routines for linear algebra.
For example, it is pointless to compute the rank and nullspace of a floating point matrix since for all practical purposes, we need to consider the matrix as having some slight errors. You are likely to get a different result than you expect. The problem is that under a small perturbation every matrix is of full rank and invertible. If the matrix however is of rational numbers, then the rank and nullspace are always exact.
In general when Genius computes the basis of a certain vectorspace (for example with the
It should be noted that Genius can remember certain properties of a matrix. For example, it will remember that a matrix is in row reduced form. If many calls are made to functions that internally use row reduced form of the matrix, we can just row reduce the matrix beforehand once. Successive calls to
Polynomials in GEL
Currently Genius can handle polynomials of one variable written out as vectors, and do some basic operations with these. It is planned to expand this support further.
Using Polynomials
[1,2,3]
1 + 2*x + 3*x^2
Currently polynomials in one variable are just horizontal vectors with value only nodes. The power of the term is the position in the vector, with the first position being 0. So,
PolyToString([1,2,3],"y")
3*y^2 + 2*y + 1
f = PolyToFunction([0,1,1])
f(2)
You can add, subtract and multiply polynomials using the
It is also possible to find roots of polynomials of degrees 1 through 4 by using the function
See
Set Theory in GEL
Genius has some basic set theoretic functionality built in. Currently a set is just a vector (or a matrix). Every distinct object is treated as a different element.
Using Sets
Just like vectors, objects in sets can include numbers, strings,
To build a set out of a vector, use the
Similarly there are functions
For testing membership, there are functions
List of GEL functions
help FunctionName
To get help on a specific function from the console type:
Commands

help
help FunctionName
Print help (or help on a function/command).

load "file.gel"
Load a file into the interpretor. The file will execute as if it were typed onto the command line.

cd /directory/name
Change working directory to

pwd
Print the current working directory.

ls
List files in the current directory.

plugin plugin_name
Load a plugin. Plugin of that name must be installed on the system in the proper directory.
Basic

AskButtons (query)
AskButtons (query, button1, ...)
Asks a question and presents a list of buttons to the user (or a menu of options in text mode). Returns the 1-based index of the button pressed. That is, returns 1 if the first button was pressed, 2 if the second button was pressed, and so on. If the user closes the window (or simply hits enter in text mode), then

AskString (query)
AskString (query, default)
Asks a question and lets the user enter a string, which it then returns. If the user cancels or closes the window, then

Compose (f,g)
Compose two functions and return a function that is the composition of

ComposePower (f,n,x)
Compose and execute a function with itself

Evaluate (str)
Parses and evaluates a string.

GetCurrentModulo
Get current modulo from the context outside the function. That is, if outside of the function was executed in modulo (using

Identity (x)
Identity function, returns its argument.

IntegerFromBoolean (bval)
Make integer (0 for

IsBoolean (arg)
Check if argument is a boolean (and not a number).

IsDefined (id)
Check if an id is defined. You should pass a string or and identifier. If you pass a matrix, each entry will be evaluated separately and the matrix should contain strings or identifiers.

IsFunction (arg)
Check if argument is a function.

IsFunctionOrIdentifier (arg)
Check if argument is a function or an identifier.

IsFunctionRef (arg)
Check if argument is a function reference. This includes variable references.

IsMatrix (arg)
Check if argument is a matrix. Even though

IsNull (arg)
Check if argument is a

IsString (arg)
Check if argument is a text string.

IsValue (arg)
Check if argument is a number.

Parse (str)
Parses but does not evaluate a string. Note that certain pre-computation is done during the parsing stage.

SetFunctionFlags (id,flags...)
Set flags for a function, currently

SetHelp (id,category,desc)
Set the category and help description line for a function.

SetHelpAlias (id,alias)
Sets up a help alias.

chdir (dir)
Changes current directory, same as the

CurrentTime
Returns the current UNIX time with microsecond precision as a floating point number. That is, returns the number of seconds since January 1st 1970.

display (str,expr)
Display a string and an expression with a colon to separate them.

DisplayVariables (var1,var2,...)
DisplayVariables(`x,`y,`z)
 
Display set of variables. The variables can be given as strings or identifiers. For example:
DisplayVariables()
 
If called without arguments (must supply empty argument list) as

error (str)
Prints a string to the error stream (onto the console).

exit
Aliases:
Exits the program.

false
Aliases:
The

manual
Displays the user manual.

print (str)
Prints an expression and then print a newline. The argument

printn (str)
Prints an expression without a trailing newline. The argument

PrintTable (f,v)
PrintTable (f,[0:10])
 
Print a table of values for a function. The values are in the vector

protect (id)
Protect a variable from being modified. This is used on the internal GEL functions to avoid them being accidentally overridden.

ProtectAll ()
Protect all currently defined variables, parameters and functions from being modified. This is used on the internal GEL functions to avoid them being accidentally overridden. Normally

set (id,val)
set(`x,1)
 
Set a global variable. The

string (s)
Make a string. This will make a string out of any argument.

true
Aliases:
The

undefine (id)
Alias:
Undefine a variable. This includes locals and globals, every value on all context levels is wiped. This function should really not be used on local variables. A vector of identifiers can also be passed to undefine several variables.

UndefineAll ()
Undefine all unprotected global variables (including functions and parameters). Normally

unprotect (id)
Unprotect a variable from being modified.

UserVariables ()
Return a vector of identifiers of user defined (unprotected) global variables.

wait (secs)
Waits a specified number of seconds.

version
Returns the version of Genius as a horizontal 3-vector with major version first, then minor version and finally the patch level.

warranty
Gives the warranty information.
Parameters

ChopTolerance = number
Tolerance of the

ContinuousNumberOfTries = number
How many iterations to try to find the limit for continuity and limits.

ContinuousSFS = number
How many successive steps to be within tolerance for calculation of continuity.

ContinuousTolerance = number
Tolerance for continuity of functions and for calculating the limit.

DerivativeNumberOfTries = number
How many iterations to try to find the limit for derivative.

DerivativeSFS = number
How many successive steps to be within tolerance for calculation of derivative.

DerivativeTolerance = number
Tolerance for calculating the derivatives of functions.

ErrorFunctionTolerance = number
Tolerance of the

FloatPrecision = number
Floating point precision.

FullExpressions = boolean
Print full expressions, even if more than a line.

GaussDistributionTolerance = number
Tolerance of the

IntegerOutputBase = number
Integer output base.

IsPrimeMillerRabinReps = number
Number of extra Miller-Rabin tests to run on a number before declaring it a prime in

LinePlotDrawLegends = true
Tells genius to draw the legends for

LinePlotDrawAxisLabels = true
Tells genius to draw the axis labels for

LinePlotVariableNames = ["x","y","z","t"]
Tells genius which variable names are used as default names for

LinePlotWindow = [x1,x2,y1,y2]
Sets the limits for

MaxDigits = number
Maximum digits to display.

MaxErrors = number
Maximum errors to display.

MixedFractions = boolean
If true, mixed fractions are printed.

NumericalIntegralFunction = function
The function used for numerical integration in

NumericalIntegralSteps = number
Steps to perform in

OutputChopExponent = number
When another number in the object being printed (a matrix or a value) is greater than 10
Output is never chopped if
If you want output always chopped according to

OutputChopWhenExponent = number
When to chop output. See

OutputStyle = string
Output style, this can be
OutputStyle = "latex"
This affects mostly how matrices and fractions are printed out and is useful for pasting into documents. For example you can set this to the latex by:

ResultsAsFloats = boolean
Convert all results to floats before printing.

ScientificNotation = boolean
Use scientific notation.

SlopefieldTicks = [vertical,horizontal]
Sets the number of vertical and horizontal ticks in a slopefield plot. (See

SumProductNumberOfTries = number
How many iterations to try for

SumProductSFS = number
How many successive steps to be within tolerance for

SumProductTolerance = number
Tolerance for

SurfacePlotDrawLegends = true
Tells genius to draw the legends for

SurfacePlotVariableNames = ["x","y","z"]
Tells genius which variable names are used as default names for

SurfacePlotWindow = [x1,x2,y1,y2,z1,z2]
Sets the limits for surface plotting (See

VectorfieldNormalized = true
Should the vectorfield plotting have normalized arrow length. If true, vector fields will only show direction and not magnitude. (See

VectorfieldTicks = [vertical,horizontal]
Sets the number of vertical and horizontal ticks in a vectorfield plot. (See
Constants

CatalanConstant
Catalan's Constant, approximately 0.915... It is defined to be the series where terms are
See

EulerConstant
Aliases:
Euler's Constant gamma. Sometimes called the Euler-Mascheroni constant.
See

GoldenRatio
The Golden Ratio.
See

Gravity
Free fall acceleration at sea level.
See

e
The base of the natural logarithm.
See

pi
The number pi, that is the ratio of a circle's circumference to its diameter. This is approximately 3.14159265359...
See
Numeric

AbsoluteValue (x)
Aliases:
Absolute value of a number and if
See

Chop (x)
Replace very small number with zero.

ComplexConjugate (z)
Aliases:
Calculates the complex conjugate of the complex number
See

Denominator (x)
Get the denominator of a rational number.
See

FractionalPart (x)
Return the fractional part of a number.
See

Im (z)
Aliases:
Get the imaginary part of a complex number.
See

IntegerQuotient (m,n)
Division without remainder.

IsComplex (num)
Check if argument is a complex (non-real) number.

IsComplexRational (num)
Check if argument is a possibly complex rational number. That is, if both real and imaginary parts are given as rational numbers. Of course rational simply means "not stored as a floating point number."

IsFloat (num)
Check if argument is a floating point number (non-complex).

IsGaussInteger (num)
Aliases:
Check if argument is a possibly complex integer.

IsInteger (num)
Check if argument is an integer (non-complex).

IsNonNegativeInteger (num)
Check if argument is a non-negative real integer.

IsPositiveInteger (num)
Aliases:
Check if argument is a positive real integer. Note that we accept the convention that 0 is not a natural number.

IsRational (num)
Check if argument is a rational number (non-complex). Of course rational simply means "not stored as a floating point number."

IsReal (num)
Check if argument is a real number.

Numerator (x)
Get the numerator of a rational number.
See

Re (z)
Aliases:
Get the real part of a complex number.
See

Sign (x)
Aliases:
Return the sign of a number. That is returns

ceil (x)
Aliases:
Get the lowest integer more than or equal to
Note that you should be careful and notice that floating point numbers are stored an binary and so may not be what you expect. For example

exp (x)
The exponential function. This is the function
See

float (x)
Make number a floating point value. That is returns the floating point representation of the number

floor (x)
Aliases:
Get the highest integer less than or equal to

ln (x)
The natural logarithm, the logarithm to base

log (x)
log (x,b)
Logarithm of

log10 (x)
Logarithm of

log2 (x)
Aliases:
Logarithm of

max (a,args...)
Aliases:
Returns the maximum of arguments or matrix.

min (a,args...)
Aliases:
Returns the minimum of arguments or matrix.

rand (size...)
Generate random float in the range

randint (max,size...)
Generate random integer in the range

round (x)
Aliases:
Round a number.

sqrt (x)
Aliases:
The square root. When operating modulo some integer will return either a
See

trunc (x)
Aliases:
Truncate number to an integer (return the integer part).
Trigonometry

acos (x)
Aliases:
The arccos (inverse cos) function.

acosh (x)
Aliases:
The arccosh (inverse cosh) function.

acot (x)
Aliases:
The arccot (inverse cot) function.

acoth (x)
Aliases:
The arccoth (inverse coth) function.

acsc (x)
Aliases:
The inverse cosecant function.

acsch (x)
Aliases:
The inverse hyperbolic cosecant function.

asec (x)
Aliases:
The inverse secant function.

asech (x)
Aliases:
The inverse hyperbolic secant function.

asin (x)
Aliases:
The arcsin (inverse sin) function.

asinh (x)
Aliases:
The arcsinh (inverse sinh) function.

atan (x)
Aliases:
Calculates the arctan (inverse tan) function.
See

atanh (x)
Aliases:
The arctanh (inverse tanh) function.

atan2 (y, x)
Aliases:
Calculates the arctan2 function. If
See

cos (x)
Calculates the cosine function.
See

cosh (x)
Calculates the hyperbolic cosine function.
See

cot (x)
The cotangent function.

coth (x)
The hyperbolic cotangent function.

csc (x)
The cosecant function.

csch (x)
The hyperbolic cosecant function.

sec (x)
The secant function.

sech (x)
The hyperbolic secant function.

sin (x)
Calculates the sine function.

sinh (x)
Calculates the hyperbolic sine function.

tan (x)
Calculates the tan function.

tanh (x)
The hyperbolic tangent function.
Number Theory

AreRelativelyPrime (a,b)
Are the real integers
See

BernoulliNumber (n)
Return the
See

ChineseRemainder (a,m)
Aliases:
Find the
See

CombineFactorizations (a,b)
Given two factorizations, give the factorization of the product.
See

ConvertFromBase (v,b)
Convert a vector of values indicating powers of b to a number.

ConvertToBase (n,b)
Convert a number to a vector of powers for elements in base

DiscreteLog (n,b,q)
Find discrete log of
See

Divides (m,n)
Checks divisibility (if

EulerPhi (n)
Compute the Euler phi function for
See

ExactDivision (n,d)
Return

Factorize (n)
Return factorization of a number as a matrix. The first row is the primes in the factorization (including 1) and the second row are the powers. So for example:
See

Factors (n)
for n=1 to 1000 do (
 if MatrixSum (Factors(n)) == 2*n then
 print(n)
)
Return all factors of

FermatFactorization (n,tries)
Attempt Fermat factorization of
This is a fairly good factorization if your number is the product of two factors that are very close to each other.
See

FindPrimitiveElementMod (q)
Find the first primitive element in F

FindRandomPrimitiveElementMod (q)
Find a random primitive element in F

IndexCalculus (n,b,q,S)
Compute discrete log base

IndexCalculusPrecalculation (b,q,S)
Run the precalculation step of

IsEven (n)
Tests if an integer is even.

IsMersennePrimeExponent (p)
Tests if a positive integer
See

IsNthPower (m,n)
Tests if a rational number

IsOdd (n)
Tests if an integer is odd.

IsPerfectPower (n)
Check an integer is any perfect power, a

IsPerfectSquare (n)
Check an integer for being a perfect square of an integer. The number must be a real integer. Negative integers are of course never perfect squares of real integers.

IsPrime (n)
Tests primality of integers, for numbers less than 2.5e10 the answer is deterministic (if Riemann hypothesis is true). For numbers larger, the probability of a false positive depends on
If
See

IsPrimitiveMod (g,q)
Check if

IsPrimitiveModWithPrimeFactors (g,q,f)
Check if

IsPseudoprime (n,b)
If

IsStrongPseudoprime (n,b)
Test if

Jacobi (a,b)
Aliases:
Calculate the Jacobi symbol (a/b) (b should be odd).

JacobiKronecker (a,b)
Aliases:
Calculate the Jacobi symbol (a/b) with the Kronecker extension (a/2)=(2/a) when a odd, or (a/2)=0 when a even.

LeastAbsoluteResidue (a,n)
Return the residue of

Legendre (a,p)
Aliases:
Calculate the Legendre symbol (a/p).
See

LucasLehmer (p)
Test if 2
See

LucasNumber (n)
Returns the
See

MaximalPrimePowerFactors (n)
Return all maximal prime power factors of a number.

MersennePrimeExponents
A vector of known Mersenne prime exponents, that is a list of positive integers

MillerRabinTest (n,reps)
Use the Miller-Rabin primality test on
See

MillerRabinTestSure (n)
Use the Miller-Rabin primality test on

ModInvert (n,m)
Returns inverse of n mod m.
See

MoebiusMu (n)
Return the Moebius mu function evaluated in
See

NextPrime (n)
Returns the least prime greater than
This function uses the GMPs

PadicValuation (n,p)
Returns the p-adic valuation (number of trailing zeros in base
See

PowerMod (a,b,m)
Compute

Prime (n)
Aliases:
Return the

PrimeFactors (n)
Return all prime factors of a number as a vector.
See

PseudoprimeTest (n,b)
Pseudoprime test, returns
See

RemoveFactor (n,m)
Removes all instances of the factor
See

SilverPohligHellmanWithFactorization (n,b,q,f)
Find discrete log of

SqrtModPrime (n,p)
Find square root of
See

StrongPseudoprimeTest (n,b)
Run the strong pseudoprime test base
See

gcd (a,args...)
Aliases:
Greatest common divisor of integers. You can enter as many integers in the argument list, or you can give a vector or a matrix of integers. If you give more than one matrix of the same size then GCD is done element by element.
See

lcm (a,args...)
Aliases:
Least common multiplier of integers. You can enter as many integers in the argument list, or you can give a vector or a matrix of integers. If you give more than one matrix of the same size then LCM is done element by element.
See
Matrix Manipulation

ApplyOverMatrix (a,func)
Apply a function over all entries of a matrix and return a matrix of the results.

ApplyOverMatrix2 (a,b,func)
Apply a function over all entries of 2 matrices (or 1 value and 1 matrix) and return a matrix of the results.

ColumnsOf (M)
Gets the columns of a matrix as a horizontal vector.

ComplementSubmatrix (m,r,c)
Remove column(s) and row(s) from a matrix.

CompoundMatrix (k,A)
Calculate the kth compound matrix of A.

CountZeroColumns (M)
Count the number of zero columns in a matrix. For example once your column reduce a matrix you can use this to find the nullity. See

DeleteColumn (M,col)
Delete a column of a matrix.

DeleteRow (M,row)
Delete a row of a matrix.

DiagonalOf (M)
Gets the diagonal entries of a matrix as a column vector.
See

DotProduct (u,v)
Get the dot product of two vectors. The vectors must be of the same size. No conjugates are taken so this is a bilinear form even if working over the complex numbers.
See

ExpandMatrix (M)
Expands a matrix just like we do on unquoted matrix input. That is we expand any internal matrices as blocks. This is a way to construct matrices out of smaller ones and this is normally done automatically on input unless the matrix is quoted.

HermitianProduct (u,v)
Aliases:
Get the Hermitian product of two vectors. The vectors must be of the same size. This is a sesquilinear form using the identity matrix.
See

I (n)
Aliases:
Return an identity matrix of a given size, that is
See

IndexComplement (vec,msize)
Return the index complement of a vector of indexes. Everything is one based. For example for vector

IsDiagonal (M)
Is a matrix diagonal.
See

IsIdentity (x)
Check if a matrix is the identity matrix. Automatically returns

IsLowerTriangular (M)
Is a matrix lower triangular. That is, are all the entries above the diagonal zero.

IsMatrixInteger (M)
Check if a matrix is a matrix of an integers (non-complex).

IsMatrixNonnegative (M)
Check if a matrix is non-negative, that is if each element is non-negative. Do not confuse positive matrices with positive semi-definite matrices.
See

IsMatrixPositive (M)
Check if a matrix is positive, that is if each element is positive (and hence real). In particular, no element is 0. Do not confuse positive matrices with positive definite matrices.

IsMatrixRational (M)
Check if a matrix is a matrix of rational (non-complex) numbers.

IsMatrixReal (M)
Check if a matrix is a matrix of real (non-complex) numbers.

IsMatrixSquare (M)
Check if a matrix is square, that is its width is equal to its height.

IsUpperTriangular (M)
Is a matrix upper triangular? That is, a matrix is upper triangular if all the entries below the diagonal are zero.

IsValueOnly (M)
Check if a matrix is a matrix of numbers only. Many internal functions make this check. Values can be any number including complex numbers.

IsVector (v)
Is argument a horizontal or a vertical vector. Genius does not distinguish between a matrix and a vector and a vector is just a 1 by

IsZero (x)
Check if a matrix is composed of all zeros. Also works on numbers, in which case it is equivalent to

LowerTriangular (M)
Returns a copy of the matrix

MakeDiagonal (v,arg...)
Aliases:
Make diagonal matrix from a vector. Alternatively you can pass in the values to put on the diagonal as arguments. So

MakeVector (A)
Make column vector out of matrix by putting columns above each other. Returns

MatrixProduct (A)
Calculate the product of all elements in a matrix or vector. That is we multiply all the elements and return a number that is the product of all the elements.

MatrixSum (A)
Calculate the sum of all elements in a matrix or vector. That is we add all the elements and return a number that is the sum of all the elements.

MatrixSumSquares (A)
Calculate the sum of squares of all elements in a matrix or vector.

NonzeroColumns (M)
Returns a row vector of the indices of nonzero columns in the matrix

NonzeroElements (v)
Returns a row vector of the indices of nonzero elements in the vector

OuterProduct (u,v)
Get the outer product of two vectors. That is, suppose that

ReverseVector (v)
Reverse elements in a vector. Return

RowSum (m)
Calculate sum of each row in a matrix and return a vertical vector with the result.

RowSumSquares (m)
Calculate sum of squares of each row in a matrix and return a vertical vector with the results.

RowsOf (M)
Gets the rows of a matrix as a vertical vector. Each element of the vector is a horizontal vector that is the corresponding row of

SetMatrixSize (M,rows,columns)
Make new matrix of given size from old one. That is, a new matrix will be returned to which the old one is copied. Entries that don't fit are clipped and extra space is filled with zeros. If

ShuffleVector (v)
Shuffle elements in a vector. Return

SortVector (v)
Sort vector elements in an increasing order.

StripZeroColumns (M)
Removes any all-zero columns of

StripZeroRows (M)
Removes any all-zero rows of

Submatrix (m,r,c)
Return column(s) and row(s) from a matrix. This is just equivalent to

SwapRows (m,row1,row2)
Swap two rows in a matrix.

UpperTriangular (M)
Returns a copy of the matrix

columns (M)
Get the number of columns of a matrix.

elements (M)
Get the total number of elements of a matrix. This is the number of columns times the number of rows.

ones (rows,columns...)
Make an matrix of all ones (or a row vector if only one argument is given). Returns

rows (M)
Get the number of rows of a matrix.

zeros (rows,columns...)
Make a matrix of all zeros (or a row vector if only one argument is given). Returns

AuxiliaryUnitMatrix (n)
Get the auxiliary unit matrix of size
See

BilinearForm (v,A,w)
Evaluate (v,w) with respect to the bilinear form given by the matrix A.

BilinearFormFunction (A)
Return a function that evaluates two vectors with respect to the bilinear form given by A.

CharacteristicPolynomial (M)
Aliases:
Get the characteristic polynomial as a vector. That is, return the coefficients of the polynomial starting with the constant term. This is the polynomial defined by
See

CharacteristicPolynomialFunction (M)
Get the characteristic polynomial as a function. This is the polynomial defined by

ColumnSpace (M)
Get a basis matrix for the columnspace of a matrix. That is, return a matrix whose columns are the basis for the column space of

CommutationMatrix (m, n)
Return the commutation matrix

CompanionMatrix (p)
Companion matrix of a polynomial (as vector).

ConjugateTranspose (M)
Conjugate transpose of a matrix (adjoint). This is the same as the
See

Convolution (a,b)
Aliases:
Calculate convolution of two horizontal vectors.

ConvolutionVector (a,b)
Calculate convolution of two horizontal vectors. Return result as a vector and not added together.

CrossProduct (v,w)
CrossProduct of two vectors in R

DeterminantalDivisorsInteger (M)
Get the determinantal divisors of an integer matrix (not its characteristic).

DirectSum (M,N...)
Direct sum of matrices.

DirectSumMatrixVector (v)
Direct sum of a vector of matrices.

Eigenvalues (M)
Aliases:
Get the eigenvalues of a square matrix. Currently only works for matrices of size up to 4 by 4, or for triangular matrices (for which the eigenvalues are on the diagonal).
See

Eigenvectors (M)
Eigenvectors (M, &eigenvalues)
Eigenvectors (M, &eigenvalues, &multiplicities)
Get the eigenvectors of a square matrix. Optionally get also the eigenvalues and their algebraic multiplicities. Currently only works for matrices of size up to 2 by 2.
See

GramSchmidt (v,B...)
Apply the Gram-Schmidt process (to the columns) with respect to inner product given by
See

HankelMatrix (c,r)
Hankel matrix.

HilbertMatrix (n)
Hilbert matrix of order
See

Image (T)
Get the image (columnspace) of a linear transform.

InfNorm (v)
Get the Inf Norm of a vector, sometimes called the sup norm or the max norm.

InvariantFactorsInteger (M)
Get the invariant factors of a square integer matrix (not its characteristic).

InverseHilbertMatrix (n)
Inverse Hilbert matrix of order

IsHermitian (M)
Is a matrix Hermitian. That is, is it equal to its conjugate transpose.
See

IsInSubspace (v,W)
Test if a vector is in a subspace.

IsInvertible (n)
Is a matrix (or number) invertible (Integer matrix is invertible if and only if it is invertible over the integers).

IsInvertibleField (n)
Is a matrix (or number) invertible over a field.

IsNormal (M)
Is
See

IsPositiveDefinite (M)
Is
Note that some authors (for example Mathworld) do not require that
See

IsPositiveSemidefinite (M)
Is
Note that some authors do not require that
See

IsSkewHermitian (M)
Is a matrix skew-Hermitian. That is, is the conjugate transpose equal to negative of the matrix.
See

IsUnitary (M)
Is a matrix unitary? That is, does
See

JordanBlock (n,lambda)
Aliases:
Get the Jordan block corresponding to the eigenvalue
See

Kernel (T)
Get the kernel (nullspace) of a linear transform.
(See

KroneckerProduct (M, N)
Aliases:
Compute the Kronecker product (tensor product in standard basis) of two matrices.
See

LUDecomposition (A, L, U)
Get the LU decomposition of
This is the LU decomposition of a matrix aka Crout and/or Cholesky reduction. (ISBN 0-201-11577-8 pp.99-103) The upper triangular matrix features a diagonal of values 1 (one). This is not Doolittle's Method, which features the 1's diagonal on the lower matrix.
Not all matrices have LU decompositions, for example
See

Minor (M,i,j)
Get the
See

NonPivotColumns (M)
Return the columns that are not the pivot columns of a matrix.

Norm (v,p...)
Aliases:
Get the p Norm (or 2 Norm if no p is supplied) of a vector.

NullSpace (T)
Get the nullspace of a matrix. That is the kernel of the linear mapping that the matrix represents. This is returned as a matrix whose column space is the nullspace of
See

Nullity (M)
Aliases:
Get the nullity of a matrix. That is, return the dimension of the nullspace; the dimension of the kernel of
See

OrthogonalComplement (M)
Get the orthogonal complement of the columnspace.

PivotColumns (M)
Return pivot columns of a matrix, that is columns that have a leading 1 in row reduced form. Also returns the row where they occur.

Projection (v,W,B...)
Projection of vector

QRDecomposition (A, Q)
Get the QR decomposition of a square matrix
See

RayleighQuotient (A,x)
Return the Rayleigh quotient (also called the Rayleigh-Ritz quotient or ratio) of a matrix and a vector.
See

RayleighQuotientIteration (A,x,epsilon,maxiter,vecref)
Find eigenvalues of
See

Rank (M)
Aliases:
Get the rank of a matrix.
See

RosserMatrix ()
Returns the Rosser matrix, which is a classic symmetric eigenvalue test problem.

Rotation2D (angle)
Aliases:
Return the matrix corresponding to rotation around origin in R

Rotation3DX (angle)
Return the matrix corresponding to rotation around origin in R

Rotation3DY (angle)
Return the matrix corresponding to rotation around origin in R

Rotation3DZ (angle)
Return the matrix corresponding to rotation around origin in R

RowSpace (M)
Get a basis matrix for the rowspace of a matrix.

SesquilinearForm (v,A,w)
Evaluate (v,w) with respect to the sesquilinear form given by the matrix A.

SesquilinearFormFunction (A)
Return a function that evaluates two vectors with respect to the sesquilinear form given by A.

SmithNormalFormField (A)
Returns the Smith normal form of a matrix over fields (will end up with 1's on the diagonal).
See

SmithNormalFormInteger (M)
Return the Smith normal form for square integer matrices over integers (not its characteristic).

SolveLinearSystem (M,V,args...)
Solve linear system Mx=V, return solution V if there is a unique solution,

ToeplitzMatrix (c, r...)
Return the Toeplitz matrix constructed given the first column c and (optionally) the first row r. If only the column c is given then it is conjugated and the nonconjugated version is used for the first row to give a Hermitian matrix (if the first element is real of course).
See

Trace (M)
Aliases:
Calculate the trace of a matrix. That is the sum of the diagonal elements.
See

Transpose (M)
Transpose of a matrix. This is the same as the
See

VandermondeMatrix (v)
Aliases:
Return the Vandermonde matrix.
See

VectorAngle (v,w,B...)
The angle of two vectors with respect to inner product given by

VectorSpaceDirectSum (M,N)
The direct sum of the vector spaces M and N.

VectorSubspaceIntersection (M,N)
Intersection of the subspaces given by M and N.

VectorSubspaceSum (M,N)
The sum of the vector spaces M and N, that is {w | w=m+n, m in M, n in N}.

adj (m)
Aliases:
Get the classical adjoint (adjugate) of a matrix.

cref (M)
Aliases:
Compute the Column Reduced Echelon Form.

det (M)
Aliases:
Get the determinant of a matrix.
See

ref (M)
Aliases:
Get the row echelon form of a matrix. That is, apply gaussian elimination but not backaddition to
See

rref (M)
Aliases:
Get the reduced row echelon form of a matrix. That is, apply gaussian elimination together with backaddition to
See
Combinatorics

Catalan (n)
Get
See

Combinations (k,n)
Get all combinations of k numbers from 1 to n as a vector of vectors. (See also

DoubleFactorial (n)
Double factorial:
See

Factorial (n)
Factorial:
See

FallingFactorial (n,k)
Falling factorial:
See

Fibonacci (x)
Aliases:
Calculate
See

FrobeniusNumber (v,arg...)
Calculate the Frobenius number. That is calculate smallest number that cannot be given as a non-negative integer linear combination of a given vector of non-negative integers. The vector can be given as separate numbers or a single vector. All the numbers given should have GCD of 1.
See

GaloisMatrix (combining_rule)
Galois matrix given a linear combining rule (a_1*x_+...+a_n*x_n=x_(n+1)).

FrobeniusNumber (n,v)
Find the vector
See

HarmonicNumber (n,r)
Aliases:
Harmonic Number, the

Hofstadter (n)
Hofstadter's function q(n) defined by q(1)=1, q(2)=1, q(n)=q(n-q(n-1))+q(n-q(n-2)).

LinearRecursiveSequence (seed_values,combining_rule,n)
Compute linear recursive sequence using Galois stepping.

Multinomial (v,arg...)
Calculate multinomial coefficients. Takes a vector of
(a+b+c)! / (a!b!c!)
The formula for
See

NextCombination (v,n)
Get combination that would come after v in call to combinations, first combination should be
For example with Combination you would normally write a loop like:

Pascal (i)
Get the Pascal's triangle as a matrix. This will return an
See

Permutations (k,n)
Get all permutations of
See

RisingFactorial (n,k)
Aliases:
(Pochhammer) Rising factorial: (n)_k = n(n+1)...(n+(k-1)).
See

StirlingNumberFirst (n,m)
Aliases:
Stirling number of the first kind.
See

StirlingNumberSecond (n,m)
Aliases:
Stirling number of the second kind.
See

Subfactorial (n)
Subfactorial: n! times sum_{k=1}^n (-1)^k/k!.

Triangular (nth)
Calculate the
See

nCr (n,r)
Aliases:
Calculate combinations, that is, the binomial coefficient.
See

nPr (n,r)
Calculate the number of permutations of size
Calculus

CompositeSimpsonsRule (f,a,b,n)
Integration of f by Composite Simpson's Rule on the interval [a,b] with n subintervals with error of max(f'''')*h^4*(b-a)/180, note that n should be even.
See

CompositeSimpsonsRuleTolerance (f,a,b,FourthDerivativeBound,Tolerance)
Integration of f by Composite Simpson's Rule on the interval [a,b] with the number of steps calculated by the fourth derivative bound and the desired tolerance.

Derivative (f,x0)
Attempt to calculate derivative by trying first symbolically and then numerically.

EvenPeriodicExtension (f,L)
Return a function that is the even periodic extension of
See also

FourierSeriesFunction (a,b,L)
Return a function that is a Fourier series with the coefficients given by the vectors
See

InfiniteProduct (func,start,inc)
Try to calculate an infinite product for a single parameter function.

InfiniteProduct2 (func,arg,start,inc)
Try to calculate an infinite product for a double parameter function with func(arg,n).

InfiniteSum (func,start,inc)
Try to calculate an infinite sum for a single parameter function.

InfiniteSum2 (func,arg,start,inc)
Try to calculate an infinite sum for a double parameter function with func(arg,n).

IsContinuous (f,x0)
Try and see if a real-valued function is continuous at x0 by calculating the limit there.

IsDifferentiable (f,x0)
Test for differentiability by approximating the left and right limits and comparing.

LeftLimit (f,x0)
Calculate the left limit of a real-valued function at x0.

Limit (f,x0)
Calculate the limit of a real-valued function at x0. Tries to calculate both left and right limits.

MidpointRule (f,a,b,n)
Integration by midpoint rule.

NumericalDerivative (f,x0)
Aliases:
Attempt to calculate numerical derivative.

NumericalFourierSeriesCoefficients (f,L,N)
Return a vector of vectors

NumericalFourierSeriesFunction (f,L,N)
Return a function that is the Fourier series of

NumericalFourierCosineSeriesCoefficients (f,L,N)
Return a vector of coefficients of the cosine Fourier series of
See

NumericalFourierCosineSeriesFunction (f,L,N)
Return a function that is the cosine Fourier series of

NumericalFourierSineSeriesCoefficients (f,L,N)
Return a vector of coefficients of the sine Fourier series of
See

NumericalFourierSineSeriesFunction (f,L,N)
Return a function that is the sine Fourier series of

NumericalIntegral (f,a,b)
Integration by rule set in NumericalIntegralFunction of f from a to b using NumericalIntegralSteps steps.

NumericalLeftDerivative (f,x0)
Attempt to calculate numerical left derivative.

NumericalLimitAtInfinity (_f,step_fun,tolerance,successive_for_success,N)
Attempt to calculate the limit of f(step_fun(i)) as i goes from 1 to N.

NumericalRightDerivative (f,x0)
Attempt to calculate numerical right derivative.

OddPeriodicExtension (f,L)
Return a function that is the odd periodic extension of
See also

OneSidedFivePointFormula (f,x0,h)
Compute one-sided derivative using five point formula.

OneSidedThreePointFormula (f,x0,h)
Compute one-sided derivative using three-point formula.

PeriodicExtension (f,a,b)
Return a function that is the periodic extension of
See also

RightLimit (f,x0)
Calculate the right limit of a real-valued function at x0.

TwoSidedFivePointFormula (f,x0,h)
Compute two-sided derivative using five-point formula.

TwoSidedThreePointFormula (f,x0,h)
Compute two-sided derivative using three-point formula.
Functions

Argument (z)
Aliases:
argument (angle) of complex number.

BesselJ0 (x)
Bessel function of the first kind of order 0. Only implemented for real numbers.
See

BesselJ1 (x)
Bessel function of the first kind of order 1. Only implemented for real numbers.

BesselJn (n,x)
Bessel function of the first kind of order

BesselY0 (x)
Bessel function of the second kind of order 0. Only implemented for real numbers.

BesselY1 (x)
Bessel function of the second kind of order 1. Only implemented for real numbers.

BesselYn (n,x)
Bessel function of the second kind of order

DirichletKernel (n,t)
Dirichlet kernel of order n.

DiscreteDelta (v)
Returns 1 if and only if all elements are zero.

ErrorFunction (x)
Aliases:
The error function, 2/sqrt(pi) * int_0^x e^(-t^2) dt.
See

FejerKernel (n,t)
Fejer kernel of order
See

GammaFunction (x)
Aliases:
The Gamma function. Currently only implemented for real values.
See

KroneckerDelta (v)
Returns 1 if and only if all elements are equal.

LambertW (x)
The principal branch of Lambert W function computed for only real values greater than or equal to
See

LambertWm1 (x)
The minus-one branch of Lambert W function computed for only real values greater than or equal to

MinimizeFunction (func,x,incr)
Find the first value where f(x)=0.

MoebiusDiskMapping (a,z)
Moebius mapping of the disk to itself mapping a to 0.
See

MoebiusMapping (z,z2,z3,z4)
Moebius mapping using the cross ratio taking z2,z3,z4 to 1,0, and infinity respectively.

MoebiusMappingInftyToInfty (z,z2,z3)
Moebius mapping using the cross ratio taking infinity to infinity and z2,z3 to 1 and 0 respectively.

MoebiusMappingInftyToOne (z,z3,z4)
Moebius mapping using the cross ratio taking infinity to 1 and z3,z4 to 0 and infinity respectively.

MoebiusMappingInftyToZero (z,z2,z4)
Moebius mapping using the cross ratio taking infinity to 0 and z2,z4 to 1 and infinity respectively.

PoissonKernel (r,sigma)
Poisson kernel on D(0,1) (not normalized to 1, that is integral of this is 2pi).

PoissonKernelRadius (r,sigma)
Poisson kernel on D(0,R) (not normalized to 1).

RiemannZeta (x)
Aliases:
The Riemann zeta function. Currently only implemented for real values.
See

UnitStep (x)
The unit step function is 0 for xlt;0, 1 otherwise. This is the integral of the Dirac Delta function. Also called the Heaviside function.
See

cis (x)
The

deg2rad (x)
Convert degrees to radians.

rad2deg (x)
Convert radians to degrees.

sinc (x)
Calculates the unnormalized sinc function, that is
See
Equation Solving

CubicFormula (p)
Compute roots of a cubic (degree 3) polynomial using the cubic formula. The polynomial should be given as a vector of coefficients. That is
See

EulersMethod (f,x0,y0,x1,n)
Use classical Euler's method to numerically solve y'=f(x,y) for initial
Systems can be solved by just having
See

EulersMethodFull (f,x0,y0,x1,n)
Use classical Euler's method to numerically solve y'=f(x,y) for initial

FindRootBisection (f,a,b,TOL,N)
Find root of a function using the bisection method.

FindRootFalsePosition (f,a,b,TOL,N)
Find root of a function using the method of false position.

FindRootMullersMethod (f,x0,x1,x2,TOL,N)
Find root of a function using the Muller's method.

FindRootSecant (f,a,b,TOL,N)
Find root of a function using the secant method.

HalleysMethod (f,df,ddf,guess,epsilon,maxn)
Find zeros using Halleys's method.
See also
Example to find the square root of 10:
See

NewtonsMethod (f,df,guess,epsilon,maxn)
Find zeros using Newton's method.
See also
Example to find the square root of 10:
See

PolynomialRoots (p)
Compute roots of a polynomial (degrees 1 through 4) using one of the formulas for such polynomials. The polynomial should be given as a vector of coefficients. That is
The function calls

QuadraticFormula (p)
Compute roots of a quadratic (degree 2) polynomial using the quadratic formula. The polynomial should be given as a vector of coefficients. That is
See

QuarticFormula (p)
Compute roots of a quartic (degree 4) polynomial using the quartic formula. The polynomial should be given as a vector of coefficients. That is
See

RungeKutta (f,x0,y0,x1,n)
Use classical non-adaptive fourth order Runge-Kutta method to numerically solve y'=f(x,y) for initial
See

RungeKuttaFull (f,x0,y0,x1,n)
Use classical non-adaptive fourth order Runge-Kutta method to numerically solve y'=f(x,y) for initial
Statistics

Average (m)
Aliases:
Calculate average of an entire matrix.
See

GaussDistribution (x,sigma)
Integral of the GaussFunction from 0 to
See

GaussFunction (x,sigma)
The normalized Gauss distribution function (the normal curve).

Median (m)
Aliases:
Calculate median of an entire matrix.
See

PopulationStandardDeviation (m)
Aliases:
Calculate the population standard deviation of a whole matrix.

RowAverage (m)
Aliases:
Calculate average of each row in a matrix.

RowMedian (m)
Calculate median of each row in a matrix and return a column vector of the medians.

RowPopulationStandardDeviation (m)
Aliases:
Calculate the population standard deviations of rows of a matrix and return a vertical vector.

RowStandardDeviation (m)
Aliases:
Calculate the standard deviations of rows of a matrix and return a vertical vector.

StandardDeviation (m)
Aliases:
Calculate the standard deviation of a whole matrix.
Polynomials

AddPoly (p1,p2)
Add two polynomials (vectors).

DividePoly (p,q,amp;r)
Divide two polynomials (as vectors) using long division. Returns the quotient of the two polynomials. The optional argument
See

IsPoly (p)
Check if a vector is usable as a polynomial.

MultiplyPoly (p1,p2)
Multiply two polynomials (as vectors).

NewtonsMethodPoly (poly,guess,epsilon,maxn)
Find a root of a polynomial using Newton's method.
See also
Example to find the square root of 10:

Poly2ndDerivative (p)
Take second polynomial (as vector) derivative.

PolyDerivative (p)
Take polynomial (as vector) derivative.

PolyToFunction (p)
Make function out of a polynomial (as vector).

PolyToString (p,var...)
Make string out of a polynomial (as vector).

SubtractPoly (p1,p2)
Subtract two polynomials (as vectors).

TrimPoly (p)
Trim zeros from a polynomial (as vector).
Set Theory

Intersection (X,Y)
Returns a set theoretic intersection of X and Y (X and Y are vectors pretending to be sets).

IsIn (x,X)
Returns

IsSubset (X, Y)
Returns

MakeSet (X)
Returns a vector where every element of X appears only once.

SetMinus (X,Y)
Returns a set theoretic difference X-Y (X and Y are vectors pretending to be sets).

Union (X,Y)
Returns a set theoretic union of X and Y (X and Y are vectors pretending to be sets).
Commutative Algebra

MacaulayBound (c,d)
For a Hilbert function that is c for degree d, given the Macaulay bound for the Hilbert function of degree d+1 (The c^lt;dgt; operator from Green's proof).

MacaulayLowerOperator (c,d)
The c_lt;dgt; operator from Green's proof of Macaulay's Theorem.

MacaulayRep (c,d)
Return the dth Macaulay representation of a positive integer c.
Miscellaneous

ASCIIToString (vec)
Convert a vector of ASCII values to a string.

AlphabetToString (vec,alphabet)
Convert a vector of 0-based alphabet values (positions in the alphabet string) to a string.

StringToASCII (str)
Convert a string to a vector of ASCII values.

StringToAlphabet (str,alphabet)
Convert a string to a vector of 0-based alphabet values (positions in the alphabet string), -1's for unknown letters.
Symbolic Operations

SymbolicDerivative (f)
Attempt to symbolically differentiate the function f, where f is a function of one variable.
Examples:

SymbolicDerivativeTry (f)
Attempt to symbolically differentiate the function f, where f is a function of one variable, returns

SymbolicNthDerivative (f,n)
Attempt to symbolically differentiate a function n times. (See

SymbolicNthDerivativeTry (f,n)
Attempt to symbolically differentiate a function n times quietly and return

SymbolicTaylorApproximationFunction (f,x0,n)
Attempt to construct the Taylor approximation function around x0 to the nth degree. (See

ExportPlot (file,type)
ExportPlot (file)
Export the contents of the plotting window to a file. The type is a string that specifies the file type to use, "png", "eps", or "ps". If the type is not specified, then it is taken to be the extension, in which case the extension must be ".png", ".eps", or ".ps".
Note that files are overwritten without asking.
On successful export, true is returned. Otherwise error is printed and exception is raised.
Examples:

LinePlot (func1,func2,func3,...)
LinePlot (func1,func2,func3,x1,x2)
LinePlot (func1,func2,func3,x1,x2,y1,y2)
LinePlot (func1,func2,func3,[x1,x2])
LinePlot (func1,func2,func3,[x1,x2,y1,y2])
Plot a function (or several functions) with a line. First (up to 10) arguments are functions, then optionally you can specify the limits of the plotting window as
The parameter
Examples:

LinePlotClear ()
Show the line plot window and clear out functions and any other lines that were drawn.

LinePlotDrawLine (x1,y1,x2,y2,...)
LinePlotDrawLine (v,...)
Draw a line from
Extra parameters can be added to specify line color, thickness, arrows, the plotting window, or legend. You can do this by adding an argument string
The color should be either a string indicating the common english word for the color that GTK will recognize such as
The window should be given as usual as
Arrow specification should be
Finally, legend should be a string that can be used as the legend in the graph. That is, if legends are being printed.
Examples:

LinePlotParametric (xfunc,yfunc,...)
LinePlotParametric (xfunc,yfunc,t1,t2,tinc)
LinePlotParametric (xfunc,yfunc,t1,t2,tinc,x1,x2,y1,y2)
LinePlotParametric (xfunc,yfunc,t1,t2,tinc,[x1,x2,y1,y2])
LinePlotParametric (xfunc,yfunc,t1,t2,tinc,"fit")
Plot a parametric function with a line. First come the functions for
If x and y limits are not specified, then the currently set limits apply (See

LinePlotCParametric (func,...)
LinePlotCParametric (func,t1,t2,tinc)
LinePlotCParametric (func,t1,t2,tinc,x1,x2,y1,y2)
Plot a parametric complex valued function with a line. First comes the function that returns
If limits are not specified, then the currently set limits apply (See

PlotCanvasFreeze ()
Freeze drawing of the canvas plot temporarily. Useful if you need to draw a bunch of elements and want to delay drawing everything to avoid flicker in an animation. After everything has been drawn you should call
The canvas is always thawed after end of any execution, so it will never remain frozen. The moment a new command line is shown for example the plot canvas is thawed automatically. Also note that calls to freeze and thaw may be safely nested.

PlotCanvasThaw ()
Thaw the plot canvas frozen by

SlopefieldClearSolutions ()
Clears the solutions drawn by the

SlopefieldDrawSolution (x, y, dx)
When a slope field plot is active, draw a solution with the specified initial condition. The standard Runge-Kutta method is used with increment

SlopefieldPlot (func)
SlopefieldPlot (func,x1,x2,y1,y2)
Plot a slope field. The function
Examples:

SurfacePlot (func)
SurfacePlot (func,x1,x2,y1,y2,z1,z2)
SurfacePlot (func,x1,x2,y1,y2)
SurfacePlot (func,[x1,x2,y1,y2,z1,z2])
SurfacePlot (func,[x1,x2,y1,y2])
Plot a surface function that takes either two arguments or a complex number. First comes the function then optionally limits as
If the z limits are not specified then the maxima and minima of the function are used.
Examples:

SurfacePlotData (data)
SurfacePlotData (data,label)
SurfacePlotData (data,x1,x2,y1,y2,z1,z2)
SurfacePlotData (data,label,x1,x2,y1,y2,z1,z2)
SurfacePlotData (data,[x1,x2,y1,y2,z1,z2])
SurfacePlotData (data,label,[x1,x2,y1,y2,z1,z2])
Plot a surface from data. The data is an n by 3 matrix whose rows are the x, y and z coordinates. The data can also be simply a vector whose length is a multiple of 3 and so contains the tripples of x, y, z. The data should contain at least 3 points.
Optionally we can give the label and also optionally the limits. If limits are not given, they are computed from the data,
Examples:
Here's an example of how to plot in polar coordinates, in particular how to plot the function

SurfacePlotDataGrid (data,[x1,x2,y1,y2])
SurfacePlotDataGrid (data,[x1,x2,y1,y2,z1,z2])
SurfacePlotDataGrid (data,[x1,x2,y1,y2],label)
SurfacePlotDataGrid (data,[x1,x2,y1,y2,z1,z2],label)
Plot a surface from regular rectangular data. The data is given in a n by m matrix where the rows are the x coordinate and the columns are the y coordinate. The x coordinate is divided into equal n-1 subintervals and y coordinate is divided into equal m-1 subintervals. The limits
Optionally we can give the label, if label is not given then empty label is used.
Examples:

VectorfieldClearSolutions ()
Clears the solutions drawn by the

VectorfieldDrawSolution (x, y, dt, tlen)
When a vector field plot is active, draw a solution with the specified initial condition. The standard Runge-Kutta method is used with increment

VectorfieldPlot (funcx, funcy)
VectorfieldPlot (funcx, funcy, x1, x2, y1, y2)
Plot a two dimensional vector field. The function
Optionally you can specify the limits of the plotting window as
Examples:
Example Programs in GEL
Here is a function that calculates factorials:
With indentation it becomes:
This is a direct port of the factorial function from the
function f(x) = prod k=1 to x do k
By far the easiest way to define a factorial function would be using the product loop as follows. This is not only the shortest and fastest, but also probably the most readable version.
Here is a larger example, this basically redefines the internal
To configure
Changing Settings with GEL
Many of the settings in Genius are simply global variables, and can be evaluated and assigned to in the same way as normal variables. See
MaxDigits = 12
As an example, you can set the maximum number of digits in a result to 12 by typing:
Output
Maximum digits to output
The maximum digits in a result (
Results as floats
If the results should be always printed as floats (
Floats in scientific notation
If floats should be in scientific notation (
Always print full expressions
Should we print out full expressions for non-numeric return values (longer than a line) (
Use mixed fractions
If fractions should be printed as mixed fractions such as "1 1/3" rather than "4/3". (
Display 0.0 when floating point number is less than 10^-x (0=never chop)
How to chop output. But only when other numbers nearby are large. See the documentation of the paramter
Only chop numbers when another number is greater than 10^-x
When to chop output. This is set by the paramter
Remember output settings across sessions
Should the output settings in the
If unchecked, either the default or any previously saved settings are used each time Genius starts up. Note that settings are saved at the end of the session, so if you wish to change the defaults check this box, restart
Display errors in a dialog
If set the errors will be displayed in a separate dialog, if unset the errors will be printed on the console.
Display information messages in a dialog
If set the information messages will be displayed in a separate dialog, if unset the information messages will be printed on the console.
Maximum errors to display
The maximum number of errors to return on one evaluation (
In addition to these preferences, there are some preferences that can only be changed by setting them in the workspace console. For others that may affect the output see
IntegerOutputBase
The base that will be used to output integers
OutputStyle
A string, can be
Precision
Floating point precision
The floating point precision in bits (
Remember precision setting across sessions
Should the precision setting be remembered for the next session. If unchecked, either the default or any previously saved setting is used each time Genius starts up. Note that settings are saved at the end of the session, so if you wish to change the default check this box, restart genius and then uncheck it again.
Terminal
Terminal refers to the console in the work area.
Scrollback lines
Lines of scrollback in the terminal.
Font
The font to use on the terminal.
Black on white
If to use black on white on the terminal.
Blinking cursor
If the cursor in the terminal should blink when the terminal is in focus. This can sometimes be annoying and it generates idle traffic if you are using Genius remotely.
Memory
Maximum number of nodes to allocate
Internally all data is put onto small nodes in memory. This gives a limit on the maximum number of nodes to allocate for computations. This limit avoids the problem of running out of memory if you do something by mistake that uses too much memory, such as a recursion without end. This could slow your computer and make it hard to even interrupt the program.
Once the limit is reached,
Setting the limit to zero means there is no limit to the amount of memory that genius uses.
About

To report a bug or make a suggestion regarding this application or this manual, send email to me (the author) or post to the mailing list (see the web page).
This program is distributed under the terms of the GNU General Public license as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version. A copy of this license can be found at this
Jiří Lebl was during various parts of the development partially supported for the work by NSF grant DMS 0900885, the University of Illinois at Urbana-Champaign, the University of California at San Diego, and the University of Wisconsin-Madison. The software has been used for both teaching and research.
translator-credits
University of Wisconsin-Madison
load
cd
plugin
AskButtons
AskString
Compose
ComposePower
Evaluate
Identity
IntegerFromBoolean
IsBoolean
IsDefined
IsFunction
IsFunctionOrIdentifier
IsFunctionRef
IsMatrix
IsNull
IsString
IsValue
Parse
SetFunctionFlags
SetHelp
SetHelpAlias
chdir
display
error
print
printn
protect
ProtectAll
set
string
undefine
UndefineAll
unprotect
UserVariables
wait
ChopTolerance
ContinuousNumberOfTries
ContinuousSFS
ContinuousTolerance
DerivativeNumberOfTries
DerivativeSFS
DerivativeTolerance
ErrorFunctionTolerance
FloatPrecision
FullExpressions
GaussDistributionTolerance
IsPrimeMillerRabinReps
LinePlotDrawLegends
LinePlotDrawAxisLabels
LinePlotVariableNames
LinePlotWindow
MaxDigits
MaxErrors
MixedFractions
NumericalIntegralFunction
NumericalIntegralSteps
Steps to perform in
OutputChopExponent
OutputChopWhenExponent
ResultsAsFloats
ScientificNotation
SlopefieldTicks
SumProductNumberOfTries
How many iterations to try for
SumProductSFS
SumProductTolerance
Tolerance for
SurfacePlotDrawLegends
SurfacePlotVariableNames
SurfacePlotWindow
VectorfieldNormalized
VectorfieldTicks
AbsoluteValue
Chop
ComplexConjugate
Denominator
FractionalPart
Im
IntegerQuotient
IsComplex
IsComplexRational
IsFloat
IsGaussInteger
IsInteger
IsNonNegativeInteger
IsPositiveInteger
IsRational
IsReal
Numerator
Re
Sign
ceil
exp
float
floor
ln
log
log10
log2
max
min
rand
randint
round
sqrt
trunc
acos
acosh
acot
acoth
acsc
acsch
asec
asech
asin
asinh
atan
atanh
atan2
cos
cosh
cot
coth
csc
csch
sec
sech
sin
sinh
tan
tanh
AreRelativelyPrime
BernoulliNumber
ChineseRemainder
CombineFactorizations
ConvertFromBase
ConvertToBase
DiscreteLog
Divides
EulerPhi
ExactDivision
Factorize
Factors
FermatFactorization
FindPrimitiveElementMod
FindRandomPrimitiveElementMod
IndexCalculus
IndexCalculusPrecalculation
IsEven
IsMersennePrimeExponent
IsNthPower
IsOdd
IsPerfectPower
IsPerfectSquare
IsPrime
IsPrimitiveMod
IsPrimitiveModWithPrimeFactors
IsPseudoprime
IsStrongPseudoprime
Jacobi
JacobiKronecker
LeastAbsoluteResidue
Legendre
LucasLehmer
LucasNumber
MaximalPrimePowerFactors
MillerRabinTest
MillerRabinTestSure
ModInvert
MoebiusMu
NextPrime
PadicValuation
PowerMod
Prime
PrimeFactors
PseudoprimeTest
RemoveFactor
SilverPohligHellmanWithFactorization
SqrtModPrime
StrongPseudoprimeTest
gcd
lcm
ApplyOverMatrix
ApplyOverMatrix2
ColumnsOf
ComplementSubmatrix
CompoundMatrix
CountZeroColumns
DeleteColumn
DeleteRow
DiagonalOf
DotProduct
ExpandMatrix
HermitianProduct
I
IndexComplement
IsDiagonal
IsIdentity
IsLowerTriangular
IsMatrixInteger
IsMatrixNonnegative
IsMatrixPositive
IsMatrixRational
IsMatrixReal
IsMatrixSquare
IsUpperTriangular
IsValueOnly
IsVector
IsZero
LowerTriangular
MakeDiagonal
MakeVector
MatrixProduct
MatrixSum
MatrixSumSquares
OuterProduct
ReverseVector
RowSum
RowSumSquares
RowsOf
SetMatrixSize
ShuffleVector
SortVector
StripZeroColumns
StripZeroRows
Submatrix
SwapRows
UpperTriangular
columns
elements
ones
rows
zeros
AuxiliaryUnitMatrix
BilinearForm
BilinearFormFunction
CharacteristicPolynomial
CharacteristicPolynomialFunction
ColumnSpace
CommutationMatrix
CompanionMatrix
ConjugateTranspose
Convolution
ConvolutionVector
CrossProduct
DeterminantalDivisorsInteger
DirectSum
DirectSumMatrixVector
Eigenvalues
Eigenvectors
GramSchmidt
HankelMatrix
HilbertMatrix
Image
InfNorm
InvariantFactorsInteger
InverseHilbertMatrix
IsHermitian
IsInSubspace
IsInvertible
IsInvertibleField
IsNormal
IsPositiveDefinite
IsPositiveSemidefinite
IsSkewHermitian
IsUnitary
JordanBlock
Kernel
LUDecomposition
See
Minor
NonPivotColumns
Norm
NullSpace
Nullity
OrthogonalComplement
PivotColumns
Projection
QRDecomposition
See
RayleighQuotient
RayleighQuotientIteration
Rank
RosserMatrix
Rotation2D
Rotation3DX
Rotation3DY
Rotation3DZ
RowSpace
SesquilinearForm
SesquilinearFormFunction
SmithNormalFormField
SmithNormalFormInteger
SolveLinearSystem
ToeplitzMatrix
See
Trace
See
Transpose
See
VandermondeMatrix
VectorAngle
VectorSpaceDirectSum
VectorSubspaceIntersection
VectorSubspaceSum
adj
cref
det
ref
rref
Catalan
Combinations
DoubleFactorial
Factorial
FallingFactorial
Fibonacci
FrobeniusNumber
GaloisMatrix
GreedyAlgorithm
HarmonicNumber
Hofstadter
LinearRecursiveSequence
Multinomial
NextCombination
Pascal
Permutations
RisingFactorial
StirlingNumberFirst
StirlingNumberSecond
Subfactorial
Triangular
nCr
nPr
CompositeSimpsonsRule
CompositeSimpsonsRuleTolerance
Derivative
EvenPeriodicExtension
FourierSeriesFunction
InfiniteProduct
InfiniteProduct2
InfiniteSum
InfiniteSum2
IsContinuous
IsDifferentiable
LeftLimit
Limit
MidpointRule
NumericalDerivative
NumericalFourierSeriesCoefficients
NumericalFourierSeriesFunction
NumericalFourierCosineSeriesCoefficients
NumericalFourierCosineSeriesFunction
NumericalFourierSineSeriesCoefficients
NumericalFourierSineSeriesFunction
NumericalIntegral
NumericalLeftDerivative
NumericalLimitAtInfinity
NumericalRightDerivative
OddPeriodicExtension
OneSidedFivePointFormula
OneSidedThreePointFormula
PeriodicExtension
RightLimit
TwoSidedFivePointFormula
TwoSidedThreePointFormula
Argument
DirichletKernel
DiscreteDelta
ErrorFunction
FejerKernel
GammaFunction
See
KroneckerDelta
MinimizeFunction
MoebiusDiskMapping
MoebiusMapping
MoebiusMappingInftyToInfty
MoebiusMappingInftyToOne
MoebiusMappingInftyToZero
PoissonKernel
PoissonKernelRadius
RiemannZeta
See
UnitStep
cis
deg2rad
rad2deg
CubicFormula
EulersMethod
EulersMethodFull
FindRootBisection
Find root of a function using the bisection method.
FindRootFalsePosition
FindRootMullersMethod
FindRootSecant
Find root of a function using the secant method.
PolynomialRoots
QuadraticFormula
QuarticFormula
RungeKutta
RungeKuttaFull
Average
GaussDistribution
GaussFunction
Median
PopulationStandardDeviation
RowAverage
RowMedian
RowPopulationStandardDeviation
RowStandardDeviation
StandardDeviation
AddPoly
DividePoly
IsPoly
MultiplyPoly
NewtonsMethodPoly
Run newton's method on a polynomial to attempt to find a root, returns after two successive values are within epsilon or after maxn tries (then returns
Poly2ndDerivative
PolyDerivative
PolyToFunction
PolyToString
SubtractPoly
TrimPoly
Intersection
IsIn
IsSubset
MakeSet
SetMinus
Union
ASCIIToString
AlphabetToString
StringToASCII
StringToAlphabet
SymbolicDerivative
SymbolicDerivativeTry
SymbolicNthDerivative
SymbolicNthDerivativeTry
SymbolicTaylorApproximationFunction
LinePlot
LinePlotClear
LinePlotDrawLine
Extra parameters can be added to specify line color, thickness, arrows, and the plotting window. You can do this by adding a string
LinePlotParametric
LinePlotCParametric
SlopefieldClearSolutions
SlopefieldDrawSolution
SlopefieldPlot
SurfacePlot
SurfacePlotData
SurfacePlotDataGrid
VectorfieldClearSolutions
VectorfieldDrawSolution
VectorfieldPlot
@@image: 'figures/genius_window.eps'; md5=b2fe72c0dea70343a11a7bbc2225f985
@@image: 'figures/line_plot.eps'; md5=1977b7181c5d8ecb7d4348e1de79919b
@@image: 'figures/line_plot_graph.eps'; md5=201bfa54ba0797171d8910eb946354c1
@@image: 'figures/parametric.eps'; md5=52274a10d3e58dc8f883fdf3a48d5ad3
@@image: 'figures/parametric_graph.eps'; md5=223659107c58320edd6030193c89524c
@@image: 'figures/surface_graph.eps'; md5=b505c811ddf51b109722ccc53f176dd2
July 2011
Division.
Element by element division.
Equality operator (returns
Logical and.
Logical or.
Logical xor.
Logical not.
Negation operator.
Variable referencing (to pass a reference to something). See
Matrix conjugate transpose.
Matrix transpose, does not conjugate the entries.
Get the lowest integer more than or equal to n.
Make diagonal matrix from a vector.
Calculate sum of squares of each row in a matrix.