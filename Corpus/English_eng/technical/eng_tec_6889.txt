# language_name_wals:	English
# language_name_glotto:	English
# ISO_6393:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	part
# comments:	NA

// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Kitten Feeder"});
Creating the SpinButtons
// Create the first spinbutton using a function
 this._kittens = Gtk.SpinButton.new_with_range (1, 9001, 1);
 this._kittens.connect ("value-changed", Lang.bind (this, this._newValue));
We can use the new_with_range function to create a new SpinButton quickly. Its first parameter is the SpinButton's starting value, its second is the maximum value, and its third is how much to increment it when the plus or minus buttons are pressed.
After we create the first SpinButton, we connect its value-changed signal to a function which handles what happens when the number inside either SpinButton changes.
// Create an adjustment to use for the second spinbutton
 this._adjustment = new Gtk.Adjustment ({
 value: 1,
 lower: 0,
 upper: 9001,
 step_increment: 1,
 page_increment: 10 });

 // Create the second spinbutton
 this._tuna = new Gtk.SpinButton ({ adjustment: this._adjustment });
 this._tuna.connect ("value-changed", Lang.bind (this, this._newValue));

 // this._tuna.set_digits (1);
 // this._tuna.set_wrap (true);
If you want more fine-grained control over a SpinButton, or want to create a bunch of SpinButtons which all use the same parameters, you can create an object called an
The commented-out lines here show things you can do to customize your SpinButton. You can set the number of digits which go after the decimal point, for example, or tell it to wrap the number around if it goes past the upper or lower bounds that you set.
For the kitties' sake, please don't use set_digits to allow a decimal number of kittens.
Creating the rest of the UI
// Create the text labels to go with the spinbuttons
 this._startLabel = new Gtk.Label ({ label: "There are " });
 this._kittenLabel = new Gtk.Label ({ label: " kitten(s), and "});
 this._tunaLabel = new Gtk.Label ({ label: " can(s) of tuna."});
 this.perKitten = Math.floor((this._tuna.get_value() / this._kittens.get_value()));
 this._lastLabel = new Gtk.Label ({
 label: "That's " + this.perKitten + " can(s) of tuna per kitten." });
We create each
// Create a grid to put the spinbuttons and their labels in
 this._spinGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_bottom: 20 });

 // Attach everything to the grid
 this._spinGrid.attach (this._startLabel, 0, 0, 1, 1);
 this._spinGrid.attach (this._kittens, 1, 0, 1, 1);
 this._spinGrid.attach (this._kittenLabel, 2, 0, 1, 1);
 this._spinGrid.attach (this._tuna, 3, 0, 1, 1);
 this._spinGrid.attach (this._tunaLabel, 4, 0, 1, 1);

 // Create a main grid to hold it and the last label
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Attach the smaller grid and the last label to the main grid
 this._mainGrid.attach (this._spinGrid, 0, 0, 1, 1);
 this._mainGrid.attach (this._lastLabel, 0, 1, 1, 1);
Here we use
There isn't a wrong way to organize things in Grids, so long as you like how it turns out. In this case, the top Grid has a margin on the bottom to keep it evenly spaced from the bottom Label, and the bottom Label is inside a separate Grid so it will be centered relative to the Labels and SpinButtons on the top.
// Add the main grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },
Finally, we add the larger Grid to the window, then tell the window to show itself and all the widgets inside of it.
Function which handles the SpinButtons' numerical values being adjusted
_newValue: function () {

 // Update the label which shows how many cans there are per kitten
 this.perKitten = Math.floor((this._tuna.get_value() / this._kittens.get_value()))
 this._lastLabel.set_label ("That's " + this.perKitten + " can(s) of tuna per kitten.");

 }

});
Here we update the perKitten variable based on the SpinButtons' new values, and use the set_label property to refresh what _lastLabel shows. Since both SpinButtons have their value-changed signal connected to this function, every time either of the numbers changes this function will update the Label.
// Run the application
let app = new SpinButtonExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished SpinButtonExample class, and set the application running.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const SpinButtonExample = new Lang.Class({
 Name: 'SpinButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsspinbutton'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Kitten Feeder"});

 // Create the first spinbutton using a function
 this._kittens = Gtk.SpinButton.new_with_range (1, 9001, 1);
 this._kittens.connect ("value-changed", Lang.bind (this, this._newValue));

 // Create an adjustment to use for the second spinbutton
 this._adjustment = new Gtk.Adjustment ({
 value: 1,
 lower: 0,
 upper: 9001,
 step_increment: 1,
 page_increment: 10 });

 // Create the second spinbutton
 this._tuna = new Gtk.SpinButton ({ adjustment: this._adjustment });
 this._tuna.connect ("value-changed", Lang.bind (this, this._newValue));

 // this._tuna.set_digits (1);
 // this._tuna.set_wrap (true);

 // Create the text labels to go with the spinbuttons
 this._startLabel = new Gtk.Label ({ label: "There are " });
 this._kittenLabel = new Gtk.Label ({ label: " kitten(s), and "});
 this._tunaLabel = new Gtk.Label ({ label: " can(s) of tuna."});
 this.perKitten = Math.floor((this._tuna.get_value() / this._kittens.get_value()));
 this._lastLabel = new Gtk.Label ({
 label: "That's " + this.perKitten + " can(s) of tuna per kitten." });

 // Create a grid to put the spinbuttons and their labels in
 this._spinGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_bottom: 20 });

 // Attach everything to the grid
 this._spinGrid.attach (this._startLabel, 0, 0, 1, 1);
 this._spinGrid.attach (this._kittens, 1, 0, 1, 1);
 this._spinGrid.attach (this._kittenLabel, 2, 0, 1, 1);
 this._spinGrid.attach (this._tuna, 3, 0, 1, 1);
 this._spinGrid.attach (this._tunaLabel, 4, 0, 1, 1);

 // Create a main grid to hold it and the last label
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Attach the smaller grid and the last label to the main grid
 this._mainGrid.attach (this._spinGrid, 0, 0, 1, 1);
 this._mainGrid.attach (this._lastLabel, 0, 1, 1, 1);

 // Add the main grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _newValue: function () {

 // Update the label which shows how many cans there are per kitten
 this.perKitten = Math.floor((this._tuna.get_value() / this._kittens.get_value()))
 this._lastLabel.set_label ("That's " + this.perKitten + " can(s) of tuna per kitten.");

 }

});

// Run the application
let app = new SpinButtonExample ();
app.application.run (ARGV);

SpinButton (Python)
Retrieve an integer or floating-point number from the user.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="SpinButton Example", application=app)
 self.set_default_size(210, 70)
 self.set_border_width(5)

 # an adjustment (initial value, min value, max value,
 # step increment - press cursor keys or +/- buttons to see!,
 # page increment - not used here,
 # page size - not used here)
 ad = Gtk.Adjustment(0, 0, 100, 1, 0, 0)

 # a spin button for integers (digits=0)
 self.spin = Gtk.SpinButton(adjustment=ad, climb_rate=1, digits=0)
 # as wide as possible
 self.spin.set_hexpand(True)

 # we connect the signal "value-changed" emitted by the spinbutton with the callback
 # function spin_selected
 self.spin.connect("value-changed", self.spin_selected)

 # a label
 self.label = Gtk.Label()
 self.label.set_text("Choose a number")

 # a grid to attach the widgets
 grid = Gtk.Grid()
 grid.attach(self.spin, 0, 0, 1, 1)
 grid.attach(self.label, 0, 1, 2, 1)

 self.add(grid)

 # callback function: the signal of the spinbutton is used to change the
 # text of the label
 def spin_selected(self, event):
 self.label.set_text(
 "The number you selected is " + str(self.spin.get_value_as_int()) + ".")


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a SpinButton widget
A Gtk.Adjustment is needed to construct the Gtk.SpinButton. This is the representation of a value with a lower and upper bound, together with step and page increments, and a page size, and it is constructed as
In line 23 the signal
If you want the value of the spinbutton to wrap around when they exceed the maximum or the minimum, set

To get the value of the spinbutton as an integer, use

SpinButton (Vala)
Retrieve an integer or floating point number.
/* This is the application. */
public class MyApplication : Gtk.Application {
 Gtk.Label label;

 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {
 var window = new Gtk.ApplicationWindow (this);
 window.title = "SpinButton Example";
 window.set_default_size (210, 70);
 window.set_border_width (5);

 var spinbutton = new Gtk.SpinButton.with_range (0, 100, 1);
 spinbutton.set_hexpand (true);

 label = new Gtk.Label ("Choose a number");

 var grid = new Gtk.Grid ();
 grid.attach (spinbutton, 0, 0, 1, 1);
 grid.attach (label, 0, 1, 1, 1);

 spinbutton.value_changed.connect (this.value_changed_cb);

 window.add (grid);
 window.show_all ();
 }

 void value_changed_cb (Gtk.SpinButton spin) {
 label.set_text ("The number you selected is %.0f.".printf (spin.get_value()));
 }
}

/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/spinner.png' md5='d04f2d81f1d72c6c2f97e8729947dfed'
Spinner (C)
A spinner animation
Spinner
This Spinner is stopped and started by pressing the spacebar.
#include &lt;gtk/gtk.hgt;
 


 /*Global variable used to indicate active state of the
spinner. TRUE = active, FALSE = not-active. This is because 
there isn't a current function for C that does this for us*/
gboolean active; 
 


/*This is the callback function. It is a handler function 
which reacts to the signal. In this case, it will cause the 
spinner to start and stop according to how many times the user 
presses the spacebar.*/ 
static gboolean
key_pressed_event (GtkWidget *widget,
 GdkEvent *event,
 gpointer user_data)
{
 GtkWidget *spinner = user_data;
 guint keyval;
 
 /*Extracts the keyval from an event. And stores it in the variable 
 "keyval" (we give the function the address). In this case, the 
 event is GdkEventKey, a key press event*/
 gdk_event_get_keyval (event, &keyval); 

 /*Grabbing the boolean value from the spinner*/
 g_object_get (GTK_SPINNER (spinner), "active", &active, NULL);
 
 if (keyval == GDK_KEY_space) {
 if (active) {
 gtk_spinner_stop (GTK_SPINNER (spinner));
 }
 else {
 gtk_spinner_start (GTK_SPINNER (spinner));
 } 
 }
 
return TRUE;
}
 


static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *spinner;
 
 /*Create a window with a title, border width and a default size*/
 window = gtk_application_window_new (app);
 
 gtk_window_set_title (GTK_WINDOW (window), "Spinner Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);
 gtk_container_set_border_width (GTK_CONTAINER(window), 30);
 
 /*Create a spinner, with extra horizontal and vertical space*/
 spinner = gtk_spinner_new ();
 gtk_spinner_start (GTK_SPINNER (spinner));
 
 gtk_container_add (GTK_CONTAINER (window), spinner);
 
 /*Connecting the key-press-event signal to the callback*/
 g_signal_connect (GTK_WINDOW (window), "key-press-event", 
 G_CALLBACK (key_pressed_event), spinner);
 
 gtk_widget_show_all (window);
}
 



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;
 
 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 
 return status;
}


Spinner (JavaScript)
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Gdk = imports.gi.Gdk;
const Lang = imports.lang;

const SpinnerExample = new Lang.Class ({
 Name: 'Spinner Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jsspinner',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Spinner Example",
 default_height: 200,
 default_width: 200,
 border_width: 30 });

 // Create a spinner which starts spinning automatically
 this._spinner = new Gtk.Spinner ({active: true});
 this._window.add (this._spinner);

 // Connect a keypress event to the function that makes it start or stop spinning
 this._window.connect("key-press-event", Lang.bind(this, this._onKeyPress));

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onKeyPress: function(widget, event) {

 // Get the value of the key that was pressed
 let keyval = event.get_keyval()[1];

 // If it was the spacebar, toggle the spinner to start or stop
 if (keyval == Gdk.KEY_space) {
 if (this._spinner.active == true)
 this._spinner.stop();
 else
 this._spinner.start();
 }
 }


});

// Run the application
let app = new SpinnerExample ();
app.application.run (ARGV);


Spinner (Python)
from gi.repository import Gtk
from gi.repository import Gdk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Spinner Example", application=app)
 self.set_default_size(200, 200)
 self.set_border_width(30)

 # a spinner
 self.spinner = Gtk.Spinner()
 # that by default spins
 self.spinner.start()
 # add the spinner to the window
 self.add(self.spinner)

 # event handler
 # a signal from the keyboard (space) controls if the spinner stops/starts
 def do_key_press_event(self, event):
 # keyname is the symbolic name of the key value given by the event
 keyname = Gdk.keyval_name(event.keyval)
 # if it is "space"
 if keyname == "space":
 # and the spinner is active
 if self.spinner.get_property("active"):
 # stop the spinner
 self.spinner.stop()
 # if the spinner is not active
 else:
 # start it again
 self.spinner.start()
 # stop the signal emission
 return True


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)



Spinner (Vala)
public class MyWindow : Gtk.ApplicationWindow {

 Gtk.Widget spinner;

 internal MyWindow (MyApplication app) {

 Object (application: app, title: "Spinner Example");

 this.set_default_size (200, 200);
 this.border_width = 30;

 spinner = new Gtk.Spinner ();

 this.add (spinner);
 (spinner as Gtk.Spinner).active = true;
 spinner.show ();
 }

 protected override bool key_press_event (Gdk.EventKey event) {

 //print (Gdk.keyval_name(event.keyval) +"\
");
 if (Gdk.keyval_name(event.keyval) == "space") {

 if ((spinner as Gtk.Spinner).active) {
 (spinner as Gtk.Spinner).stop ();
 //spinner.visible = false;
 }
 else {
 (spinner as Gtk.Spinner).start ();
 //spinner.visible = true;
 }
 }
 return true;
 }
}

public class MyApplication : Gtk.Application {

 protected override void activate () {
 MyWindow window = new MyWindow (this);
 window.show ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.spinner");
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}



external ref='media/statusbar3.png' md5='60c71604fb44656237ee66dfb39a8689'
Statusbar (C)
Report messages of minor importance to the user
Statusbar
This statusbar is used to demonstrate how messages are stacked in a last-in-first-out order. The message at the top of the stack is always the one displayed.
#include &lt;gtk/gtk.hgt;



/*Callback function in which pushes an item onto the statusbar*/
static void 
push_item (GtkWidget *widget,
 gpointer data)
{
 GtkWidget *status_bar = data;

 /*Create a context id, which is used to uniquely identify 
 *the source of a message*/
 guint context_id = gtk_statusbar_get_context_id (GTK_STATUSBAR (status_bar), 
 "Statusbar example");

 /*Count is used to keep track of the amount of items 
 the user is pushing/popping*/
 static int count = 1;
 char hold_output[20];
 
 /*This is a safer form of the standard sprintf () function. The output is 
 gauranteed in this case to not exceed 20 characters, and the result is stored 
 into the 'hold_output' variable*/
 g_snprintf (hold_output, 20, "Item %d", count++);
 gtk_statusbar_push (GTK_STATUSBAR (status_bar), 
 context_id, 
 hold_output);
}



/*Callback function that is used to pop an item off the statusbar*/
static void 
pop_item (GtkWidget *widget,
 gpointer data )
{
 GtkWidget *status_bar = data;
 guint context_id = gtk_statusbar_get_context_id (GTK_STATUSBAR (status_bar), 
 "Statusbar example");

 gtk_statusbar_pop (GTK_STATUSBAR (status_bar), context_id);
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *grid;
 GtkWidget *window;
 GtkWidget *status_bar;
 GtkWidget *pop_button;
 GtkWidget *push_button;

 /*Create a window with a title, border width, and a default size**/
 window = gtk_application_window_new (app);
 gtk_window_set_default_size (GTK_WINDOW (window), 220, 100);
 gtk_window_set_title (GTK_WINDOW (window), "Statusbar Example");
 gtk_container_set_border_width (GTK_CONTAINER(window), 10);
 
 /*Create the status bar, which is held in the global variable*/
 status_bar = gtk_statusbar_new (); 
 
 /*Create the buttons with labels*/
 push_button = gtk_button_new_with_label ("push item");
 pop_button = gtk_button_new_with_label ("pop last item");
 
 /*Create the grid, and attach the buttons/statusbar accordingly*/
 grid = gtk_grid_new ();
 gtk_grid_attach (GTK_GRID (grid), push_button, 0,1,1,1);
 gtk_grid_attach (GTK_GRID (grid), pop_button, 0,2,1,1);
 gtk_grid_attach (GTK_GRID (grid), status_bar, 0,3,1,1);
 
 /*Connecting the clicked signals to the corresponding callback functions*/
 g_signal_connect (GTK_BUTTON (push_button), "clicked", 
 G_CALLBACK (push_item), status_bar);
 g_signal_connect (GTK_BUTTON (pop_button), "clicked", 
 G_CALLBACK (pop_item), status_bar);
 
 /*Attach the grid holding the child widgets onto the window, and show all*/
 gtk_container_add (GTK_CONTAINER (window), grid);
 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}


external ref='media/statusbar2.png' md5='ff6f7e5b270827ca98b2d5f7087aa766'
Statusbar (JavaScript)
Show notifications in a dedicated statusbar
This statusbar keeps track of how many times you've clicked a button. Applications like
Messages pushed to a statusbar go on top of its stack, and can be popped off to show the next-most recent one. You can also clear away every message of a specific type all at once. This sample application demonstrates these functions.
const StatusbarExample = new Lang.Class({
 Name: 'Statusbar Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsstatusbar',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
All the code for this sample goes in the StatusbarExample class. The above code creates a
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 120,
 default_width: 300,
 title: "Button Clicker"});

 // Create a paned interface
 this._panes = new Gtk.Paned ({
 orientation: Gtk.Orientation.VERTICAL });
The _buildUI function is where we put all the code to create the application's user interface. The first step is creating a new
Creating the buttons
// Create the main button
 this._clickMe = new Gtk.Button ({
 label: "Click Me!" });
 this._clickMe.connect ("clicked", Lang.bind (this, this._clicked));

 // Create the back button
 this._backButton = new Gtk.Button ({
 label: "gtk-go-back",
 use_stock: true });
 this._backButton.connect ("clicked", Lang.bind (this, this._back));

 // Create the clear button
 this._clearButton = new Gtk.Button ({
 label: "gtk-clear",
 use_stock: true });
 this._clearButton.connect ("clicked", Lang.bind (this, this._clear));
This code creates the three
// Put the buttons in a grid
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });
 this._grid.attach (this._backButton, 0, 0, 1, 1);
 this._grid.attach_next_to (this._clickMe, this._backButton, Gtk.PositionType.RIGHT, 1, 1);
 this._grid.attach_next_to (this._clearButton, this._clickMe, Gtk.PositionType.RIGHT, 1, 1);

 // Put the grid in a large frame that fills most of the window
 this._topFrame = new Gtk.Frame ({
 border_width: 20,
 height_request: 90,
 width_request: 300});
 this._topFrame.add (this._grid);
This code creates the
Creating the statusbar
// Create the statusbar
 this._statusbar = new Gtk.Statusbar();

 // Keep track of the number of times the button has been clicked
 this.Clicks = 0;
 this.ContextID = this._statusbar.get_context_id ("Number of Clicks");

 // Give the statusbar an initial message
 this._statusbar.push (this.ContextID, "Number of clicks: " + this.Clicks);

 // Put the statusbar in its own frame at the bottom
 this._barFrame = new Gtk.Frame ({
 height_request: 30 });
 this._barFrame.add (this._statusbar);
Here we create the Gtk.Statusbar, and push a message to it to start off with. Then we give it its own narrow frame at the bottom of the window.
Every message needs to have a context id, which is an integer value you can get from the statusbar with the get_context_id() function. Its only parameter is the string value you use to describe that particular context id. Normally, you'll get a new context id for different kinds of messages, so that you can use the remove() function to remove a specific message and not just the most recent one on the stack. This is a simple example with only one kind of message, though, so we're just using one for everything.
We use the push() function to push a new message onto the stack. Its first parameter is the context id, and its second is the message.
// Assemble the frames into the paned interface
 this._panes.pack1 (this._topFrame, true, false);
 this._panes.pack2 (this._barFrame, false, false);

 // Put the panes into the window
 this._window.add (this._panes);

 // Show the window and all child widgets
 this._window.show_all();
 },
This code finishes up creating the window, by packing the frames into the pane, adding it to the window, and telling the window to show all child widgets.
Functions for interacting with the statusbar
_clicked: function() {

 // Increment the number of clicks by 1
 this.Clicks++;

 // Update the statusbar with the new number of clicks
 this._statusbar.push (this.ContextID, "Number of clicks: " + this.Clicks);

 },



 _back: function () {

 // If there have been any clicks, decrement by 1 and remove last statusbar update
 if (this.Clicks &gt; 0 ) {
 this.Clicks--;
 this._statusbar.pop (this.ContextID);
 };

 },



 _clear: function () {

 // Reset the number of clicks
 this.Clicks = 0;

 // Wipe out all the messages pushed to the statusbar
 this._statusbar.remove_all (this.ContextID);

 // Reset the statusbar's message
 this._statusbar.push (this.ContextID, "Number of clicks: " + this.Clicks);

 }

});
Here we have functions which demonstrate pushing a message onto the stack, popping the top one off of it, and clearing all messages of a particular context id. The pop() function just takes one parameter, which is the context id for the type of message you want to pop off the most recent one of. The remove_all() function works the same way, except it removes all messages of that type from the stack.
// Run the application
let app = new StatusbarExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished StatusbarExample class, and set the application running.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const StatusbarExample = new Lang.Class({
 Name: 'Statusbar Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsstatusbar',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 120,
 default_width: 300,
 title: "Button Clicker"});

 // Create a paned interface
 this._panes = new Gtk.Paned ({
 orientation: Gtk.Orientation.VERTICAL });

 // Create the main button
 this._clickMe = new Gtk.Button ({
 label: "Click Me!" });
 this._clickMe.connect ("clicked", Lang.bind (this, this._clicked));

 // Create the back button
 this._backButton = new Gtk.Button ({
 label: "gtk-go-back",
 use_stock: true });
 this._backButton.connect ("clicked", Lang.bind (this, this._back));

 // Create the clear button
 this._clearButton = new Gtk.Button ({
 label: "gtk-clear",
 use_stock: true });
 this._clearButton.connect ("clicked", Lang.bind (this, this._clear));

 // Put the buttons in a grid
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });
 this._grid.attach (this._backButton, 0, 0, 1, 1);
 this._grid.attach_next_to (this._clickMe, this._backButton, Gtk.PositionType.RIGHT, 1, 1);
 this._grid.attach_next_to (this._clearButton, this._clickMe, Gtk.PositionType.RIGHT, 1, 1);

 // Put the grid in a large frame that fills most of the window
 this._topFrame = new Gtk.Frame ({
 border_width: 20,
 height_request: 90,
 width_request: 300});
 this._topFrame.add (this._grid);

 // Create the statusbar
 this._statusbar = new Gtk.Statusbar();

 // Keep track of the number of times the button has been clicked
 this.Clicks = 0;
 this.ContextID = this._statusbar.get_context_id ("Number of Clicks");

 // Give the statusbar an initial message
 this._statusbar.push (this.ContextID, "Number of clicks: " + this.Clicks);

 // Put the statusbar in its own frame at the bottom
 this._barFrame = new Gtk.Frame ({
 height_request: 30 });
 this._barFrame.add (this._statusbar);

 // Assemble the frames into the paned interface
 this._panes.pack1 (this._topFrame, true, false);
 this._panes.pack2 (this._barFrame, false, false);

 // Put the panes into the window
 this._window.add (this._panes);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _clicked: function() {

 // Increment the number of clicks by 1
 this.Clicks++;

 // Update the statusbar with the new number of clicks
 this._statusbar.push (this.ContextID, "Number of clicks: " + this.Clicks);

 },



 _back: function () {

 // If there have been any clicks, decrement by 1 and remove last statusbar update
 if (this.Clicks &gt; 0 ) {
 this.Clicks--;
 this._statusbar.pop (this.ContextID);
 };

 },



 _clear: function () {

 // Reset the number of clicks
 this.Clicks = 0;

 // Wipe out all the messages pushed to the statusbar
 this._statusbar.remove_all (this.ContextID);

 // Reset the statusbar's message
 this._statusbar.push (this.ContextID, "Number of clicks: " + this.Clicks);

 }

});

// Run the application
let app = new StatusbarExample ();
app.application.run (ARGV);



external ref='media/statusbar.png' md5='eb1aca55315d6cda57b12a5f36058ba8'
Statusbar (Python)
This statusbar tells you if you click the button or if you press any key (and which key).
from gi.repository import Gtk
from gi.repository import Gdk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="StatusBar Example", application=app)
 self.set_default_size(200, 100)

 # a label
 label = Gtk.Label(label="Press any key or ")

 # a button
 button = Gtk.Button(label="click me.")
 # connected to a callback
 button.connect("clicked", self.button_clicked_cb)

 # the statusbar
 self.statusbar = Gtk.Statusbar()
 # its context_id - not shown in the UI but needed to uniquely identify
 # the source of a message
 self.context_id = self.statusbar.get_context_id("example")
 # we push a message onto the statusbar's stack
 self.statusbar.push(
 self.context_id, "Waiting for you to do something...")

 # a grid to attach the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing(5)
 grid.set_column_homogeneous(True)
 grid.set_row_homogeneous(True)
 grid.attach(label, 0, 0, 1, 1)
 grid.attach_next_to(button, label, Gtk.PositionType.RIGHT, 1, 1)
 grid.attach(self.statusbar, 0, 1, 2, 1)

 # add the grid to the window
 self.add(grid)

 # callback function for the button clicked
 # if the button is clicked the event is signaled to the statusbar
 # onto which we push a new status
 def button_clicked_cb(self, button):
 self.statusbar.push(self.context_id, "You clicked the button.")

 # event handler
 def do_key_press_event(self, event):
 # any signal from the keyboard is signaled to the statusbar
 # onto which we push a new status with the symbolic name
 # of the key pressed
 self.statusbar.push(self.context_id, Gdk.keyval_name(event.keyval) +
 " key was pressed.")
 # stop the signal emission
 return True


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)

Useful methods for a Statusbar widget
In line 17 the signal





Statusbar (Vala)
This statusbar tells you what's going on.
public class MyWindow : Gtk.ApplicationWindow {

 Gtk.Statusbar statusbar;
 uint context_id;

 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Statusbar Example");

 statusbar = new Gtk.Statusbar ();
 context_id = statusbar.get_context_id ("example");
 statusbar.push (context_id, "Waiting for you to do something...");

 //set the default size of the window
 this.set_default_size (200, 100);
 var grid = new Gtk.Grid ();
 var label = new Gtk.Label ("Press any key or ");

 grid.attach (label, 0, 0, 1, 1);
 label.show ();

 var button = new Gtk.Button.with_label ("click me.");
 grid.attach_next_to (button, label, Gtk.PositionType.RIGHT, 1, 1);
 button.show ();

 grid.attach (statusbar, 0, 1, 2, 1);
 statusbar.show ();

 grid.set_column_spacing (5);
 grid.set_column_homogeneous (true);
 grid.set_row_homogeneous (true);

 this.add (grid);
 grid.show ();

 button.clicked.connect(button_clicked_cb);
 }

 /* Since the key-press-event is a signal received by the window, we don't need to connect
 the window to a callback function. We can just override key_press_event. */
 protected override bool key_press_event (Gdk.EventKey event) {
 statusbar.push (context_id, Gdk.keyval_name(event.keyval) + " key was pressed.");
 return true;
 }

 void button_clicked_cb (Gtk.Button button) {
 statusbar.push (context_id, "You clicked the button.");
 }
}

public class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.status");
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}

Strings (Python)
An explanation of how to deal with strings in Python and GTK+.
Strings
GNOME strongly encourages the use of Python 3 for writing applications!
Strings in Python 2
Python 2 comes with two different kinds of objects that can be used to represent strings,
&gt;gt;gt; unicode_string = u"Fu\\u00dfb\\u00e4lle"
&gt;gt;gt; print unicode_string
Fußbälle
Unicode strings can be converted to 8-bit strings with
&gt;gt;gt; type(unicode_string)
&lt;type 'unicode'gt;
&gt;gt;gt; unicode_string.encode("utf-8")
'Fu\\xc3\\x9fb\\xc3\\xa4lle'
&gt;gt;gt; utf8_string = unicode_string.encode("utf-8")
&gt;gt;gt; type(utf8_string)
&lt;type 'str'gt;
&gt;gt;gt; unicode_string == utf8_string.decode("utf-8")
True
Unfortunately, Python 2.x allows you to mix
Strings in Python 3
Since Python 3.0, all strings are stored as Unicode in an instance of the
In addition, it is no longer possible to mix Unicode strings with encoded strings, because it will result in a
&gt;gt;gt; text = "Fu\\u00dfb\\u00e4lle"
&gt;gt;gt; data = b" sind rund"
&gt;gt;gt; text + data
Traceback (most recent call last):
 File "lt;stdingt;", line 1, in &lt;modulegt;
TypeError: Can't convert 'bytes' object to str implicitly
&gt;gt;gt; text + data.decode("utf-8")
'Fußbälle sind rund'
&gt;gt;gt; text.encode("utf-8") + data
b'Fu\\xc3\\x9fb\\xc3\\xa4lle sind rund'
Unicode in GTK+
GTK+ uses UTF-8 encoded strings for all text. This means that if you call a method that returns a string you will always obtain an instance of the
&gt;gt;gt; from gi.repository import Gtk
&gt;gt;gt; label = Gtk.Label()
&gt;gt;gt; unicode_string = u"Fu\\u00dfb\\u00e4lle"
&gt;gt;gt; label.set_text(unicode_string)
&gt;gt;gt; txt = label.get_text()
&gt;gt;gt; type(txt)
&lt;type 'str'gt;
Furthermore:
&gt;gt;gt; txt == unicode_string
would return
This is especially important if you want to internationalize your program using
In general it is recommended to not use
String encoding is more consistent in Python 3.x because PyGObject will automatically encode/decode to/from UTF-8 if you pass a string to a method or a method returns a string. Strings, or text, will always be represented as instances of

external ref='media/switch_off.png' md5='211a2962708800697ad5373dcc86ad6d'
external ref='media/switch_on.png' md5='95e8769f758c2d95ace0fa8ecf30b29d'
Switch (C)
A "light switch" style toggle
Switch
This switch toggles the title of the window.
#include &lt;gtk/gtk.hgt;



/*Signal handler for the "active" signal of the Switch*/
static void
activate_cb (GObject *switcher,
 GParamSpec *pspec,
 gpointer user_data)
{
 GtkWindow *window = user_data;

 if (gtk_switch_get_active (GTK_SWITCH (switcher)))
 gtk_window_set_title (GTK_WINDOW (window), "Switch Example");
 else
 gtk_window_set_title (GTK_WINDOW (window), "");
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *grid;
 GtkWidget *window;
 GtkWidget *label;
 GtkWidget *switcher;

 /*Create a window with a set title and default size.
 Also, set a border width for the amount of space to leave
 inside the window*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Switch Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 300, 100);
 gtk_container_set_border_width (GTK_CONTAINER (window), 10);

 /*Create a label*/
 label = gtk_label_new ("Title");

 /*Create a switch with a default active state*/
 switcher = gtk_switch_new ();
 gtk_switch_set_active (GTK_SWITCH (switcher), TRUE);

 /*Create a grid and set the column spacing, attach the label and
 switch onto the grid and position them accordingly*/
 grid = gtk_grid_new();
 gtk_grid_set_column_spacing (GTK_GRID (grid), 10);
 gtk_grid_attach (GTK_GRID (grid), label, 0, 0, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), switcher, 1, 0, 1, 1);

 /*Connecting the clicked signal to the callback function*/
 g_signal_connect (GTK_SWITCH (switcher), 
 "notify::active", 
 G_CALLBACK (activate_cb), 
 window);

 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (grid));

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}
external ref='media/switchanimals.png' md5='513ae15dcf68e15eef30b76420b8c714'
Switch (JavaScript)
A sliding switch that can be flipped on and off
A Switch has two positions, on and off. This example shows how you can use multiple switches together to control which
The window will contain a "broken image" icon instead of a picture if picture files named




Photo credits and licensing information are shown in the application's
const SwitchExample = new Lang.Class({
 Name: 'Switch Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsswitch',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal creates the menu and builds the UI
 _onStartup: function() {
 this._initMenus();
 this._buildUI ();
 },
All the code for this sample goes in the SwitchExample class. The above code creates a
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Animal Creator"});
Creating the switches
// Create the image widget and set its default picture
 this._image = new Gtk.Image ({file: "redfox.png"});
We first create the
// Create a label for the first switch
 this._flyLabel = new Gtk.Label ({
 label: "Make it fly",
 margin_right: 30});

 // Create the first switch and set its default position
 this._flySwitch = new Gtk.Switch ({active: false});
 this._flySwitch.connect ('notify::active', Lang.bind (this, this._switchFlip));

 // Create a label for the second switch
 this._birdLabel = new Gtk.Label ({
 label: "Make it a bird",
 margin_right: 30});

 // Create the second switch
 this._birdSwitch = new Gtk.Switch ({active: false});
 this._birdSwitch.connect ('notify::active', Lang.bind (this, this._switchFlip));
We use a
The signal a switch sends out when it's flipped on or off is called notify::active. After we create each switch, we connect its notify::active signal to a function called _switchFlip. If you have multiple switches that each do something different, you might want to connect them to different functions, but here they're both used for the same thing: To control what picture's displayed by _image.
// Create a grid for the labels and switches beneath the picture
 this._UIGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_top: 20});

 // Attach the labels and switches to that grid
 this._UIGrid.attach (this._flyLabel, 0, 0, 1, 1);
 this._UIGrid.attach (this._flySwitch, 1, 0, 1, 1);
 this._UIGrid.attach (this._birdLabel, 0, 1, 1, 1);
 this._UIGrid.attach (this._birdSwitch, 1, 1, 1, 1);

 // Create a master grid to put both the UI and the picture into
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Attach the picture and the UI grid to the master grid
 this._mainGrid.attach (this._image, 0, 0, 1, 1);
 this._mainGrid.attach (this._UIGrid, 0, 1, 1, 1);
We create a
// Add the master grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },
Function which handles the switches being flipped
_switchFlip: function() {

 // Change the picture depending on which switches are flipped
 if (this._flySwitch.get_active()) {

 if (this._birdSwitch.get_active()) this._image.set_from_file ("muteswan.png");

 else this._image.set_from_file ("fruitbat.png");
 }

 else {

 if (this._birdSwitch.get_active()) this._image.set_from_file ("gentoopenguin.png");

 else this._image.set_from_file ("redfox.png");

 }

 },
Each time a Switch is flipped, this function checks to see which of the two Switches are active afterwards, using the Switches' built-in get_active() function. It then changes the Image accordingly. You can change the filenames around as you like, so long as you have pictures to go with them.
Creating the AboutDialog
_initMenus: function() {

 // Build the application's menu so we can have an "About" button
 let menu = new Gio.Menu();
 menu.append("About", 'app.about');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 // Bind the "About" button to the _showAbout() function
 let aboutAction = new Gio.SimpleAction ({ name: 'about' });
 aboutAction.connect('activate', Lang.bind(this,
 function() {
 this._showAbout();
 }));
 this.application.add_action(aboutAction);

 // Bind the "Quit" button to the function that closes the window
 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },
The first step is building the
_showAbout: function () {

 // String arrays of the names of the people involved in the project
 var artists = ['Rob Lee http://en.wikipedia.org/wiki/File:Fuzzy_Freddy.jpg', 'Ken Funakoshi http://en.wikipedia.org/wiki/File:Pygoscelis_papua_-Nagasaki_Penguin_Aquarium_-swimming_underwater-8a.jpg', 'Shek Graham http://www.flickr.com/photos/shekgraham/127431519/in/photostream/', 'Mindaugas Urbonas http://commons.wikimedia.org/wiki/File:Mute_Swan-Mindaugas_Urbonas.jpg'];
 var authors = ["GNOME Documentation Team"];
 var documenters = ["GNOME Documentation Team"];

 // Create the About dialog
 let aboutDialog = new Gtk.AboutDialog({
 title: "AboutDialog Example",
 program_name: "Animal Creator",
 copyright: "Copyright \\xa9 2012 GNOME Documentation Team\
\
Red fox photo licensed CC-By by Rob Lee\
Gentoo penguin photo licensed CC-By-SA by Ken Funakoshi\
Fruit bat photo licensed CC-By by Shek Graham\
Mute swan photo licensed CC-By-SA by Mindaugas Urbonas\
Links to the originals are available under Credits.\
\
Have you hugged a penguin today?",
 artists: artists,
 authors: authors,
 documenters: documenters,
 website: "http://developer.gnome.org",
 website_label: "GNOME Developer Website" });

 // Attach the About dialog to the window
 aboutDialog.modal = true;
 aboutDialog.transient_for = this._window;

 // Show the About dialog
 aboutDialog.show();

 // Connect the Close button to the destroy signal for the dialog
 aboutDialog.connect('response', function() {
 aboutDialog.destroy();
 });
 }

});
An
// Run the application
let app = new SwitchExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished SwitchExample class, and set the application running.
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const SwitchExample = new Lang.Class({
 Name: 'Switch Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jsswitch'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal creates the menu and builds the UI
 _onStartup: function() {
 this._initMenus();
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 border_width: 20,
 title: "Animal Creator"});

 // Create the image widget and set its default picture
 this._image = new Gtk.Image ({file: "redfox.png"});

 // Create a label for the first switch
 this._flyLabel = new Gtk.Label ({
 label: "Make it fly",
 margin_right: 30});

 // Create the first switch and set its default position
 this._flySwitch = new Gtk.Switch ({active: false});
 this._flySwitch.connect ('notify::active', Lang.bind (this, this._switchFlip));

 // Create a label for the second switch
 this._birdLabel = new Gtk.Label ({
 label: "Make it a bird",
 margin_right: 30});

 // Create the second switch
 this._birdSwitch = new Gtk.Switch ({active: false});
 this._birdSwitch.connect ('notify::active', Lang.bind (this, this._switchFlip));

 // Create a grid for the labels and switches beneath the picture
 this._UIGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER,
 margin_top: 20});

 // Attach the labels and switches to that grid
 this._UIGrid.attach (this._flyLabel, 0, 0, 1, 1);
 this._UIGrid.attach (this._flySwitch, 1, 0, 1, 1);
 this._UIGrid.attach (this._birdLabel, 0, 1, 1, 1);
 this._UIGrid.attach (this._birdSwitch, 1, 1, 1, 1);

 // Create a master grid to put both the UI and the picture into
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Attach the picture and the UI grid to the master grid
 this._mainGrid.attach (this._image, 0, 0, 1, 1);
 this._mainGrid.attach (this._UIGrid, 0, 1, 1, 1);

 // Add the master grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _switchFlip: function() {

 // Change the picture depending on which switches are flipped
 if (this._flySwitch.get_active()) {

 if (this._birdSwitch.get_active()) this._image.set_from_file ("muteswan.png");

 else this._image.set_from_file ("fruitbat.png");
 }

 else {

 if (this._birdSwitch.get_active()) this._image.set_from_file ("gentoopenguin.png");

 else this._image.set_from_file ("redfox.png");

 }

 },



 _initMenus: function() {

 // Build the application's menu so we can have an "About" button
 let menu = new Gio.Menu();
 menu.append("About", 'app.about');
 menu.append("Quit",'app.quit');
 this.application.set_app_menu(menu);

 // Bind the "About" button to the _showAbout() function
 let aboutAction = new Gio.SimpleAction ({ name: 'about' });
 aboutAction.connect('activate', Lang.bind(this,
 function() {
 this._showAbout();
 }));
 this.application.add_action(aboutAction);

 // Bind the "Quit" button to the function that closes the window
 let quitAction = new Gio.SimpleAction ({ name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },



 _showAbout: function () {

 // String arrays of the names of the people involved in the project
 var artists = ['Rob Lee http://en.wikipedia.org/wiki/File:Fuzzy_Freddy.png', 'Ken Funakoshi http://en.wikipedia.org/wiki/File:Pygoscelis_papua_-Nagasaki_Penguin_Aquarium_-swimming_underwater-8a.png', 'Shek Graham http://www.flickr.com/photos/shekgraham/127431519/in/photostream/', 'Mindaugas Urbonas http://commons.wikimedia.org/wiki/File:Mute_Swan-Mindaugas_Urbonas.png'];
 var authors = ["GNOME Documentation Team"];
 var documenters = ["GNOME Documentation Team"];

 // Create the About dialog
 let aboutDialog = new Gtk.AboutDialog({
 title: "AboutDialog Example",
 program_name: "Animal Creator",
 copyright: "Copyright \\xa9 2012 GNOME Documentation Team\
\
Red fox photo licensed CC-By by Rob Lee\
Gentoo penguin photo licensed CC-By-SA by Ken Funakoshi\
Fruit bat photo licensed CC-By by Shek Graham\
Mute swan photo licensed CC-By-SA by Mindaugas Urbonas\
Links to the originals are available under Credits.\
\
Have you hugged a penguin today?",
 artists: artists,
 authors: authors,
 documenters: documenters,
 website: "http://developer.gnome.org",
 website_label: "GNOME Developer Website" });

 // Attach the About dialog to the window
 aboutDialog.modal = true;
 aboutDialog.transient_for = this._window;

 // Show the About dialog
 aboutDialog.show();

 // Connect the Close button to the destroy signal for the dialog
 aboutDialog.connect('response', function() {
 aboutDialog.destroy();
 });
 }

});

// Run the application
let app = new SwitchExample ();
app.application.run (ARGV);


Switch (Python)
This Switch makes the title appears and disappear.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Switch Example", application=app)
 self.set_default_size(300, 100)
 self.set_border_width(10)

 # a switch
 switch = Gtk.Switch()
 # turned on by default
 switch.set_active(True)
 # connect the signal notify::active emitted by the switch
 # to the callback function activate_cb
 switch.connect("notify::active", self.activate_cb)

 # a label
 label = Gtk.Label()
 label.set_text("Title")

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_column_spacing(10)
 grid.attach(label, 0, 0, 1, 1)
 grid.attach(switch, 1, 0, 1, 1)

 # add the grid to the window
 self.add(grid)

 # Callback function. Since the signal is notify::active
 # we need the argument 'active'
 def activate_cb(self, button, active):
 # if the button (i.e. the switch) is active, set the title
 # of the window to "Switch Example"
 if button.get_active():
 self.set_title("Switch Example")
 # else, set it to "" (empty string)
 else:
 self.set_title("")


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Switch widget
In line 17 the signal

Switch (Vala)
This Switch toggles the title.
class MyWindow : Gtk.ApplicationWindow {

 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Switch Example");

 this.set_default_size (300, 100);
 this.border_width = 10;

 var label = new Gtk.Label ("Title");
 var switcher = new Gtk.Switch ();

 switcher.set_active (true);

 switcher.notify["active"].connect (switcher_cb);

 var grid = new Gtk.Grid ();
 grid.set_column_spacing (10);
 grid.attach (label, 0, 0, 1, 1);
 grid.attach (switcher, 1, 0, 1, 1);

 this.add (grid);
 }

 void switcher_cb (Object switcher, ParamSpec pspec) {
 if ((switcher as Gtk.Switch).get_active())
 this.set_title ("Switch Example");
 else
 this.set_title ("");
 }
}

class MyApplication : Gtk.Application {
 protected override void activate () {

 var window = new MyWindow (this);
 window.show_all (); //show all the things
 }

 internal MyApplication () {
 Object (application_id: "org.example.checkbutton");
 }
}

int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/textview.png' md5='049e859ed1af2d7c93d8cb5cfd9f7792'
TextView (C)
Widget which displays a GtkTextBuffer
TextView widget
If we press "enter", we have a new line.
If we press "enter" more times then there are lines in the default sized window, then a vertical scrollbar appears.
If we write a long sentence, the text will wrap breaking lines between words.
If we have a loooooooooooooooooooooooooooooooooooong (that was long) word, a* horizontal scrollbar will appear.
This is an example of Gtk.TextView
#include &lt;gtk/gtk.hgt;



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 /* Declare variables */
 GtkWidget *window;
 GtkWidget *text_view;
 GtkWidget *scrolled_window;

 GtkTextBuffer *buffer;


 /* Create a window with a title, and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "TextView Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 220, 200);


 /* The text buffer represents the text being edited */
 buffer = gtk_text_buffer_new (NULL);
 

 /* Text view is a widget in which can display the text buffer. 
 * The line wrapping is set to break lines in between words.
 */
 text_view = gtk_text_view_new_with_buffer (buffer);
 gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (text_view), GTK_WRAP_WORD); 


 /* Create the scrolled window. Usually NULL is passed for both parameters so 
 * that it creates the horizontal/vertical adjustments automatically. Setting 
 * the scrollbar policy to automatic allows the scrollbars to only show up 
 * when needed. 
 */
 scrolled_window = gtk_scrolled_window_new (NULL, NULL);
 gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_window), 
 GTK_POLICY_AUTOMATIC, 
 GTK_POLICY_AUTOMATIC); 
 /* The function directly below is used to add children to the scrolled window 
 * with scrolling capabilities (e.g text_view), otherwise, 
 * gtk_scrolled_window_add_with_viewport() would have been used
 */
 gtk_container_add (GTK_CONTAINER (scrolled_window), 
 text_view);
 gtk_container_set_border_width (GTK_CONTAINER (scrolled_window), 5);
 
 
 gtk_container_add (GTK_CONTAINER (window), scrolled_window);

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

external ref='media/textviewpenguinchat.png' md5='0dd6f6aa44aaeab7901bd90162ed4c9a'
TextView (JavaScript)
A multiline text editor
TextView
A TextView is really (or at least usually) a nested set of three objects.
At the bottom there is a
In the middle there is the
Since the automatic resizing can make a TextView unwieldy, you normally place it inside of a ScrolledWindow. Despite the name, it's not an actual window in terms of having a title bar and an X button; it's a widget you put on the application you're making, which acts like a window onto a more manageable chunk of a TextView. If the text in the buffer is too big to fit, scrollbars will appear.
If you want to change what text is displayed in the TextView, you act on the TextBuffer, since it's what actually holds the text. The same goes for if you want to see what text someone typed in. This sample application lets you talk to a (make-believe) penguin, and checks the TextBuffer to see if you typed the word "fish" anywhere in it.
Real-life penguin populations are declining fast, because climate change is melting the ice that they live on and killing the fish that they eat. If you'd like to play a (somewhat silly) GNOME game based on this premise, take a look at
const TextViewExample = new Lang.Class ({
 Name: 'TextView Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jstextview' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },
All the code for this sample goes in the TextViewExample class. The above code creates a
// Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Talk to a Penguin",
 default_height: 400,
 default_width: 440,
 border_width: 20 });
Creating the TextView
// Create a label for the penguin to talk to you
 this._penguin = new Gtk.Label ({
 height_request: 180,
 width_request: 400,
 label: "Squaaaak?",
 wrap: true });
Our first step in this example is to create the
// Create a textview for you to talk to the penguin
 this.buffer = new Gtk.TextBuffer();
 this._textView = new Gtk.TextView ({
 buffer: this.buffer,
 editable: true,
 wrap_mode: Gtk.WrapMode.WORD });
Our first step is to create a TextBuffer to put the words into. After that we create the TextView, and tell it to use the TextBuffer we created as its buffer. We also set it to be editable, since we want to be able to type new things in.
The wrap_mode property lets you select from four different
// Create a "scrolled window" to put your textview in so it will scroll
 this._scrolled = new Gtk.ScrolledWindow ({
 hscrollbar_policy: Gtk.PolicyType.AUTOMATIC,
 vscrollbar_policy: Gtk.PolicyType.AUTOMATIC,
 shadow_type: Gtk.ShadowType.ETCHED_IN,
 height_request: 180,
 width_request: 400, });

 // Put the textview into the scrolled window
 this._scrolled.add_with_viewport (this._textView);
Here we create a ScrolledWindow, and set it to automatically scroll if it gets to be too big horizontally or vertically. We also give it a nice-looking ETCHED_IN border. After that, we put our TextView inside, and tell the ScrolledWindow to give us a viewport onto it.
// Create a grid to organize them in
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Put the label and textview in the grid one on top of the other
 this._grid.attach (this._penguin, 0, 0, 1, 1);
 this._grid.attach (this._scrolled, 0, 1, 1, 1);
The first
// Create a button to send your message to the penguin
 this._send = new Gtk.Button ({
 halign: Gtk.Align.END,
 margin_top: 20,
 label: "Send" });
 this._send.connect ('clicked', Lang.bind (this, this._chat));

 // Create a grid that will have the other grid on top and the button on bottom
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Add the other grid and the button to the main grid
 this._mainGrid.attach (this._grid, 0, 0, 1, 1);
 this._mainGrid.attach (this._send, 0, 1, 1, 1);
We create a
// Attach the main grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },
Finally, we attach the main Grid to the window, then we tell the window and everything inside it to become visible when the application is run.
Function which handles the penguin's response
_chat: function () {

 // Create a random number to determine what the penguin says
 this.number = Math.floor ((Math.random() * 3) + 1);

 // Did you actually say anything?
 if (this.buffer.text) {

 // Did you mention fish?
 if (this.buffer.text.match (/fish/gi)) {

 // Have the penguin squaak about fish
 if (this.number == 1)
 this._penguin.set_label ("FISH!");

 else if (this.number == 2)
 this._penguin.set_label ("Fish fish fish fish. Fish!");

 else
 this._penguin.set_label ("Fish? Fish fish fish. Fish fish. FISH!");

 }

 // I guess you didn't mention fish
 else {

 // Have the penguin talk about penguinny stuff
 if (this.number == 1)
 this._penguin.set_label ("SQUAAK!");

 else if (this.number == 2)
 this._penguin.set_label ("Ork ork ork ork squaak. Squaak squaak! *waves flippers*");

 else
 this._penguin.set_label ("Ork ork ork ork ork?");

 }

 }

 // Clear the buffer
 this.buffer.text = "";

 // Give focus back to the textview so you don't have to click it again
 this._textView.has_focus = true;

 }

});
Here we use some basic JavaScript functions to have the penguins say something random. Penguins like fish, though, so if you mention fish we want the penguin to respond to that. To do that, we use the JavaScript String object's match method on
Since we want to clear out the TextBuffer after each time you click Send, we set
// Run the application
let app = new TextViewExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished TextViewExample class, and set the application running.
#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const TextViewExample = new Lang.Class ({
 Name: 'TextView Example',

 // Create the application itself
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.jstextview' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function () {
 this._window.present ();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this._window = new Gtk.ApplicationWindow ({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Talk to a Penguin",
 default_height: 400,
 default_width: 440,
 border_width: 20 });

 // Create a label for the penguin to talk to you
 this._penguin = new Gtk.Label ({
 height_request: 180,
 width_request: 400,
 label: "Squaaaak?",
 wrap: true });

 // Create a textview for you to talk to the penguin
 this.buffer = new Gtk.TextBuffer();
 this._textView = new Gtk.TextView ({
 buffer: this.buffer,
 editable: true,
 wrap_mode: Gtk.WrapMode.WORD });

 // Create a "scrolled window" to put your textview in so it will scroll
 this._scrolled = new Gtk.ScrolledWindow ({
 hscrollbar_policy: Gtk.PolicyType.AUTOMATIC,
 vscrollbar_policy: Gtk.PolicyType.AUTOMATIC,
 shadow_type: Gtk.ShadowType.ETCHED_IN,
 height_request: 180,
 width_request: 400, });

 // Put the textview into the scrolled window
 this._scrolled.add_with_viewport (this._textView);

 // Create a grid to organize them in
 this._grid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Put the label and textview in the grid one on top of the other
 this._grid.attach (this._penguin, 0, 0, 1, 1);
 this._grid.attach (this._scrolled, 0, 1, 1, 1);

 // Create a button to send your message to the penguin
 this._send = new Gtk.Button ({
 halign: Gtk.Align.END,
 margin_top: 20,
 label: "Send" });
 this._send.connect ('clicked', Lang.bind (this, this._chat));

 // Create a grid that will have the other grid on top and the button on bottom
 this._mainGrid = new Gtk.Grid ({
 halign: Gtk.Align.CENTER,
 valign: Gtk.Align.CENTER });

 // Add the other grid and the button to the main grid
 this._mainGrid.attach (this._grid, 0, 0, 1, 1);
 this._mainGrid.attach (this._send, 0, 1, 1, 1);

 // Attach the main grid to the window
 this._window.add (this._mainGrid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _chat: function () {

 // Create a random number to determine what the penguin says
 this.number = Math.floor ((Math.random() * 3) + 1);

 // Did you actually say anything?
 if (this.buffer.text) {

 // Did you mention fish?
 if (this.buffer.text.match (/fish/gi)) {

 // Have the penguin squaak about fish
 if (this.number == 1)
 this._penguin.set_label ("FISH!");

 else if (this.number == 2)
 this._penguin.set_label ("Fish fish fish fish. Fish!");

 else
 this._penguin.set_label ("Fish? Fish fish fish. Fish fish. FISH!");

 }

 // I guess you didn't mention fish
 else {

 // Have the penguin talk about penguinny stuff
 if (this.number == 1)
 this._penguin.set_label ("SQUAAK!");

 else if (this.number == 2)
 this._penguin.set_label ("Ork ork ork ork squaak. Squaak squaak! *waves flippers*");

 else
 this._penguin.set_label ("Ork ork ork ork ork?");

 }

 }

 // Clear the buffer
 this.buffer.text = "";

 // Give focus back to the textview so you don't have to click it again
 this._textView.has_focus = true;

 }

});

// Run the application
let app = new TextViewExample ();
app.application.run (ARGV);



TextView (Python)
Widget that displays a GtkTextBuffer
This is an example of Gtk.TextView.
But we can also have a new line if we write a long sentence (the text will wrap breaking lines between words).
If we have a loooooooooooooooooooooooooooooooooooong
(that was long)
word, an horizontal scrollbar will appear.
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="TextView Example", application=app)
 self.set_default_size(300, 450)

 # a scrollbar for the child widget (that is going to be the textview)
 scrolled_window = Gtk.ScrolledWindow()
 scrolled_window.set_border_width(5)
 # we scroll only if needed
 scrolled_window.set_policy(
 Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

 # a text buffer (stores text)
 buffer1 = Gtk.TextBuffer()

 # a textview (displays the buffer)
 textview = Gtk.TextView(buffer=buffer1)
 # wrap the text, if needed, breaking lines in between words
 textview.set_wrap_mode(Gtk.WrapMode.WORD)

 # textview is scrolled
 scrolled_window.add(textview)

 self.add(scrolled_window)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a TextView widget
A
Methods for a TextView widget:
The TextView widget is by default editable. If you prefer otherwise, use
The justification of the text is set with
The line wrapping of the text is set with
Methods for a TextBuffer widget:






To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then apply that tag to the region of text using
tag = textbuffer.create_tag("orange_bg", background="orange")
textbuffer.apply_tag(tag, start_iter, end_iter)
The following are some of the common styles applied to text:
Background colour ("background" property)
Foreground colour ("foreground" property)
Underline ("underline" property)
Bold ("weight" property)
Italics ("style" property)
Strikethrough ("strikethrough" property)
Justification ("justification" property)
Size ("size" and "size-points" properties)
Text wrapping ("wrap-mode" property)
You can also delete particular tags later using
Methods for a TextIter widget





TextView (Vala)
If we have a loooooooooooooooooooooooooooooooooooong word, a horizontal scrollbar will appear.
/* This is the application. */
public class MyApplication : Gtk.Application {
 /* Override the 'activate' signal of GLib.Application. */
 protected override void activate () {
 /* Create the window of this applicationt. */
 new MyWindow (this).show_all ();
 }
}

/* This is the window. */
class MyWindow: Gtk.ApplicationWindow {
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "TextView Example");
 this.set_default_size (220, 200);

 var buffer = new Gtk.TextBuffer (null); //stores text to be displayed
 var textview = new Gtk.TextView.with_buffer (buffer); //displays TextBuffer
 textview.set_wrap_mode (Gtk.WrapMode.WORD); //sets line wrapping

 var scrolled_window = new Gtk.ScrolledWindow (null, null);
 scrolled_window.set_policy (Gtk.PolicyType.AUTOMATIC,
 Gtk.PolicyType.AUTOMATIC);

 scrolled_window.add (textview);
 scrolled_window.set_border_width (5);

 this.add (scrolled_window);
 }
}
/* main creates and runs the application. */
public int main (string[] args) {
 return new MyApplication ().run (args);
}



external ref='media/togglebutton.png' md5='791e062613d4f9bd5936390b0aa18448'
ToggleButton (C)
A button which retains state
ToggleButton
When this ToggleButton is in an active state, the spinner spins.
#include &lt;gtk/gtk.hgt;



/*This is the callback function. It is a handler function 
which reacts to the signal. In this case, it will cause the 
spinner to start and stop according to how many times the user 
presses the button.*/
static void
button_toggled_cb (GtkWidget *button,
 gpointer user_data)
{
 GtkWidget *spinner = user_data;

 if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON(button)))
 gtk_spinner_start (GTK_SPINNER (spinner));
 else {
 gtk_spinner_stop (GTK_SPINNER (spinner));
 }
}



static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;
 GtkWidget *button;
 GtkWidget *grid;
 GtkWidget *spinner;

 /*Create a window with a title, border width and a default size*/
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "ToggleButton Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 300, 300);
 gtk_container_set_border_width(GTK_CONTAINER(window), 30);

 /*Create a togglebutton with a label*/
 button = gtk_toggle_button_new_with_label ("Start/Stop");

 /*Create a spinner, with extra horizontal and vertical space*/
 spinner = gtk_spinner_new ();
 gtk_widget_set_hexpand (spinner, TRUE);
 gtk_widget_set_vexpand (spinner, TRUE);

 /*Create a grid and set the row spacing, attach the togglebutton 
 and spinner onto the grid and position them accordingly*/
 grid = gtk_grid_new();
 gtk_grid_set_row_homogeneous (GTK_GRID (grid), FALSE);
 gtk_grid_set_row_spacing (GTK_GRID (grid), 15);
 gtk_grid_attach (GTK_GRID (grid), spinner, 0, 0, 1, 1);
 gtk_grid_attach (GTK_GRID (grid), button, 0, 1, 1, 1);
 
 gtk_container_add (GTK_CONTAINER (window), grid);

 /*Connecting the toggled signal to the callback*/
 g_signal_connect (GTK_TOGGLE_BUTTON (button), "toggled", 
 G_CALLBACK (button_toggled_cb), spinner);

 gtk_widget_show_all (window);
}



int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}

ToggleButton (JavaScript)
Stays pressed until you click it again
A ToggleButton is like a normal
A ToggleButton's get_active method returns true if it's pressed in, and false if it's not. Its set_active method is used if you want to change its state without needing to click on it. When it changes state from pressed in to popped out and vice-versa, it sends out the "toggled" signal, which you can connect to a function to do something.
const ToggleButtonExample = new Lang.Class({
 Name: 'ToggleButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jstogglebutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 300,
 default_width: 300,
 border_width: 30,
 title: "ToggleButton Example"});
Creating the ToggleButton and other widgets
// Create the spinner that the button stops and starts
 this._spinner = new Gtk.Spinner ({hexpand: true, vexpand: true});
We want this
// Create the togglebutton that starts and stops the spinner
 this._toggleButton = new Gtk.ToggleButton ({label: "Start/Stop"});
 this._toggleButton.connect ('toggled', Lang.bind (this, this._onToggle));
Creating a ToggleButton is a lot like creating a normal
// Create a grid and put everything in it
 this._grid = new Gtk.Grid ({
 row_homogeneous: false,
 row_spacing: 15});
 this._grid.attach (this._spinner, 0, 0, 1, 1);
 this._grid.attach (this._toggleButton, 0, 1, 1, 1);
Here we create a simple
// Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },
Now we add the Grid to the Window, and tell the Window to show itself and its child widgets when the application is started.
Making something happen when the ToggleButton is toggled
_onToggle: function() {

 // Start or stop the spinner
 if (this._toggleButton.get_active ())
 this._spinner.start ();
 else this._spinner.stop ();

 }

});
Whenever someone toggles the button, this function checks what its state is afterwards using get_active and starts or stops the spinner accordingly. We want it to spin only while the button is pressed in, so if get_active returns true we start the spinner. Otherwise, we tell it to stop.
// Run the application
let app = new ToggleButtonExample ();
app.application.run (ARGV);
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const ToggleButtonExample = new Lang.Class({
 Name: 'ToggleButton Example',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jstogglebutton',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 300,
 default_width: 300,
 border_width: 30,
 title: "ToggleButton Example"});

 // Create the spinner that the button stops and starts
 this._spinner = new Gtk.Spinner ({hexpand: true, vexpand: true});

 // Create the togglebutton that starts and stops the spinner
 this._toggleButton = new Gtk.ToggleButton ({label: "Start/Stop"});
 this._toggleButton.connect ('toggled', Lang.bind (this, this._onToggle));

 // Create a grid and put everything in it
 this._grid = new Gtk.Grid ({
 row_homogeneous: false,
 row_spacing: 15});
 this._grid.attach (this._spinner, 0, 0, 1, 1);
 this._grid.attach (this._toggleButton, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onToggle: function() {

 // Start or stop the spinner
 if (this._toggleButton.get_active ())
 this._spinner.start ();
 else this._spinner.stop ();

 }

});

// Run the application
let app = new ToggleButtonExample ();
app.application.run (ARGV);

ToggleButton (Python)
from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):
 # a window

 def __init__(self, app):
 Gtk.Window.__init__(
 self, title="ToggleButton Example", application=app)
 self.set_default_size(300, 300)
 self.set_border_width(30)

 # a spinner animation
 self.spinner = Gtk.Spinner()
 # with extra horizontal space
 self.spinner.set_hexpand(True)
 # with extra vertical space
 self.spinner.set_vexpand(True)

 # a togglebutton
 button = Gtk.ToggleButton.new_with_label("Start/Stop")
 # connect the signal "toggled" emitted by the togglebutton
 # when its state is changed to the callback function toggled_cb
 button.connect("toggled", self.toggled_cb)

 # a grid to allocate the widgets
 grid = Gtk.Grid()
 grid.set_row_homogeneous(False)
 grid.set_row_spacing(15)
 grid.attach(self.spinner, 0, 0, 1, 1)
 grid.attach(button, 0, 1, 1, 1)

 # add the grid to the window
 self.add(grid)

 # callback function for the signal "toggled"
 def toggled_cb(self, button):
 # if the togglebutton is active, start the spinner
 if button.get_active():
 self.spinner.start()
 # else, stop it
 else:
 self.spinner.stop()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a ToggleButton widget
In line 22 the signal

ToggleButton (Vala)
public class MyWindow : Gtk.ApplicationWindow {

 Gtk.Spinner spinner;

 internal MyWindow (MyApplication app) {
 Object (application: app, title: "ToggleButton Example");

 this.set_default_size (300, 300);
 this.border_width = 30;

 /*Spinner*/
 spinner = new Gtk.Spinner ();
 spinner.set_hexpand (true);
 spinner.set_vexpand (true);

 /*ToggleButton*/
 var togglebutton = new Gtk.ToggleButton.with_label ("Start/Stop");
 togglebutton.toggled.connect (toggled_cb);

 /*Grid*/
 var grid = new Gtk.Grid ();
 grid.set_row_homogeneous (false);
 grid.set_row_spacing (15);
 grid.attach (spinner, 0, 0, 1, 1);
 grid.attach (togglebutton, 0, 1, 1, 1);

 this.add (grid);
 }

 void toggled_cb (Gtk.ToggleButton button) {
 if (button.get_active()) {
 spinner.start ();
 }
 else {
 spinner.stop ();
 }
 }
}

public class MyApplication : Gtk.Application {

 protected override void activate () {

 //Show all the things
 new MyWindow (this).show_all ();
 }

 internal MyApplication () {
 Object (application_id: "org.example.spinner");
 }
}

public int main (string[] args) {
 return new MyApplication ().run (args);
}

external ref='media/toolbar.png' md5='f0350855eedf6343952b72d6d906f738'
Toolbar (C)
A bar of buttons
Toolbar
Toolbar can contain either text or stock icons. In this sample we use stock icons. This example has fullscreen functionality.
This example uses SimpleActions (window and app). App actions can easily be added to the app menu.
#include &lt;gtk/gtk.hgt;

/* Declare these two Toolbuttons, as they will be used in both the fullscreen
 * action callback as well as the activate function.
 */
GtkToolItem *fullscreen_button;
GtkToolItem *leavefullscreen_button;



/* Callback function for the undo action */
static void
undo_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"Undo\\".\
");
}



/* Callback function for the fullscreen action */
static void
fullscreen_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 GdkWindow *window = gtk_widget_get_window (GTK_WIDGET (user_data));

 GdkWindowState current_state = gdk_window_get_state (window);

 /* If the window is currently in fullscreen mode */
 if ( (current_state & GDK_WINDOW_STATE_FULLSCREEN) != 0)
 {
 /* Minimize the window and change to the fullscreen button */
 gdk_window_unfullscreen (window);
 gtk_widget_hide (GTK_WIDGET(leavefullscreen_button));
 gtk_widget_show (GTK_WIDGET(fullscreen_button));
 }
 else
 {
 /* Maximize the window, and change to the unfullscreen button */
 gdk_window_fullscreen (window);
 gtk_widget_hide (GTK_WIDGET (fullscreen_button));
 gtk_widget_show (GTK_WIDGET (leavefullscreen_button));
 }
}


static void
activate (GtkApplication *app,
 gpointer user_data)
{
 /* Initialize variables */
 GtkWidget *window;
 GtkWidget *grid;
 GtkWidget *toolbar;

 GtkToolItem *new_button;
 GtkToolItem *open_button;
 GtkToolItem *undo_button;

 GtkStyleContext *style_context;

 GSimpleAction *undo_action;
 GSimpleAction *fullscreen_action;
 GSimpleAction *leavefullscreen_action;

 /* Create a window with a title and a default size */
 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Toolbar Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 400, 200);

 /* Here we begin to create the toolbar */
 toolbar = gtk_toolbar_new ();
 /* Set the toolbar to be the primary toolbar of the application */
 style_context = gtk_widget_get_style_context (toolbar);
 gtk_style_context_add_class (style_context, GTK_STYLE_CLASS_PRIMARY_TOOLBAR);

 /* Create a button for the "new" action, with a stock image */
 new_button = gtk_tool_button_new_from_stock (GTK_STOCK_NEW);
 /* Show the "new" button's label */
 gtk_tool_item_set_is_important (new_button, TRUE);
 /* Insert the button in the desired position within the toolbar */
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), new_button, 0);
 /* Show the button */
 gtk_widget_show (GTK_WIDGET (new_button));
 /* Set the action name for the "new" action. We use "app.new" to
 * indicate that the action controls the application.
 */
 gtk_actionable_set_action_name (GTK_ACTIONABLE (new_button), "app.new");

 /* Repeat the same steps for the "open" action */
 open_button = gtk_tool_button_new_from_stock (GTK_STOCK_OPEN);
 gtk_tool_item_set_is_important (open_button, TRUE);
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), open_button, 1);
 gtk_widget_show (GTK_WIDGET (open_button));
 gtk_actionable_set_action_name (GTK_ACTIONABLE (open_button), "app.open");

 /* Repeat the same steps for the "undo" action */
 undo_button = gtk_tool_button_new_from_stock (GTK_STOCK_UNDO);
 gtk_tool_item_set_is_important (undo_button, TRUE);
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), undo_button, 2);
 gtk_widget_show (GTK_WIDGET (undo_button));
 /* In this case, we use "win.undo" to indicate that
 * the action controls only the window
 */
 gtk_actionable_set_action_name (GTK_ACTIONABLE (undo_button), "win.undo");

 /* Repeat the same steps for the "fullscreen" action */
 fullscreen_button = gtk_tool_button_new_from_stock (GTK_STOCK_FULLSCREEN);
 gtk_tool_item_set_is_important (fullscreen_button, TRUE);
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), fullscreen_button, 3);
 gtk_widget_show (GTK_WIDGET (fullscreen_button));
 gtk_actionable_set_action_name (GTK_ACTIONABLE (fullscreen_button),
 "win.fullscreen");

 /*Repeat the same steps for the "leavefullscreen" action */
 leavefullscreen_button = gtk_tool_button_new_from_stock (GTK_STOCK_LEAVE_FULLSCREEN);
 gtk_tool_item_set_is_important (leavefullscreen_button, TRUE);
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), leavefullscreen_button, 3);
 /* The only difference here is that we don't show the leavefullscreen button,
 * as it will later replace the fullscreen button.
 */
 gtk_actionable_set_action_name (GTK_ACTIONABLE (leavefullscreen_button),
 "win.leavefullscreen");

 /* Once we've created the bare-bones of the toolbar, we make
 * sure it has enough horizontal space.
 */
 gtk_widget_set_hexpand (toolbar, TRUE);
 gtk_widget_show (toolbar);

 /* Attach the toolbar to the grid and add it to the overall window */
 grid = gtk_grid_new ();
 gtk_grid_attach (GTK_GRID (grid), toolbar, 0, 0, 1, 1);
 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (grid));
 gtk_widget_show (GTK_WIDGET (grid));

 /* Use the action names to create the actions that control the window, and
 * connect them to the appropriate callbackfunctions.
 */
 undo_action = g_simple_action_new ("undo", NULL);
 g_signal_connect (undo_action, "activate", G_CALLBACK (undo_callback),
 GTK_WINDOW (window));
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (undo_action));

 fullscreen_action = g_simple_action_new ("fullscreen", NULL);
 g_signal_connect (fullscreen_action, "activate", G_CALLBACK (fullscreen_callback),
 GTK_WINDOW (window));
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (fullscreen_action));

 leavefullscreen_action = g_simple_action_new ("leavefullscreen", NULL);
 g_signal_connect (leavefullscreen_action, "activate", G_CALLBACK (fullscreen_callback),
 GTK_WINDOW (window));
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (leavefullscreen_action));

 gtk_widget_show (window);
}



/* Callback function for the new action */
static void
new_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"New\\".\
");
}



/* Callback function for the open action */
static void
open_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"Open\\".\
");
}



/* In this function, we create the actions in which control the window, and
 * connect their signals to the appropriate callback function.
 */
static void
startup (GApplication *app,
 gpointer user_data)
{
 GSimpleAction *new_action;
 GSimpleAction *open_action;

 new_action = g_simple_action_new ("new", NULL);
 g_signal_connect (new_action, "activate", G_CALLBACK (new_callback), app);
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (new_action));

 open_action = g_simple_action_new ("open", NULL);
 g_signal_connect (open_action, "activate", G_CALLBACK (open_callback), app);
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (open_action));
}



/* Startup function for the application */
int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 g_signal_connect (app, "startup", G_CALLBACK (startup), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}


Toolbar (JavaScript)
A bar of tools
This example uses SimpleActions (window and app). App actions can easily be added the the app menu.
#!/usr/bin/gjs

const Gdk = imports.gi.Gdk;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const Application = new Lang.Class({
 Name: 'Application',

 //create the application
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.myapp',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 //connect to 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 //create the UI (in this case it's just the ApplicationWindow
 _buildUI: function() {
 this._window = new Gtk.ApplicationWindow({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Toolbar Example",
 default_height: 200,
 default_width: 400 });

 this._grid = new Gtk.Grid();
 this._window.add(this._grid);
 this._grid.show();

 this._createToolbar();
 this._toolbar.set_hexpand(true);
 this._grid.attach(this._toolbar, 0, 0, 1, 1);

 //show the toolbar and window
 this._toolbar.show();
 this._window.show();
 },

 //callback function for 'activate' signal
 _onActivate: function() {
 this._window.present();
 },

 //callback function for 'startup' signal
 _onStartup: function() {
 this._initMenus();
 this._buildUI();
 },

 //create the toolbar, its toolbuttons and their actions
 _createToolbar: function() {

 this._toolbar = new Gtk.Toolbar();
 this._toolbar.get_style_context().add_class(Gtk.STYLE_CLASS_PRIMARY_TOOLBAR);

 //create the "New" ToolButton and its SimpleAction.
 //Using actions allows you to add them to the app menu
 //without duplicating code.
 let newAction = new Gio.SimpleAction({ name: 'new'});
 newAction.connect('activate', Lang.bind(this,
 function() {
 this._newCB();
 }));
 this.application.add_action(newAction);//note: this action is added to the app

 this._newButton = new Gtk.ToolButton.new_from_stock(Gtk.STOCK_NEW);
 this._newButton.is_important = true;
 this._toolbar.add(this._newButton);
 this._newButton.show();
 this._newButton.action_name = "app.new";

 //create the "Open" ToolButton and its SimpleAction
 let openAction = new Gio.SimpleAction({ name: 'open'});
 openAction.connect('activate', Lang.bind(this,
 function() {
 this._openCB();
 }));
 this.application.add_action(openAction);

 this._openButton = new Gtk.ToolButton.new_from_stock(Gtk.STOCK_OPEN);
 this._openButton.is_important = true;
 this._toolbar.add(this._openButton);
 this._openButton.show();
 this._openButton.action_name = "app.open";

 //create the "Undo" ToolButton and its SimpleAction
 let undoAction = new Gio.SimpleAction({ name: 'undo'});
 undoAction.connect('activate', Lang.bind (this,
 function() {
 this._undoCB();
 }));
 this._window.add_action(undoAction);//note this action is added to the window

 this._undoButton = new Gtk.ToolButton.new_from_stock(Gtk.STOCK_UNDO);
 this._undoButton.is_important = true;
 this._toolbar.add(this._undoButton);
 this._undoButton.show();
 this._undoButton.action_name = "win.undo";

 //create the "Fullscreen" ToolButton and its SimpleAction
 let fullscreenToggleAction = new Gio.SimpleAction ({ name: 'fullscreenToggle' });
 fullscreenToggleAction.connect ('activate', Lang.bind (this,
 function () {
 this._fullscreenToggleCB();
 }));
 this._window.add_action(fullscreenToggleAction);

 this._fullscreenButton = new Gtk.ToolButton.new_from_stock(Gtk.STOCK_FULLSCREEN);
 this._fullscreenButton.is_important = true;
 this._toolbar.add(this._fullscreenButton);
 this._fullscreenButton.show();
 this._fullscreenButton.action_name = "win.fullscreenToggle";

 //create the "leaveFullscreen" ToolButton, and set the action name to "win.fullscreenToggle"
 this._leaveFullscreenButton = new Gtk.ToolButton.new_from_stock(Gtk.STOCK_LEAVE_FULLSCREEN);
 this._leaveFullscreenButton.is_important = true;
 this._toolbar.add(this._leaveFullscreenButton);
 this._leaveFullscreenButton.action_name = "win.fullscreenToggle";
 },

 _initMenus: function () {
 let menu = new Gio.Menu();
 menu.append("New", 'app.new');
 menu.append("Open", 'app.open');
 menu.append("Quit", 'app.quit');

 this.application.set_app_menu(menu);

 let quitAction = new Gio.SimpleAction({name: 'quit' });
 quitAction.connect('activate', Lang.bind(this,
 function() {
 this._window.destroy();
 }));
 this.application.add_action(quitAction);
 },

 _newCB: function() {
 print("You clicked 'New'.");
 },

 _openCB: function() {
 print("You clicked 'Open'.");
 },

 _undoCB:function () {
 print ("You clicked 'Undo'.");
 },

 _fullscreenToggleCB: function() {
 if ((this._window.get_window().get_state() & Gdk.WindowState.FULLSCREEN) != 0 ) {
 this._window.unfullscreen();
 this._leaveFullscreenButton.hide();
 this._fullscreenButton.show();
 }
 else {
 this._window.fullscreen();
 this._fullscreenButton.hide();
 this._leaveFullscreenButton.show();
 }
 }
});

//run the application
let app = new Application();
app.application.run(ARGV);





Toolbar (Python)
A bar of buttons and other widgets
An example of toolbar with buttons (from stock icons).
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Toolbar Example", application=app)
 self.set_default_size(400, 200)

 # a grid to attach the toolbar
 grid = Gtk.Grid()

 # a toolbar created in the method create_toolbar (see below)
 toolbar = self.create_toolbar()
 # with extra horizontal space
 toolbar.set_hexpand(True)
 # show the toolbar
 toolbar.show()

 # attach the toolbar to the grid
 grid.attach(toolbar, 0, 0, 1, 1)

 # add the grid to the window
 self.add(grid)

 # create the actions that control the window and connect their signal to a
 # callback method (see below):

 # undo
 undo_action = Gio.SimpleAction.new("undo", None)
 undo_action.connect("activate", self.undo_callback)
 self.add_action(undo_action)

 # fullscreen
 fullscreen_action = Gio.SimpleAction.new("fullscreen", None)
 fullscreen_action.connect("activate", self.fullscreen_callback)
 self.add_action(fullscreen_action)

 # a method to create the toolbar
 def create_toolbar(self):
 # a toolbar
 toolbar = Gtk.Toolbar()

 # which is the primary toolbar of the application
 toolbar.get_style_context().add_class(Gtk.STYLE_CLASS_PRIMARY_TOOLBAR)

 # create a button for the "new" action, with a stock image
 new_button = Gtk.ToolButton.new_from_stock(Gtk.STOCK_NEW)
 # label is shown
 new_button.set_is_important(True)
 # insert the button at position in the toolbar
 toolbar.insert(new_button, 0)
 # show the button
 new_button.show()
 # set the name of the action associated with the button.
 # The action controls the application (app)
 new_button.set_action_name("app.new")

 # button for the "open" action
 open_button = Gtk.ToolButton.new_from_stock(Gtk.STOCK_OPEN)
 open_button.set_is_important(True)
 toolbar.insert(open_button, 1)
 open_button.show()
 open_button.set_action_name("app.open")

 # button for the "undo" action
 undo_button = Gtk.ToolButton.new_from_stock(Gtk.STOCK_UNDO)
 undo_button.set_is_important(True)
 toolbar.insert(undo_button, 2)
 undo_button.show()
 undo_button.set_action_name("win.undo")

 # button for the "fullscreen/leave fullscreen" action
 self.fullscreen_button = Gtk.ToolButton.new_from_stock(
 Gtk.STOCK_FULLSCREEN)
 self.fullscreen_button.set_is_important(True)
 toolbar.insert(self.fullscreen_button, 3)
 self.fullscreen_button.set_action_name("win.fullscreen")

 # return the complete toolbar
 return toolbar

 # callback method for undo
 def undo_callback(self, action, parameter):
 print "You clicked \\"Undo\\"."

 # callback method for fullscreen / leave fullscreen
 def fullscreen_callback(self, action, parameter):
 # check if the state is the same as Gdk.WindowState.FULLSCREEN, which
 # is a bit flag
 is_fullscreen = self.get_window().get_state(
 ) & Gdk.WindowState.FULLSCREEN != 0
 if not is_fullscreen:
 self.fullscreen_button.set_stock_id(Gtk.STOCK_LEAVE_FULLSCREEN)
 self.fullscreen()
 else:
 self.fullscreen_button.set_stock_id(Gtk.STOCK_FULLSCREEN)
 self.unfullscreen()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 # create the actions that control the window and connect their signal to a
 # callback method (see below):

 # new
 new_action = Gio.SimpleAction.new("new", None)
 new_action.connect("activate", self.new_callback)
 app.add_action(new_action)

 # open
 open_action = Gio.SimpleAction.new("open", None)
 open_action.connect("activate", self.open_callback)
 app.add_action(open_action)

 # callback method for new
 def new_callback(self, action, parameter):
 print "You clicked \\"New\\"."

 # callback method for open
 def open_callback(self, action, parameter):
 print "You clicked \\"Open\\"."

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Toolbar widget
In line 32 the signal
Use


If the toolbar does not have room for all the menu items, and







Toolbar (Vala)
/* This is the Window */
class MyWindow : Gtk.ApplicationWindow {

 /* Instance variables belonging to the window */
 Gtk.Toolbar toolbar;
 Gtk.ToolButton new_button;
 Gtk.ToolButton open_button;
 Gtk.ToolButton undo_button;
 Gtk.ToolButton fullscreen_button;
 Gtk.ToolButton leave_fullscreen_button;

 /* Contstructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Toolbar Example");

 this.set_default_size (400, 200);
 var grid = new Gtk.Grid ();
 this.add (grid);
 grid.show ();

 create_toolbar ();
 toolbar.set_hexpand (true);
 grid.attach (toolbar, 0, 0, 1, 1);
 toolbar.show ();

 /* create the "undo" window action action */
 var undo_action = new SimpleAction ("undo", null);
 undo_action.activate.connect (undo_callback);
 this.add_action (undo_action);

 /* create the "fullscreen" window action */
 var fullscreen_action = new SimpleAction ("fullscreen", null);
 fullscreen_action.activate.connect (fullscreen_callback);
 this.add_action (fullscreen_action);
 }

 /* This function creates the toolbar, its ToolButtons,
 * and assigns the actions names to the ToolButtons.*/
 void create_toolbar () {
 toolbar = new Gtk.Toolbar ();
 toolbar.get_style_context ().add_class (Gtk.STYLE_CLASS_PRIMARY_TOOLBAR);

 new_button = new Gtk.ToolButton.from_stock (Gtk.Stock.NEW);
 new_button.is_important = true; //decides whether to show the label
 toolbar.add (new_button);
 new_button.show ();
 new_button.action_name = "app.new";

 open_button = new Gtk.ToolButton.from_stock (Gtk.Stock.OPEN);
 open_button.is_important = true;
 toolbar.add (open_button);
 open_button.show ();
 open_button.action_name = "app.open";

 undo_button = new Gtk.ToolButton.from_stock (Gtk.Stock.UNDO);
 undo_button.is_important = true;
 toolbar.add (undo_button);
 undo_button.show ();
 undo_button.action_name = "win.undo";

 fullscreen_button = new Gtk.ToolButton.from_stock (Gtk.Stock.FULLSCREEN);
 fullscreen_button.is_important = true;
 toolbar.add (fullscreen_button);
 fullscreen_button.show ();
 fullscreen_button.action_name = "win.fullscreen";

 leave_fullscreen_button = new Gtk.ToolButton.from_stock (Gtk.Stock.LEAVE_FULLSCREEN)
;
 leave_fullscreen_button.is_important = true;
 toolbar.add (leave_fullscreen_button);

 leave_fullscreen_button.action_name = "win.fullscreen";
 }

 void undo_callback (SimpleAction simple, Variant? parameter) {
 print ("You clicked \\"Undo\\".\
");
 }

 void fullscreen_callback (SimpleAction simple, Variant? parameter) {
 if ((this.get_window ().get_state () & Gdk.WindowState.FULLSCREEN) != 0) {
 this.unfullscreen ();
 leave_fullscreen_button.hide ();
 fullscreen_button.show ();
 }
 else {
 this.fullscreen ();
 fullscreen_button.hide ();
 leave_fullscreen_button.show ();
 }
 }
}

/* This is the application */
class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }

 protected override void startup () {
 base.startup ();

 /* Create the "new" action and add it to the app*/
 var new_action = new SimpleAction ("new", null);
 new_action.activate.connect (new_callback);
 this.add_action (new_action);

 /* Create the "open" action, and add it to the app */
 var open_action = new SimpleAction ("open", null);
 open_action.activate.connect (open_callback);
 this.add_action (open_action);

 /* You could also add the action to the app menu
 * if you wanted to.
 */
 //var menu = new Menu ();
 //menu.append ("New", "app.new");
 //this.app_menu = menu;
 }

 void new_callback (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"New\\".\
");
 }

 void open_callback (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"Open\\".\
");
 }
}

/* The main function creates the application and runs it. */
int main (string[] args) {
 return new MyApplication ().run (args);
}



external ref='media/glade_ui.png' md5='baea74fe213bc12ea934f64f6977215a'
external ref='media/glade_select_toolbar.png' md5='f7b5b224050b2e387eb04362fc99df00'
external ref='media/glade_toolbar_general.png' md5='e31daba6e8a3e526aca89d5f1622edaa'
external ref='media/glade_toolbar_common.png' md5='d5ec6cc0218ca98e195dbd033feb9ac5'
external ref='media/glade_toolbar_edit.png' md5='feb1e2b7040d24a4d030f94cf07c81fd'
external ref='media/glade_toolbar_editor.png' md5='8af65241e5ca47d5494a7b36640e6f1c'
external ref='media/glade_visible_no.png' md5='dc6c025aa825f4d772fbd283d6330026'
Toolbar created using Glade (Python)
Toolbar created using Glade
This example is similar to
Creating the toolbar with Glade
To create the toolbar using the
Open Glade, and save the file as

Under

Under the

Under the

Right click on the toolbar in the top right and select

We want to add 5 ToolButtons: New, Open, Undo, Fullscreen and Leave Fullscreen. First, we will add the New ToolButton.
Under
Change the name of the ToolItem to
Scroll down and set
Enter the
Change the
Select the
Repeat the above steps for the remaining ToolButtons, with the following properties:
Is important
Action name
Stock Id
open_button
Yes
app.open
Open
gtk-open
undo_button
win.undo
Undo
gtk-undo
fullscreen_button
win.fullscreen
Fullscreen
gtk-fullscreen
leave_fullscreen_button
Leave Fullscreen
gtk-leave-fullscreen
Close the
When our program will first start, we do not want the

Save your work, and close Glade.
The XML file created by Glade is shown below. This is the description of the toolbar. At the time of this writing, the option to add the class Gtk.STYLE_CLASS_PRIMARY_TOOLBAR in the Glade Interface did not exist. We can manually add this to the XML file. To do this, add the following XML code at line 9 of
&lt;stylegt;
 &lt;class name="primary-toolbar"/gt;
 &lt;/stylegt;
If you do not add this, the program will still work fine. The resulting toolbar will however look slightly different then the screenshot at the top of this page.
&lt;?xml version="1.0" encoding="UTF-8"?gt;
&lt;interfacegt;
 &lt;!-- interface-requires gtk+ 3.0 --gt;
 &lt;object class="GtkToolbar" id="toolbar"gt;
 &lt;property name="visible"gt;Truelt;/propertygt;
 &lt;property name="can_focus"gt;Falselt;/propertygt;
 &lt;property name="hexpand"gt;Truelt;/propertygt;
 &lt;property name="show_arrow"gt;Falselt;/propertygt;
 &lt;childgt;
 &lt;object class="GtkToolButton" id="new_button"gt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="visible"gt;Truelt;/propertygt;
 &lt;property name="can_focus"gt;Falselt;/propertygt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="is_important"gt;Truelt;/propertygt;
 &lt;property name="action_name"gt;app.newlt;/propertygt;
 &lt;property name="label" translatable="yes"gt;Newlt;/propertygt;
 &lt;property name="use_underline"gt;Truelt;/propertygt;
 &lt;property name="stock_id"gt;gtk-newlt;/propertygt;
 &lt;/objectgt;
 &lt;packinggt;
 &lt;property name="expand"gt;Falselt;/propertygt;
 &lt;property name="homogeneous"gt;Truelt;/propertygt;
 &lt;/packinggt;
 &lt;/childgt;
 &lt;childgt;
 &lt;object class="GtkToolButton" id="open_button"gt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="visible"gt;Truelt;/propertygt;
 &lt;property name="can_focus"gt;Falselt;/propertygt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="is_important"gt;Truelt;/propertygt;
 &lt;property name="action_name"gt;app.openlt;/propertygt;
 &lt;property name="label" translatable="yes"gt;Openlt;/propertygt;
 &lt;property name="use_underline"gt;Truelt;/propertygt;
 &lt;property name="stock_id"gt;gtk-openlt;/propertygt;
 &lt;/objectgt;
 &lt;packinggt;
 &lt;property name="expand"gt;Falselt;/propertygt;
 &lt;property name="homogeneous"gt;Truelt;/propertygt;
 &lt;/packinggt;
 &lt;/childgt;
 &lt;childgt;
 &lt;object class="GtkToolButton" id="undo_button"gt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="visible"gt;Truelt;/propertygt;
 &lt;property name="can_focus"gt;Falselt;/propertygt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="is_important"gt;Truelt;/propertygt;
 &lt;property name="action_name"gt;win.undolt;/propertygt;
 &lt;property name="label" translatable="yes"gt;Undolt;/propertygt;
 &lt;property name="use_underline"gt;Truelt;/propertygt;
 &lt;property name="stock_id"gt;gtk-undolt;/propertygt;
 &lt;/objectgt;
 &lt;packinggt;
 &lt;property name="expand"gt;Falselt;/propertygt;
 &lt;property name="homogeneous"gt;Truelt;/propertygt;
 &lt;/packinggt;
 &lt;/childgt;
 &lt;childgt;
 &lt;object class="GtkToolButton" id="fullscreen_button"gt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="visible"gt;Truelt;/propertygt;
 &lt;property name="can_focus"gt;Falselt;/propertygt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="is_important"gt;Truelt;/propertygt;
 &lt;property name="action_name"gt;win.fullscreenlt;/propertygt;
 &lt;property name="label" translatable="yes"gt;Fullscreenlt;/propertygt;
 &lt;property name="use_underline"gt;Truelt;/propertygt;
 &lt;property name="stock_id"gt;gtk-fullscreenlt;/propertygt;
 &lt;/objectgt;
 &lt;packinggt;
 &lt;property name="expand"gt;Falselt;/propertygt;
 &lt;property name="homogeneous"gt;Truelt;/propertygt;
 &lt;/packinggt;
 &lt;/childgt;
 &lt;childgt;
 &lt;object class="GtkToolButton" id="leave_fullscreen_button"gt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="can_focus"gt;Falselt;/propertygt;
 &lt;property name="use_action_appearance"gt;Falselt;/propertygt;
 &lt;property name="is_important"gt;Truelt;/propertygt;
 &lt;property name="action_name"gt;win.fullscreenlt;/propertygt;
 &lt;property name="label" translatable="yes"gt;Leave Fullscreenlt;/propertygt;
 &lt;property name="use_underline"gt;Truelt;/propertygt;
 &lt;property name="stock_id"gt;gtk-leave-fullscreenlt;/propertygt;
 &lt;/objectgt;
 &lt;packinggt;
 &lt;property name="expand"gt;Falselt;/propertygt;
 &lt;property name="homogeneous"gt;Truelt;/propertygt;
 &lt;/packinggt;
 &lt;/childgt;
 &lt;/objectgt;
&lt;/interfacegt;
We now create the code below, which adds the toolbar from the file we just created.
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Toolbar Example", application=app)
 self.set_default_size(400, 200)

 # a grid to attach the toolbar (see below)
 grid = Gtk.Grid()
 self.add(grid)
 # we have to show the grid (and therefore the toolbar) with show(),
 # as show_all() would show also the buttons in the toolbar that we want to
 # be hidden (such as the leave_fullscreen button)
 grid.show()

 # a builder to add the UI designed with Glade to the grid:
 builder = Gtk.Builder()
 # get the file (if it is there)
 try:
 builder.add_from_file("toolbar_builder.ui")
 except:
 print "file not found"
 sys.exit()
 # and attach it to the grid
 grid.attach(builder.get_object("toolbar"), 0, 0, 1, 1)

 # two buttons that will be used later in a method
 self.fullscreen_button = builder.get_object("fullscreen_button")
 self.leave_fullscreen_button = builder.get_object(
 "leave_fullscreen_button")

 # create the actions that control the window, connect their signal to a
 # callback method (see below), add the action to the window:

 # undo
 undo_action = Gio.SimpleAction.new("undo", None)
 undo_action.connect("activate", self.undo_callback)
 self.add_action(undo_action)

 # and fullscreen
 fullscreen_action = Gio.SimpleAction.new("fullscreen", None)
 fullscreen_action.connect("activate", self.fullscreen_callback)
 self.add_action(fullscreen_action)

 # callback for undo
 def undo_callback(self, action, parameter):
 print "You clicked \\"Undo\\"."

 # callback for fullscreen
 def fullscreen_callback(self, action, parameter):
 # check if the state is the same as Gdk.WindowState.FULLSCREEN, which
 # is a bit flag
 is_fullscreen = self.get_window().get_state(
 ) & Gdk.WindowState.FULLSCREEN != 0
 if is_fullscreen:
 self.unfullscreen()
 self.leave_fullscreen_button.hide()
 self.fullscreen_button.show()
 else:
 self.fullscreen()
 self.fullscreen_button.hide()
 self.leave_fullscreen_button.show()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 # show the window - with show() not show_all() because that would show also
 # the leave_fullscreen button
 win.show()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 # actions that control the application: create, connect their signal to a
 # callback method (see below), add the action to the application

 # new
 new_action = Gio.SimpleAction.new("new", None)
 new_action.connect("activate", self.new_callback)
 app.add_action(new_action)

 # open
 open_action = Gio.SimpleAction.new("open", None)
 open_action.connect("activate", self.open_callback)
 app.add_action(open_action)

 # callback for new
 def new_callback(self, action, parameter):
 print "You clicked \\"New\\"."

 # callback for open
 def open_callback(self, action, parameter):
 print "You clicked \\"Open\\"."

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for Gtk.Builder
For the useful methods for a Toolbar widget, see
Gtk.Builder builds an interface from an XML UI definition.







Toolbar created using Glade (Vala)
This example is similar to
When our program will first start, we don't want the
/* This is the Window */
class MyWindow : Gtk.ApplicationWindow {

 /* Declare these two ToolButtons, as we will get them
 * from the ui file (see lines 32 and 33), so we can
 * hide() and show() them as needed.*/
 Gtk.ToolButton fullscreen_button;
 Gtk.ToolButton leave_fullscreen_button;

 /* Contstructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Toolbar Example");

 this.set_default_size (400, 200);
 var grid = new Gtk.Grid ();
 this.add (grid);
 grid.show ();

 /* add the toolbar from the ui file */
 var builder = new Gtk.Builder ();
 try {
 builder.add_from_file ("toolbar_builder.ui");
 }
 /* Handle the exception */
 catch (Error e) {
 error ("Unable to load file: %s", e.message);
 }

 grid.attach (builder.get_object ("toolbar") as Gtk.Toolbar, 0, 0, 1, 1);

 /* get these objects from the ui file so we can toggle between them */
 fullscreen_button = builder.get_object ("fullscreen_button") as Gtk.ToolButton;
 leave_fullscreen_button = builder.get_object ("leave_fullscreen_button") as Gtk.ToolButton;

 /* create the "undo" window action action */
 var undo_action = new SimpleAction ("undo", null);
 undo_action.activate.connect (undo_callback);
 this.add_action (undo_action);

 /* create the "fullscreen" window action */
 var fullscreen_action = new SimpleAction ("fullscreen", null);
 fullscreen_action.activate.connect (fullscreen_callback);
 this.add_action (fullscreen_action);
 }

 void undo_callback (SimpleAction simple, Variant? parameter) {
 print ("You clicked \\"Undo\\".\
");
 }

 void fullscreen_callback (SimpleAction simple, Variant? parameter) {
 if ((this.get_window ().get_state () & Gdk.WindowState.FULLSCREEN) != 0) {
 this.unfullscreen ();
 leave_fullscreen_button.hide ();
 fullscreen_button.show ();
 }
 else {
 this.fullscreen ();
 fullscreen_button.hide ();
 leave_fullscreen_button.show ();
 }
 }
}

/* This is the application */
class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }

 protected override void startup () {
 base.startup ();

 /* Create the "new" action and add it to the app*/
 var new_action = new SimpleAction ("new", null);
 new_action.activate.connect (new_callback);
 this.add_action (new_action);

 /* Create the "open" action, and add it to the app */
 var open_action = new SimpleAction ("open", null);
 open_action.activate.connect (open_callback);
 this.add_action (open_action);

 /* You could also add the action to the app menu
 * if you wanted to.
 */
 //var menu = new Menu ();
 //menu.append ("New", "app.new");
 //this.app_menu = menu;
 }

 void new_callback (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"New\\".\
");
 }

 void open_callback (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"Open\\".\
");
 }
}

/* The main function creates the application and runs it. */
int main (string[] args) {
 return new MyApplication ().run (args);
}
external ref='media/tooltip.png' md5='41e35860a51e39cb48c71e57bb8fb1d0'
Tooltip (C)
Add tips to your widgets
Tooltip
A toolbar with a tooltip (with an image) for a button.
This example builds on the
#include &lt;gtk/gtk.hgt;

static gboolean 
undo_tooltip_callback (GtkStatusIcon *status_icon,
 gint x,
 gint y,
 gboolean keyboard_mode,
 GtkTooltip *tooltip,
 gpointer user_data)
{
 /* set the text for the tooltip */
 gtk_tooltip_set_text (tooltip, "Undo your last action");
 
 /* set an icon fot the tooltip */
 gtk_tooltip_set_icon_from_stock(tooltip, "gtk-undo", GTK_ICON_SIZE_MENU);

 /* show the tooltip */
 return TRUE;
}


static void
undo_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"Undo\\".\
");
}


static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *grid;
 GtkWidget *window;
 GtkWidget *toolbar;

 GtkToolItem *new_button;
 GtkToolItem *open_button;
 GtkToolItem *undo_button;

 GtkStyleContext *style_context;

 GSimpleAction *undo_action;

 window = gtk_application_window_new (app);
 gtk_window_set_title (GTK_WINDOW (window), "Toolbar with Tooltips Example");
 gtk_window_set_default_size (GTK_WINDOW (window), 400, 200);

 /* Here we begin to create the toolbar */
 toolbar = gtk_toolbar_new ();

 /* Set the toolbar to be the primary toolbar of the application */
 style_context = gtk_widget_get_style_context (toolbar);
 gtk_style_context_add_class (style_context, GTK_STYLE_CLASS_PRIMARY_TOOLBAR);

 /* Create a button for the "new" action, with a stock image */
 new_button = gtk_tool_button_new_from_stock (GTK_STOCK_NEW);
 gtk_tool_item_set_is_important (new_button, TRUE);
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), new_button, 0);
 gtk_widget_show (GTK_WIDGET (new_button));

 /* Set the action name for the "new" action. We use "app.new" to
 * indicate that the action controls the application.
 */
 gtk_actionable_set_action_name (GTK_ACTIONABLE (new_button), "app.new");

 /*******************************
 * Tooltip for the New ToolItem:
 * a tooltip with text
 *******************************/
 gtk_tool_item_set_tooltip_text (new_button, "Create a new file"); 

 /* "Open" */
 open_button = gtk_tool_button_new_from_stock (GTK_STOCK_OPEN);
 gtk_tool_item_set_is_important (open_button, TRUE);
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), open_button, 1);
 gtk_widget_show (GTK_WIDGET (open_button));
 gtk_actionable_set_action_name (GTK_ACTIONABLE (open_button), "app.open");

 /*******************************
 * Tooltip for the Open ToolItem:
 * a tooltip using Pango markup 
 * language
 *******************************/
 gtk_tool_item_set_tooltip_text (open_button, "Open an &lt;igt;existinglt;/igt; file");

 /* "Undo" */
 undo_button = gtk_tool_button_new_from_stock (GTK_STOCK_UNDO);
 gtk_tool_item_set_is_important (undo_button, TRUE);
 gtk_toolbar_insert (GTK_TOOLBAR (toolbar), undo_button, 2);
 gtk_widget_show (GTK_WIDGET (undo_button));

 /* In this case, we use "win.undo" to indicate that
 * the action controls only the window
 */
 gtk_actionable_set_action_name (GTK_ACTIONABLE (undo_button), "win.undo");

 /*******************************
 * Tooltip for the Undo ToolItem:
 * a tooltip with an image
 *******************************/
 gtk_widget_set_has_tooltip (GTK_WIDGET (undo_button), TRUE);

 // Next, we connect the query_tooltip signal
 g_signal_connect (undo_button, "query-tooltip", G_CALLBACK (undo_tooltip_callback), NULL);

 gtk_widget_set_hexpand (toolbar, TRUE);
 gtk_widget_show (toolbar);

 grid = gtk_grid_new ();
 gtk_grid_attach (GTK_GRID (grid), toolbar, 0, 0, 1, 1);
 gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (grid));
 gtk_widget_show (GTK_WIDGET (grid));

 /* Use the action names to create the actions that control the window, and
 * connect them to the appropriate callbackfunctions.
 */
 undo_action = g_simple_action_new ("undo", NULL);
 g_signal_connect (undo_action, "activate", G_CALLBACK (undo_callback),
 GTK_WINDOW (window));
 g_action_map_add_action (G_ACTION_MAP (window), G_ACTION (undo_action));

 gtk_widget_show (window);
}


/* Callback function for the new action */
static void
new_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"New\\".\
");
}


/* Callback function for the open action */
static void
open_callback (GSimpleAction *simple,
 GVariant *parameter,
 gpointer user_data)
{
 g_print ("You clicked \\"Open\\".\
");
}


/* In this function, we create the actions in which control the window, and
 * connect their signals to the appropriate callback function.
 */
static void
startup (GApplication *app,
 gpointer user_data)
{
 GSimpleAction *new_action;
 GSimpleAction *open_action;

 new_action = g_simple_action_new ("new", NULL);
 g_signal_connect (new_action, "activate", G_CALLBACK (new_callback), app);
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (new_action));

 open_action = g_simple_action_new ("open", NULL);
 g_signal_connect (open_action, "activate", G_CALLBACK (open_callback), app);
 g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (open_action));
}



/* Startup function for the application */
int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 g_signal_connect (app, "startup", G_CALLBACK (startup), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);

 return status;
}



Tooltip (JavaScript)
This example builds on the
//!/usr/bin/gjs

const Gdk = imports.gi.Gdk;
const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;
const Gtk = imports.gi.Gtk; 
const Lang = imports.lang;

const TooltipExample = new Lang.Class ({
 Name: 'Tooltip Example',

 // Create the application 
 _init: function () {
 this.application = new Gtk.Application ({ application_id: 'org.example.jstooltip' });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents windows when active
 _onActivate: function() {
 this.window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function () {
 this._buildUI ();
 },

 // Build the application's UI
 _buildUI: function () {

 // Create the application window
 this.window = new Gtk.ApplicationWindow ({ application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 title: "Toolbar with Tooltips Example",
 default_width: 400,
 default_height: 200,
 border_width: 10 });

 this.grid = new Gtk.Grid();

 this.toolbar = this._createToolbar();
 this.toolbar.set_hexpand(true);
 this.toolbar.show();

 this.grid.attach(this.toolbar, 0, 0, 1, 1);

 this.window.add(this.grid);

 this._newAction = new Gio.SimpleAction({ name: "new" });
 this._newAction.connect("activate", Lang.bind(this, this._newCallback));
 this.window.add_action(this._newAction);

 this._openAction = new Gio.SimpleAction({ name: "open" });
 this._openAction.connect("activate", Lang.bind(this, this._openCallback));
 this.window.add_action(this._openAction);

 this._undoAction = new Gio.SimpleAction({ name: "undo" });
 this._undoAction.connect("activate", Lang.bind(this, this._undoCallback));
 this.window.add_action(this._undoAction);

 this._fullScreenAction = new Gio.SimpleAction({ name: "fullscreenToggle" });
 this._fullScreenAction.connect("activate", Lang.bind(this, this._fullScreenCallback));
 this.window.add_action(this._fullScreenAction);

 this.window.show_all();
 },

 _createToolbar: function(){
 this.toolbar = new Gtk.Toolbar();
 this.toolbar.get_style_context().add_class(Gtk.STYLE_CLASS_PRIMARY_TOOLBAR);

 // button for the "new" action
 this.newButton = Gtk.ToolButton.new_from_stock(Gtk.STOCK_NEW);
 // with a tooltip with a given text 
 this.newButton.set_tooltip_text("Create a new file");
 this.newButton.set_is_important(true);
 this.toolbar.insert(this.newButton, 0);
 this.newButton.show();
 this.newButton.set_action_name("win.new");

 // button for the "open" action
 this.openButton = Gtk.ToolButton.new_from_stock(Gtk.STOCK_OPEN);
 // with a tooltip with a given text in the Pango markup language 
 this.openButton.set_tooltip_markup("Open an &lt;igt;existinglt;/igt; file");
 this.openButton.set_is_important(true);
 this.toolbar.insert(this.openButton, 1);
 this.openButton.show();
 this.openButton.set_action_name("win.open");

 // button for the "undo" action
 this.undoButton = Gtk.ToolButton.new_from_stock(Gtk.STOCK_UNDO);
 // with a tooltip with an image
 // set true the property "has-tooltip" 
 this.undoButton.set_property("has-tooltip", true);
 // connect to the callback function that for the tooltip
 // with the signal "query-tooltip"
 this.undoButton.connect("query-tooltip", Lang.bind(this, this._undoTooltipCallback));
 this.undoButton.set_is_important(true);
 this.toolbar.insert(this.undoButton, 2);
 this.undoButton.show();
 this.undoButton.set_action_name("win.undo");

 // button for the "fullscreen/leave fullscreen" action
 this.fullscreenButton = Gtk.ToolButton.new_from_stock(Gtk.STOCK_FULLSCREEN);
 this.fullscreenButton.set_is_important(true);
 this.toolbar.insert(this.fullscreenButton, 3);
 this.fullscreenButton.set_action_name("win.fullscreenToggle");

 return this.toolbar;
 },

 _newCallback: function(action, parameter) {
 print("You clicked \\"New\\".");
 },

 _openCallback: function(action, parameter) {
 print("You clicked \\"Open\\".");
 },

 // the callback function for the tooltip of the "undo" button
 _undoTooltipCallback: function(widget, x, y, keyboard_mode, tooltip) {
 // set the text for the tooltip
 tooltip.set_text("Undo your last action");
 // set an icon fot the tooltip
 tooltip.set_icon_from_stock(Gtk.STOCK_UNDO, Gtk.IconSize.MENU);
 // show the tooltip
 return true;
 },

 _undoCallback: function(action, parameter) {
 print("You clicked \\"Undo\\".");
 },

 _fullScreenCallback: function() {
 if ((this.window.get_window().get_state() & Gdk.WindowState.FULLSCREEN) != 0 ){
 this.fullscreenButton.set_stock_id(Gtk.STOCK_FULLSCREEN);
 this.fullscreenButton.set_tooltip_text("Make your window fullscreen");
 this.window.unfullscreen();
 } else {
 this.fullscreenButton.set_stock_id(Gtk.STOCK_LEAVE_FULLSCREEN);
 this.fullscreenButton.set_tooltip_text("Leave fullscreen");
 this.window.fullscreen();
 }
 }
});

// Run the application
let app = new TooltipExample ();
app.application.run (ARGV);



Tooltip (Python)
This example builds on the
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import Gio
import sys


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(
 self, title="Toolbar with Tooltips Example", application=app)
 self.set_default_size(400, 200)

 grid = Gtk.Grid()

 toolbar = self.create_toolbar()
 toolbar.set_hexpand(True)
 toolbar.show()

 grid.attach(toolbar, 0, 0, 1, 1)

 self.add(grid)

 undo_action = Gio.SimpleAction.new("undo", None)
 undo_action.connect("activate", self.undo_callback)
 self.add_action(undo_action)

 fullscreen_action = Gio.SimpleAction.new("fullscreen", None)
 fullscreen_action.connect("activate", self.fullscreen_callback)
 self.add_action(fullscreen_action)

 def create_toolbar(self):
 toolbar = Gtk.Toolbar()
 toolbar.get_style_context().add_class(Gtk.STYLE_CLASS_PRIMARY_TOOLBAR)

 # button for the "new" action
 new_button = Gtk.ToolButton.new_from_stock(Gtk.STOCK_NEW)
 # with a tooltip with a given text
 new_button.set_tooltip_text("Create a new file")
 new_button.set_is_important(True)
 toolbar.insert(new_button, 0)
 new_button.show()
 new_button.set_action_name("app.new")

 # button for the "open" action
 open_button = Gtk.ToolButton.new_from_stock(Gtk.STOCK_OPEN)
 # with a tooltip with a given text in the Pango markup language
 open_button.set_tooltip_markup("Open an &lt;igt;existinglt;/igt; file")
 open_button.set_is_important(True)
 toolbar.insert(open_button, 1)
 open_button.show()
 open_button.set_action_name("app.open")

 # button for the "undo" action
 undo_button = Gtk.ToolButton.new_from_stock(Gtk.STOCK_UNDO)
 # with a tooltip with an image
 # set True the property "has-tooltip"
 undo_button.set_property("has-tooltip", True)
 # connect to the callback function that for the tooltip
 # with the signal "query-tooltip"
 undo_button.connect("query-tooltip", self.undo_tooltip_callback)
 undo_button.set_is_important(True)
 toolbar.insert(undo_button, 2)
 undo_button.show()
 undo_button.set_action_name("win.undo")

 # button for the "fullscreen/leave fullscreen" action
 self.fullscreen_button = Gtk.ToolButton.new_from_stock(
 Gtk.STOCK_FULLSCREEN)
 self.fullscreen_button.set_is_important(True)
 toolbar.insert(self.fullscreen_button, 3)
 self.fullscreen_button.set_action_name("win.fullscreen")

 return toolbar

 # the callback function for the tooltip of the "undo" button
 def undo_tooltip_callback(self, widget, x, y, keyboard_mode, tooltip):
 # set the text for the tooltip
 tooltip.set_text("Undo your last action")
 # set an icon fot the tooltip
 tooltip.set_icon_from_stock("gtk-undo", Gtk.IconSize.MENU)
 # show the tooltip
 return True

 def undo_callback(self, action, parameter):
 print "You clicked \\"Undo\\"."

 def fullscreen_callback(self, action, parameter):
 is_fullscreen = self.get_window().get_state(
 ) & Gdk.WindowState.FULLSCREEN != 0
 if not is_fullscreen:
 self.fullscreen_button.set_stock_id(Gtk.STOCK_LEAVE_FULLSCREEN)
 self.fullscreen()
 else:
 self.fullscreen_button.set_stock_id(Gtk.STOCK_FULLSCREEN)
 self.unfullscreen()


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

 new_action = Gio.SimpleAction.new("new", None)
 new_action.connect("activate", self.new_callback)
 app.add_action(new_action)

 open_action = Gio.SimpleAction.new("open", None)
 open_action.connect("activate", self.open_callback)
 app.add_action(open_action)

 def new_callback(self, action, parameter):
 print "You clicked \\"New\\"."

 def open_callback(self, action, parameter):
 print "You clicked \\"Open\\"."

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Tooltip widget

For more complex tooltips, for instance for a tooltip with an image:
Set the
Connect to the
Return
In the probably rare case where you want to have even more control over the tooltip that is about to be shown, you can set your own GtkWindow which will be used as tooltip window. This works as follows:
Set
Use
In the
Tooltip (Vala)
This example builds on the
/* This is the Window */
class MyWindow : Gtk.ApplicationWindow {

 /* Instance variables belonging to the window */
 Gtk.Toolbar toolbar;
 Gtk.ToolButton new_button;
 Gtk.ToolButton open_button;
 Gtk.ToolButton undo_button;
 Gtk.ToolButton fullscreen_button;
 Gtk.ToolButton leave_fullscreen_button;

 /* Contstructor */
 internal MyWindow (MyApplication app) {
 Object (application: app, title: "Toolbar with Tooltips Example");

 this.set_default_size (400, 200);
 var grid = new Gtk.Grid ();
 this.add (grid);
 grid.show ();

 create_toolbar ();
 toolbar.set_hexpand (true);
 grid.attach (toolbar, 0, 0, 1, 1);
 toolbar.show ();

 /* create the "undo" window action action */
 var undo_action = new SimpleAction ("undo", null);
 undo_action.activate.connect (undo_callback);
 this.add_action (undo_action);

 /* create the "fullscreen" window action */
 var fullscreen_action = new SimpleAction ("fullscreen", null);
 fullscreen_action.activate.connect (fullscreen_callback);
 this.add_action (fullscreen_action);
 }

 /* Callback for query_tooltip signal */
 bool undo_tooltip_callback (int x, int y, bool keyboard_tooltip, Gtk.Tooltip tooltip) {

 /* set the text for the tooltip */
 tooltip.set_text ("Undo your last action");
 
 /* set an icon fot the tooltip */
 tooltip.set_icon_from_stock("gtk-undo", Gtk.IconSize.MENU);

 /* show the tooltip */
 return true;
 }

 /* This function creates the toolbar, its ToolButtons,
 * and assigns the actions names to the ToolButtons.*/
 void create_toolbar () {
 toolbar = new Gtk.Toolbar ();
 toolbar.get_style_context ().add_class (Gtk.STYLE_CLASS_PRIMARY_TOOLBAR);

 new_button = new Gtk.ToolButton.from_stock (Gtk.Stock.NEW);

 /* tooltip with text */
 new_button.set_tooltip_text ("Create a new file");

 new_button.is_important = true; //decides whether to show the label
 toolbar.add (new_button);
 new_button.show ();
 new_button.action_name = "app.new";

 open_button = new Gtk.ToolButton.from_stock (Gtk.Stock.OPEN);

 /* a tooltip using Pango markup language */
 open_button.set_tooltip_markup ("Open an &lt;igt;existinglt;/igt; file");

 open_button.is_important = true;
 toolbar.add (open_button);
 open_button.show ();
 open_button.action_name = "app.open";

 undo_button = new Gtk.ToolButton.from_stock (Gtk.Stock.UNDO);
 
 /* For a tooltip to have an image, first we must set_has_tooltip to be 'true' */ 
 (undo_button as Gtk.Widget).set_has_tooltip (true);

 /* Connect the query_tooltip signal to the callback */
 undo_button.query_tooltip.connect (undo_tooltip_callback);
 
 undo_button.is_important = true;
 toolbar.add (undo_button);
 undo_button.show ();
 undo_button.action_name = "win.undo";

 fullscreen_button = new Gtk.ToolButton.from_stock (Gtk.Stock.FULLSCREEN);
 fullscreen_button.is_important = true;
 toolbar.add (fullscreen_button);
 fullscreen_button.show ();
 fullscreen_button.action_name = "win.fullscreen";

 leave_fullscreen_button = new Gtk.ToolButton.from_stock (Gtk.Stock.LEAVE_FULLSCREEN)
;
 leave_fullscreen_button.is_important = true;
 toolbar.add (leave_fullscreen_button);

 leave_fullscreen_button.action_name = "win.fullscreen";
 }

 void undo_callback (SimpleAction simple, Variant? parameter) {
 print ("You clicked \\"Undo\\".\
");
 }

 void fullscreen_callback (SimpleAction simple, Variant? parameter) {
 if ((this.get_window ().get_state () & Gdk.WindowState.FULLSCREEN) != 0) {
 this.unfullscreen ();
 leave_fullscreen_button.hide ();
 fullscreen_button.show ();
 }
 else {
 this.fullscreen ();
 fullscreen_button.hide ();
 leave_fullscreen_button.show ();
 }
 }
}

/* This is the application */
class MyApplication : Gtk.Application {
 protected override void activate () {
 new MyWindow (this).show ();
 }

 protected override void startup () {
 base.startup ();

 /* Create the "new" action and add it to the app*/
 var new_action = new SimpleAction ("new", null);
 new_action.activate.connect (new_callback);
 this.add_action (new_action);

 /* Create the "open" action, and add it to the app */
 var open_action = new SimpleAction ("open", null);
 open_action.activate.connect (open_callback);
 this.add_action (open_action);

 /* You could also add the action to the app menu
 * if you wanted to.
 */
 //var menu = new Menu ();
 //menu.append ("New", "app.new");
 //this.app_menu = menu;
 }

 void new_callback (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"New\\".\
");
 }

 void open_callback (SimpleAction action, Variant? parameter) {
 print ("You clicked \\"Open\\".\
");
 }
}

/* The main function creates the application and runs it. */
int main (string[] args) {
 return new MyApplication ().run (args);
}



external ref='media/treeview_advanced_liststore.png' md5='102b512197fb9aa4ed9a16462f6af911'
Simple Treeview with ListStore (Python)
A TreeView displaying a ListStore (more complex example)
More Complex Treeview with ListStore
This TreeView displays a simple ListStore with the selection "changed" signal connected.
from gi.repository import Gtk
from gi.repository import Pango
import sys

list_of_dvd = [["The Usual Suspects"],
 ["Gilda"],
 ["The Godfather"],
 ["Pulp Fiction"],
 ["Once Upon a Time in the West"],
 ["Rear Window"]]


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="My DVDs", application=app)
 self.set_default_size(250, 100)
 self.set_border_width(10)

 # the data are stored in the model
 # create a liststore with one column
 self.listmodel = Gtk.ListStore(str)
 for i in range(len(list_of_dvd)):
 self.listmodel.append(list_of_dvd[i])

 # a treeview to see the data stored in the model
 view = Gtk.TreeView(model=self.listmodel)

 # cellrenderer for the first column
 cell = Gtk.CellRendererText()
 # the first column is created
 col = Gtk.TreeViewColumn("Title", cell, text=0)
 # and it is appended to the treeview
 view.append_column(col)

 # when a row of the treeview is selected, it emits a signal
 self.selection = view.get_selection()
 self.selection.connect("changed", self.on_changed)

 # the label we use to show the selection
 self.label = Gtk.Label()
 self.label.set_text("")

 # a button to add new titles, connected to a callback function
 self.button_add = Gtk.Button(label="Add")
 self.button_add.connect("clicked", self.add_cb)

 # an entry to enter titles
 self.entry = Gtk.Entry()

 # a button to remove titles, connected to a callback function
 self.button_remove = Gtk.Button(label="Remove")
 self.button_remove.connect("clicked", self.remove_cb)

 # a button to remove all titles, connected to a callback function
 self.button_remove_all = Gtk.Button(label="Remove All")
 self.button_remove_all.connect("clicked", self.remove_all_cb)

 # a grid to attach the widgets
 grid = Gtk.Grid()
 grid.attach(view, 0, 0, 4, 1)
 grid.attach(self.label, 0, 1, 4, 1)
 grid.attach(self.button_add, 0, 2, 1, 1)
 grid.attach_next_to(
 self.entry, self.button_add, Gtk.PositionType.RIGHT, 1, 1)
 grid.attach_next_to(
 self.button_remove, self.entry, Gtk.PositionType.RIGHT, 1, 1)
 grid.attach_next_to(
 self.button_remove_all, self.button_remove, Gtk.PositionType.RIGHT, 1, 1)

 # add the grid to the window
 self.add(grid)

 def on_changed(self, selection):
 # get the model and the iterator that points at the data in the model
 (model, iter) = selection.get_selected()
 # set the label to a new value depending on the selection, if there is
 # one
 if iter is not None:
 self.label.set_text("\
 %s" % (model[iter][0]))
 else:
 self.label.set_text("")
 return True

 # callback function for the "Add" button
 def add_cb(self, button):
 # append to the model the title that is in the entry
 title = self.entry.get_text()
 self.listmodel.append([title])
 # and print a message in the terminal
 print "%s has been added" % (title)

 def remove_cb(self, button):
 # if there is still an entry in the model
 if len(self.listmodel) != 0:
 # get the selection
 (model, iter) = self.selection.get_selected()
 # if there is a selection, print a message in the terminal
 # and remove it from the model
 if iter is not None:
 print "%s has been removed" % (model[iter][0])
 self.listmodel.remove(iter)
 # otherwise, ask the user to select something to remove
 else:
 print "Select a title to remove"
 # else, if there are no entries in the model, print "Empty list"
 # in the terminal
 else:
 print "Empty list"

 def remove_all_cb(self, button):
 # if there is still an entry in the model
 if len(self.listmodel) != 0:
 # remove all the entries in the model
 for i in range(len(self.listmodel)):
 iter = self.listmodel.get_iter(0)
 self.listmodel.remove(iter)
 # print a message in the terminal alerting that the model is empty
 print "Empty list"


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a TreeView widget
The TreeView widget is designed around a
In line 36 the
external ref='media/treeview_cellrenderertoggle.png' md5='ade9b9437f8f83150acf37610dab834d'
TreeView with TreeStore (Python)
A TreeView displaying a TreeStore (more complex example, with CellRendererToggle)
More Complex TreeView with TreeStore
This TreeView displays a TreeStore with two columns, one of which is rendered as a toggle.
from gi.repository import Gtk
from gi.repository import Pango
import sys

books = [["Tolstoy, Leo", ["War and Peace", True], ["Anna Karenina", False]],
 ["Shakespeare, William", ["Hamlet", False],
 ["Macbeth", True], ["Othello", False]],
 ["Tolkien, J.R.R.", ["The Lord of the Rings", False]]]


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Library", application=app)
 self.set_default_size(250, 100)
 self.set_border_width(10)

 # the data are stored in the model
 # create a treestore with two columns
 self.store = Gtk.TreeStore(str, bool)
 # fill in the model
 for i in range(len(books)):
 # the iter piter is returned when appending the author in the first column
 # and False in the second
 piter = self.store.append(None, [books[i][0], False])
 # append the books and the associated boolean value as children of
 # the author
 j = 1
 while j &lt; len(books[i]):
 self.store.append(piter, books[i][j])
 j += 1

 # the treeview shows the model
 # create a treeview on the model self.store
 view = Gtk.TreeView()
 view.set_model(self.store)

 # the cellrenderer for the first column - text
 renderer_books = Gtk.CellRendererText()
 # the first column is created
 column_books = Gtk.TreeViewColumn("Books", renderer_books, text=0)
 # and it is appended to the treeview
 view.append_column(column_books)

 # the cellrenderer for the second column - boolean rendered as a toggle
 renderer_in_out = Gtk.CellRendererToggle()
 # the second column is created
 column_in_out = Gtk.TreeViewColumn("Out?", renderer_in_out, active=1)
 # and it is appended to the treeview
 view.append_column(column_in_out)
 # connect the cellrenderertoggle with a callback function
 renderer_in_out.connect("toggled", self.on_toggled)

 # add the treeview to the window
 self.add(view)

 # callback function for the signal emitted by the cellrenderertoggle
 def on_toggled(self, widget, path):
 # the boolean value of the selected row
 current_value = self.store[path][1]
 # change the boolean value of the selected row in the model
 self.store[path][1] = not current_value
 # new current value!
 current_value = not current_value
 # if length of the path is 1 (that is, if we are selecting an author)
 if len(path) == 1:
 # get the iter associated with the path
 piter = self.store.get_iter(path)
 # get the iter associated with its first child
 citer = self.store.iter_children(piter)
 # while there are children, change the state of their boolean value
 # to the value of the author
 while citer is not None:
 self.store[citer][1] = current_value
 citer = self.store.iter_next(citer)
 # if the length of the path is not 1 (that is, if we are selecting a
 # book)
 elif len(path) != 1:
 # get the first child of the parent of the book (the first book of
 # the author)
 citer = self.store.get_iter(path)
 piter = self.store.iter_parent(citer)
 citer = self.store.iter_children(piter)
 # check if all the children are selected
 all_selected = True
 while citer is not None:
 if self.store[citer][1] == False:
 all_selected = False
 break
 citer = self.store.iter_next(citer)
 # if they do, the author as well is selected; otherwise it is not
 self.store[piter][1] = all_selected


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
In line 48 the


external ref='media/treeview_simple_liststore_penguins.png' md5='d750a0b9fddf8e508753cc639839871d'
TreeView with ListStore (JavaScript)
A widget that shows a separate list of items
TreeView with ListStore
A TreeView is like a window onto the contents of either a ListStore or a TreeStore. A ListStore is like a spreadsheet: a "flat", two-dimensional list of things broken up into rows and columns. A TreeStore, meanwhile, can branch out in different directions like a tree can. In this example, we create a TreeView that shows the contents of a ListStore with (fictitious) names and phone numbers in it, and set it so that the
The TreeView is not just a single widget, but contains a number of smaller ones:
TreeViewColumn widgets show each (vertical) column of information from the ListStore. Each one has a title which can be shown at the top of the column, like in the screenshot.
CellRenderer widgets are "packed" into each TreeViewColumn, and contain the instructions for how to display each individual "cell", or item from the ListStore. There are multiple different types, including the CellRendererText used here and the CellRendererPixbuf, which displays a picture ("pixel buffer").
Finally, we're going to use an object called a TreeIter, which isn't a widget so much as an invisible cursor which points to a (horizontal) row in the ListStore. Whenever you click on a name in the phonebook, for instance, we create a TreeIter pointing to the row that's selected, and then use that to tell the ListStore which entry we want the Label to show more information about.
The TreeView is probably the most complicated Gtk widget, because of how many parts it has and how they all have to work together. Give yourself time to learn how it works and experiment with it, or try something easier first if you're having trouble.
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Pango = imports.gi.Pango;
const TreeViewExample = new Lang.Class({
 Name: 'TreeView Example with Simple ListStore',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jstreeviewsimpleliststore'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },
All the code for this sample goes in the TreeViewExample class. The above code creates a
// Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 250,
 default_width: 100,
 border_width: 20,
 title: "My Phone Book"});
// Create the underlying liststore for the phonebook
 this._listStore = new Gtk.ListStore ();
 this._listStore.set_column_types ([
 GObject.TYPE_STRING,
 GObject.TYPE_STRING,
 GObject.TYPE_STRING,
 GObject.TYPE_STRING]);
We first create the ListStore like we would any widget. Then we call its set_column_types method, and pass it an array of GObject data types. (We could have put the types all on one line, but here we are breaking them up to make it easier to read.)
The GObject data types you can use include:

In this case, we're making a ListStore of four columns, each one containing string values.
// Data to go in the phonebook
 this.phonebook =
 let phonebook =
 [{ name: "Jurg", surname: "Billeter", phone: "555-0123",
 description: "A friendly person."},
 { name: "Johannes", surname: "Schmid", phone: "555-1234",
 description: "Easy phone number to remember."},
 { name: "Julita", surname: "Inca", phone: "555-2345",
 description: "Another friendly person."},
 { name: "Javier", surname: "Jardon", phone: "555-3456",
 description: "Bring fish for his penguins."},
 { name: "Jason", surname: "Clinton", phone: "555-4567",
 description: "His cake's not a lie."},
 { name: "Random J.", surname: "Hacker", phone: "555-5678",
 description: "Very random!"}];
Here we have the information to go in the ListStore. It's an array of objects, each one corresponding to a single entry in our phone book.
Note that the TreeView in the screenshot doesn't actually show the data from the "description" properties. Instead, that information's shown in the Label beneath it, for whichever row that you click on. That's because the TreeView and ListStore are two separate things, and a TreeView can show all or part of a ListStore, and display what's in it in different ways. You can even have multiple widgets show things from the same ListStore, like the Label in our example or even a second TreeView.
for (i = 0; i &lt; phonebook.length; i++ ) {
 let contact = phonebook [i];
 this._listStore.set (this._listStore.append(), [0, 1, 2, 3],
 [contact.name, contact.surname, contact.phone, contact.description]);
 }
This
A ListStore's
Creating the TreeView
// Create the treeview
 this._treeView = new Gtk.TreeView ({
 expand: true,
 model: this._listStore });
Here we create a basic TreeView widget, that expands both horizontally and vertically to use as much space as needed. We set it to use the ListStore we created as its "model", or the thing it'll show us stuff from.
// Create the columns for the address book
 let firstName = new Gtk.TreeViewColumn ({ title: "First Name" });
 let lastName = new Gtk.TreeViewColumn ({ title: "Last Name" });
 let phone = new Gtk.TreeViewColumn ({ title: "Phone Number" });
Now we create each of the vertical TreeViewColumns we'll see in the TreeView. The title for each one goes at the top, as you can see in the screenshot.
// Create a cell renderer for when bold text is needed
 let bold = new Gtk.CellRendererText ({
 weight: Pango.Weight.BOLD });

 // Create a cell renderer for normal text
 let normal = new Gtk.CellRendererText ();

 // Pack the cell renderers into the columns
 firstName.pack_start (bold, true);
 lastName.pack_start (normal, true);
 phone.pack_start (normal, true);
Here we create the CellRenderers that we'll use to display the text from our ListStore, and pack them into the TreeViewColumns. Each CellRendererText is used for all the entries in that column. Our normal CellRendererText just creates plain text, while our bold one uses heavier-weight text. We put it into the first name column, and tell the other two to use copies of the normal one. The "true" used as the second parameter for the

firstName.add_attribute (bold, "text", 0);
 lastName.add_attribute (normal, "text", 1);
 phone.add_attribute (normal, "text", 2);

 // Insert the columns into the treeview
 this._treeView.insert_column (firstName, 0);
 this._treeView.insert_column (lastName, 1);
 this._treeView.insert_column (phone, 2);
Now that we've put the CellRenderers into the TreeViewColumns, we use the
The first parameter is which CellRenderer we're going to use to render what we're pulling in.
The second parameter is what kind of information we're going to pull in. In this case, we're letting it know that we're rendering text.
The third parameter is which of the ListStore's columns we're pulling that information in from.
After we've set that up, we use the TreeView's
Normally, you might want to use a loop to initialize your TreeView, but in this example we're spelling things out step by step for the sake of making it easier to understand.
Building the rest of the UI
// Create the label that shows details for the name you select
 this._label = new Gtk.Label ({ label: "" });

 // Get which item is selected
 this.selection = this._treeView.get_selection();

 // When something new is selected, call _on_changed
 this.selection.connect ('changed', Lang.bind (this, this._onSelectionChanged));
The TreeView's
After we get the TreeSelection that goes with our TreeView, we ask it to tell us when it changes which row it's pointing to. We do this by connecting its
// Create a grid to organize everything in
 this._grid = new Gtk.Grid;

 // Attach the treeview and label to the grid
 this._grid.attach (this._treeView, 0, 0, 1, 1);
 this._grid.attach (this._label, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },
After we've gotten that out of the way, we create a
Function which handles a changed selection
_onSelectionChanged: function () {

 // Grab a treeiter pointing to the current selection
 let [ isSelected, model, iter ] = this.selection.get_selected();

 // Set the label to read off the values stored in the current selection
 this._label.set_label ("\
" +
 this._listStore.get_value (iter, 0) + " " +
 this._listStore.get_value (iter, 1) + " " +
 this._listStore.get_value (iter, 2) + "\
" +
 this._listStore.get_value (iter, 3));

 }

});
The line of code with the let statement is a little convoluted, but it's nonetheless the best way to get a TreeIter pointing to the same row as our TreeSelection. It has to create a couple of other object references, but
After we've done that, we call the Label's
Here, we want to get data from all four columns, including the "hidden" one that's not part of the TreeView. This way, we can use our Label to show strings that are too large to fit in the TreeView, and that we don't need to see at a glance.
// Run the application
let app = new TreeViewExample ();
app.application.run (ARGV);
Finally, we create a new instance of the finished TreeViewExample class, and set the application running.
#!/usr/bin/gjs

const GObject = imports.gi.GObject;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;
const Pango = imports.gi.Pango;

const TreeViewExample = new Lang.Class({
 Name: 'TreeView Example with Simple ListStore',

 // Create the application itself
 _init: function() {
 this.application = new Gtk.Application({
 application_id: 'org.example.jstreeviewsimpleliststore'
 });

 // Connect 'activate' and 'startup' signals to the callback functions
 this.application.connect('activate', Lang.bind(this, this._onActivate));
 this.application.connect('startup', Lang.bind(this, this._onStartup));
 },

 // Callback function for 'activate' signal presents window when active
 _onActivate: function() {
 this._window.present();
 },

 // Callback function for 'startup' signal builds the UI
 _onStartup: function() {
 this._buildUI ();
 },



 // Build the application's UI
 _buildUI: function() {

 // Create the application window
 this._window = new Gtk.ApplicationWindow({
 application: this.application,
 window_position: Gtk.WindowPosition.CENTER,
 default_height: 250,
 default_width: 100,
 border_width: 20,
 title: "My Phone Book"});

 // Create the underlying liststore for the phonebook
 this._listStore = new Gtk.ListStore ();
 this._listStore.set_column_types ([
 GObject.TYPE_STRING,
 GObject.TYPE_STRING,
 GObject.TYPE_STRING,
 GObject.TYPE_STRING]);

 // Data to go in the phonebook
 let phonebook =
 [{ name: "Jurg", surname: "Billeter", phone: "555-0123",
 description: "A friendly person."},
 { name: "Johannes", surname: "Schmid", phone: "555-1234",
 description: "Easy phone number to remember."},
 { name: "Julita", surname: "Inca", phone: "555-2345",
 description: "Another friendly person."},
 { name: "Javier", surname: "Jardon", phone: "555-3456",
 description: "Bring fish for his penguins."},
 { name: "Jason", surname: "Clinton", phone: "555-4567",
 description: "His cake's not a lie."},
 { name: "Random J.", surname: "Hacker", phone: "555-5678",
 description: "Very random!"}];

 // Put the data in the phonebook
 for (let i = 0; i &lt; phonebook.length; i++ ) {
 let contact = phonebook [i];
 this._listStore.set (this._listStore.append(), [0, 1, 2, 3],
 [contact.name, contact.surname, contact.phone, contact.description]);
 }

 // Create the treeview
 this._treeView = new Gtk.TreeView ({
 expand: true,
 model: this._listStore });

 // Create the columns for the address book
 let firstName = new Gtk.TreeViewColumn ({ title: "First Name" });
 let lastName = new Gtk.TreeViewColumn ({ title: "Last Name" });
 let phone = new Gtk.TreeViewColumn ({ title: "Phone Number" });

 // Create a cell renderer for when bold text is needed
 let bold = new Gtk.CellRendererText ({
 weight: Pango.Weight.BOLD });

 // Create a cell renderer for normal text
 let normal = new Gtk.CellRendererText ();

 // Pack the cell renderers into the columns
 firstName.pack_start (bold, true);
 lastName.pack_start (normal, true);
 phone.pack_start (normal, true);

 // Set each column to pull text from the TreeView's model
 firstName.add_attribute (bold, "text", 0);
 lastName.add_attribute (normal, "text", 1);
 phone.add_attribute (normal, "text", 2);

 // Insert the columns into the treeview
 this._treeView.insert_column (firstName, 0);
 this._treeView.insert_column (lastName, 1);
 this._treeView.insert_column (phone, 2);

 // Create the label that shows details for the name you select
 this._label = new Gtk.Label ({ label: "" });

 // Get which item is selected
 this.selection = this._treeView.get_selection();

 // When something new is selected, call _on_changed
 this.selection.connect ('changed', Lang.bind (this, this._onSelectionChanged));

 // Create a grid to organize everything in
 this._grid = new Gtk.Grid;

 // Attach the treeview and label to the grid
 this._grid.attach (this._treeView, 0, 0, 1, 1);
 this._grid.attach (this._label, 0, 1, 1, 1);

 // Add the grid to the window
 this._window.add (this._grid);

 // Show the window and all child widgets
 this._window.show_all();
 },



 _onSelectionChanged: function () {

 // Grab a treeiter pointing to the current selection
 let [ isSelected, model, iter ] = this.selection.get_selected();

 // Set the label to read off the values stored in the current selection
 this._label.set_label ("\
" +
 this._listStore.get_value (iter, 0) + " " +
 this._listStore.get_value (iter, 1) + " " +
 this._listStore.get_value (iter, 2) + "\
" +
 this._listStore.get_value (iter, 3));

 }

});

// Run the application
let app = new TreeViewExample ();
app.application.run (ARGV);



external ref='media/treeview_simple_liststore.png' md5='2dc501a2b95b094da985d37b66aee90c'
Simple TreeView with ListStore (Python)
A TreeView displaying a ListStore (simpler example)
Simple TreeView with ListStore
from gi.repository import Gtk
from gi.repository import Pango
import sys

columns = ["First Name",
 "Last Name",
 "Phone Number"]

phonebook = [["Jurg", "Billeter", "555-0123"],
 ["Johannes", "Schmid", "555-1234"],
 ["Julita", "Inca", "555-2345"],
 ["Javier", "Jardon", "555-3456"],
 ["Jason", "Clinton", "555-4567"],
 ["Random J.", "Hacker", "555-5678"]]


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="My Phone Book", application=app)
 self.set_default_size(250, 100)
 self.set_border_width(10)

 # the data in the model (three strings for each row, one for each
 # column)
 listmodel = Gtk.ListStore(str, str, str)
 # append the values in the model
 for i in range(len(phonebook)):
 listmodel.append(phonebook[i])

 # a treeview to see the data stored in the model
 view = Gtk.TreeView(model=listmodel)
 # for each column
 for i in range(len(columns)):
 # cellrenderer to render the text
 cell = Gtk.CellRendererText()
 # the text in the first column should be in boldface
 if i == 0:
 cell.props.weight_set = True
 cell.props.weight = Pango.Weight.BOLD
 # the column is created
 col = Gtk.TreeViewColumn(columns[i], cell, text=i)
 # and it is appended to the treeview
 view.append_column(col)

 # when a row is selected, it emits a signal
 view.get_selection().connect("changed", self.on_changed)

 # the label we use to show the selection
 self.label = Gtk.Label()
 self.label.set_text("")

 # a grid to attach the widgets
 grid = Gtk.Grid()
 grid.attach(view, 0, 0, 1, 1)
 grid.attach(self.label, 0, 1, 1, 1)

 # attach the grid to the window
 self.add(grid)

 def on_changed(self, selection):
 # get the model and the iterator that points at the data in the model
 (model, iter) = selection.get_selected()
 # set the label to a new value depending on the selection
 self.label.set_text("\
 %s %s %s" %
 (model[iter][0], model[iter][1], model[iter][2]))
 return True


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
The TreeView widget is designed around a
In line 44 the

Simple Treeview with ListStore (Vala)
A widget can display any TreeModel implementation (lists and trees)
Simple Treeview with ListStore
This TreeView displays a simple ListStore with the Selection "changed" signal connected.
public class PhoneBookEntry {
 public string firstname;
 public string lastname;
 public string phone;

 public PhoneBookEntry (string f, string l, string p) {
 this.firstname = f;
 this.lastname = l;
 this.phone = p;
 }
}

class TreeViewSimpleListStore : Gtk.ApplicationWindow {

 Gtk.Label label;

 PhoneBookEntry[] phonebook = {
 new PhoneBookEntry ("Jurg", "Billeter", "555-0123"),
 new PhoneBookEntry ("Johannes", "Schmid", "555-1234"),
 new PhoneBookEntry ("Julita", "Inca", "555-2345"),
 new PhoneBookEntry ("Javier", "Jardon", "555-3456"),
 new PhoneBookEntry ("Jason", "Clinton", "555-4567"),
 new PhoneBookEntry ("Random J.", "Hacker", "555-5678")
 };

 enum Column {
 FIRSTNAME,
 LASTNAME,
 PHONE
 }

 internal TreeViewSimpleListStore (MyApplication app) {
 Object (application: app, title: "My Phone Book");

 this.set_default_size (250, 100);
 this.border_width = 10;

 var view = new Gtk.TreeView ();
 this.setup_treeview (view);
 view.expand = true;

 label = new Gtk.Label ("");

 var grid = new Gtk.Grid ();

 grid.attach (view, 0, 0, 1, 1);
 grid.attach (label, 0, 1, 1, 1);
 this.add (grid);

 var selection = view.get_selection ();
 selection.changed.connect (this.on_changed);
 }

 void setup_treeview (Gtk.TreeView view) {
 var listmodel = new Gtk.ListStore (3, typeof (string),
 typeof (string),
 typeof (string));
 view.set_model (listmodel);

 var cell = new Gtk.CellRendererText ();

 /* 'weight' refers to font boldness.
 * 400 is normal.
 * 700 is bold.
 */
 cell.set ("weight_set", true);
 cell.set ("weight", 700);

 /*columns*/
 view.insert_column_with_attributes (-1, "First Name",
 cell, "text",
 Column.FIRSTNAME);

 view.insert_column_with_attributes (-1, "Last Name",
 new Gtk.CellRendererText (),
 "text", Column.LASTNAME);

 view.insert_column_with_attributes (-1, "Phone Number",
 new Gtk.CellRendererText (),
 "text", Column.PHONE);

 /* Insert the phonebook into the ListStore */
 Gtk.TreeIter iter;
 for (int i = 0; i &lt; phonebook.length; i++) {
 listmodel.append (out iter);
 listmodel.set (iter, Column.FIRSTNAME,
 phonebook[i].firstname,
 Column.LASTNAME, phonebook[i].lastname,
 Column.PHONE, phonebook[i].phone);
 }
 }

 void on_changed (Gtk.TreeSelection selection) {
 Gtk.TreeModel model;
 Gtk.TreeIter iter;
 string name;
 string lastname;
 string phone;

 if (selection.get_selected (out model, out iter)) {
 model.get (iter,
 Column.FIRSTNAME, out name,
 Column.LASTNAME, out lastname,
 Column.PHONE, out phone);

 label.set_text ("\
" + name + " " + lastname + " " + phone);
 }
 }
}

class MyApplication : Gtk.Application {
 protected override void activate () {

 /* Create new Window and show all the things. */
 new TreeViewSimpleListStore (this).show_all ();
 }

 internal MyApplication () {
 Object (application_id: "example.liststore.simple.treeview");
 }
}

int main (string[] args) {
 return new MyApplication ().run (args);
}


external ref='media/treeview_treestore.png' md5='5ca87bc4acd55c527b3fb5fd46779d85'
A TreeView displaying a TreeStore (simpler example)
Simpler TreeView with TreeStore
This TreeView displays a TreeStore.
from gi.repository import Gtk
from gi.repository import Pango
import sys

books = [["Tolstoy, Leo", "War and Peace", "Anna Karenina"],
 ["Shakespeare, William", "Hamlet", "Macbeth", "Othello"],
 ["Tolkien, J.R.R.", "The Lord of the Rings"]]


class MyWindow(Gtk.ApplicationWindow):

 def __init__(self, app):
 Gtk.Window.__init__(self, title="Library", application=app)
 self.set_default_size(250, 100)
 self.set_border_width(10)

 # the data are stored in the model
 # create a treestore with one column
 store = Gtk.TreeStore(str)
 for i in range(len(books)):
 # the iter piter is returned when appending the author
 piter = store.append(None, [books[i][0]])
 # append the books as children of the author
 j = 1
 while j &lt; len(books[i]):
 store.append(piter, [books[i][j]])
 j += 1

 # the treeview shows the model
 # create a treeview on the model store
 view = Gtk.TreeView()
 view.set_model(store)

 # the cellrenderer for the column - text
 renderer_books = Gtk.CellRendererText()
 # the column is created
 column_books = Gtk.TreeViewColumn(
 "Books by Author", renderer_books, text=0)
 # and it is appended to the treeview
 view.append_column(column_books)

 # the books are sortable by author
 column_books.set_sort_column_id(0)

 # add the treeview to the window
 self.add(view)


class MyApplication(Gtk.Application):

 def __init__(self):
 Gtk.Application.__init__(self)

 def do_activate(self):
 win = MyWindow(self)
 win.show_all()

 def do_startup(self):
 Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Michael Hill
Help translate
The
There are
To start translating you will need to
You can chat with GNOME translators using
Alternatively, you can contact the Internationalization Team using their
Tutorial for beginners (Python)
A tutorial for beginners who want to learn how to program GUIs using GTK+ in Python.
2012 2013
Jim Campbell
By following these tutorials you will learn the basics of GUI programming using GTK+ in Python.
If you have never programmed before, or are not familiar with the concepts of object oriented programming, you may need to learn a few basics first. The book
To run the code samples
To run the code samples in the tutorial:
Type or copy and paste the code into a file, and save the file with a name like
To execute the code, type in the terminal:
python
After executing the code, you will either see the widget on your screen, or (if you have mistyped some of the code) you will see an error message that will help you identify the problem.
A path through the widgets (with some theory)
The tutorial will walk you through increasingly complex examples and programming theory, but you can also feel free to just go directly to the tutorial that is most helpful to you.
Tutorial
Basic windows
Images and labels
Introduction to properties
Grid, separator and scrolling
Signals, callbacks and buttons
Other display widgets
Entry widgets
A widget to write and display text
Dialogs
Menus, Toolbars and Tooltips (also: using Glade and GtkBuilder)
TreeViews and ComboBoxes (using the M/V/C design)
Custom widget
Vala
Tutorials, code samples and platform demos in Vala
external ref='media/weatherAppJs.png' md5='1fe859ac4854273d72ea8fc9203639b2'
Weather application (JavaScript)
How to plan an application that uses asynchronous calls. Asynchronous calls will be presented through a weather application.
Weather application
In this guide well construct a weather application using asynchronous calls. Weather information in this example is fetched from geonames.org and the application is using the





Planning the graphical user interface
Structuring an application for GNOME 3 means you will be using
Asynchronous calls
With many programming languages, all operations are run synchronously - you tell the program to do something, and it will wait until that action completes before proceeding. This is however bad for graphical user interfaces, as then the whole application will be frozen while the program waits for the operation. Going asynchronous (async) helps here. With async calls, your UI won't be blocked with any requests. Async calls make your application more flexible and better equipped to handle situations when calls take more time than expected or for some reason get jammed. Async calls can be used for example file system I/O and for slower calculations in the background.
In this example we have to get data from geonames.org. While we do that we want the rest of our program to continue. If we wouldn't get any information from geonames.org for the lack of internet connection and this would be a synchronous application we would never get to the point where our main_quit() is processed correctly and the application would have to killed from Terminal.
The different parts of the program
The main program file
In this part of the guide well construct the main program file of the weather application. To write and run all the code examples yourself, you need an editor to write code in, Terminal and GNOME 3 or higher installed into your computer. In this part we we'll go through the following parts:




This line tells how to run the script. It needs to be the first line of the code and it needs to be executable. To get the execution rights go to Terminal and run in right folder: chmod +x scriptname. Or you can use the graphical filemanager. Just go to the right folder where your code is, right click you code file, choose properties, click the permissions tab and check the box for allow executing file as a program
var Gtk = imports.gi.Gtk;
const WeatherService = imports.geonames;
In order to have a working program we need to import a GObject Introspection -library to our use. For working UI, we need Gtk. Gtk is imported in the beginning so we have it in our use everywhere. We also import our own local JavaScript library geonames to our use here.
// Initialize the gtk
Gtk.init(null, 0);
//create your window, name it and connect the x to quit function. Remember that window is a taken word
var weatherwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL});
weatherwindow.title = "Todays weather";
//Window only accepts one widget and a title. Further structure with Gtk.boxes of similar
weatherwindow.connect("destroy", function(){Gtk.main_quit()});

weatherwindow.show_all();
//and run it
Gtk.main();
Adding a grid and all the necessary widgets to it
var grid = new Gtk.Grid();
weatherwindow.add(grid);

//We initialize the icon here, but deside the file later in geonames.js.
var weatherIcon = new Gtk.Image();

//Set some labels to your window
var label1 = new Gtk.Label({label: ""});
var label2 = new Gtk.Label({label: "Looking in the sky..."});
var label3 = new Gtk.Label({label: ""});

var entry = new Gtk.Entry();
entry.set_width_chars(4);
entry.set_max_length(4);
var label4 = new Gtk.Label({label: "Enter ICAO station for weather: "});
var button1 = new Gtk.Button({label: "search!"});

grid.attach(label4, 2, 1, 1, 1);
grid.attach_next_to(label1,label4,3,1,1);
grid.attach_next_to(label2,label1,3,1,1);
grid.attach_next_to(label3,label2,3,1,1);
grid.attach_next_to(entry,label4,1,1,1);
grid.attach_next_to(button1,entry,1,1,1);
grid.attach_next_to(weatherIcon,label2,1,1,1)
In this section we create the grid we are going to use for positioning the widgets. All the buttons, labels and entrys are initialized and placed on the grid. As seen from the placing of the different widgets, they don't need to be related only to one widget. At this point some of the labels don't have any content. The content for those widgets is applied later. If you run the application at this stage, you have the UI ready, but the widgets are not connected to anything. For this we need to first build the weather searching local library, and then get the information we need asynchronously. When we have our local library ready we can connect it to the necessary widgets.
Requesting the weather information asynchronously
function getWeatherForStation() {
 var station = entry.get_text();

 var GeoNames = new WeatherService.GeoNames(station); //"EFHF";

 GeoNames.getWeather(function(error, weather) {
 //this here works bit like signals. This code will be run when we have weather.
 if (error) {
 label2.set_text("Suggested ICAO station does not exist Try EFHF");
 return; }
 weatherIcon.file = GeoNames.getIcon(weather);

 label1.set_text("Temperature is " + weather.weatherObservation.temperature + " degrees.");
 if (weather.weatherObservation.weatherCondition !== "n/a"){
 label2.set_text("Looks like there is " + weather.weatherObservation.weatherCondition + " in the sky.");
 }
 else {
 label2.set_text("Looks like there is " + weather.weatherObservation.clouds + " in the sky.");
 }
 label3.set_text("Windspeed is " + weather.weatherObservation.windSpeed + " m/s")
 // ...
 });
}
This function is dedicated for calling for the weather information and updating labels and icons accordingly. In the beginning of the function we get the user input for the search. So here for the first time we use our own library and assign it to variable GeoNames. While assigning WeatherService we give it the station. The firs thing we do with GeoNames is to request weather. Everything after GeoNames.getWeather(function(error, weather) happens only if we either get an error message or weather information. If either doesn't come, the rest of the program works as normal, so main_Quit works.
Connecting signals to button and entry.
entry.connect("key_press_event", function(widget, event) {
 if (entry.get_text().length === 4) {
 // Enough is enough
 getWeatherForStation();
 }
 return false;
});

button1.connect("clicked", function(){
 getWeatherForStation();
});
And finally we have the connections that make the whole application run as it should. We connect both the entry and the button to do the same thing, getting the weather. So it doesn't matter weather you press enter of click the search button.
Weatherapp.js
Weatherapp.js file looks like this:
#!/usr/bin/gjs
//The previous line is a hash bang tells how to run the script.
// Note that the script has to be executable (run in terminal in the right folder: chmod +x scriptname)

var Gtk = imports.gi.Gtk;

const WeatherService = imports.geonames;
//Bring your own library from same folder (as set in GJS_PATH). If using autotools .desktop will take care of this

// Initialize the gtk
Gtk.init(null, 0);
//create your window, name it and connect the x to quit function. Remember that window is a taken word
var weatherwindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL});
weatherwindow.title = "Todays weather";
//Window only accepts one widget and a title. Further structure with Gtk.boxes of similar
weatherwindow.connect("destroy", function(){Gtk.main_quit()});
//We initialize the icon here, but deside the file later in geonames.js.

var weatherIcon = new Gtk.Image();

//Set some labels to your window
var label1 = new Gtk.Label({label: ""});
var label2 = new Gtk.Label({label: "Looking in the sky..."});
var label3 = new Gtk.Label({label: ""});

var grid = new Gtk.Grid();
weatherwindow.add(grid);

var entry = new Gtk.Entry();
entry.set_width_chars(4);
entry.set_max_length(4);
var label4 = new Gtk.Label({label: "Enter ICAO station for weather: "});
var button1 = new Gtk.Button({label: "search!"});

//some weather

entry.connect("key_press_event", function(widget, event) {
 // FIXME: Get weather on enter (key 13)
 if (entry.get_text().length === 4) {
 // Enough is enough
 getWeatherForStation();
 }
 return false;
});

button1.connect("clicked", function(){
 getWeatherForStation();
});

function getWeatherForStation() {
 var station = entry.get_text();

 var GeoNames = new WeatherService.GeoNames(station); //"EFHF";

 GeoNames.getWeather(function(error, weather) {
 //this here works bit like signals. This code will be run when we have weather.
 if (error) {
 label2.set_text("Suggested ICAO station does not exist Try EFHF");
 return; }
 weatherIcon.file = GeoNames.getIcon(weather);

 label1.set_text("Temperature is " + weather.weatherObservation.temperature + " degrees.");
 if (weather.weatherObservation.weatherCondition !== "n/a"){
 label2.set_text("Looks like there is " + weather.weatherObservation.weatherCondition + " in the sky.");
 }
 else {
 label2.set_text("Looks like there is " + weather.weatherObservation.clouds + " in the sky.");
 }
 label3.set_text("Windspeed is " + weather.weatherObservation.windSpeed + " m/s")
 // ...
 });
}

grid.attach(label4, 2, 1, 1, 1);
grid.attach_next_to(label1,label4,3,1,1);
grid.attach_next_to(label2,label1,3,1,1);
grid.attach_next_to(label3,label2,3,1,1);
grid.attach_next_to(entry,label4,1,1,1);
grid.attach_next_to(button1,entry,1,1,1);
grid.attach_next_to(weatherIcon,label2,1,1,1)
weatherwindow.show_all();
//and run it
Gtk.main();
Running until you have all the autotools files ready. :

Use this command on terminal while developing your modules. When calling your program in this manner it knows where to find your custom JSlibraries, in this case geonames.js.
Autotools and Icons
In this part of the guide well construct the autotools and custom icons needed for weather application to be a seamless part of your desktop. To write and run all the code examples yourself, you need an editor to write code in, Terminal and GNOME 3 or higher installed into your computer. In this guide we we'll go through the following parts:


Autotools and necessary files
Having more than one file in your folder makes using autotools a bit tricky. You need the .desktop file, autogen.sh, Makefile.am, configure.ac and as a new file: myapp.sh.in file. Hacking the autotools file is a complicated field. More information can be found in many different sources,
weatherapp.desktop
weatherapp.sh.in
[Desktop Entry]
Version=1.0
Encoding=UTF-8
Name=Weather app
Comment=Weather showing application
Exec=weatherapp.sh
Icon=application-default-icon
Terminal=false
Type=Application
StartupNotify=true
Categories=GNOME;GTK;Utility;
The thing to notice in this file is that the Exec line will make this .desktop file work only after running all the other makefiles. Weatherapp.sh is a small shell script created with the weatherapp.sh.in.
#!/bin/sh
export GJS_PATH=@bindir@
gjs @bindir@/weatherapp.js
This file is a template to the file Makefile will do to be run from .desktop.
# The actual runnable program is set to the SCRIPTS primitive. Prefix bin_ tells where to copy this
bin_SCRIPTS = weatherapp.js geonames.js weatherapp.sh
# List of files to be distributed
EXTRA_DIST= \\
 $(bin_SCRIPTS) \\
 $(private_icons) \\
 $(NULL)

CLEANFILES =

# The desktop files
desktopdir = $(datadir)/applications
desktop_DATA =weatherapp.desktop

# convenience command for doing Makefile variable substitutions in non-Makefile
# files (scripts, service files, etc.)
do_subst = sed -e 's|@abs_top_srcdir[@]|$(abs_top_srcdir)|g' \\
 -e 's|@abs_top_builddir[@]|$(abs_top_builddir)|g' \\
 -e 's|@localedir[@]|$(localedir)|g' \\
 -e 's|@bindir[@]|$(bindir)|g' \\
 -e 's|@libexecdir[@]|$(libexecdir)|g' \\
 -e 's|@pkglibdir[@]|$(pkglibdir)|g' \\
 -e 's|@pkgdatadir[@]|$(pkgdatadir)|g' \\
 -e 's|@have_libnotify[@]|$(HAVE_LIBNOTIFY)|g' \\
 -e 's|@have_libsoup[@]|$(HAVE_LIBSOUP)|g' \\
 -e 's|@have_cheese[@]|$(HAVE_CHEESE)|g'

weatherapp.sh: weatherapp.sh.in
 $(AM_V_GEN) $(do_subst) $lt; &gt; $@
 chmod +x $@

CLEANFILES += weatherapp.sh
EXTRA_DIST += weatherapp.sh.in

#the application icon
appicondir=$(datadir)/icons/hicolor/scalable/apps
appicon_DATA=weather-icon.svg

#icons in the application
NULL =

private_icons = \\
 weather-clear.svg \\
 weather-few-clouds.svg \\
 weather-fog.svg \\
 weather-icon.svg \\
 weather-overcast.svg \\
 weather-showers.svg \\
 weather-showers-scattered.svg \\
 weather-snow.svg \\
 $(NULL)

install-icons:
 for icon in $(private_icons); do \\
 mkdir -p $(DESTDIR)$(pkgdatadir)/icons/; \\
 $(INSTALL_DATA) $(srcdir)/$$icon $(DESTDIR)$(pkgdatadir)/icons/; \\
 done

install-data-local: install-icons
This needs a bit more explaining. Compared to the HelloWorld Makefile.am this has changed quite a bit. Lets go through all the new blocks:
bin_scripts are the files that are needed to run your application. In thin case they are the first two files are the program itself and the third is the script that launches the application.
EXTRA_DIST are the files that are to be distributed
do_subst block is bits and pieces that need to be where they are
after the comment #icons in the application there are all the icons that are used by the program. For them to be useful you need to install the icons in correct places and that is done byt the install-icons: bit
dnl This file is processed by autoconf to create a configure script
AC_INIT([Weather App], 1.0)
AM_INIT_AUTOMAKE([1.10 no-define foreign])
AC_CONFIG_FILES(Makefile)
AC_OUTPUT
autohen.sh
#!/bin/sh
# This will run autoconf, automake, etc. for us
autoreconf --force --install
Custom icons for your application
When thinking about custom icons a good rule of thumb is: do you expect to see that icon used elsewhere or is it private to your app? If the first (e.g. the icons in the desktop file that are shown by the shell) then you need /usr/share/hicolor, otherwise (e.g. the weather icons of your app) /usr/share/$application/bla/bla
Using autotools you have to make some changes to your .desktop and Makefile.am files. In the desktop file you change the Icon's name Icon=weather-icon. In the Makefile.am file you add these two lines to the end of your application #the application icon
appicondir=$(datadir)/icons/hicolor/scalable/apps
appicon_DATA=weather-icon.svg
Local library geoNames
In this part of the guide we'll construct the local library geoNames using asynchronous calls. Weather information in this example is fetched from geonames.org and the application is using the




Local library for getting the weather
For this we need a new file that will be our local library.
const Soup = imports.gi.Soup;
const _httpSession = new Soup.SessionAsync();
Soup.Session.prototype.add_feature.call(_httpSession, new Soup.ProxyResolverDefault());
In the first lines we'll import and initialize the libraries we need to use in this local library. Soup handles all the requests we have to make with http.
Creating function GeoNames
function GeoNames(station) {
 this.station = station;
}

GeoNames.prototype = {

}
Here we create the function GeoNames that will handle getting weather for us. JavaScript allows us to create functions that have little inside at first and later expand them. This will be done inside the GeoNames.prototype curly braces{}
Methods for GeoNames
getWeather: function(callback) {
 var request = Soup.Message.new('GET', 'http://api.geonames.org/weatherIcaoJSON?ICAO=' + this.station + 'amp;username=demo');
 _httpSession.queue_message(request, function(_httpSession, message) {
 if (message.status_code !== 200) {
 callback(message.status_code, null);
 return;
 }
 var weatherJSON = request.response_body.data;
 var weather = JSON.parse(weatherJSON);
 callback(null, weather);
 });
},

getIcon: function(weather){
 switch (weather.weatherObservation.weatherCondition){
 case "drizzle":
 case "light showers rain":
 case "light rain":
 return "weather-showers-scattered.svg";
 case "rain":
 return "weather-showers.svg";
 case "light snow":
 case "snow grains":
 return "weather-snow.svg";
 }
 switch (weather.weatherObservation.clouds){
 case "few clouds":
 case "scattered clouds":
 return "weather-few-clouds.svg";
 case "clear sky":
 return "weather-clear.svg"
 case "broken clouds":
 case "overcast":
 return "weather-overcast.svg";
 }
 return "weather-fog.svg";
}
The first method for GeoNames is getWeather and the second getIcon. In getWeather we make a http request with soup, handle errors and then parse the information from the request to form we can use it. In getIcon we simply compare the results we got from getWeather to the switch we have in order to get the icon matching current weather. Now that we have our local library ready, it's time to make use of it.
geonames.js
Here is the entire code for our local library. The main program file calls this asynchronously.
const Soup = imports.gi.Soup;
const _httpSession = new Soup.SessionAsync();
Soup.Session.prototype.add_feature.call(_httpSession, new Soup.ProxyResolverDefault());

function GeoNames(station) {
 this.station = station;
}

GeoNames.prototype = {
 getWeather: function(callback) {
 var request = Soup.Message.new('GET', 'http://api.geonames.org/weatherIcaoJSON?ICAO=' + this.station + 'amp;username=demo');
 _httpSession.queue_message(request, function(_httpSession, message) {
 if (message.status_code !== 200) {
 callback(message.status_code, null);
 return;
 }
 var weatherJSON = request.response_body.data;
 var weather = JSON.parse(weatherJSON);
 callback(null, weather);
 });
 },

 getIcon: function(weather){
 switch (weather.weatherObservation.weatherCondition){
 case "drizzle":
 case "light showers rain":
 case "light rain":
 return "weather-showers-scattered.svg";
 case "rain":
 return "weather-showers.svg";
 case "light snow":
 case "snow grains":
 return "weather-snow.svg";
 }
 switch (weather.weatherObservation.clouds){
 case "few clouds":
 case "scattered clouds":
 return "weather-few-clouds.svg";
 case "clear sky":
 return "weather-clear.svg"
 case "broken clouds":
 case "overcast":
 return "weather-overcast.svg";
 }
 return "weather-fog.svg";
 }
}
}
Window (C)
A toplevel window which can contain other widgets
Window
A minimal GtkApplication. Use
#include &lt;gtk/gtk.hgt;

static void
activate (GtkApplication *app,
 gpointer user_data)
{
 GtkWidget *window;

 window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

 gtk_window_set_application (GTK_WINDOW (window), GTK_APPLICATION (app));
 gtk_window_set_title (GTK_WINDOW (window), "Hello GNOME");

 gtk_widget_show_all (GTK_WIDGET (window));
}

int
main (int argc, char **argv)
{
 GtkApplication *app;
 int status;

 app = gtk_application_new ("org.gtk.example",G_APPLICATION_FLAGS_NONE);
 g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
 status = g_application_run (G_APPLICATION (app), argc, argv);
 g_object_unref (app);
 return status;
}
Window (JavaScript)
A basic window which can contain other widgets
A minimal GtkApplication
Use
#!/usr/bin/gjs

const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Gtk = imports.gi.Gtk;
const Lang = imports.lang;

const Application = new Lang.Class ({
 Name: 'Application',

 //create the application
 _init: function () {
 this.application = new Gtk.Application ({
 application_id: 'org.example.myapp',
 flags: Gio.ApplicationFlags.FLAGS_NONE
 });

 this.application.connect('activate', Lang.bind(this, this._onActivate));
 },

 //callback function for 'activate' signal
 _onActivate: function () {

 MyWindow = new Gtk.Window({type: Gtk.WindowType.TOPLEVEL});
 MyWindow.title = "Welcome to GNOME";

 /* Here are a few ways we can customize our window.
 Try uncommenting them or changing their values! */
 //MyWindow.set_default_size (400,200);
 //MyWindow.set_has_resize_grip (false);
 //MyWindow.set_opacity (0.5);
 //MyWindow.maximize ();

 //show the window and all child widgets (none in this case)
 MyWindow.show_all();
 this.application.add_window(MyWindow);
 }
});

//run the application
let app = new Application ();
app.application.run (ARGV);
In this example we used the following:

Window (Python)
A minimal GTK+ Application: a window with a title.
Use
from gi.repository import Gtk
import sys


class MyApplication(Gtk.Application):

 def do_activate(self):
 # create a Gtk Window belonging to the application itself
 window = Gtk.Window(application=self)
 # set the title
 window.set_title("Welcome to GNOME")
 # show the window
 window.show_all()

# create and run the application, exit with the value returned by
# running the program
app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
Useful methods for a Window widget
Window (Vala)
The simplest Gtk.Application
Use
/* This is the application. */
public class Application : Gtk.Application {

 /* Constructor */
 public Application () {
 Object (application_id: "org.example.window");
 }

 /* Override the 'activate' signal of GLib.Application,
 * which is inherited by Gtk.Application. */
 public override void activate () {

 var window = new Gtk.Window ();
 window.title = "Welcome to GNOME";

 /* The following 3 lines are included here to introduce
 * you to ways you can adjust the toplevel window to suit
 * your needs. Uncomment them to see what they do.
 */

 //window.border_width = 10;
 //window.set_default_size (350, 70);
 //window.window_position = Gtk.WindowPosition.CENTER;

 /* Add the window to this application. */
 this.add_window (window);

 /* Show the window. */
 window.show ();
 }
}

/* The main function creates the application and runs it.*/
int main (string[] args) {
 var app = new Application ();
 return app.run (args);
}
The widget
The enum
The method


tiffany.antopolski@gmail.com
Gtk.Application
border_width
window_position
mmcasetti@gmail.com

GtkApplication
GtkWindow
jewelfox@fursona.net
Gtk.Window
ihmis.suski@gmail.com
Creating function geoNames
Methods for geoNames
Autotools
Connecting signals to button and entry."gt;
weatherapp.js
$
GJS_PATH=`pwd` gjs weatherapp.js
Beginner's Tutorial (Python)
0 Beginner's Tutorial
Basic buttons
Entry widgets (with a detour on basic scrolling)
Selectors (a recap)
More containers
More scrolling
"scrollbar.py"
"widget.py"
Some theory to help you
mdhillca@gmail.com
The TreeView widget is designed around a
GtkTreeView
GtkTreeModel
GtkTreeStore
GtkCellRendererText
GtkTreeViewColumn
Gtk.TreeView
Gtk.ListStore
Gtk.TreeSelection
GtkListStore
pygobject - Python bindings for GObject Introspection
Fonts
Gtk.ApplicationWindow
Gtk.CellRendererText
Gtk.TreeIter
Gtk.TreeViewColumn
GtkCellRendererToggle
For buttons and callbacks functions, see
@@image: 'media/tooltip.png'; md5=6950da5f4444aa941ecc2f0fc5951d52
GtkTooltip
GtkToolbar
GtkWidget
Stock Items
Screenshot of Glade ui
Screenshot of toolbar icon in Glade ui
Screenshot of General tab
Screenshot of Common tab
Setting the visible property to No
Gtk.Toolbar
Gtk.Toolbutton
Gtk.Stock
sebp@k-d-w.org
GtkGrid
GtkBuilder
Event Structures
The Python Gtk+ 3 Tutorial - Glade and Gtk.Builder
GtkToolButton
GtkToolItem
GtkActionable
Gtk.ToolButton
Gtk Stock items
Gdk.WindowState
Gtk.ToggleButton
For an explanation of signals and callback functions, see
GtkToggleButton
GtkSpinner
Gtk.Grid
Gtk.Spinner
monicakochofar@gmail.com
GtkTogglebutton
Gtk.TextBuffer
Gtk.TextView
Gtk.ScrolledWindow
Gtk.WrapMode
Gtk.PolicyType
GtkTextView
GtkTextBuffer
GtkTextTag
GtkScrolledWindow
Standard Enumerations
Gtk.Button
Gtk.Label
Gtk.RadioButton
GtkContainer
Gtk.Switch
For a discussion on signals and callback functions, see
GtkSwitch
GtkLabel
GSimpleAction
Gtk.Image
Definitions
Conceptionally, a
The representation of a string as a list of code points is abstract. In order to convert this abstract representation into a sequence of bytes the Unicode string must be
If the code point is strictly less than 128, each byte is the same as the value of the code point.
If the code point is 128 or greater, the Unicode string can’t be represented in this encoding. (Python raises a
Although ASCII encoding is simple to apply it can only encode for 128 different characters which is hardly enough. One of the most commonly used encodings that addresses this problem is UTF-8 (it can handle any Unicode code point). UTF stands for “Unicode Transformation Format”, and the ‘8’ means that 8-bit numbers are used in the encoding.
How To Deal With Strings - The Python GTK+ 3 Tutorial
Gtk.Statusbar
GtkStatusbar
Gdk - Key Values
Gtk.Frame
Gtk.Paned
GtkStatusBar
String Utility Functions
Gtk.Widget
Gdk.keyval_name
Key Values
GObject
Gtk.SpinButton
For an explanation of signals and callback functions, see
GtkSpinButton
GtkAdjustment
Gtk.Adjustment
GtkSeparator
GtkImage
Gtk.Scale
Gtk.PositionType
Gtk.Orientation
For an explanation of signals and callback functions, see
GtkScale
GtkRange
gnome-doc-list@gnome.org
jhs@gnome.org
For a general discussion of this, see
GtkRadioButton
This is equivalent to:
Gtk.ProgressBar
GLib.Timeout
GtkProgressBar
GLib - The Main Event Loop
GLib
G_Timeout
chrisk@openismus.com
Line 7: We'll look at this function in a later section.
Line 9: This adds our
Interesting to note is that we want to prepend the
Line 9: This line of code runs a custom function,
The address of the
The animation mode to use. Here we use
The duration of the animation in milliseconds. I've chosen 500 ms for this example.
The remaining arguments are property/value pairs. Here we want to set the
The last argument must always be
The
Depth also determines which
Lines 27‒33: This is similar to the above block of code. Notice that we are setting the the depth to raise it above the other images.
The following is the convenience function passed to
Lines 2‒5: The signature of this function requires two
Line 7: Depending on which boolean value is passed in, the
@@image: 'media/paned.png'; md5=01e36d8a51ee18313616d63d2e15d993
GtkPaned
GtkComboBox
GtkCellRenderer
The Python Gtk+ 3 Tutorial - Tree and List Widgets
The Python Gtk+ 3 Tutorial - CellRenderers
The Python Gtk+ 3 Tutorial - ComboBox
Gtk.MessageDialog
Gtk.DialogFlags
Gtk.MessageType
Gtk.ButtonsType
GtkMessageDialog
GtkDialog
GActionMap
List of button types
List of message types
GApplication
shaunm@gnome.org
"UTF-8"
NULL
shaunm
FIXME: Is this true? Does query_selector take CSS, CSSish, or what?
Not passing the GError**, but we should give it a quick mention and link to somewhere that explains how GError-handling works.
g_base64_encode has bad args
Link to method to get HTML from DOM and to GIO APIs.
Link to strftime or something
@@image: 'media/menubutton.png'; md5=1feb7b836a522c3007079d4420621d9d
azzurroverde@gmail.com
Glib.ActionEntry
Gtk.Builder
dgsiegel@gnome.org
Gtk.LinkButton
GtkLinkButton

philip.chimento@gmail.com
1 Image Viewer
jwendell@gnome.org
GtkApplicationWindow
To set a stock icon as image, you can use
You can also use
gjs helloWorld.js
chmod +x helloWorld
chmod +x autogen.sh
2 Guitar Tuner
GJS_PATH=`pwd` gjs guitarTuner.js
GtkButton
desrt@desrt.ca
This program will not compile with the quit action connected until
Menu
append
SimpleAction
add_action
GVariantType
GVariant
@@image: 'media/ubuntu.png'; md5=40845e4a40b335b1958da1403f01c13f
@@image: 'media/fedora.png'; md5=19add55f4349fd9e90f3a50b344ba626
@@image: 'media/opensuse.png'; md5=a852a94199328e2f978c7f6a55bf8b54
Install GNOME development tools
Getting ready for GNOME development
Install the required tools
Before you can start coding you will have to install the required tools for GNOME development on your computer. This shouldn't take you more than ten minutes.
Automatic installation
On an up-to-date distribution you should be able to simply install the required packages by clicking on
Manual installation
If you prefer manual installation you can find the instructions for the various distributions in the
Ubuntu
Fedora
OpenSuSE
Others
Required versions
The guides assume that you have at least the following versions of the tools installed:
Anjuta - 3.0
Devhelp - 3.0
Glade - 3.10
Of course, any newer version will also work. Now, we wish you a lot of fun with the
GtkFontChooserWidget
FileChooser
GLib.ActionEntry
GtkFileChooserDialog
GtkFileChooser
Gtk.Entry
GtkEntry
Gtk.Dialog
Gtk.Dialog.with_buttons
get_content_area
Platform demos in C++
GtkCellRendererPixbuf
Gtk.ComboBox
set_attributes
GtkCellLayout
Gtk.CellRendererPixbuf
Gtk.ComboBoxText
Gtk.ColorButton
Gdk.RGBA
GtkColorButton
GtkColorChooser
RGBA Colors
Gtk.CheckButton
We could also create the CheckButton with
GtkCheckButton
tiffany.antpoolski@gmail.com
GtkButtonBox
GtkBox

Unicode Manipulation
tiffany@antopolski.com
Beginner Tutorials (Vala)
0 Beginner's Tutorials
The Vala Tutorial
Sample Vala code
0 Beginner's tutorials and samples
Beginner's Tutorials (C)
set_default_size
GtkAboutDialog
Gtk.AboutDialog