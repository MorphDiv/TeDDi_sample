# language_name_wals:	English
# language_name_glotto:	English
# ISO_6393:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

Platform Overview
The GNOME platform provides a comprehensive development environment for graphical applications and other software. Using the technologies in GNOME, you can create high-quality software to meet and exceed your users' expectations. This chapter provides a very brief overview of the components that are discussed in this document.
Core Technologies
GNOME provides a number of libraries for constructing attractive graphical interfaces. It provides libraries for displaying and manipulating common user interface controls, for laying out and rendering text from most of the world's writing systems, and for drawing sophisticated vector graphics to the screen. The graphical technologies in GNOME are outlined in
The GIO library in GLib, together with the GVFS backend, provides a file system abstraction that allows users to work with files on remote servers as well as the local file systems. GIO provides a high-level API for file operations, making development fast and easy. Using GIO will allow your application to support remote files and folders automatically. GIO and GVFS are discussed in
GNOME provides the GConf library and daemon for storing and retrieving user preferences. GConf has a simple API that makes it easy to provide instant-apply preferences in your application. Using GConf also allows administrators to provide default and mandatory application settings for their users. GConf is discussed in
GNOME provides facilities for internationalization and accessibility, helping you reach the largest possible number of potential users. Much of the internationalization and accessibility support is built right in, but there are many issues you should be aware of when developing applications. Internationalization is discussed in
GNOME ships with GStreamer, an extremely powerful multimedia framework for creating, editing, and playing audio and video content. GStreamer is discussed in
GNOME also provides a complete print framework which leverages CUPS whenever possible. The print framework in GNOME allows you to provide a consistent interface to high-quality printing. The print framework is discussed in
IPC and Networking
The GNOME desktop has full support for transferring data using the clipboard or with drag and drop. The APIs in GTK+ can help you create applications that interoperate well with the rest of the desktop. Clipboard and drag and drop functionality are discussed in
With
GNOME features the Bonobo component system, built on top of CORBA. Bonobo allows programmers to create complex embeddable components which can be reused inside other programs. Note that Bonobo has been deprecated. Newly written code should use D-Bus and other technologies instead. Bonobo is discussed in
To make networks more manageable for users, GNOME supports DNS Service Discovery. DNS Service Discovery enables applications to find services automatically on a local network, rather than requiring users to provide network addresses. DNS Service Discovery is discussed in
Finally, GNOME provides a number of libraries for working with XML and web services. These technologies are becoming increasingly important to application developers. XML and web services are discussed in
Desktop Technologies
The GNOME desktop features numerous places where applications can provide better integration, such as providing panel applets or plugins for the file manager. Many of these features are discussed in
GNOME provides comprehensive Human Interface Guidelines to help you create more usable applications. GNOME's usability standards were a first among free desktop environments, and they continue to improve through GNOME's commitment to a better user experience. Usability is discussed in
GNOME also provides a complete help system, as well as style guidelines for writing documentation. Though often under-appreciated, good user help can significantly improve your software. Documentation is discussed in
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License (GFDL), Version 1.1 or any later version published by the Free Software Foundation with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You can find a copy of the GFDL at this
This manual is part of a collection of GNOME manuals distributed under the GFDL. If you want to distribute this manual separately from the collection, you can do so by adding a copy of the license to the manual, as described in section 6 of the license.
Many of the names used by companies to distinguish their products and services are claimed as trademarks. Where those names appear in any GNOME documentation, and the members of the GNOME Documentation Project are made aware of those trademarks, then the names are in capital letters or initial capital letters.
DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS FREE OF DEFECTS MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND PERFORMANCE OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS WITH YOU. SHOULD ANY DOCUMENT OR MODIFIED VERSION PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER; AND
UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE AUTHOR, INITIAL WRITER, ANY CONTRIBUTOR, OR ANY DISTRIBUTOR OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER DAMAGES OR LOSSES ARISING OUT OF OR RELATING TO USE OF THE DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.
DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT ARE PROVIDED UNDER THE TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE FURTHER UNDERSTANDING THAT:
Clipboards and Drag and Drop
As users work with more and more types of data in different applications, they have an increasing need to share objects and data between their applications. GNOME supports two related methods for transfering data between applications: using drag and drop operations, and copying to and pasting from a system-wide clipboard. Both the clipboard and drag and drop work across multiple applications, including those not developed with GNOME.
The clipboard is used when a user explicitly copies data in an application. The application then claims ownership of the clipboard. When the user pastes the data into another application, that application requests the clipboard data from the first application. Clipboard operations are fully supported in GTK+.
Drag and drop operations are similar, but they require the pointer to be tracked and updated as the user moves across potential drop targets. When an application is notified a pointer is moving over it during an active drag, it must update the cursor to indicate whether or not it can accept the drop. GTK+ provides drag and drop support with a sophisticated API that makes it easy to manage drop targets in your applications.
Both the clipboard and drag and drop operations support content negotation. When an application has data to offer, it advertises which formats are available for that data. Receiving applications can request the most suitable formats. For instance, if a user copies text from a web browser, a word processor can maintain formatting by requesting the data in HTML, while a plain text editor can receive the text without formatting.
You should provide clipboard and drag and drop functionality for any data your application operates on. The clipboard and drag and drop are useful for more than just text: files, graphics, and sound clips are all examples of data that can be transferred between applications. When you use GTK+, you automatically get clipboard and drag and drop support for text areas, color buttons, file choosers, and other built-in user interface controls. You should use the APIs in GTK+ to provide support for any other data in your application.
For more information, see
D-BUS Messaging
D-Bus is a cross-desktop message bus for sending events between various applications, the desktop, and low-level components of the system. D-Bus provides a simple API for sending messages to particular services and for broadcasting messages to all interested services. D-Bus enables different types of applications to communicate and integrate with each other and with the desktop, providing better interaction and a richer experience for the user.
D-Bus provides a session and a system bus. The session bus is used by applications in a single user session, allowing them to share data and event notifications and to integrate into the user's desktop. For example, movie players can send a D-Bus message to prevent the screensaver from activating when the user is watching a movie.
The system bus is a single message bus which runs independently of any user sessions. It can communicate with applications in any session, enabling those applications to interact with system components without dealing with low-level system details. The system bus is used to provide important functionality that users expect to work on their systems. For example, the system bus is used to monitor when network interfaces go up or down, when external drives get plugged in, and when laptop batteries are low.
D-Bus is developed jointly on
For more information on D-Bus, see
Bonobo and CORBA
Note that Bonobo, libIDL and ORBit have been deprecated in favor of D-Bus and other technologies. See above.
Bonobo is a framework for creating reusable components for use in applications. Built on top of the industry-standard Common Object Request Broker Architecture (CORBA), Bonobo provides all the common interfaces needed to create and use well-behaved components in GNOME applications.
Bonobo components can be used in a variety of situations, and can help create flexible and extensible software. For example, a component to display multimedia content could be embedded inside a word processor, effectively adding multimedia support to the word processor without the word processor working directly with it. Bonobo components are also used to embed the applets in the GNOME panel. Using Bonobo enables the applets to communicate effectively with the panel, affording users a consistent interface.
Bonobo components are not limited to graphical controls. Bonobo was used by Evolution, GNOME's email and groupware suite, to provide access to users' addressbook and calendar. This allows users to keep all their information in one place, where all applications can access it.
Bonobo is built off of CORBA, allowing components to run in seperate processes. Components can be written in different languages and run on top of different runtimes; they need only adhere to an interface specified with the Interface Definition Language (IDL). CORBA's flexible design even allows components to run on seperate machines over a network.
GNOME provides its own fast and lightweight CORBA implementation with ORBit. The tools and libraries supplied with GNOME even allow components to be written effectively in C, a language often excluded by other CORBA implementations. ORBit is an incredibly fast CORBA implementation.
Bonobo helps fill the gaps in CORBA, providing the additional interfaces and specifications needed to support consistent components. Although you will rarely need to use CORBA without Bonobo, it can be used directly. For instance, GNOME's accessibility infastructure uses CORBA to allow assistive tools to inspect and interact with running applications.
You may wish to use Bonobo to provide complex graphical components that can be embedded into applications. For most IPC needs, however, GNOME is moving towards D-Bus, as integrating D-Bus into applications is considerably easier.
For more information on Bonobo, see the
Service Discovery
DNS Service Discovery, or Zeroconf, is a technology for automatically locating available services on a network. Zeroconf allows users to access network resources without having to provide explicit addresses or configure their applications manually.
DNS Service Discovery is already used in numerous places throughout GNOME, and further support will be added in the future. For example,
Full DNS Service Discovery support is provided by the Avahi library. For more information on Avahi, visit
XML and Web Services
In our increasingly inter-connected world, more and more applications need to provide support for various web services. Sometimes web services simply provide added functionality, while other times they are the core purpose of the application. Even applications that have been providing a standalone user experience for years have found innovative new uses for web services.
The GNOME Platform provides support for using web services from within your application, as well as comprehensive libraries for consuming, managing, and transforming XML, the language of the web.
HTTP
Libsoup is an HTTP library designed to be used in graphical applications which need asynchronous operations to avoid blocking the user interface while network requests are going on.
Soup provides functionality for using HTTP cookies, SSL encrypted connections, and the XML-RPC protocol based on HTTP.
For more information on libsoup, see the
XML Processing
Since its formal introduction in 1998, XML (eXtensible Markup Langauge) has been used in increasingly more applications. It is used for a wide variety of purposes, from document formats like XHMTL and DocBook to internet protocols like SOAP and Jabber. XML provides a clean and simple base syntax, allowing applications to focus on their particular needs.
GNOME ships with the libxml2 library, and uses it extensively throughout the desktop. The libxml2 library is a fast and fully standards-compliant XML processing library, providing everything you need to use XML in your application.
The libxml2 library provides a number of different APIs for working with XML, so you can use whatever best suits your application development needs. In addition to a native tree API, libxml2 also provides the callback-based SAX2 API, streaming XML reader and writer interfaces, and complete support for XPath.
In addition to DTD support, libxml2 also provides full support for validing documents using RELAX NG, which allows a more flexible validation model while remaining simple to use. There is also partial support for XML Schema, the new schema language produced by W3C.
You should use libxml2 whenever you need to work directly with XML in your application. Using libxml2 ensures that you have fully standards-compliant parsing, processing, and XML output. This means developers can stop worrying about incompatibilities between applications.
For more information on libxml2, see
Transforming XML with XSLT
XSLT is an XML-based language for transforming XML into other formats. XSLT is a template-based language, allowing you to match particular types of XML elements and create output accordingly. Based on XML and XPath, XSLT enables developers to create clean and modularized templates to convert an XML dialect into another format more suitable for the application.
GNOME ships with the libxslt library, a complete implementation of XSLT. The libxslt library is built on top of the XML and XPath support in libxml2, allowing it to be fast and fully standards-compliant.
You should use libxslt if you need to transform XML documents. Although XSLT is not always the right solution for XML processing, it can often simplify development. Since libxslt allows you to add extension elements and extension functions, you can customize it to fit your application.
For more information on libxslt, see
Introduction
GNOME is a powerful but simple desktop environment with a strong focus on usability, accessibility, and internationalization. GNOME is designed to be usable by everybody, regardless of technical expertise, disabilitites, or native language. GNOME makes it easy for people to use their computers.
GNOME provides a comprehensive developer platform that allow developers to create professional software that is easy to use and aesthetically pleasing. This document provides a high-level overview of the GNOME platform along with links to detailed documentation on each part of the platform.
Who Should Read This Document
You should read this document if you want to create software using the GNOME platform. Developing with the GNOME platform will help you create consistent applications that integrate well into the user's desktop. This guide will introduce you to the various components of the platform, so you know which libraries can accomplish which tasks. This guide links to additional detailed documentation, so you can explore each component of the platform in more depth.
This guide will also be useful if you are picking a development platform for your software project. It will provide an overview how you can use the GNOME platform to build useful software.
This guide also describes ways of extending the GNOME desktop with plugins, panel applets, and other useful tools. If you want to develop additional functionality to plug into the GNOME desktop, you should read this guide, particularly
If you have existing software that you want to port to the GNOME platform, you should see the online
The GNOME Family
GNOME is a global effort, with many contributors all over the world. GNOME is a success because of its contributors and users. This section lists the web sites and conferences where you can learn more about GNOME, as well as other organizations that work with GNOME.
Web Sites
www.gnome.org
The primary web site for GNOME users. It contains release information, downloads, and documentation.
library.gnome.org
The complete source for all GNOME documentation. It contains all of the user and developer documentation produced by GNOME, automatically built and updated for each release.
foundation.gnome.org
The web site for the GNOME Foundation, the not-for-profit foundation that oversees the development of GNOME.
bugzilla.gnome.org
The GNOME bug trackers. Use this site to submit a bug report or feature request, or to track the status of a report.
live.gnome.org
The GNOME wiki. Many projects within GNOME now use the wiki as their primary web space. In additional, the wiki is often used to sketch out future development.
developer.gnome.org
The old website for developer information. This once contained developer documentation and information about the usability, documentation, and translation teams. The content on this site has since been largely superseded by
mail.gnome.org
Information on GNOME mailing lists. This site contains full archives of all GNOME mailing lists.
git.gnome.org
The GNOME Git repository, tracking all GNOME source code back to the inception of the project.
Mailing Lists
gnome-list
The primary mailing list for GNOME users.
gnome-devel-list
Information and questions about development using the GNOME platform.
gnome-love
The first place to go to get involved with GNOME.
gnome-accessibility-list
Information on accessibility in GNOME applications.
gnome-doc-list
Information on writing documentation for GNOME applications.
gnome-i18n
Information about internationalization and localization of GNOME applications.
usability
Information on usability for GNOME applications.
Conferences
GUADEC
The primary conference for GNOME users and developers. GUADEC is hosted annually in May or June. Each year, it is hosted in a different European city, making it an excellent excuse to see more of Europe. GUADEC features talks aimed at users, developers, and vendors.
The GNOME Summit
The hacker get-together. The Summit is geared primarily at existing GNOME developers, although there is often useful information for new developers. The Summit is hosted annually in Boston.
GNOME.conf.au
A casual get-together hosted annually at linux.conf.au.
Other Organizations
freedesktop.org
The collaborative effort for interoperability and shared technology among desktop environments. Through freedesktop.org, GNOME works with projects such as KDE and XFCE to make it easier for application developers to provide better experiences for their users.
Mozilla
The free web engine, and a whole lot more. GNOME maintains close ties to the Mozilla development team to provide an overall better user interface.
OpenOffice.org
The free office suite. GNOME works with the OpenOffice.org development team to help provide a more unified interface when using the free office suite on GNOME.
Free Software Foundation
Freedom. Established in 1985, the Free Software Foundation has worked to create a complete free operating systems, giving its users the freedom to use, modify, and redistribute their software. As part of the GNU project, GNOME aims to provide a fully free desktop environment.
Application and File Type Registries
In order for applications to be useful, users need to be able to find and run them. Users of the GNOME desktop may run applications using the applications menu, or they may run them by accessing files in the file manager. The GNOME desktop allows you to add applications and file types when you install your application. The mechanism for these is specified on
Adding your application is as simple as providing a desktop entry file with the necessary information. Desktop entry files use a simple key-value syntax, with extra provisions for providing translated content of particular values. Your application's desktop entry file will contain the following information:
A name and a comment, each translated into as many languages as your application supports,
A list of categories from a fixed list, which are used to place your application in the applications menu,
An icon, either as a full file path or as a simple name for the icon theme system,
A list of file types that your application supports, and
The command to run your application.
If your application handles custom file types that are not already known by the system, you will need to add those types to the file type registry. All file types are accessed with MIME types. For example, Ogg Vorbis audio files have the MIME type
For more information on applications, see
Panel Applets
The GNOME desktop features flexible and powerful panels to which users can add any number of small applications, called panel applets. Panel applets can provide all sorts of quick access to all sorts of useful information and functionality. For instance, the GNOME desktop ships with panel applets to switch between windows and workspaces, display the current weather conditions, and display network activity, among many others.
You may provide a panel applet to augment the functionality of your application, or you may provide a simple stand-alone panel applet. If you simply need to display quick notifications, you should consider using the notification area instead, which is also displayed in the user's panel. Panel applets should be used when you need to provide more functionality than that provided by notification icons.
Panel applets are independent processes that use Bonobo to communicate with the panel. Bonobo allows applets to integrate with the panel to provide a consistent user experience. For example, the context menu for every panel applet contains standard items to remove, move, and lock the applet. Each panel applet can then add items to the context menu to perform other actions. The
Note that Bonobo has been deprecated in favor of D-Bus and other technologies.
For more information on panel applets, see the
Notification Area
In addition to launchers and panel applets, the GNOME panel also features a notification area that applications can use to notify users of events. Notifications can be used to alert the user of new emails, available updates, upcoming meetings, or any number of other events.
Notifications are simple icons that your application can place in the notification area on the user's panel. Your application can then take further action when the user clicks on the icon. Currently, the notification system is implemented in the experimental Egg library; however, the next version of GTK+ will have support for notification icons.
The notification area is a
File Manager
GNOME ships with


Plugins can also add columns to the list view and automatically place emblems on files. This can be used to provide pertinent information to the user at a glance. For example, a

In addition to a flexible plugin architecture,
Window Manager
The window manager is a special program responsible for drawing the borders and titlebars around windows. The window manager is responsible for handling all the operations performed on windows, such as moving, resizing, minimizing, and moving between workspaces. Windows are managed consistently with little or no work from application developers. When applications need to influence the window manager, they can provide hints on their windows using function calls in GTK+.
External programs can, however, interact directly with the window manager, and even control its behavior. Using GNOME's libwnck library, applications can get information about the placement and state of all the windows and instruct the window manager to perform various actions on those windows.
The libwnck library isn't specific to GNOME's window manager. All of its functionality uses the Extended Window Manager Hints, or EWMH. EWMH was developed jointly with
Window manager interaction with libwnck can be used for simple tasks, such as displaying workspace and window list applets on the user's panel, as well as for complex applications, such as performing automatic actions on new windows based on certain window properties.
Control Center
The GNOME desktop provides a single menu of all the desktop-wide preferences and system administration settings. Preferences and settings dialogs can be placed in this menu to make them easily accessible. Dialogs can be placed in the preferences menu by adding them to the applications registry with the
If you provide a dialog that allows administrators to configure desktop systems, then you should add your dialog to the administration menu. If you provide a dialog that allows users to adjust preferences that affect a number of applications, then you should add your dialog to the preferences menu. You should not use these global menus for individual application preferences.
Storing Passwords
GNOME provides a modern and secure keyring manager to store users' passwords and other sensitive data. Applications can use the keyring manager library to store and access passwords, and users can manage their passwords using GNOME's
The keyring manager provides any number of keyrings, where each keyring can contain any number of keyring items. Items in a keyring store some piece of data, often a password. Each keyring is locked individually, and users must provide a password to unlock the keyring. Once a keyring has been unlocked, the user has access to all of the items in that keyring.
The keyring manager provides access control lists for each keyring item, controlling which applications are allowed access to that item. If an unknown application attempts to access a keyring item, the keyring manager will prompt the user to allow or deny that application access. This helps prevent malicious or poorly-written programs from accessing the user's sensitive data.
Keyring data stored on the file system is encrypted with the AES block cipher, and SHA1 is used for hashes of the item's attributes. Using the attributes hash, the keyring manager is able to look up items requested by applications without ever unlocking the keyring. The keyring has to be unlocked when a matching item is found and accessed.
The keyring manager also provides a session keyring. Items in the session keyring are never stored on disk, and are lost as soon as the user's session ends. The session keyring can be used to store passwords to be used in the current session only.
If you use GIO to access remote servers, you automatically get the benefits of the keyring manager. Whenever GVFS needs to authenticate the user, it provides the option to store the password, either in the default keyring or in the session keyring.
You should use the keyring manager whenever your application needs to store passwords or other sensitive data for users. Using the keyring manager provides a better user experience while still keeping user data safe and secure.
For API references please see the
Session Management
GNOME provides tools to allow your application to run smoothly from session to session. Users can log out with running applications and have those applications fully restored when they log back in. To provide this functionality, your application must connect to the session manager and save its state when the user logs out.
Note that this section is outdated as GnomeClient and Libgnomeui are deprecated. Newly written code should use
GNOME provides a simple API for session management in the GNOME User Interface Library. See the section
Address Book and Calendar
With Evolution Data Server, GNOME provides a single address book and calendar that all applications can use to store and retrieve information. Using Evolution Data Server means that users no longer have to maintain separate lists of contacts in each application, or manually copy events to their calendar.
People use computers increasingly to interact with their friends and colleagues. Applications such as email programs, instant messengers, and telephony and video conferencing applications are used to communicate with others. These applications often provide contact lists to help users. Using Evolution Data Server, applications can store contact information in a single location, allowing all applications to see all the pertinent data about users' contacts.
Applications can also use Evolution Data Server to store and retrieve appointments on the user's calendar. For example, the clock on the panel shows a simple calendar when clicked. If the user has any appointments scheduled, they are shown alongside the calendar. This makes it easy to see upcoming appointments without opening a full calendar application.
For more information on the address book, see
Usability
The GNOME desktop is designed around usability, and it aims to provide a consistent and simple user experience. People use computers to get work done (or to play!), not to figure out complicated user interface puzzles. When designing your application, you should consider how well users can recognize common user interface paradigms, how quickly they can learn the elements that are unique to your application, and how efficiently they can execute tasks once they've learned them.
GNOME provides comprehensive Human Interface Guidelines to help you write applications that are attractive and usable. While no guidelines can provide a single answer for all usability concerns, understanding the GNOME Human Interface Guidelines can make it easier to create a usable application. For more information, please see the
Documentation
All applications should provide documentation to help their users understand the application and troubleshoot problems that may arise. While a well-designed application should not require reading the documentation before use, documentation can nonetheless be an important tool for users, particularly for complex applications.
GNOME provides a unified framework for providing user documentation. You can provide documentation in the industry-standard DocBook format. Using DocBook means that you don't have to worry about formatting details. Instead, your documentation will be automatically formatted with the same consistent conventions as the rest of the system documentation.
GNOME's help viewer,
For more information on writing documentation for your application, see the
@@image: 'figures/graphics.png'; md5=d7ab482cbaaf268b4c439c57b2624826
@@image: 'figures/pango.png'; md5=e308eb839e5e70aea097a4cfe744e44c
@@image: 'figures/i18n.png'; md5=75f5d47d566817d32f1ed76e4c761ffb
Graphical Interfaces
Most applications will need to provide a graphical interface to interact with users. Graphical interfaces can create an intuitive and discoverable medium for people to interact with software, and users expect applications to provide usable and attractive user interfaces.
The GNOME Platform features sophisticated graphics and user interface technology, from standard user interface controls to an API for drawing high-quality graphics to the screen. Using the graphics technologies in GNOME allows you to create applications that are consistent, intuitive, and aesthetically pleasing.
Layered Look at Graphics Libraries
GTK+
GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its modern, object-oriented API allows you to construct attractive and sophisticated user interfaces without dealing with the low-level details of drawing and device interaction.
In addition to basic widgets, such as buttons, check boxes, and text entries, GTK+ also provides powerful Model-View-Controller (MVC) APIs for tree views, multi-line text fields, and menu and toolbar actions.
Widgets in GTK+ are placed on windows using a box-packing model. Programmers specify only how to pack widgets together in container boxes, rather than position them directly with absolute coordinates. GTK+ ensures that windows are sized correctly to fit their contents, and it automatically handles window resizing.
Because GTK+ offers a flexible API, developing additional widgets for use in GTK+ applications is easy. A number of third-party libraries exist which provide additional widgets, and many developers have created custom, special-purpose widgets for their applications.
GTK+ handles the difficult details of user interfaces and user interaction, and provides a simple yet powerful API which allows you to focus on the details of your application. Applications developed with GTK+ will automatically follow the user's theme and font settings, will interact properly with accessibility technologies, and will behave as users expect.
For more information on GTK+, see the
Libglade
Note that Libglade has been deprecated in favor of
Libglade is a library for constructing user interfaces dynamically from XML descriptions. You can use a graphical interface builder like
Libglade allows programmers to focus their code on the logic of their applications, keeping it uncluttered by the actual construction of the interface. Graphical interface builders also make it easy for dedicated interface designers to construct the interfaces without having to know how to program.
For more information on Libglade, see the
Pango
The Pango layout engine can be used with different font backends and drawing backends. On most GNOME systems, Pango will use FreeType, fontconfig, and Cairo to access fonts and render text. On other systems, Pango will use the native font systems, such as Uniscribe on Microsoft Windows and ATSUI on MacOS
Pango is the core text and font handling library in the GNOME platform. It is responsible for laying out and rendering text, and is used throughout GTK+.
Pango has extensive support for the various writing systems used throughout the world. Many of the writing systems used for languages have complex rules for laying out glyphs and composing characters. With Pango, nearly all languages can be written and displayed correctly, allowing users everywhere to view text in their native languages. Pango support for multiple writing systems is automatic; application developers do not have to write any special code to support other languages.
Displaying Multiple Languages With Pango
Screenshot of the
Pango supports the text styling used in typical documents and interfaces, including italics, font weights, and underlines. Pango uses a simple XML-like vocabulary called PangoMarkup which enables you to set font size, color, styles, and other text attributes. Using PangoMarkup, you can specify inline styles without manually iterating over text blocks. PangoMarkup can be used directly from GTK+, enabling you to style text in your graphical interfaces easily.
You should use Pango directly whenever you need to lay text out on the screen or on a different medium. Using Pango will allow your text layout to work seamlessly with GTK+ and the rest of the GNOME platform. It will help you create portable code, and most importantly, it will ensure that your application can render text correctly in hundreds of different languages.
For more information on Pango, see the
GDK
GDK runs on a number of different platforms, including the X Window System, Microsoft Windows, DirectFB, and Quartz. On any platform, GDK provides the same consistent API, allowing GTK+ and GTK+ applications to run unmodified.
GDK is the low-level library used by GTK+ to interact with the system for graphics and input devices. Although you will rarely use GDK directly in application code, it contains all the necessary functionality to draw objects and text to the screen and to interact with the user with various input devices.
GDK features a graphics context and drawing primitives that are suitable for drawing simple objects and rendering images on the screen. Since a more extensive drawing system is provided by Cairo, GDK provides hooks to use Cairo contexts within GDK.
GDK enables you to access events from keyboards, mice, and other input devices, rather than connect to the high-level signals used in GTK+. GDK also provides low-level routines to access drag and drop and clipboard data from the system. When implementing custom controls, you may need to access these features to implement proper user interaction behavior.
GDK provides other functionality which is needed to implement a complete graphical toolkit like GTK+. Since GDK acts as a platform abstraction, allowing GTK+ to run under multiple environments, it provides an API for all of the system functionality needed by GTK+. This includes information about multi-head displays, resolution and color depth, colormaps, and cursors.
You should use GDK whenever you need low-level access to the underlying windowing system, including low-level access to events, windows, and the clipboard. Using GDK for these tasks ensures that your code is portable and integrates with the rest of your GTK+ code. The simple drawing routines in GDK should generally not be used. Instead, you should use the extensive functionality provide by Cairo.
For more information on GDK, see the
Cairo
Cairo is a 2D graphics library featuring a sophisticated API for drawing vector graphics, compositing images, and rendering anti-aliased text. Cairo provides support for multiple output devices, including the X Window System, Microsoft Windows, and image buffers, allowing you to write platform-independent code to draw graphics on different media.
The Cairo drawing model is similar to those provided by PostScript and PDF. The Cairo API provides such drawing operations as stroking and filling cubic BÃ©zier splines, compositing images, and performing affine transformations. These vector operations allow for rich, anti-aliased graphics without using expensive pixel-based drawing in your application code.
Cairo's rich drawing model allows for high-quality rendering to multiple media. The same API can be used to create stunning on-screen graphics and text, to render images, or create crisp output suitable for printing.
You should use Cairo whenever you need to draw graphics in your application beyond the widgets provided by GTK+. Much of the drawing inside GTK+ is done using Cairo. Using Cairo for your custom drawing will allow your application to have high-quality, anti-aliased, and resolution-independent graphics.
For more information on Cairo, see
Virtual File System
GIO, a part of GLib, is the core library used for file and folder operations in GNOME applications. GIO provides a unified file system abstraction layer with pluggable backends. In GNOME, the GVFS library provides a GIO backend implementing multiple network and local protocols. Using GIO with GVFS allows your application to work with files on remote machines as easily as local files.
GIO can provide extensive information about files and folders, including the MIME type and icon of a file and which applications can be used to open a file. Since the GVFS uses the standard from
GIO is used throughout the GNOME desktop. The file manager,
For more information on GIO, see the
In previous versions of GNOME, the GnomeVFS library was used for access to files and folders. While GnomeVFS provided many of the same features, including transparent access to remote folders, it had a number of limitations which have been addressed in GIO. GnomeVFS is deprecated and should not be used in newly written code, although it will continue to be supported throughout the GNOME 2 lifetime. For information on GnomeVFS, see
Configuration and Lockdown
GConf is the system for storing and retrieving configuration settings in GNOME. GConf consists of two parts: a client library for accessing settings, and a session daemon which is responsible for the details of storing and retrieving those settings. Using a daemon allows GConf to use different storage backends, validate input, and provide simultaneous access to different applications.
Settings stored in GConf are stored and retrieved using a unique key, or identifier string. Keys use a simple hierarchical namespace to avoid collision among settings for applications and the desktop. You can provide a schema file to detail your configuration keys. This allows GConf to validate the type of the input, and to show localized documentation about the key. This helps systems administrators, who can set multiple settings at once without having to navigate preference dialogs.
GConf can look up settings from different settings at once, typically from different locations on the file system. By having appropriate system sources configured, GConf enables systems administrators to provide both default and mandatory settings for all users. Tools such as GNOME's
The GConf client library provides notifications of changes to settings, making it easy to provide instant-apply settings in your application, regardless if settings are changed from within your application or using another tool. Setting the value of a key will notify all interested applications, allowing desktop-wide and other cross-application settings to work instantly and effortlessly.
GConf makes it easy to lock down systems by setting particular keys read-only, preventing users from changing their values. In addition, GNOME provides a number of high-level keys that can be used to disable actions such as saving to disk and changing the panel layout. Tools such as
You should use GConf to store all user preferences in your application. Using GConf will make it easy to provide instant-apply preferences, and it will make your settings accessible to systems administrators and configuration and backup tools.
For more information on GConf, see the
Internationalization
The GNOME Desktop and Developer Platform provides full support for internationalizing and localizing applications. Internationalization is the process of ensuring your application can be localized, including marking all strings for translations, using numbers and format strings correctly, and making adjustments for variations in conventions for times and dates, units, and formatting.
GNOME uses the standard gettext and related routines for accessing localizations. Support for localization using gettext is built into every component of the GNOME platform. Your source code can be scanned for specially-marked tools by automated tools. Those strings are then placed in PO files to allow translators to track their translations. Using gettext, you can easily and efficiently access translated versions of all user-visible strings in your application from translation domains installed along with your application.
These translation domains can be created using PO files, which can be used by translators to track string changes and update their translations accordingly. GNOME ships with intltool, a tool for managing translations in PO files. Using intltool, translators can use PO files to translate not only the strings in your application, but also other types of files that you use, such as GConf schema files, desktop entry files, and XML files.
GNOME also provides the xml2po tool as part of the gnome-doc-utils package. This tool allows translators to use PO files to create translated versions of documentation written in various XML formats, including XHTML and DocBook.
Internationalization involves more than just allowing strings to be translated, and GNOME supports your application development at every step of the process. GTK+ will automatically adjust its presentation for languages that are read right-to-left, and Pango has complete support for rendering bidirectional text and text in various different writing systems. GTK+ supports multiple input methods, allowing users from all language to input text efficiently with their keyboards. The entire GNOME platform uses the UTF-8 encoding of Unicode natively, providing access to the characters and writing systems of the entire world.

Screenshots of the
Internationalizing your application helps make it available to many more users across the world. While skilled translators must provide translations for any language, programmers must ensure the application is properly internationalized before it can be fully localized.
For more information on internationalization in GNOME, see
Accessibility
Accessibility is the process of ensuring your application can be used by people with various disabilities. Disabilities come in many forms: visual impairments, movement impairments, hearing impairments, cognitive and language impairments, and seizure disorders. Many people have some sort of disability, and making your application accessibility will allow more people to use your application effectively.
GNOME provides support for accessibility devices using the ATK framework. This framework defines a set of interfaces to which graphical interface components adhere. This allows, for instance, screen readers to read the text of an interface and interact with its controls. ATK support is built into GTK+ and the rest of the GNOME platform using the GAIL library, so any application using GTK+ will have reasonable accessibility support for free.
Nonetheless, you should be aware of accessibility issues when when developing your applications. Although GTK+ interfaces provide reasonable accessibility by default, you can often improve how well your program behaves with accessibility tools by providing additional information to ATK. If you develop custom widgets, you should ensure that they expose their properties to ATK. You should also avoid using sound, graphics, or color as the sole means of conveying information to the user.
The GNOME desktop ships with a number of accessibility tools which enable users with disabilities to take full advantage of their desktop and applications. Applications that fully implement ATK will be able to work with the accessibility tools. GNOME's accessibility tools include a screen reader, a screen magnifier, an on-screen keyboard, and
For extensive recommendations on accessibility, see
Multimedia
GStreamer is a powerful multimedia library for playing, creating, and manipulating sound, video, and other media. You can use GStreamer to provide sound and video playback, record input from multiple sources, and edit multimedia content. GStreamer supports encoding and decoding numerous formats by default, and support for additional formats can be added with plug-ins.
GStreamer provides a flexible architecture wherein media is processed through a pipeline of elements. Each element may apply filters to the content, such as encoding or decoding, combining multiple sources, or transforming the multimedia content. This architecture allows for an arbitrary arrangement of elements, so that you can accomplish virtually any effect using GStreamer. Furthermore, GStreamer is designed to have low overhead, so it can be used in applications with high demands on latency.
While GStreamer provides a powerful API for manipulating multimedia, it also provides convenient routines for simple playback. GStreamer can automatically construct a pipeline to read and playback files in any supported format, allowing you to use sound and video in your application easily.
The GStreamer architecture allows plugins to add encoders, decoders, and all sorts of content filters. Third-party developers can provide GStreamer plugins which will be automatically available to other applications using GStreamer. Plugins can provide support for other multimedia formats or provide additional functionality and effects.
You should use GStreamer whenever you need to read or play multimedia content in your application, or if your application needs to manipulate sound or video. Using GStreamer makes your application development easy, and it provides you well-tested elements for many of your needs.
For comprehensive information on GStreamer, see
Printing
Most applications need to provide support for printing. Users expect to be able to print the contents they can view on-screen. The GNOME platform provides libraries to help you add support for high-quality printing to your application.
GNOME Print
Note that this section is outdated and that libgnomeprint and libgnomeprintui have been deprecated in favor of
The GNOME print framework consists of two libraries which help you provide high-quality printing with a consistent interface in your application. At the core of the printing framework is libgnomeprint, a library for creating PostScript output to send to printers. On top of that is libgnomeprintui, which provides standard print controls for your user interface.
The libgnomeprint library implements the PostScript imaging model, which is used by most printers. Printers which do not support PostScript can still be supported through CUPS, described below. In addition to the standard PostScript imaging, libgnomeprint also features alpha channel support and anti-aliasing.
The libgnomeprintui library provides a standard print dialog, a print preview dialog, and various other controls and functionality required to build printing into an intuitive user interface. The GNOME print framework handles the details of locating printers and spooling print jobs, and also provides PostScript and PDF export directly in the print dialog.
You should use libgnomeprint whenever you need to render content to PostScript for printing. You should use libgnomeprintui to construct your printing user interface, even if your rendered output comes from another source. Using the GNOME print framework provides your users a consistent user interface with the features they expect of printing appliations.
CUPS
On most GNOME systems, CUPS (Common UNIX Printing System) acts as the low-level printing system. CUPS provides a modern, feature-rich architecture for printer discovery, printer option access, and spooling print jobs to different types of printers.
CUPS provides a set of utilities for automatically discovering printers locally and on the network. This allows users not only to see all available printers, but to use different types of printers without manual configuration.
CUPS provides a unified interface for printing, regardless of the location or type of the printer. Multiple print protocols are handled seamlessly by CUPS by automatically applying filters to content sent to the printers. Applications can simply provide PostScript output, and CUPS will automatically convert it for printers that do not support PostScript natively.
CUPS also provides printer configuration options in the form of PostScript Printer Description (PPD) files. PPD configurations allow applications to expose the capabilities of individual printers to the users with a consistent user interface. For instance, PPD allows you to detect whether a printer can collate and staple print jobs, and to provide an option in your user interface.
In most cases, you will not need to interface directly with CUPS in your applications. By using the GNOME print framework, you have access to the power and flexibility of CUPS automatically. Having CUPS underneath means a better user experience with less programming.
Language Bindings
Although the GNOME platform is written primarily in C, it is written intentionally to make it easy to bind to other programming languages. Using language bindings, you can develop with the GNOME platform natively in your programming language of choice.
Language bindings exist for many programming languages, and the GNOME platform officially supports bindings for C++, Java, Perl, and Python.
C++
The C++ bindings provide complete coverage of the GNOME platform, including GTK+, Libglade, and GConf. The C++ bindings wrap all objects with native C++ objects and allow programmers to provide custom widgets with normal C++ inheritence. They provide a fully native API, with type-safe signal handlers, full use of the standard C++ library, and complete C++ memory management.
For more information on the GNOME C++ bindings, visit
Java
The Java bindings provide complete coverage of the GNOME platform, including GTK+, Cairo, and GConf. The Java bindings wrap all objects with native Java objects and allow programmers to provide custom widgets with normal Java inheritence. They provide a fully native API, using Java's class libraries and interfaces wherever appropriate.
For more information on the GNOME Java bindings, visit
Perl
The Perl bindings provide native Perl interfaces for the GNOME platform, including GTK+, GnomeVFS, and GConf. The Perl bindings wrap all objects with Perl objects and allow programmers to use standard Perl practices to manipulate them. They provide a fully native API, using Perl's native data types wherever appropriate.
For more information on the GNOME Perl bindings, visit
Python
The Python bindings provide native Python interfaces for the GNOME platform, including GTK+, GnomeVFS, and GConf. The Python bindings wrap all objects with native Python objects and allow programmers to provide custom widgets with normal Python inheritence. They provide a fully native Python API which automatically handles details like type casting and memory management.
For more information on the GNOME Python bindings, visit
Other Languages
Full or partial bindings exist for many other programming languages, such as C#, Eiffel, JavaScript, Ruby, and Scheme. Even though they may not currently be officially supported by GNOME, many of these bindings are of the same high quality as the official GNOME bindings, and some of them may be included as official GNOME bindings in future releases.
For a list of language bindings, visit
Quick Module Overview
This appendix provides a quick overview of the libraries included in the GNOME desktop and developer platform. Libraries are listed by module with a brief description and a link for more information in this document, where possible.
Platform Modules
Modules in the GNOME developer platform make strict guarantees about API and ABI stability. Applications developed against platform modules can be assured of running unmodified for the duration of the GNOME 2 lifecycle.
GConf
GConf provides the daemon and libraries for storing and retrieving configuration data. GConf is discussed in
ORBit
ORBit is a deprecated CORBA server. GNOME's deprecated component architecture, Bonobo, is built on top of CORBA. CORBA is discussed in
atk
ATK provides the set of accessibility interfaces that are implemented by other toolkits and applications. Using the ATK interfaces, accessibility tools have full access to view and control running applications. ATK is discussed in
gail
GAIL provides an implementation of the ATK interfaces for GTK+ and GNOME libraries, allowing accessibility tools to interact with applications written using these libraries. In 2009 GAIL was moved into GTK+. Accessibility is discussed in
gio
A part of GLib, the GIO library provides a high-level API for accessing files and folders. Together with the GVFS library, it provides a file system abstraction that allows transparent access to local and remote files. GIO is discussed in
glib
GLib provides the core application building blocks for libraries and applications written in C. It provides the core object system used in GNOME, the main loop implementation, and a large set of utility functions for strings and common data structures.
gnome-vfs
GnomeVFS is a deprecated library for accessing files and folders. It is superseded by GIO and GVFS. Newly written code should use GIO instead.
gtk+
GTK+ is the primary library used to construct user interfaces in GNOME applications. It provides user interface controls and signal callbacks to control user interfaces. GTK+ is discussed in
gvfs
GVFS provides a backend implementation for GIO, allowing access to numerous protocols with the GIO API. Developers do not access GVFS directly. Instead, applications written with GIO will automatically use GVFS on systems where it is enabled.
libIDL
libIDL is a deprecated library for parsing Interface Definition Language (IDL) files, which are necessary for CORBA interfaces. libIDL is used by GNOME's deprecated CORBA implementation, ORBit. CORBA is discussed in
libart_lgpl
libart is a deprecated graphics library which can render vector paths. It is used by the GnomeCanvas widget. Newly written code should not use libart_lgpl and instead use Cairo and/or other technologies.
libbonobo
Bonobo is a deprecated framework for creating reusable components for use in GNOME applications, built on top of CORBA. Bonobo is discussed in
libbonoboui
The deprecated Bonobo UI library provides a number of user interface controls using the Bonobo component framework. Bonobo is discussed in
libglade
Libglade is a deprecated library for constructing user interfaces dynamically from XML descriptions. Libglade has been deprecated in favor of
libgnome
The deprecated libgnome library provides a number of useful routines for building modern applications, including session management, activation of files and URIs, and displaying help.
libgnomecanvas
The GnomeCanvas widget provides a flexible widget for creating interactive structured graphics.
libgnomeui
The deprecated libgnomeui library provides additional widgets for applications. Many of the widgets from libgnomeui have already been ported to GTK+.
libxml2
The libxml2 library provides a number of APIs for working with XML in a standards-compliant manner. The libxml2 library is discussed in
libxslt
The libxslt library provides a fast and complete implementation of XSLT, a language for transforming XML. The libxslt library is discussed in
pango
Pango is the core text and font handling library used in GNOME applications. It has extensive support for the different writing systems used throughout the world. Pango is discussed in
Desktop Modules
Modules in the GNOME desktop are not required to make the same API and ABI stability guarantees as modules in the platform, although attempts are made to keep them relatively stable. Often, modules are introduced in the desktop release to mature, and are moved into the platform once they've stabilized.
eel
The eel library provides a number of additional widgets primarily for use inside
evolution-data-server
Evolution Data Server provides a unified location for address book and calendar information, allowing multiple applications to share the same data. Evolution Data Server is discussed in
gnome-panel
In addition to the actual panel, the gnome-panel package provides the libraries used to construct panel applets to run on the user's panel. Panel applets are discussed in
gnome-keyring
The GNOME keyring manager provides a modern and secure means of storing users' passwords and other sensitive data. Keys are encrypted and can only be accessed by explicit user permission. The keyring manager is discussed in
gstreamer
GStreamer is the powerful multimedia used throughout GNOME to play, create, and manipulate sound and video. GStreamer is discussed in
gtkhtml
The gtkhtml library provides a lightweight HTML renderer with full support for rich text editing. It is used inside the
gtksourceview
The gtksourceview library provides an extension of the GtkTextView widget with support for automatic syntax highlighting and other functions that are useful for source code editors. It is used in the
libgail-gnome
GAIL provides an implementation of the ATK interfaces for GTK+ and GNOME libraries, allowing accessibility tools to interact with applications written using these libraries. Accessibility is discussed in
libgnomeprint
libgnomeprint is a deprecated library that provides an implementation of the PostScript imaging model. It is superseded by
libgnomeprintui
libgnomeprintui is a deprecated library that provides a standard print dialog, a print preview dialog, and various other controls required for printing. It is superseded by
libgtop
The libgtop library provides a portable API for obtaining information about running processes. It is used in the
librsvg
The librsvg library provides an implementation of Scalable Vector Graphics (SVG). It is used throughout the desktop to render resolution-independent vector graphics.
libsoup
The libsoup library provides a flexible interface for HTTP servers and clients. Both synchronous and asynchronous APIs are provided. The libsoup library is discussed in
libwnck
The libwnck library provides a means of controlling any EWMH-compliant window manager, including
libxklavier
The libxklavier library provides a high-level API for accessing and setting keyboard layouts. It is used in the
vte
VTE is a terminal emulator widget for use in GTK+ applications. It provides a consistent API and uses Pango for text drawing, allowing it to display all internationalized text. VTE is used in GNOME's
Overview of the GNOME Platform
2005
2006
Shaun McCance
GNOME Foundation
2007-03-16
2.20
Overview of the powerful technologies inside the GNOME platform.
Shaun
McCance
GNOME Documentation Project
shaunm@gnome.org
translator-credits
SOAP
With the libsoup library, GNOME provides support for the SOAP, a widely-used protocol for passing XML messages over HTTP. SOAP allows developers to expose an interface over the web, which can then be used by applications to retrieve information, send data, make transactions, or use any number of other services provided.
SOAP can be used to search and retrieve information, to interact with an online store, to manage users' accounts on other systems, or for many other purposes. Web services are being used more and more to provide essential functionality for users, and applications using SOAP can provide a more integrated and featureful user experience.
The libsoup library contains an HTTP implementation and a set of API for constructing and consuming SOAP messages. It also allows for secure authentication, so you can use web services to access private accounts over a secure connection. Using libsoup makes it easy to use web services without manually parsing and interpreting the messages sent through SOAP.
The libsoup library provides an implementation of the Simple Object Access Protocol (SOAP), as well as an HTTP implementation. SOAP can be used to build web services into applications. The libsoup library is discussed in