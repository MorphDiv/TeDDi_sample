# language_name_wals:	English
# language_name_glotto:	English
# iso639_3:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

translator-credits
external ref='figures/anjuta_logo.png' md5='82636133d39ac4a688facd76954b8b29'
Help for Anjuta DevStudio.
Anjuta
Anjuta DevStudio
Johannes Schmid

Project Management
Coding and code navigation
Building Project
Debugging Program
User interface editor
Reference
Configure and use the integrated editor features
Autocompletion and calltips
Autocompletion
Autocompletion automatically suggests functions and other code symbols after you start typing by trying to match existing symbols with the first characters typed. It will popup a drop-down menu where you can select a match by using the
Anjuta supports autocompletion for code written in C/C++, Vala, Javascript and Python. Note that autocompletion can only work if anjuta knows about the symbols used. If you are using C/C++ libraries that are not configured using
In addition some syntax might be too complex for the integrated parser and it might not be able to detect which completion is required
Effective coding using calltips
As it is usually quite hard to remember the signature of every method or function used in a project, the editor will automatically display a small tooltip whenever you type '(' after a function name and show you the signature.
Quickly find the information you need in the API documentation
Using the API reference
Browsing the API reference
For a quick access to the API reference of libraries, anjuta features an integrated API browser. If not already done it can be activated in the preferences (
The API reference has two windows, one for searching for a specific symbol and the browser for viewing the help documents.
Jump to the API reference using shortcuts in the editor
In case you are unsure how a specific function used in existing code works, simply place the cursor on the function name and use
Configure and use automatic indentation for a consistent coding style
Auto-indentation
Configuring and using auto-indentation
Manual configuration
Automatic indentation is configured in the preferences (
The big disadvantage of manually configuring indentation is that all developers working on a project must use the same settings or it will result if different styles used in the same files. For a better solution, see the next section.
Unless explicitely changed in the preferences the indentation settings found in the Modeline of a file will be used instead of the configured settings to keep the file consistent.
Modelines
Modelines are used to help editors to automatically detect the indentation mode which should be used for a particular file. They are especially useful if many developers work on the same project and use different environments.
Anjuta supports modelines in the two formats used by
Indenting blocks of code
Normally new lines are approprietely indented automatically but you can indent existing lines or all selected code with the
Efficient ways to nagivate through source code
Code navigation using the symbol browser
Using the symbol browser
The symbol browser allows you to get an overview over the symbols used in your project. Symbols refers to variables, functions/methods and classes here and the exact definition depends on the programming language used.
The symbol browser has three tabs:



Double click on jumps to the definition of the symbol in the editor.
Navigating in the editor
In the


If you want to go back to the position in the editor where you used the shown items in the
Autoconnecting signals
Add signals to the signal editor
Create the signal handler
C
Python
Vala
Getting started with the user interface editor
Start the user-interface editor
Create a new user-interface file
Open an existing user-interface file
Add widgets
Organize widgets in containers
Common widgets and what they are used for
Add widget properties
Generating code for widgets
Introduction
In a GUI program, sometimes, some widgets are only important for generating events (eg: static buttons) while other ones are needed to get or show data to the user (eg: a text entry). In this later case, some code has to be generated so that these widgets can be accessed at runtime. With the glade plug-in,
Automatic generation
To automatically generate code for a widget, some conditions must be met: the glade plug-in must be running and the source file that will hold the code must be opened. To make sure that the glade plug-in is running, it is enough to open the
Once the glade plug-in is running and the file that will hold the code is being viewed, simply double click a widget in the glade inspector. The file being viewed will then be scanned for some marker comments (/* ANJUTA: Widgets declaration for application.ui - DO NOT REMOVE */ and /* ANJUTA: Widgets initialization for application.ui - DO NOT REMOVE */) and, if found, code will be added right after such comments. So, for this feature to work correctly, it is important not to modify such marker comments.
Autotools project backend.
Sébastien Granjoux
Philip Chimento
GNU Autotools project backend plugin
This is the most common project format on Linux. It has been designed to distribute source code packages on a wide range of Unix-like systems. If you have ever installed a program using
It is typically a bit more difficult to use as a developer. However, it is the default backend for
Autotools files give more information than a makefile, but the backend does not support all the possible tricks. If you find a project that cannot be read correctly, filing a
Edit autotools folder properties.
Edit an Autotools Folder
These properties allows you to define common properties for all targets belonging to this folder.

The flags to pass to the C compiler if a per target value is not defined.

These flags are passed to every compilation that invokes the C preprocessor. This value is ignored if these flags are defined for the target.

The flags to pass to the C++ compiler flags if a per target value is not defined.

The flags to pass to the Fortran 9x compiler if a per target value is not defined.

This defines installation directories. It is needed if you want to install files in custom directories.

The flags to pass to the Java compiler if a per target value is not defined.

The flags to pass to the scanner generator Lex or Flex if a per target value is not defined.

The flags to pass to the linker if a per target value is not defined.

The flags to pass to the Objective C compiler if a per target value is not defined.

The flags to pass to the Vala compiler if a per target value is not defined.

The flags to pass to the parser generator Bison or Yacc if a per target value is not defined.
Edit autotools project properties.
Edit Autotools Project Properties
These are the properties of the root item.

This the project backend used by the project: Autotools. Another backend can be selected by clicking on this button. It can be useful if the current backend has some troubles to parse your project files.

The name of your project. It can contains space.

This is the project version.

This is an URL allowing to send bug report, by example an email address or a link to a bug tracker. It is optional.

This is the name of distribution package, it shouldn't contain spaces. It is optional.

This is the home page of the project. It is optional.
In addition, the root item works as a folder and has all its properties. See
Edit autotools target properties.
Edit an Autotools Target
Here is a list of all target properties used in autotools project. Some of them are not available on all targets.

If checked, this target is not installed and has to be built only when running checks.
The flags to pass to the C compiler when compiling target source files. This value overrides the one eventually defined in the parent folder.
These flags are passed to every compilation that invokes the C preprocessor. This value overrides the one eventually defined in the parent folder.
The flags to pass to the C++ compiler flags when compiling target source files. This value overrides the one eventually defined in the parent folder.

If checked, this target is not installed. It can be used for utilities used to build other target or programs used only by developers.

If checked, do not add prefix to manual page and executable. Such prefix are used to provide alternative of system tools.
The flags to pass to the Fortran 9x compiler when compiling target source files. This value overrides the one eventually defined in the parent folder.

If checked, include the target in the distribution package.

It defines where the target is installed. It is not directly the directory where the files are installed but the name of one of the standard directory variable (bindir, sbindir, libdir, libexecdir, datadir, pkgdatadir, pkglibexecdir, includedir, mandir, infodir, docdir) or a custom variable defined in the folder properties.
The flags to pass to the Java compiler when compiling target source files. This value overrides the one eventually defined in the parent folder.

If checked, keep the hierarchy of the project directory when installing files.
The flags to pass to the scanner generator Lex or Flex when generating target source files. This value overrides the one eventually defined in the parent folder.

Specify additional libraries used by the target. Useful for adding non package libraries. See
The flags to pass to the linker when linking the target. This value overrides the one eventually defined in the parent folder.

Specify the section of the manual where to add man page. Valid section name are the digits ‘0’ through ‘9’, and the letters ‘l’ and ‘n’.
The flags to pass to the Objective C compiler when compiling target source files. This value overrides the one eventually defined in the parent folder.
The flags to pass to the Vala compiler when compiling target source files. This value overrides the one eventually defined in the parent folder.
The flags to pass to the parser generator Bison or Yacc when generating target source files. This value overrides the one eventually defined in the parent folder.
Autotools target type.
Autotools project type
There are different types of target available.
Shared Library (Libtool)
It represents a library shared by several programs which is linked at run time. It is the most common kind of libraries on Linux. It is called dynamic link library on Windows.
It uses the Libtool package. Its name must start with 'lib' and has the '.la' extension.
Module (Libtool)
It represents a library, often named a plugin, linked at run time explicitely by the program itself. It is used to only load the code corresponding to the used features.
It uses the Libtool package. Its name does not need the 'lib' prefix but must have the '.la' extension.
Static Library (Libtool)
It represents a library linked with the program at compile time. Only the function used are kept inside the generated executable.
It uses the Libtool package. Its name must start with 'lib' and has the '.a' extension.
Program
It represents compiled program by example from C souces files. All children represent the source files compiled to generate the program.
Python module
It represents a program written in Python.
Java module
It represents a progran written in Java.
LISP module
It represents a progran written in LISP.
Header files
This target allows you to group header files and define where they have to be installed.
Man documentation
It groups man pages needed by the project.
Info documentation
It groups info page needed by the project.
Miscellaneous Data
It groups data files which needed by the project like pictures, ui description, settings files...
Script
It represents program those are scripts. Those scripts are only installed in the specified directory. If scripts are generated additional rules are needed.
Build targets or project.
Build targets
A target is a file created from source files. Typically, it is a program or a library, but it could also be documentation if the documentation needs processing, for example.
The build command compiles all needed source files, and possibly links them with some other files, like libraries, in order to create the target. If some source files are already compiled and haven't been modified, they are not be recompiled, in order to save time. There are several ways to trigger a build.
From the
From the
From the
Click on the right mouse button to make the
From the
Click on the right mouse button to make the
Remove built files.
Clean targets
It can be useful to delete all files created by the build process. For example, if all dependencies are not taken into account and a modified file does not trigger a recompiling as it should, deleting all files will fix this. There are several ways to do this
From the
From the
Click on the right mouse button to make the
Click on the right mouse button to make the
Compile files.
Compile files
Most programming languages allow you to compile an individual source file. It reads the file, checks for errors and convert into an intermediate object file. Most errors happens in this step, so it is useful to compile a file after modifying it to check for errors. There are several ways to do it.
From the
From the
Click on the right mouse button to make the
From the
Click on the right mouse button to make the
You do not need to save your file before compiling it, it will be done automatically by
Autotools configure dialog
Autotools Configure Dialog
The

If checked, the project will be completely regenerated, else only the configure step is done.

You can have several configurations having their own options and build directory, this text box allows to name them. Typically you have already defined a Default configuration, a Debug configuration making programs easier to debug (keeping intermediate variables and code ordering) and an Optimized configuration generating faster programs but increasing build time. You can define additional custom configurations.

Select here the build directory. It can be the project directory or a subdirectory. This is particularly useful when switching between different configurations to avoid rebuilding the whole project.
With autotools, you cannot have one configuration using a different directory if you already have one configuration using the project directory. You need to remove it first.
Some autotools project cannot be built outside the project directory. You can still use different configurations but they all have to use the project directory and everything will be recompiled on each change of the configuration.

This text box list all command line arguments used by the configure step. All arguments are separated by spaces and must be quoted if they contains a space. Each configuration fills this text box with default values that you can modify.
Each autotools project supports a common list of arguments but can have specify arguments. You can have a list of all accepted arguments by running
Configure an autotools project and manage configurations.
Configure a project
Before compiling and building files, an autotools project has to be configured. This step is needed to set global options, to check that all required libraries and programs are installed on your system and to generate appropriate build scripts.
Configure the project
From the
Keep the default configuration, select a new configuration or create a new one. You can inspect and modify all configuration options. See
Click on
The configuration could fail if some libraries or programs are not installed or do not have the right version. The error message tell you what is missing.
Change the configuration
From the
If the project has not been already configured, it will be automatically configured before building any file.
Remove configuration
It is a like cleaning the project but it removes even more files. You need to re-configure your project to build it afterward.
From the
Create a distribution package.
Create a distribution package
The standard way to distribute a autotools project is as a compressed tar archive containing all source files. The user will have to decompress it, then compile and install it on his system using the command sequence
From the
Install targets or project.
Install targets
Unless your project is very simple, it needs some data files like user interface description files. These files are typically copied in standard directories and read from there. It means that you cannot run your program from the build directory. You need to install it in order to copy all these files in the final place, by example in a subdirectory of
There are several possibilities to install targets or a project.
From the
From the
Click on the right mouse button to make the
Click on the right mouse button to make the
If you install the program in a system directory, you can have to use
Autotools build plugin
This plugin is targeted at autotools projects but as they use make it is useful for other kind of projects using make.
Make command used
Here is a list of the targets used by the plugin. They are implemented in all autotools projects but you need to implement them if you use a custom makefile.

Use to compile an source file. The object file name is found by replacing the source file extension with the corresponding object extension.

Use to build all targets in a directory.

Use to install all targets in a directory.

Use to delete all file built in a directory.

Use to build a distributation package, called only in the project directory.
As make comes with default rules allowing it to compile and link a C program without needing a makefile. You can compile a C program from a single source file without a makefile nor a project.
Autotools build preferences dialog.
Autotools Build Preferences Dialog
The dialog allows you to set global options for building files.



By default

By default errors and warnings message are translated. It has two drawbacks though. In order to recognize errors and warnings the translation of

Errors and warnings during the build are displayed and highlighted in the message window. By checking this option, they are highlighted in the editor too.

Installing a program needs to copy files into system directories which are often not writable by users. If this check box is checked, you can choose to use
Used to create or edit a breakpoint
Breakpoint Dialog

This is the position of the breakpoint. For an existing breakpoint, you cannot change this. You can set a breakpoint at a certain line number, or at the beginning of a function. Use one of the following formats:




The break condition is an expression which should evaluate to a boolean value
If you leave this field blank the condition is always considered

The debugger can also skip the breakpoint a certain number of times before breaking. If the pass count is not zero, then the debugger will have to encounter the breakpoint this number of times before breaking.
The pass count has a higher priority than the condition. Only when the pass count has been reached will the debugger evaluate the condition if it is present and break the program's execution.
Managing breakpoints.
Breakpoints
Breakpoints are used to stop the execution of the program at a particular point so that the state of the program can be examined at those locations.
Listing breakpoints
From the
This view has the following columns:
Location
This is the position of the breakpoint in the source file. When the breakpoint is set by the debugger, you can get additional information such as the function containing the breakpoint.
Address
This field is filled with the address of the breakpoint when it is set by the debugger.
Type
This always displays
Condition
This is the breakpoint condition. It is empty if no condition is defined.
Pass count
When the debugger is not running, this column displays the pass count of the breakpoint, or zero if it is not defined.
When the debugger is running, if the pass count is zero, this column displays the number of times this breakpoint has been triggered. If the pass count is not zero, both numbers are displayed. The pass count is the second number.
State
This is the state of the breakpoint. It may be
Pending:
the breakpoint is not set in your program.
Permanent:
the breakpoint is set (its id number is displayed in parentheses).
Temporary:
the breakpoint is set but will be deleted if reached.
All breakpoints are kept across Anjuta sessions even if they correspond to a non-existing locations, for example in a source file of a shared library not loaded yet. In this case their states are set as pending.
Setting breakpoints
From the
Fill in the
Another solution is to use the toggle breakpoint function. If there is no breakpoint on the current line, it will add one. Otherwise, it will remove it.
From the
Editing breakpoints
You can't change the location of a breakpoint; create a new breakpoint instead. However, you can change the break condition or the pass count. To edit a breakpoint:
Select a breakpoint in the
Right click in the
Change the
Removing breakpoints
You can remove a breakpoint using the toggle breakpoint function described above. However, if you want to remove more than one breakpoint or the breakpoint is in a different file than the one you are editing, you can use the breakpoint window:
Right click in the
To remove all breakpoints:
From the
Enabling and disabling breakpoints
Sometimes you might want to disable a breakpoint temporarily instead of deleting it altogether. To disable or re-enable a breakpoint:
Click on the
You can disable all breakpoints using:
From the
Examine CPU information.
CPU
View CPU registers
From the
Registers whose values have changed since the last stop are in red. It is possible to change the value of any register by clicking in the value column and entering a new value.
View memory
From the
The first column displays memory addresses in hexadecimal, the second displays memory contents in hexadecimal and the last column shows memory contents in ASCII.
The addressing space of even a 32-bit microprocessor is very large (4 gigabytes), so it is very difficult to go to a particular address with the scrollbar. But you can click the right mouse button and select
View Disassembly
From the
The first column displays addresses in hexadecimal. In the second column, you can have a label starting at the beginning of the line and ending with a colon or a assembly-language instruction indented by 4 space characters.
The position in the disassembly window will be changed to the program counter value when the program is stopped.
Use custom debugger command.
Custom command
You can send a custom command to the debugger like this:
From the
Enter your command.
The output of the command is displayed in the message window used by the debugger.
The command is sent directly to the debugger without performing any checks. For example, if you set a breakpoint like this, it will not appear in the
Examine program Data.
Examine data
Control program execution.
Control execution
Evaluate expressions and modify variables.
Examine expressions
Inspect an expression and modify a variable
While you are debugging a program, you can find out the value of an expression or variable while the program is paused. It is also sometimes useful to change the value of a variable.
From the
If the expression is a variable name, you can change its value by clicking on the
Examine additional program information.
Miscellaneous information
The debugger can tell you various information about the program while it is running.
View shared libraries
From the
This opens a window which will list all shared libraries the program has loaded and their locations in memory. It also shows whether each library's symbol table is loaded or not.
View signals
From the
This lists all available signals with a small description and three columns to specify what to do when a signal is received:
Stop
The debugger stops the program execution when the program receives this signal.
Print
The debugger displays the received signal.
Pass
The debugger passes the signal to the program.
The context menu that is displayed when you click the right mouse button has all its items disabled because the corresponding functions are not implemented yet.
Examine local variables.
Local variables
Local variables of the current frame (the current function in which the program control is present) are displayed in the
Listing local variables
From the
All local variables are displayed in a tree view with children used to represent structure or array members.
Variable
The name of the variable.
Value
The variable value.
The type of the variable.
Changing the value of a variable
In the
Type the new value.
Attach to process dialog
Attach to Process Dialog
The

This hides command paths in the process list if checked.

This hides the command line arguments in the process list if checked.

If unchecked, the processes are displayed in a list. If checked, the processes are displayed in a tree.
Start a program with the debugger.
Debug a program
Start a program in the debugger
The current program is defined in the
From the
A program can be more difficult to debug if it is highly optimized or if debugging information is missing. Whether optimization and debugging information are enabled, is defined in the configure step. Normally, there is a Debug configuration available, that turns off optimization and includes all debugging information. Anjuta displays a warning if this configuration is not used. See
Debug an already running application
The debugger can be used on an already running application.
From the
Select a process in the
Debug a remote application
The debugger can be used to debug an application running on another computer connected through a TCP or serial connection.
From the
Select the type of the connection to the remote application,
For a TCP connection, fill in the
For a serial connection, fill in the text box below with the serial device name, for example
Click on
Stop the debugger
The debugger and the program can be stopped at any time like this:
From the
Examine the stack.
Stack
List stack frames
A stack frame is the area of the stack associated to each function call. It lists all functions and their arguments in the sequence they were called. Each stack frame is numbered starting from 0 for the current function. You can only view the stack frames while the debugger is running.
Moreover, a program can be composed of several threads. Each thread is executed independently and has its own registers, stack and local variables, but shares all global variables.
From the
The stacks are displayed in a tree view having their corresponding thread as parent and displaying the following information:
Active
This contains a yellow arrow to represent the active stack frame. By default it is frame 0, the current function. All evaluations and local variables are relative to this active frame. You can change the active stack frame to examine local variables in other functions.
Thread
This is a number corresponding to each thread.
Frame
This is the frame number starting from 0 for the current function. The first function of your program, for example
File
The name of the file containing the function corresponding to this frame.
Line
The line number of the function corresponding to this frame.
Function
The name of the function corresponding to this frame.
The address of the function corresponding to this frame.
Arguments
The function arguments.
Change the current stack frame or thread
In the
Right-click and select
Clicking on a stack frame in the same thread changes only the stack frame, allowing to see other local variables. But doing it in another thread will change both the stack frame and the thread. The register values will be different and the debugger will restart in the selected thread.
View the current function
Double-click, or right-click and select
Get a stack trace
In the
Stopping and continuing.
Stop and step
Like a video editing session, the program can be executed in slow motion with the ability to go forward, pause, stop, and so on. This is essential for tracking program behavior. You cannot go backward yet, though.
Step in
From the
Single stepping executes only one statement of the program (from the place where it has stopped) and then returns control. If the statement that is executed contains one function, the debugger tries to step inside the functions (in the sequence in which the functions are executed). Once the statement is executed and control is passed back, you can study your program's state.
If the
Step over
From the
Stepping over is similar to stepping except that it does not stop inside any function in the statement being executed.
If the
Step out
From the
Stepping out executes the current function until it returns to the calling function.
Run and continue
From the
This command restarts the program and lets it run until a breakpoint is encountered or the program exits.
Run To
From the
This restarts the program and lets it run until the line or the address (if the
Stopping the Program
From the
This interrupts the program and returns control to the debugger, allowing you to perform debugging tasks, like inspecting data or adding breakpoints.
Debugging tips and tricks.
Debugging tips
Fixing GLib/GTK+ critical errors
Sometimes it can be difficult to track down where GLib critical errors are occurring, since they do not stop the program. You can set the program to stop as soon as it gets a GLib critical error, by setting the environment variable
Open the
Click the plus sign next to
Click
Fill in
Click
Run the program with the debugger by selecting
Use the program until the critical error occurs.
When the debugger stops your program, look at the
The top function with frame number 0 is in GLib, so you have to look down in the stack. Typically the error originates from the topmost function that belongs to your program.
Monitor expressions and variables.
Watch expressions
Watch expressions, or watches for short, are expressions that the debugger evaluates and prints the result of every time the program is stopped; for example, after every
List watched expressions
From the
Like local variables, all watch expressions are displayed in a tree with children used to represent structure or array members.
The name of the variable or the expression.
The variable or expression value.
The type of the variable or of the expression result.
Update watches
Watch expressions can be updated automatically as soon as the program is stopped or on user request.
To set a watch expression to update automatically:
In the
To update a watch expression manually:
In the
To update all watch expressions manually at once:
In the
Add a watch on an expression
To add an expression to the watch list:
From the
Enter the expression to watch. Check
An expression can be evaluated and then added as a watch like this:
From the
Click on
Remove a watch
You can remove an expression from the watches list.
In the
All watches can be removed at the same time.
In the
If a watch expression corresponds to a variable, you can change its value.
In the
Enter the new value.
Directory project backend.
Directory project backend plugin
This is the simplest project backend. There is no project file. It works like a file viewer, considering all files matching typical source extensions (for example
This backend is a useful workaround if your project does not have a corresponding backend in
It is not possible to add or change anything with a project using this backend. But if you create a source file in the project directory, with the right extension, it will be added automatically.
All help topics.
Index
external ref='figures/anjuta-in-action.png' md5='a31f1c85a4a14032fcd30ab6f6d6b3c0'
Introduction to



We hope you will have a good time using
The following screenshot illustrates some of the things you will find in


Supported Emacs modelines features.
Emacs modelines
Such modeline is a comment in the first line of the file, composed by a list of variable names followed by
A typical
/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
Anjuta support only the following variables.

Set to

Number of space characters corresponding to one tabulation character.

Number of space characters used to indent C code.
Supported Vim modelines features.
Vim modelines
This modeline is a comment in the first line of the file which has to start with
A typical
/* vim: set noet ts=4 sw=4: */


Use spaces for indentation.


Use tabulation for indentation.






Makefile project backend.
Makefile project backend plugin
A makefile is probably the most common way to build software on all kinds of platforms. A makefile contains a list or rules describing which commands have to be run in order to generate a target from a list of dependencies. When building a program, the target is an object file and the dependencies are the source files. The target of one rule can be a dependency of another one, allowing several rules to be chained in order to make a final target.
It is a low-level, general tool, making it difficult to find all source files and targets of a project. So
If the project backend is not able to find all the source files, you can try to use the directory backend instead. It does not recognize any targets but should get all source files.
Changing properties, or adding or removing targets and source files are disabled with this backend, as automatically editing the makefile is not implemented. It has to be changed by hand using the text editor. When the makefile is saved, it is automatically reloaded though.
Import an existing project.
Import a Project

From the
Select
Or Select
After selecting an existing project, the

Add a folder to a project.
Add a Folder
A folder allows you to group several target allowing to set common properties for all of them. It often corresponds to a directory.
Select the group or the project where you want to add the new group in the
Or from the
Enter a new group name.
Groups names are typically restricted to letters, digits and the underscore, so it's safer to avoid other characters.
You can select another group in the bottom
When you have chosen the parent and enter the name, click on the
Add, edit or remove folders from a project.
Manage Folders
Remove folders from a project.
Remove Folder
Select the folder you want to remove in the
Confirm the removal. This will only remove the folder from the project files without removing any files or directories from your disk.
Add a custom library to a target.
Add a Custom Library
It is easier to use a packaged library, which is common on Linux, so check if it is the case
In order to use a library in C, you need to tell the compiler where the header files are, and tell the linker where to find the needed libraries. The issue is that your program will not compile on another computer if the header and the libraries are elsewhere.
Select the directory containing the program where you want to add the library in the
Or from the
If the header files are installed in a standard location (
You might have to expand the
Next, you need to add the library to a target. Select the target where you want to add the library in the
You need to set the
If the library is in not in a standard directory,
Add or remove libraries to project targets.
Manage Libraries
Remove a custom library from a target.
Remove a Custom Library
Select the target that has the library you want to remove in the
Remove the library from the
Add a set of libraries to a target.
Add packaged libraries
On Linux, most libraries are distributed with additional data stored in a
Select the program where you want to add the new library in the
Or from the
You need to select the target where you want to add the library in the
A library cannot be added directly to a target. You can add only a module displayed in the
If the library you want is not displayed in the
After creating a new module, you have to wait a few seconds while the project files are reloaded to see the new module in the list.
When you are done, click on the
Groups libraries in a module.
Add a Module
Packages cannot be added directly to a program but have to be grouped in a module.
Select a program in the
On the
You will get a list of all the packaged libraries installed on your system. You can check one or more libraries.
If the library you want does not appear here:
Perhaps it is not installed on your system. Launch the application you use to install new programs and search for the library name. The package you need often has a "dev" or "devel" suffix and should include header files and a
It could be that the library is not packaged, it is often the case for libraries not developped on Linux. See the chapter
After selecting one library, a module name will be automatically generated but you can change it. You can select an already existing module name to add a new library to it and to all targets already using it.
When you are done, click on the
Remove a set of libraries from a target.
Remove a Module
Select the library you want to remove in the
Confirm the removal. This library will be removed from the target.
Remove a library from a module.
Remove a Package
Select the package you want to remove in the
Confirm the removal. This package will be removed from the project file.
Project manager.
Project manager plugin

The project backend to use is choosen when creating or importing a new project in
Whatever the underlying backend, the graphical interface is the same but some functions might be disabled.
Project Backend Plugin
Edit project properties.
Edit a Project
Add existing files to a project.
Add Files
Select the target where you want to add the new source files in the
Or from the
You can select another target in the top
In the file chooser below, select the files you want to add. Then click on the
You can add files in sub-directories of the project. Most project formats require the files to be under the project directory. Added source files outside the project directory are automatically copied inside to fulfill this requirement.
Add or remove files from a project.
Manage Files
Remove files from a project.
Remove Files
Select the file you want to remove in the
Confirm the removal. The file will only be removed from the project, not from your disk.
You can select several files at the same time by keeping the
Add a target to a project.
Add a Target
A target groups files together and defines their use. It is used to represent a program, with all its source files as its children or only group data files those should be installed at the same place.
Select the directory where you want to add the new target in the
Or from the
You can select another directory in the bottom
Enter a target name and select the type of the target in the drop-down list below. Depending on your project backend, various types of target are possible, see at the bottom.
Target names are typically restricted to letters, digits and the underscore, so it's safer to avoid other characters.
When you have chosen the target name, type and parent, click on the
Add, edit or remove targets from a project.
Manage Targets
Remove a target from a project.
Remove a Target
Select the target you want to remove in the
Confirm the removal. The target and all its properties will be removed from the project file. All its files stay untouched on your hard disk.
Display project's content.
View a Project
A project is represented by a tree, the root item corresponds to the project while children represent programs, libraries, directories and source files. Each item can have properties allowing to set more details like project version, compiler flags or installation directories. These item are divided in several categories, depending on the backend not all are available:
Root
There is only one node of this kind. It represents the project itself. It is the place where you can set project wide properties like the project name or the project version.
Module
This is a set of packages used in autotools project. They appear as children of the root node to represent all modules defined and as children of each target using them. For more details, see
Package
This is a packaged library used in autotools project. They appear as children of each module. For more details, see
Folder
This is used to group targets allowing to set common properties. They are often implemented by sub directories. For more details, see
Target
It groups files and define how they are used. There are several kinds of targets, by example program, library or data, corresponding to different use of the child files. They often represent generated project files like compiled programs or libraries. For more details see
You can drag and drop targets at the beginning of the project tree view to create a shortcut allowing to access them more easily. By default all program targets are already put here.
Source
Each source file is represented by a item in the project view. The use of each file depends on its parent target. All children of a program target are compiled to generate it. While children of a data target are only copied to a directory when the project is installed. For more details see
Create a new project from scratch.
Create a Project
New projects are created from templates.
From the
Or from the drop-down list of the
Select the icon representing the type of the project you want to create and click on
Leave the mouse over a project icon for a second and a small pop-up message will appear showing more information about this type of project.
Depending on the selected project type, you will have to enter different information. When you are done, click on
All informations are grouped in pages, typically you will have to fill two or three pages. You can go back at any time using the button
Keep the mouse over the button or typing area for a second to get a small pop-up message with more details about the corresponding setting.
After filling out all the information pages, you will get a summary page listing the main information about your project. Nothing has been written to your disk yet at this point. Click on
Each project type corresponds to a template.
Project wizard template.
Project wizard template
A project template is composed of a bunch of files which can be processed by a powerful template processing engine called
This
Run parameters dialog
Run Parameters Dialog
The

This is the program that will be executed if you run a program with or without the debugger. The drop-down list allows you to select programs created by the current project, but you can click on the

These are the command line arguments used by your program. The drop-down list keeps an history of the last arguments used.

The working directory is the current directory when your program will be run.

You can click on the drop-down section, to display all environment variables that will be accessible by your program. By default, it includes all the current environment variables, they are displayed in light gray.
You can click on the
You can click on the
You can click on the
When a variable has not the same value as in the current environment, it is displayed in black.

This has to be checked to run the program in a terminal allowing you to provide inputs and see its outputs using the standard Unix streams. It is not necessary for programs having a graphical interface.
Start a program without the debugger.
Run a program
If
From the
The current program and several parameters can be set on the
From the
If your program needs data files, you probably have to install it at least one time before running it. See
All windows and dialogs.
Windows and dialogs
Packages cannot be added directly to a target. You need to put them into a module first and add this module to the target. See
Create a set of libraries.
Create a Module

Select the program where you want to add the new library in the
Or from the
Read the
Add a Package
Select the module where you want to add the new library in the
In the list of all packaged libraries, check the additional libraries wanted. Check that expected module name is selected in the bottom text box. Then click on the
Read the