# language_name_wals:	English
# language_name_glotto:	English
# ISO_6393:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	ada83
# source:	https://object.pouta.csc.fi/OPUS-ada83/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/ada83.php
# copyright_long:	http://opus.nlpl.eu/ada83.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	part
# comments:	NA

Ada is a programming language designed in accordance with requirements defined by the United States Department of Defense: the so-called Steelman requirements.
Overall, these requirements call for a language with considerable expressive power covering a wide application domain.
As a result, the language includes facilities offered by classical languages such as Pascal as well as facilities often found only in specialized languages.
Thus the language is a modern algorithmic language with the usual control structures, and with the ability to define types and subprograms.
It also serves the need for modularity, whereby data, types, and subprograms can be packaged.
It treats modularity in the physical sense as well, with a facility to support separate compilation.
In addition to these aspects, the language covers real-time programming, with facilities to model parallel tasks and to handle exceptions.
It also covers systems programming;
this requires precise control over the representation of data and access to system-dependent properties.
Finally, both application-level and machine-level input-output are defined.
This standard specifies the form and meaning of program units written in Ada.
Its purpose is to promote the portability of Ada programs to a variety of data processing systems.
This standard specifies:
The form of a program unit written in Ada.
The effect of translating and executing such a program unit.
The manner in which program units may be combined to form Ada programs.
The predefined program units that a conforming implementation must supply.
The permissible variations within the standard, and the manner in which they must be specified.
Those violations of the standard that a conforming implementation is required to detect, and the effect of attempting to translate or execute a program unit containing such violations.
Those violations of the standard that a conforming implementation is not required to detect.
This standard does not specify:
The means whereby a program unit written in Ada is transformed into object code executable by a processor.
The means whereby translation or execution of program units is invoked and the executing units are controlled.
The size or speed of the object code, or the relative execution speed of different language constructs.
The form or contents of any listings produced by implementations; in particular, the form or contents of error or warning messages.
The effect of executing a program unit that contains any violation that a conforming implementation is not required to detect.
The size of a program or program unit that will exceed the capacity of a particular conforming implementation.
Where this standard specifies that a program unit written in Ada has an exact effect, this effect is the operational meaning of the program unit and must be produced by all conforming implementations.
Where this standard specifies permissible variations in the effects of constituents of a program unit written in Ada, the operational meaning of the program unit as a whole is understood to be the range of possible effects that result from all these variations, and a conforming implementation is allowed to produce any of these possible effects.
Examples of permissible variations are:
The represented values of fixed or floating numeric quantities, and the results of operations upon them.
The order of execution of statements in different parallel tasks, in the absence of explicit synchronization.
A conforming implementation is one that:
Correctly translates and executes legal program units written in Ada, provided that they are not so large as to exceed the capacity of the implementation.
Rejects all program units that are so large as to exceed the capacity of the implementation.
Rejects all program units that contain errors whose detection is required by the standard.
Supplies all predefined program units required by the standard.
Contains no variations except where the standard permits.
Specifies all such permitted variations in the manner prescribed by the standard.
This reference manual contains fourteen chapters, three annexes, three appendices, and an index.
Each chapter is divided into sections that have a common structure.
Each section introduces its subject, gives any necessary syntax rules, and describes the semantics of the corresponding language constructs.
Examples and notes, and then references, may appear at the end of a section.
Examples are meant to illustrate the possible forms of the constructs described.
Notes are meant to emphasize consequences of the rules described in the section or elsewhere.
References are meant to attract the attention of readers to a term or phrase having a technical meaning defined in another section.
The standard definition of the Ada programming language consists of the fourteen chapters and the three annexes, subject to the following restriction: the material in each of the items listed below is informative, and not part of the standard definition of the Ada programming language:
Section 1.3 Design goals and sources
Section 1.4 Language summary
The examples, notes, and references given at the end of each section
Each section whose title starts with the word "Example" or "Examples"
Ada was designed with three overriding concerns: program reliability and maintenance, programming as a human activity, and efficiency.
The need for languages that promote reliability and simplify maintenance is well established.
Hence emphasis was placed on program readability over ease of writing.
For example, the rules of the language require that program variables be explicitly declared and that their type be specified.
Since the type of a variable is invariant, compilers can ensure that operations on variables are compatible with the properties intended for objects of the type.
Furthermore, error-prone notations have been avoided, and the syntax of the language avoids the use of encoded forms in favor of more English-like constructs.
Finally, the language offers support for separate compilation of program units in a way that facilitates program development and maintenance, and which provides the same degree of checking between units as within a unit.
Concern for the human programmer was also stressed during the design.
Above all, an attempt was made to keep the language as small as possible, given the ambitious nature of the application domain.
We have attempted to cover this domain with a small number of underlying concepts integrated in a consistent and systematic way.
Nevertheless we have tried to avoid the pitfalls of excessive involution, and in the constant search for simpler designs we have tried to provide language constructs that correspond intuitively to what the users will normally expect.
Like many other human activities, the development of programs is becoming ever more decentralized and distributed.
Consequently, the ability to assemble a program from independently produced software components has been a central idea in this design.
The concepts of packages, of private types, and of generic units are directly related to this idea, which has ramifications in many other aspects of the language.
No language can avoid the problem of efficiency.
Languages that require over-elaborate compilers, or that lead to the inefficient use of storage or execution time, force these inefficiencies on all machines and on all programs.
Every construct of the language was examined in the light of present implementation techniques.
Any proposed construct whose implementation was unclear or that required excessive machine resources was rejected.
None of the above design goals was considered as achievable after the fact.
The design goals drove the entire design process from the beginning.
A perpetual difficulty in language design is that one must both identify the capabilities required by the application domain and design language features that provide these capabilities.
The difficulty existed in this design, although to a lesser degree than usual because of the Steelman requirements.
These requirements often simplified the design process by allowing it to concentrate on the design of a given system providing a well defined set of capabilities, rather than on the definition of the capabilities themselves.
Another significant simplification of the design work resulted from earlier experience acquired by several successful Pascal derivatives developed with similar goals.
These are the languages Euclid, Lis, Mesa, Modula, and Sue.
Many of the key ideas and syntactic forms developed in these languages have counterparts in Ada.
Several existing languages such as Algol 68 and Simula, and also recent research languages such as Alphard and Clu, influenced this language in several respects, although to a lesser degree than did the Pascal family.
Finally, the evaluation reports received on an earlier formulation (the Green language), and on alternative proposals (the Red, Blue, and Yellow languages), the language reviews that took place at different stages of this project, and the thousands of comments received from fifteen different countries during the preliminary stages of the Ada design and during the ANSI canvass, all had a significant impact on the standard definition of the language.
An Ada program is composed of one or more program units.
These program units can be compiled separately.
Program units may be subprograms (which define executable algorithms), package units (which define collections of entities), task units (which define parallel computations), or generic units (which define parameterized forms of packages and subprograms).
Each unit normally consists of two parts: a specification, containing the information that must be visible to other units, and a body, containing the implementation details, which need not be visible to other units.
This distinction of the specification and body, and the ability to compile units separately, allows a program to be designed, written, and tested as a set of largely independent software components.
An Ada program will normally make use of a library of program units of general utility.
The language provides means whereby individual organizations can construct their own libraries.
The text of a separately compiled program unit must name the library units it requires.
Program Units
A subprogram is the basic unit for expressing an algorithm.
There are two kinds of subprograms: procedures and functions.
A procedure is the means of invoking a series of actions.
For example, it may read data, update variables, or produce some output.
It may have parameters, to provide a controlled means of passing information between the procedure and the point of call.
A function is the means of invoking the computation of a value.
It is similar to a procedure, but in addition will return a result.
A package is the basic unit for defining a collection of logically related entities.
For example, a package can be used to define a common pool of data and types, a collection of related subprograms, or a set of type declarations and associated operations.
Portions of a package can be hidden from the user, thus allowing access only to the logical properties expressed by the package specification.
A task unit is the basic unit for defining a task whose sequence of actions may be executed in parallel with those of other tasks.
Such tasks may be implemented on multicomputers, multiprocessors, or with interleaved execution on a single processor.
A task unit may define either a single executing task or a task type permitting the creation of any number of similar tasks.
Declarations and Statements
The body of a program unit generally contains two parts: a declarative part, which defines the logical entities to be used in the program unit, and a sequence of statements, which defines the execution of the program unit.
The declarative part associates names with declared entities.
For example, a name may denote a type, a constant, a variable, or an exception.
A declarative part also introduces the names and parameters of other nested subprograms, packages, task units, and generic units to be used in the program unit.
The sequence of statements describes a sequence of actions that are to be performed.
The statements are executed in succession
(unless an exit, return, or goto statement, or the raising of an exception, causes execution to continue from another place).
An assignment statement changes the value of a variable.
A procedure call invokes execution of a procedure after associating any actual parameters provided at the call with the corresponding formal parameters.
Case statements and if statements allow the selection of an enclosed sequence of statements based on the value of an expression or on the value of a condition.
The loop statement provides the basic iterative mechanism in the language.
A loop statement specifies that a sequence of statements is to be executed repeatedly as directed by an iteration scheme, or until an exit statement is encountered.
A block statement comprises a sequence of statements preceded by the declaration of local entities used by the statements.
Certain statements are only applicable to tasks.
A delay statement delays the execution of a task for a specified duration.
An entry call statement is written as a procedure call statement;
it specifies that the task issuing the call is ready for a rendezvous with another task that has this entry.
The called task is ready to accept the entry call when its execution reaches a corresponding accept statement, which specifies the actions then to be performed.
After completion of the rendezvous, both the calling task and the task having the entry may continue their execution in parallel.
One form of the select statement allows a selective wait for one of several alternative rendezvous.
Other forms of the select statement allow conditional or timed entry calls.
Execution of a program unit may encounter error situations in which normal program execution cannot continue.
For example, an arithmetic computation may exceed the maximum allowed value of a number, or an attempt may be made to access an array component by using an incorrect index value.
To deal with such error situations, the statements of a program unit can be textually followed by exception handlers that specify the actions to be taken when the error situation arises.
Exceptions can be raised explicitly by a raise statement.
Data Types
Every object in the language has a type, which characterizes a set of values and a set of applicable operations.
The main classes of types are scalar types (comprising enumeration and numeric types), composite types, access types, and private types.
An enumeration type defines an ordered set of distinct enumeration literals, for example a list of states or an alphabet of characters.
The enumeration types BOOLEAN and CHARACTER are predefined.
Numeric types provide a means of performing exact or approximate numerical computations.
Exact computations use integer types, which denote sets of consecutive integers.
Approximate computations use either fixed point types, with absolute bounds on the error, or floating point types, with relative bounds on the error.
The numeric types INTEGER, FLOAT, and DURATION are predefined.
Composite types allow definitions of structured objects with related components.
The composite types in the language provide for arrays and records.
An array is an object with indexed components of the same type.
A record is an object with named components of possibly different types.
The array type STRING is predefined.
A record may have special components called discriminants.
Alternative record structures that depend on the values of discriminants can be defined within a record type.
Access types allow the construction of linked data structures created by the evaluation of allocators.
They allow several variables of an access type to designate the same object, and components of one object to designate the same or other objects.
Both the elements in such a linked data structure and their relation to other elements can be altered during program execution.
Private types can be defined in a package that conceals structural details that are externally irrelevant.
Only the logically necessary properties (including any discriminants) are made visible to the users of such types.
The concept of a type is refined by the concept of a subtype, whereby a user can constrain the set of allowed values of a type.
Subtypes can be used to define subranges of scalar types, arrays with a limited set of index values, and records and private types with particular discriminant values.
Other Facilities
Representation clauses can be used to specify the mapping between types and features of an underlying machine.
For example, the user can specify that objects of a given type must be represented with a given number of bits, or that the components of a record are to be represented using a given storage layout.
Other features allow the controlled use of low level, nonportable, or implementation-dependent aspects, including the direct insertion of machine code.
Input-output is defined in the language by means of predefined library packages.
Facilities are provided for input-output of values of user-defined as well as of predefined types.
Standard means of representing values in display form are also provided.
Finally, the language provides a powerful means of parameterization of program units, called generic program units.
The generic parameters can be types and subprograms (as well as objects) and so allow general algorithms to be applied to all types of a given class.
The form of Ada program units is described by means of a context-free syntax together with context-dependent requirements expressed by narrative rules.
The meaning of Ada program units is described by means of narrative rules defining both the effects of each construct and the composition rules for constructs.
This narrative employs technical terms whose precise definition is given in the text
(references to the section containing the definition of a technical term appear at the end of each section that uses the term).
All other terms are in the English language and bear their natural meaning, as defined in Webster's Third New International Dictionary of the English Language.
The context-free syntax of the language is described using a simple variant of Backus-Naur-Form.
In particular,
Lower case words, some containing embedded underlines, are used to denote syntactic categories, for example:
Whenever the name of a syntactic category is used apart from the syntax rules themselves, spaces take the place of the underlines (thus: adding operator).
Boldface words are used to denote reserved words, for example:
Square brackets enclose optional items.
Thus the two following rules are equivalent.
Braces enclose a repeated item.
The item may appear zero or more times;
the repetitions occur from left to right as with an equivalent left-recursive rule.
Thus the two following rules are equivalent.
A vertical bar separates alternative items unless it occurs immediately after an opening brace, in which case it stands for itself:
If the name of any syntactic category starts with an italicized part, it is equivalent to the category name without the italicized part.
The italicized part is intended to convey some semantic information.
For example type name and task name are both equivalent to name alone.
The syntax rules describing structured constructs are presented in a form that corresponds to the recommended paragraphing.
For example, an if statement is defined as
Different lines are used for parts of a syntax rule if the corresponding parts of the construct described by the rule are intended to be on different lines.
Indentation in the rule is a recommendation for indentation of the corresponding part of the construct.
It is recommended that all indentations be by multiples of a basic step of indentation
(the number of spaces for the basic step is not defined).
The preferred places for other line breaks are after semicolons.
On the other hand, if a complete construct can fit on one line, this is also allowed in the recommended paragraphing.
The language definition classifies errors into several different categories:
Errors that must be detected at compilation time by every Ada compiler.
These errors correspond to any violation of a rule given in this reference manual, other than the violations that correspond to (b) or (c) below.
In particular, violation of any rule that uses the terms must, allowed, legal, or illegal belongs to this category.
Any program that contains such an error is not a legal Ada program;
on the other hand, the fact that a program is legal does not mean, per se, that the program is free from other forms of error.
Errors that must be detected at run time by the execution of an Ada program.
The corresponding error situations are associated with the names of the predefined exceptions.
Every Ada compiler is required to generate code that raises the corresponding exception if such an error situation arises during program execution.
If an exception is certain to be raised in every execution of a program, then compilers are allowed (although not required) to report this fact at compilation time.
Erroneous execution.
The language rules specify certain rules to be obeyed by Ada programs, although there is no requirement on Ada compilers to provide either a compilation-time or a run-time detection of the violation of such rules.
The errors of this category are indicated by the use of the word erroneous to qualify the execution of the corresponding constructs.
The effect of erroneous execution is unpredictable.
Incorrect order dependences.
Whenever the reference manual specifies that different parts of a given construct are to be executed in some order that is not defined by the language, this means that the implementation is allowed to execute these parts in any given order, following the rules that result from that given order, but not in parallel.
Furthermore, the construct is incorrect if execution of these parts in a different order would have a different effect.
Compilers are not required to provide either compilation-time or run-time detection of incorrect order dependences.
The foregoing is expressed in terms of the process that is called execution; it applies equally to the processes that are called evaluation and elaboration.
If a compiler is able to recognize at compilation time that a construct is erroneous or contains an incorrect order dependence, then the compiler is allowed to generate, in place of the code otherwise generated for the construct, code that raises the predefined exception PROGRAM_ERROR.
Similarly, compilers are allowed to generate code that checks at run time for erroneous constructs, for incorrect order dependences, or for both.
The predefined exception PROGRAM_ERROR is raised if such a check fails.
The text of a program consists of the texts of one or more compilations.
The text of a compilation is a sequence of lexical elements, each composed of characters;
the rules of composition are given in this chapter.
Pragmas, which provide certain information for the compiler, are also described in this chapter.
The only characters allowed in the text of a program are the graphic characters and format effectors.
Each graphic character corresponds to a unique code of the ISO seven-bit coded character set (ISO standard 646), and is represented (visually) by a graphical symbol.
Some graphic characters are represented by different graphical symbols in alternative national representations of the ISO character set.
The description of the language definition in this standard reference manual uses the ASCII graphical symbols, the ANSI graphical representation of the ISO character set.
The basic character set is sufficient for writing any program.
The characters included in each of the categories of basic graphic characters are defined as follows: upper case letters, digits, special characters, the space character.
Format effectors are the ISO (and ASCII) characters called horizontal tabulation, vertical tabulation, carriage return, line feed, and form feed.
The characters included in each of the remaining categories of graphic characters are defined as follows: lower case letters, other special characters.
Allowable replacements for the special characters vertical bar (|), sharp (#), and quotation (") are defined in section 2.10.
The ISO character that corresponds to the sharp graphical symbol in the ASCII representation appears as a pound sterling symbol in the French, German, and United Kingdom standard national representations.
In any case, the font design of graphical symbols (for example, whether they are in italic or bold typeface) is not part of the ISO standard.
The meanings of the acronyms used in this section are as follows: ANSI stands for American National Standards Institute, ASCII stands for American Standard Code for Information Interchange, and ISO stands for International Organization for Standardization.
The following names are used when referring to special characters and other special characters:
The text of a program consists of the texts of one or more compilations.
The text of each compilation is a sequence of separate lexical elements.
Each lexical element is either a delimiter, an identifier (which may be a reserved word), a numeric literal, a character literal, a string literal, or a comment.
The effect of a program depends only on the particular sequences of lexical elements that form its compilations, excluding the comments, if any.
In some cases an explicit separator is required to separate adjacent lexical elements
(namely, when without separation, interpretation as a single lexical element is possible).
A separator is any of a space character, a format effector, or the end of a line.
A space character is a separator except within a comment, a string literal, or a space character literal.
Format effectors other than horizontal tabulation are always separators.
Horizontal tabulation is a separator except within a comment.
The end of a line is always a separator.
The language does not define what causes the end of a line.
However if, for a given implementation, the end of a line is signified by one or more characters, then these characters must be format effectors other than horizontal tabulation.
In any case, a sequence of one or more format effectors other than horizontal tabulation must cause at least one end of line.
One or more separators are allowed between any two adjacent lexical elements, before the first of each compilation, or after the last.
At least one separator is required between an identifier or a numeric literal and an adjacent identifier or numeric literal.
A delimiter is either one of the following special characters (in the basic character set)
or one of the following compound delimiters each composed of two adjacent special characters
Each of the special characters listed for single character delimiters is a single delimiter except if this character is used as a character of a compound delimiter, or as a character of a comment, string literal, character literal, or numeric literal.
The remaining forms of lexical element are described in other sections of this chapter.
Each lexical element must fit on one line, since the end of a line is a separator.
The quotation, sharp, and underline characters, likewise two adjacent hyphens, are not delimiters, but may form part of other lexical elements.
The following names are used when referring to compound delimiters:
Identifiers are used as names and also as reserved words.
All characters of an identifier are significant, including any underline character inserted between a letter or digit and an adjacent letter or digit.
Identifiers differing only in the use of corresponding upper and lower case letters are considered as the same.
No space is allowed within an identifier since a space is a separator.
There are two classes of numeric literals: real literals and integer literals.
A real literal is a numeric literal that includes a point;
an integer literal is a numeric literal without a point.
Real literals are the literals of the type universal real.
Integer literals are the literals of the type universal integer.
A decimal literal is a numeric literal expressed in the conventional decimal notation (that is, the base is implicitly ten).
An underline character inserted between adjacent digits of a decimal literal does not affect the value of this numeric literal.
The letter E of the exponent, if any, can be written either in lower case or in upper case, with the same meaning.
An exponent indicates the power of ten by which the value of the decimal literal without the exponent is to be multiplied to obtain the value of the decimal literal with the exponent.
An exponent for an integer literal must not have a minus sign.
Leading zeros are allowed.
No space is allowed in a numeric literal, not even between constituents of the exponent, since a space is a separator.
A zero exponent is allowed for an integer literal.
A based literal is a numeric literal expressed in a form that specifies the base explicitly.
The base must be at least two and at most sixteen.
An underline character inserted between adjacent digits of a based literal does not affect the value of this numeric literal.
The base and the exponent, if any, are in decimal notation.
The only letters allowed as extended digits are the letters A through F for the digits ten through fifteen.
A letter in a based literal (either an extended digit or the letter E of an exponent) can be written either in lower case or in upper case, with the same meaning.
The conventional meaning of based notation is assumed;
in particular the value of each extended digit of a based literal must be less than the base.
An exponent indicates the power of the base by which the value of the based literal without the exponent is to be multiplied to obtain the value of the based literal with the exponent.
A character literal is formed by enclosing one of the 95 graphic characters (including the space) between two apostrophe characters.
A character literal has a value that belongs to a character type.
A string literal is formed by a sequence of graphic characters (possibly none) enclosed between two quotation characters used as string brackets.
A string literal has a value that is a sequence of character values corresponding to the graphic characters of the string literal apart from the quotation character itself.
If a quotation character value is to be represented in the sequence of character values, then a pair of adjacent quotation characters must be written at the corresponding place within the string literal.
(This means that a string literal that includes two adjacent quotation characters is never interpreted as two adjacent string literals.)
The length of a string literal is the number of character values in the sequence represented.
(Each doubled quotation character is counted as a single character.)
A string literal must fit on one line since it is a lexical element (see 2.2).
Longer sequences of graphic character values can be obtained by catenation of string literals.
Similarly catenation of constants declared in the package ASCII can be used to obtain sequences of character values that include nongraphic character values (the so-called control characters).
Examples of such uses of catenation are given below:
A comment starts with two adjacent hyphens and extends up to the end of the line.
A comment can appear on any line of a program.
The presence or absence of comments has no influence on whether a program is legal or illegal.
Furthermore, comments do not influence the effect of a program;
their sole purpose is the enlightenment of the human reader.
Horizontal tabulation can be used in comments, after the double hyphen, and is equivalent to one or more spaces (see 2.2).
A pragma is used to convey information to the compiler.
A pragma starts with the reserved word pragma followed by an identifier that is the name of the pragma.
Pragmas are only allowed at the following places in a program:
After a semicolon delimiter, but not within a formal part or discriminant part.
At any place where the syntax rules allow a construct defined by a syntactic category whose name ends with "declaration", "statement", "clause", or "alternative", or one of the syntactic categories variant and exception handler; but not in place of such a construct.
Also at any place where a compilation unit would be allowed.
Additional restrictions exist for the placement of specific pragmas.
Some pragmas have arguments.
Argument associations can be either positional or named as for parameter associations of subprogram calls (see 6.4).
Named associations are, however, only possible if the argument identifiers are defined.
A name given in an argument must be either a name visible at the place of the pragma or an identifier specific to the pragma.
The pragmas defined by the language are described in Annex B: they must be supported by every implementation.
In addition, an implementation may provide implementation-defined pragmas, which must then be described in Appendix F.
An implementation is not allowed to define pragmas whose presence or absence influences the legality of the text outside such pragmas.
Consequently, the legality of a program does not depend on the presence or absence of implementation-defined pragmas.
A pragma that is not language-defined has no effect if its identifier is not recognized by the (current) implementation.
Furthermore, a pragma (whether language-defined or implementation-defined) has no effect if its placement or its arguments do not correspond to what is allowed for the pragma.
The region of text over which a pragma has an effect depends on the pragma.
It is recommended (but not required) that implementations issue warnings for pragmas that are not recognized and therefore ignored.
Categories ending with "declaration" comprise: basic declaration 3.1, component declaration 3.7, entry declaration 9.5, generic parameter declaration 12.1
Categories ending with "clause" comprise: alignment clause 13.4, component clause 13.4, context clause 10.1.1, representation clause 13.1, use clause 8.4, with clause 10.1.1
Categories ending with "alternative" comprise: accept alternative 9.7.1, case statement alternative 5.4, delay alternative 9.7.1, select alternative 9.7.1, selective wait alternative 9.7.1, terminate alternative 9.7.1
The identifiers listed below are called reserved words and are reserved for special significance in the language.
For readability of this manual, the reserved words appear in lower case boldface.
A reserved word must not be used as a declared identifier.
Reserved words differing only in the use of corresponding upper and lower case letters are considered as the same (see 2.3).
In some attributes the identifier that appears after the apostrophe is identical to some reserved word.
The following replacements are allowed for the vertical bar, sharp, and quotation basic characters:
A vertical bar character (|) can be replaced by an exclamation mark (!) where used as a delimiter.
The sharp characters (#) of a based literal can be replaced by colons (:) provided that the replacement is done for both occurrences.
The quotation characters (") used as string brackets at both ends of a string literal can be replaced by percent characters (%) provided that the enclosed sequence of characters contains no quotation character, and provided that both string brackets are replaced.
Any percent character within the sequence of characters must then be doubled and each such doubled percent character is interpreted as a single percent character value.
These replacements do not change the meaning of the program.
It is recommended that use of the replacements for the vertical bar, sharp, and quotation characters be restricted to cases where the corresponding graphical symbols are not available.
Note that the vertical bar appears as a broken bar on some equipment; replacement is not recommended in this case.
The rules given for identifiers and numeric literals are such that lower case and upper case letters can be used indifferently;
these lexical elements can thus be written using only characters of the basic character set.
If a string literal of the predefined type STRING contains characters that are not in the basic character set, the same sequence of character values can be obtained by catenating string literals that contain only characters of the basic character set with suitable character constants declared in the predefined package ASCII.
Thus the string literal "AB$CD" could be replaced by "AB" & ASCII.DOLLAR & "CD".
Similarly, the string literal "ABcd" with lower case letters could be replaced by "AB" & ASCII.LC_C & ASCII.LC_D.
This chapter describes the types in the language and the rules for declaring constants, variables, and named numbers.
The language defines several kinds of entities that are declared, either explicitly or implicitly, by declarations.
Such an entity can be a numeric literal, an object, a discriminant, a record component, a loop parameter, an exception, a type, a subtype, a subprogram, a package, a task unit, a generic unit, a single entry, an entry family, a formal parameter (of a subprogram, entry, or generic subprogram), a generic formal parameter, a named block or loop, a labeled statement, or an operation (in particular, an attribute or an enumeration literal; see 3.3.3).
There are several forms of declaration.
A basic declaration is a form of declaration defined as follows.
Certain forms of declaration always occur (explicitly) as part of a basic declaration; these forms are discriminant specifications, component declarations, entry declarations, parameter specifications, generic parameter declarations, and enumeration literal specifications.
A loop parameter specification is a form of declaration that occurs only in certain forms of loop statement.
The remaining forms of declaration are implicit: the name of a block, the name of a loop, and a statement label are implicitly declared.
Certain operations are implicitly declared (see 3.3.3).
For each form of declaration the language rules define a certain region of text called the scope of the declaration (see 8.2).
Several forms of declaration associate an identifier with a declared entity.
Within its scope, and only there, there are places where it is possible to use the identifier to refer to the associated declared entity;
these places are defined by the visibility rules (see 8.3).
At such places the identifier is said to be a name of the entity (its simple name);
the name is said to denote the associated entity.
Certain forms of enumeration literal specification associate a character literal with the corresponding declared entity.
Certain forms of declaration associate an operator symbol or some other notation with an explicitly or implicitly declared operation.
The process by which a declaration achieves its effect is called the elaboration of the declaration;
this process happens during program execution.
After its elaboration, a declaration is said to be elaborated.
Prior to the completion of its elaboration (including before the elaboration), the declaration is not yet elaborated.
The elaboration of any declaration has always at least the effect of achieving this change of state (from not yet elaborated to elaborated).
The phrase "the elaboration has no other effect" is used in this manual whenever this change of state is the only effect of elaboration for some form of declaration.
An elaboration process is also defined for declarative parts, declarative items, and compilation units (see 3.9 and 10.5).
Object, number, type, and subtype declarations are described here.
The remaining basic declarations are described in later chapters.
The syntax rules use the term identifier for the first occurrence of an identifier in some form of declaration;
the term simple name is used for any occurrence of an identifier that already denotes some declared entity.
An object is an entity that contains (has) a value of a given type.
An object is one of the following:
an object declared by an object declaration or by a single task declaration,
a formal parameter of a subprogram, entry, or generic subprogram,
a generic formal object,
a loop parameter,
an object designated by a value of an access type,
a component or a slice of another object.
A number declaration is a special form of object declaration that associates an identifier with a value of type universal integer or universal real.
An object declaration is called a single object declaration if its identifier list has a single identifier;
it is called a multiple object declaration if the identifier list has two or more identifiers.
A multiple object declaration is equivalent to a sequence of the corresponding number of single object declarations.
For each identifier of the list, the equivalent sequence has a single object declaration formed by this identifier, followed by a colon and by whatever appears at the right of the colon in the multiple object declaration;
the equivalent sequence is in the same order as the identifier list.
A similar equivalence applies also for the identifier lists of number declarations, component declarations, discriminant specifications, parameter specifications, generic parameter declarations, exception declarations, and deferred constant declarations.
In the remainder of this reference manual, explanations are given for declarations with a single identifier;
the corresponding explanations for declarations with several identifiers follow from the equivalence stated above.
An object declaration declares an object whose type is given either by a subtype indication or by a constrained array definition.
If the object declaration includes the assignment compound delimiter followed by an expression, the expression specifies an initial value for the declared object;
the type of the expression must be that of the object.
The declared object is a constant if the reserved word constant appears in the object declaration;
the declaration must then include an explicit initialization.
The value of a constant cannot be modified after initialization.
Formal parameters of mode in of subprograms and entries, and generic formal parameters of mode in, are also constants;
a loop parameter is a constant within the corresponding loop;
a subcomponent or slice of a constant is a constant.
An object that is not a constant is called a variable
(in particular, the object declared by an object declaration that does not include the reserved word constant is a variable).
The only ways to change the value of a variable are either directly by an assignment, or indirectly when the variable is updated (see 6.2) by a procedure or entry call statement
(this action can be performed either on the variable itself, on a subcomponent of the variable, or on another variable that has the given variable as subcomponent).
The elaboration of an object declaration proceeds as follows:
The subtype indication or the constrained array definition is first elaborated.
This establishes the subtype of the object.
If the object declaration includes an explicit initialization, the initial value is obtained by evaluating the corresponding expression.
Otherwise any implicit initial values for the object or for its subcomponents are evaluated.
The object is created.
Any initial value (whether explicit or implicit) is assigned to the object or to the corresponding subcomponent.
Implicit initial values are defined for objects declared by object declarations, and for components of such objects, in the following cases:
If the type of an object is an access type, the implicit initial value is the null value of the access type.
If the type of an object is a task type, the implicit initial (and only) value designates a corresponding task.
If the type of an object is a type with discriminants and the subtype of the object is constrained, the implicit initial (and only) value of each discriminant is defined by the subtype of the object.
If the type of an object is a composite type, the implicit initial value of each component that has a default expression is obtained by evaluation of this expression, unless the component is a discriminant of a constrained object (the previous case).
In the case of a component that is itself a composite object and whose value is defined neither by an explicit initialization nor by a default expression, any implicit initial values for components of the composite object are defined by the same rules as for a declared object.
The steps (a) to (d) are performed in the order indicated.
For step (b), if the default expression for a discriminant is evaluated, then this evaluation is performed before that of default expressions for subcomponents that depend on discriminants, and also before that of default expressions that include the name of the discriminant.
Apart from the previous rule, the evaluation of default expressions is performed in some order that is not defined by the language.
The initialization of an object (the declared object or one of its subcomponents) checks that the initial value belongs to the subtype of the object;
for an array object declared by an object declaration, an implicit subtype conversion is first applied as for an assignment statement, unless the object is a constant whose subtype is an unconstrained array type.
The exception CONSTRAINT_ERROR is raised if this check fails.
The value of a scalar variable is undefined after elaboration of the corresponding object declaration unless an initial value is assigned to the variable by an initialization (explicitly or implicitly).
If the operand of a type conversion or qualified expression is a variable that has scalar subcomponents with undefined values, then the values of the corresponding subcomponents of the result are undefined.
The execution of a program is erroneous if it attempts to evaluate a scalar variable with an undefined value.
Similarly, the execution of a program is erroneous if it attempts to apply a predefined operator to a variable that has a scalar subcomponent with an undefined value.
Examples of variable declarations:
Examples of constant declarations:
The expression initializing a constant object need not be a static expression (see 4.9).
In the above examples, LIMIT and LOW_LIMIT are initialized with static expressions, but TOLERANCE is not if DISPERSION is a user-defined function.
A number declaration is a special form of constant declaration.
The type of the static expression given for the initialization of a number declaration must be either the type universal integer or the type universal real.
The constant declared by a number declaration is called a named number and has the type of the static expression.
The rules concerning expressions of a universal type are explained in section 4.10.
It is a consequence of these rules that if every primary contained in the expression is of the type universal integer, then the named number is also of this type.
Similarly, if every primary is of the type universal real, then the named number is also of this type.
Examples of number declarations:
A type is characterized by a set of values and a set of operations.
There exist several classes of types.
Scalar types are integer types, real types, and types defined by enumeration of their values;
values of these types have no components.
Array and record types are composite;
a value of a composite type consists of component values.
An access type is a type whose values provide access to objects.
Private types are types for which the set of possible values is well defined, but not directly available to the users of such types.
Finally, there are task types.
(Private types are described in chapter 7, task types are described in chapter 9, the other classes of types are described in this chapter.)
Certain record and private types have special components called discriminants whose values distinguish alternative forms of values of one of these types.
If a private type has discriminants, they are known to users of the type.
Hence a private type is only known by its name, its discriminants if any, and by the corresponding set of operations.
The set of possible values for an object of a given type can be subjected to a condition that is called a constraint
(the case where the constraint imposes no restriction is also included);
a value is said to satisfy a constraint if it satisfies the corresponding condition.
A subtype is a type together with a constraint;
a value is said to belong to a subtype of a given type if it belongs to the type and satisfies the constraint;
the given type is called the base type of the subtype.
A type is a subtype of itself; such a subtype is said to be unconstrained: it corresponds to a condition that imposes no restriction.
The base type of a type is the type itself.
The set of operations defined for a subtype of a given type includes the operations that are defined for the type;
however the assignment operation to a variable having a given subtype only assigns values that belong to the subtype.
Additional operations, such as qualification (in a qualified expression), are implicitly defined by a subtype declaration.
Certain types have default initial values defined for objects of the type; certain other types have default expressions defined for some or all of their components.
Certain operations of types and subtypes are called attributes;
these operations are denoted by the form of name described in section 4.1.4.
The term subcomponent is used in this manual in place of the term component to indicate either a component, or a component of another component or subcomponent.
Where other subcomponents are excluded, the term component is used instead.
A given type must not have a subcomponent whose type is the given type itself.
The name of a class of types is used in this manual as a qualifier for objects and values that have a type of the class considered.
For example, the term "array object" is used for an object whose type is an array type;
similarly, the term "access value" is used for a value of an access type.
The set of values of a subtype is a subset of the values of the base type.
This subset need not be a proper subset;
it can be an empty subset.
A type declaration declares a type.
The elaboration of a full type declaration consists of the elaboration of the discriminant part, if any (except in the case of the full type declaration for an incomplete or private type declaration), and of the elaboration of the type definition.
The types created by the elaboration of distinct type definitions are distinct types.
Moreover, the elaboration of the type definition for a numeric or derived type creates both a base type and a subtype of the base type;
the same holds for a constrained array definition (one of the two forms of array type definition).
The simple name declared by a full type declaration denotes the declared type, unless the type declaration declares both a base type and a subtype of the base type, in which case the simple name denotes the subtype, and the base type is anonymous.
A type is said to be anonymous if it has no simple name.
For explanatory purposes, this reference manual sometimes refers to an anonymous type by a pseudo-name, written in italics, and uses such pseudo-names at places where the syntax normally requires an identifier.
Examples of type definitions:
Examples of type declarations:
Two type definitions always define two distinct types, even if they are textually identical.
Thus, the array type definitions given in the declarations of A and B below define distinct types.
If A and B are declared by a multiple object declaration as below, their types are nevertheless different, since the multiple object declaration is equivalent to the above two single object declarations.
Incomplete type declarations are used for the definition of recursive and mutually dependent types (see 3.8.1).
Private type declarations are used in package specifications and in generic parameter declarations (see 7.4 and 12.1).
A subtype declaration declares a subtype.
A type mark denotes a type or a subtype.
If a type mark is the name of a type, the type mark denotes this type and also the corresponding unconstrained subtype.
The base type of a type mark is, by definition, the base type of the type or subtype denoted by the type mark.
A subtype indication defines a subtype of the base type of the type mark.
If an index constraint appears after a type mark in a subtype indication, the type mark must not already impose an index constraint.
Likewise for a discriminant constraint, the type mark must not already impose a discriminant constraint.
The elaboration of a subtype declaration consists of the elaboration of the subtype indication.
The elaboration of a subtype indication creates a subtype.
If the subtype indication does not include a constraint, the subtype is the same as that denoted by the type mark.
The elaboration of a subtype indication that includes a constraint proceeds as follows:
The constraint is first elaborated.
A check is then made that the constraint is compatible with the type or subtype denoted by the type mark.
The condition imposed by a constraint is the condition obtained after elaboration of the constraint.
(The rules of constraint elaboration are such that the expressions and ranges of constraints are evaluated by the elaboration of these constraints.)
The rules defining compatibility are given for each form of constraint in the appropriate section.
These rules are such that if a constraint is compatible with a subtype, then the condition imposed by the constraint cannot contradict any condition already imposed by the subtype on its values.
The exception CONSTRAINT_ERROR is raised if any check of compatibility fails.
Examples of subtype declarations:
A subtype declaration does not define a new type.
The set of operations of a type includes the explicitly declared subprograms that have a parameter or result of the type;
such subprograms are necessarily declared after the type declaration.
The remaining operations are each implicitly declared for a given type declaration, immediately after the type definition.
These implicitly declared operations comprise the basic operations, the predefined operators (see 4.5), and enumeration literals.
In the case of a derived type declaration, the implicitly declared operations include any derived subprograms.
The operations implicitly declared for a given type declaration occur after the type declaration and before the next explicit declaration, if any.
The implicit declarations of derived subprograms occur last.
A basic operation is an operation that is inherent in one of the following:
An assignment (in assignment statements and initializations), an allocator, a membership test, or a short-circuit control form.
A selected component, an indexed component, or a slice.
A qualification (in qualified expressions), an explicit type conversion, or an implicit type conversion of a value of type universal integer or universal real to the corresponding value of another numeric type.
A numeric literal (for a universal type), the literal null (for an access type), a string literal, an aggregate, or an attribute.
For every type or subtype T, the following attribute is defined:
The base type of T.
This attribute is allowed only as the prefix of the name of another attribute: for example, T'BASE'FIRST.
Each literal is an operation whose evaluation yields the corresponding value (see 4.2).
Likewise, an aggregate is an operation whose evaluation yields a value of a composite type (see 4.3).
Some operations of a type operate on values of the type, for example, predefined operators and certain subprograms and attributes.
The evaluation of some operations of a type returns a value of the type, for example, literals and certain functions, attributes, and predefined operators.
Assignment is an operation that operates on an object and a value.
The evaluation of the operation corresponding to a selected component, an indexed component, or a slice, yields the object or value denoted by this form of name.
A derived type definition defines a new (base) type whose characteristics are derived from those of a parent type; the new type is called a derived type.
A derived type definition further defines a derived subtype, which is a subtype of the derived type.
The subtype indication that occurs after the reserved word new defines the parent subtype.
The parent type is the base type of the parent subtype.
If a constraint exists for the parent subtype, a similar constraint exists for the derived subtype;
the only difference is that for a range constraint, and likewise for a floating or fixed point constraint that includes a range constraint, the value of each bound is replaced by the corresponding value of the derived type.
The characteristics of the derived type are defined as follows:
The derived type belongs to the same class of types as the parent type.
The set of possible values for the derived type is a copy of the set of possible values for the parent type.
If the parent type is composite, then the same components exist for the derived type, and the subtype of corresponding components is the same.
For each basic operation of the parent type, there is a corresponding basic operation of the derived type.
Explicit type conversion of a value of the parent type into the corresponding value of the derived type is allowed and vice versa as explained in section 4.6.
For each enumeration literal or predefined operator of the parent type there is a corresponding operation for the derived type.
If the parent type is a task type, then for each entry of the parent type there is a corresponding entry for the derived type.
If a default expression exists for a component of an object having the parent type, then the same default expression is used for the corresponding component of an object having the derived type.
If the parent type is an access type, then the parent and the derived type share the same collection;
there is a null access value for the derived type and it is the default initial value of that type.
If an explicit representation clause exists for the parent type and if this clause appears before the derived type definition, then there is a corresponding representation clause (an implicit one) for the derived type.
Certain subprograms that are operations of the parent type are said to be derivable.
For each derivable subprogram of the parent type, there is a corresponding derived subprogram for the derived type.
Two kinds of derivable subprograms exist.
First, if the parent type is declared immediately within the visible part of a package, then a subprogram that is itself explicitly declared immediately within the visible part becomes derivable after the end of the visible part, if it is an operation of the parent type.
(The explicit declaration is by a subprogram declaration, a renaming declaration, or a generic instantiation.)
Second, if the parent type is itself a derived type, then any subprogram that has been derived by this parent type is further derivable, unless the parent type is declared in the visible part of a package and the derived subprogram is hidden by a derivable subprogram of the first kind.
Each operation of the derived type is implicitly declared at the place of the derived type declaration.
The implicit declarations of any derived subprograms occur last.
The specification of a derived subprogram is obtained implicitly by systematic replacement of the parent type by the derived type in the specification of the derivable subprogram.
Any subtype of the parent type is likewise replaced by a subtype of the derived type with a similar constraint
(as for the transformation of a constraint of the parent subtype into the corresponding constraint of the derived subtype).
Finally, any expression of the parent type is made to be the operand of a type conversion that yields a result of the derived type.
Calling a derived subprogram is equivalent to calling the corresponding subprogram of the parent type, in which each actual parameter that is of the derived type is replaced by a type conversion of this actual parameter to the parent type
(this means that a conversion to the parent type happens before the call for the modes in and in out;
a reverse conversion to the derived type happens after the call for the modes in out and out, see 6.4.1).
In addition, if the result of a called function is of the parent type, this result is converted to the derived type.
If a derived or private type is declared immediately within the visible part of a package, then, within this visible part, this type must not be used as the parent type of a derived type definition.
(For private types, see also section 7.4.1.)
For the elaboration of a derived type definition, the subtype indication is first elaborated, the derived type is then created, and finally, the derived subtype is created.
The rules of derivation of basic operations and enumeration literals imply that the notation for any literal or aggregate of the derived type is the same as for the parent type;
such literals and aggregates are said to be overloaded.
Similarly, it follows that the notation for denoting a component, a discriminant, an entry, a slice, or an attribute is the same for the derived type as for the parent type.
Hiding of a derived subprogram is allowed even within the same declarative region (see 8.3).
A derived subprogram hides a predefined operator that has the same parameter and result type profile (see 6.6).
A generic subprogram declaration is not derivable since it declares a generic unit rather than a subprogram.
On the other hand, an instantiation of a generic subprogram is a (nongeneric) subprogram, which is derivable if it satisfies the requirements for derivability of subprograms.
If the parent type is a boolean type, the predefined relational operators of the derived type deliver a result of the predefined type BOOLEAN (see 4.5.2).
If a representation clause is given for the parent type but appears after the derived type declaration, then no corresponding representation clause applies to the derived type;
hence an explicit representation clause for such a derived type is allowed.
For a derived subprogram, if a parameter belongs to the derived type, the subtype of this parameter need not have any value in common with the derived subtype.
Scalar types comprise enumeration types, integer types, and real types.
Enumeration types and integer types are called discrete types;
each value of a discrete type has a position number which is an integer value.
Integer types and real types are called numeric types.
All scalar types are ordered, that is, all relational operators are predefined for their values.
A range specifies a subset of values of a scalar type.
The range L ..
R specifies the values from L to R inclusive if the relation L <= R is true.
The values L and R are called the lower bound and upper bound of the range, respectively.
A value V is said to satisfy a range constraint if it belongs to the range;
the value V is said to belong to the range if the relations L <= V and V <= R are both TRUE.
A null range is a range for which the relation R < L is TRUE;
no value belongs to a null range.
The operators <= and < in the above definitions are the predefined operators of the scalar type.
If a range constraint is used in a subtype indication, either directly or as part of a floating or fixed point constraint, the type of the simple expressions (likewise, of the bounds of a range attribute) must be the same as the base type of the type mark of the subtype indication.
A range constraint is compatible with a subtype if each bound of the range belongs to the subtype, or if the range constraint defines a null range;
otherwise the range constraint is not compatible with the subtype.
The elaboration of a range constraint consists of the evaluation of the range.
The evaluation of a range defines its lower bound and its upper bound.
If simple expressions are given to specify the bounds, the evaluation of the range evaluates these simple expressions in some order that is not defined by the language.
Attributes
For any scalar type T or for any subtype T of a scalar type, the following attributes are defined:
Yields the lower bound of T.
The value of this attribute has the same type as T.
Yields the upper bound of T.
The value of this attribute has the same type as T.
Indexing and iteration rules use values of discrete types.
An enumeration type definition defines an enumeration type.
The identifiers and character literals listed by an enumeration type definition must be distinct.
Each enumeration literal specification is the declaration of the corresponding enumeration literal: this declaration is equivalent to the declaration of a parameterless function, the designator being the enumeration literal, and the result type being the enumeration type.
The elaboration of an enumeration type definition creates an enumeration type;
this elaboration includes that of every enumeration literal specification.
Each enumeration literal yields a different enumeration value.
The predefined order relations between enumeration values follow the order of corresponding position numbers.
The position number of the value of the first listed enumeration literal is zero;
the position number for each other enumeration literal is one more than for its predecessor in the list.
If the same identifier or character literal is specified in more than one enumeration type definition, the corresponding literals are said to be overloaded.
At any place where an overloaded enumeration literal occurs in the text of a program, the type of the enumeration literal must be determinable from the context (see 8.7).
If an enumeration literal occurs in a context that does not otherwise suffice to determine the type of the literal, then qualification by the name of the enumeration type is one way to resolve the ambiguity (see 8.7).
An enumeration type is said to be a character type if at least one of its enumeration literals is a character literal.
The predefined type CHARACTER is a character type whose values are the 128 characters of the ASCII character set.
Each of the 95 graphic characters of this character set is denoted by the corresponding character literal.
The predefined package ASCII includes the declaration of constants denoting control characters and of constants denoting graphic characters that are not in the basic character set.
A conventional character set such as EBCDIC can be declared as a character type;
the internal codes of the characters can be specified by an enumeration representation clause as explained in section 13.3.
There is a predefined enumeration type named BOOLEAN.
It contains the two literals FALSE and TRUE ordered with the relation FALSE < TRUE.
A boolean type is either the type BOOLEAN or a type that is derived, directly or indirectly, from a boolean type.
An integer type definition defines an integer type whose set of values includes at least those of the specified range.
If a range constraint is used as an integer type definition, each bound of the range must be defined by a static expression of some integer type, but the two bounds need not have the same integer type.
(Negative bounds are allowed.)
A type declaration of the form:
is, by definition, equivalent to the following declarations:
where integer type is an anonymous type, and where the predefined integer type is implicitly selected by the implementation, so as to contain the values L to R inclusive.
The integer type declaration is illegal if none of the predefined integer types satisfies this requirement, excepting universal integer.
The elaboration of the declaration of an integer type consists of the elaboration of the equivalent type and subtype declarations.
The predefined integer types include the type INTEGER.
An implementation may also have predefined types such as SHORT_INTEGER and LONG_INTEGER, which have (substantially) shorter and longer ranges, respectively, than INTEGER.
The range of each of these types must be symmetric about zero, excepting an extra negative value which may exist in some implementations.
The base type of each of these types is the type itself.
Integer literals are the literals of an anonymous predefined integer type that is called universal integer in this reference manual.
Other integer types have no literals.
However, for each integer type there exists an implicit conversion that converts a universal integer value into the corresponding value (if any) of the integer type.
The circumstances under which these implicit conversions are invoked are described in section 4.6.
The position number of an integer value is the corresponding value of the type universal integer.
The same arithmetic operators are predefined for all integer types (see 4.5).
The exception NUMERIC_ERROR is raised by the execution of an operation (in particular an implicit conversion) that cannot deliver the correct result
(that is, if the value corresponding to the mathematical result is not a value of the integer type).
However, an implementation is not required to raise the exception NUMERIC_ERROR if the operation is part of a larger expression whose result can be computed correctly, as described in section 11.6.
The name declared by an integer type declaration is a subtype name.
On the other hand, the predefined operators of an integer type deliver results whose range is defined by the parent predefined type;
such a result need not belong to the declared subtype, in which case an attempt to assign the result to a variable of the integer subtype raises the exception CONSTRAINT_ERROR.
The smallest (most negative) value supported by the predefined integer types of an implementation is the named number SYSTEM.MIN_INT and the largest (most positive) value is SYSTEM.MAX_INT (see 13.7).
The basic operations of a discrete type include the operations involved in assignment, the membership tests, and qualification;
for a boolean type they include the short-circuit control forms;
for an integer type they include the explicit conversion of values of other numeric types to the integer type, and the implicit conversion of values of the type universal integer to the type.
Finally, for every discrete type or subtype T, the basic operations include the attributes listed below.
In this presentation, T is referred to as being a subtype (the subtype T) for any property that depends on constraints imposed by T;
other properties are stated in terms of the base type of T.
The first group of attributes yield characteristics of the subtype T.
This group includes the attribute BASE (see 3.3.2), the attributes FIRST and LAST (see 3.5), the representation attribute SIZE (see 13.7.2), and the attribute WIDTH defined as follows:
Yields the maximum image length over all values of the subtype T
(the image is the sequence of characters returned by the attribute IMAGE, see below).
Yields zero for a null range.
The value of this attribute is of the type universal integer.
All attributes of the second group are functions with a single parameter.
The corresponding actual parameter is indicated below by X.
The parameter X must be a value of the base type of T.
The result type is the type universal integer.
The result is the position number of the value of the parameter.
The parameter X can be of any integer type.
The result type is the base type of T.
The result is the value whose position number is the universal integer value corresponding to X.
The exception CONSTRAINT_ERROR is raised if the universal integer value corresponding to X is not in the range T'POS(T'BASE'FIRST) ..
T'POS(T'BASE'LAST).
The parameter X must be a value of the base type of T.
The result type is the base type of T.
The result is the value whose position number is one greater than that of X.
The exception CONSTRAINT_ERROR is raised if X equals T'BASE'LAST.
The parameter X must be a value of the base type of T.
The result type is the base type of T.
The result is the value whose position number is one less than that of X.
The exception CONSTRAINT_ERROR is raised if X equals T'BASE'FIRST.
The parameter X must be a value of the base type of T.
The result type is the predefined type STRING.
The result is the image of the value of X, that is, a sequence of characters representing the value in display form.
The image of an integer value is the corresponding decimal literal; without underlines, leading zeros, exponent, or trailing spaces; but with a single leading character that is either a minus sign or a space.
The lower bound of the image is one.
The image of an enumeration value is either the corresponding identifier in upper case or the corresponding character literal (including the two apostrophes);
neither leading nor trailing spaces are included.
The image of a character C, other than a graphic character, is implementation-defined;
the only requirement is that the image must be such that C equals CHARACTER'VALUE(CHARACTER'IMAGE(C)).
The parameter X must be a value of the predefined type STRING.
The result type is the base type of T.
Any leading and any trailing spaces of the sequence of characters that corresponds to the parameter are ignored.
For an enumeration type, if the sequence of characters has the syntax of an enumeration literal and if this literal exists for the base type of T, the result is the corresponding enumeration value.
For an integer type, if the sequence of characters has the syntax of an integer literal, with an optional single leading character that is a plus or minus sign, and if there is a corresponding value in the base type of T, the result is this value.
In any other case, the exception CONSTRAINT_ERROR is raised.
In addition, the attributes A'SIZE and A'ADDRESS are defined for an object A of a discrete type (see 13.7.2).
Besides the basic operations, the operations of a discrete type include the predefined relational operators.
For enumeration types, operations include enumeration literals.
For boolean types, operations include the predefined unary logical negation operator not, and the predefined logical operators.
For integer types, operations include the predefined arithmetic operators: these are the binary and unary adding operators - and +, all multiplying operators, the unary operator abs, and the exponentiating operator.
The operations of a subtype are the corresponding operations of its base type except for the following: assignment, membership tests, qualification, explicit type conversions, and the attributes of the first group;
the effect of each of these operations depends on the subtype
(assignments, membership tests, qualifications, and conversions involve a subtype check;
attributes of the first group yield a characteristic of the subtype).
For a subtype of a discrete type, the results delivered by the attributes SUCC, PRED, VAL, and VALUE need not belong to the subtype;
similarly, the actual parameters of the attributes POS, SUCC, PRED, and IMAGE need not belong to the subtype.
The following relations are satisfied (in the absence of an exception) by these attributes:
Real types provide approximations to the real numbers, with relative bounds on errors for floating point types, and with absolute bounds for fixed point types.
A set of numbers called model numbers is associated with each real type.
Error bounds on the predefined operations are given in terms of the model numbers.
An implementation of the type must include at least these model numbers and represent them exactly.
An implementation-dependent set of numbers, called the safe numbers, is also associated with each real type.
The set of safe numbers of a real type must include at least the set of model numbers of the type.
The range of safe numbers is allowed to be larger than the range of model numbers, but error bounds on the predefined operations for safe numbers are given by the same rules as for model numbers.
Safe numbers therefore provide guaranteed error bounds for operations on an implementation-dependent range of numbers;
in contrast, the range of model numbers depends only on the real type definition and is therefore independent of the implementation.
Real literals are the literals of an anonymous predefined real type that is called universal real in this reference manual.
Other real types have no literals.
However, for each real type, there exists an implicit conversion that converts a universal real value into a value of the real type.
The conditions under which these implicit conversions are invoked are described in section 4.6.
If the universal real value is a safe number, the implicit conversion delivers the corresponding value;
if it belongs to the range of safe numbers but is not a safe number, then the converted value can be any value within the range defined by the safe numbers next above and below the universal real value.
The execution of an operation that yields a value of a real type may raise the exception NUMERIC_ERROR, as explained in section 4.5.7, if it cannot deliver a correct result
(that is, if the value corresponding to one of the possible mathematical results does not belong to the range of safe numbers);
in particular, this exception can be raised by an implicit conversion.
However, an implementation is not required to raise the exception NUMERIC_ERROR if the operation is part of a larger expression whose result can be computed correctly (see 11.6).
The elaboration of a real type definition includes the elaboration of the floating or fixed point constraint and creates a real type.
An algorithm written to rely only upon the minimum numerical properties guaranteed by the type definition for model numbers will be portable without further precautions.
For floating point types, the error bound is specified as a relative precision by giving the required minimum number of significant decimal digits.
The minimum number of significant decimal digits is specified by the value of the static simple expression of the floating accuracy definition.
This value must belong to some integer type and must be positive (nonzero);
it is denoted by D in the remainder of this section.
If the floating point constraint is used as a real type definition and includes a range constraint, then each bound of the range must be defined by a static expression of some real type, but the two bounds need not have the same real type.
For a given radix, the following canonical form is defined for any floating point model number other than zero:
In this form: sign is either +1 or -1;
mantissa is expressed in a number base given by radix;
and exponent is an integer number (possibly negative) such that the integer part of mantissa is zero and the first digit of its fractional part is not a zero.
The specified number D is the minimum number of decimal digits required after the point in the decimal mantissa
(that is, if radix is ten).
The value of D in turn determines a corresponding number B that is the minimum number of binary digits required after the point in the binary mantissa
(that is, if radix is two).
The number B associated with D is the smallest value such that the relative precision of the binary form is no less than that specified for the decimal form.
(The number B is the integer next above (D*log(10)/log(2)) + 1.)
The model numbers defined by a floating accuracy definition comprise zero and all numbers whose binary canonical form has exactly B digits after the point in the mantissa and an exponent in the range -4*B .. +4*B.
The guaranteed minimum accuracy of operations of a floating point type is defined in terms of the model numbers of the floating point constraint that forms the corresponding real type definition (see 4.5.7).
The predefined floating point types include the type FLOAT.
An implementation may also have predefined types such as SHORT_FLOAT and LONG_FLOAT, which have (substantially) less and more accuracy, respectively, than FLOAT.
The base type of each predefined floating point type is the type itself.
The model numbers of each predefined floating point type are defined in terms of the number D of decimal digits returned by the attribute DIGITS (see 3.5.8).
For each predefined floating point type (consequently also for each type derived therefrom), a set of safe numbers is defined as follows.
The safe numbers have the same number B of mantissa digits as the model numbers of the type and have an exponent in the range -E .. +E where E is implementation-defined and at least equal to the 4*B of model numbers.
(Consequently, the safe numbers include the model numbers.)
The rules defining the accuracy of operations with model and safe numbers are given in section 4.5.7.
The safe numbers of a subtype are those of its base type.
A floating point type declaration of one of the two forms
(that is, with or without the optional range constraint indicated by the square brackets):
is, by definition, equivalent to the following declarations:
where floating point type is an anonymous type, and where the predefined floating point type is implicitly selected by the implementation so that its model numbers include the model numbers defined by D;
furthermore, if a range L ..
R is supplied, then both L and R must belong to the range of safe numbers.
The floating point declaration is illegal if none of the predefined floating point types satisfies these requirements, excepting universal real.
The maximum number of digits that can be specified in a floating accuracy definition is given by the system-dependent named number SYSTEM.MAX_DIGITS (see 13.7.1).
The elaboration of a floating point type declaration consists of the elaboration of the equivalent type and subtype declarations.
If a floating point constraint follows a type mark in a subtype indication, the type mark must denote a floating point type or subtype.
The floating point constraint is compatible with the type mark only if the number D specified in the floating accuracy definition is not greater than the corresponding number D for the type or subtype denoted by the type mark.
Furthermore, if the floating point constraint includes a range constraint, the floating point constraint is compatible with the type mark only if the range constraint is, itself, compatible with the type mark.
The elaboration of such a subtype indication includes the elaboration of the range constraint, if there is one;
it creates a floating point subtype whose model numbers are defined by the corresponding floating accuracy definition.
A value of a floating point type belongs to a floating point subtype if and only if it belongs to the range defined by the subtype.
The same arithmetic operators are predefined for all floating point types (see 4.5).
A range constraint is allowed in a floating point subtype indication, either directly after the type mark, or as part of a floating point constraint.
In either case the bounds of the range must belong to the base type of the type mark (see 3.5).
The imposition of a floating point constraint on a type mark in a subtype indication cannot reduce the allowed range of values unless it includes a range constraint
(the range of model numbers that correspond to the specified number of digits can be smaller than the range of numbers of the type mark).
A value that belongs to a floating point subtype need not be a model number of the subtype.
Notes on the examples:
The implemented accuracy for COEFFICIENT is that of a predefined type having at least 10 digits of precision.
Consequently the specification of 5 digits of precision for the subtype SHORT_COEFF is allowed.
The largest model number for the type MASS is approximately 1.27E30 and hence less than the specified upper bound (1.0E35).
Consequently the declaration of this type is legal only if this upper bound is in the range of the safe numbers of a predefined floating point type having at least 7 digits of precision.
The basic operations of a floating point type include the operations involved in assignment, membership tests, qualification, the explicit conversion of values of other numeric types to the floating point type, and the implicit conversion of values of the type universal real to the type.
In addition, for every floating point type or subtype T, the basic operations include the attributes listed below.
In this presentation, T is referred to as being a subtype (the subtype T) for any property that depends on constraints imposed by T;
other properties are stated in terms of the base type of T.
The first group of attributes yield characteristics of the subtype T.
The attributes of this group are the attribute BASE (see 3.3.2), the attributes FIRST and LAST (see 3.5), the representation attribute SIZE (see 13.7.2), and the following attributes:
Yields the number of decimal digits in the decimal mantissa of model numbers of the subtype T.
(This attribute yields the number D of section 3.5.7.)
The value of this attribute is of the type universal integer.
Yields the number of binary digits in the binary mantissa of model numbers of the subtype T.
(This attribute yields the number B of section 3.5.7.)
The value of this attribute is of the type universal integer.
Yields the absolute value of the difference between the model number 1.0 and the next model number above, for the subtype T.
The value of this attribute is of the type universal real.
Yields the largest exponent value in the binary canonical form of model numbers of the subtype T.
(This attribute yields the product 4*B of section 3.5.7.)
The value of this attribute is of the type universal integer.
Yields the smallest positive (nonzero) model number of the subtype T.
The value of this attribute is of the type universal real.
Yields the largest positive model number of the subtype T.
The value of this attribute is of the type universal real.
The attributes of the second group include the following attributes which yield characteristics of the safe numbers:
Yields the largest exponent value in the binary canonical form of safe numbers of the base type of T.
(This attribute yields the number E of section 3.5.7.)
The value of this attribute is of the type universal integer.
Yields the smallest positive (nonzero) safe number of the base type of T.
The value of this attribute is of the type universal real.
Yields the largest positive safe number of the base type of T.
The value of this attribute is of the type universal real.
In addition, the attributes A'SIZE and A'ADDRESS are defined for an object A of a floating point type (see 13.7.2).
Finally, for each floating point type there are machine-dependent attributes that are not related to model numbers and safe numbers.
They correspond to the attribute designators MACHINE_RADIX, MACHINE_MANTISSA, MACHINE_EMAX, MACHINE_EMIN, MACHINE_ROUNDS, and MACHINE_OVERFLOWS (see 13.7.3).
Besides the basic operations, the operations of a floating point type include the relational operators, and the following predefined arithmetic operators: the binary and unary adding operators - and +, the multiplying operators * and /, the unary operator abs, and the exponentiating operator.
The operations of a subtype are the corresponding operations of the type except for the following: assignment, membership tests, qualification, explicit conversion, and the attributes of the first group;
the effects of these operations are redefined in terms of the subtype.
The attributes EMAX, SMALL, LARGE, and EPSILON are provided for convenience; they are all related to MANTISSA by the following formulas:
The attribute MANTISSA, giving the number of binary digits in the mantissa, is itself related to DIGITS.
The following relations hold between the characteristics of the model numbers and those of the safe numbers:
The attributes T'FIRST and T'LAST need not yield model or safe numbers.
If a certain number of digits is specified in the declaration of a type or subtype T, the attribute T'DIGITS yields this number.
For fixed point types, the error bound is specified as an absolute value, called the delta of the fixed point type.
The delta is specified by the value of the static simple expression of the fixed accuracy definition.
This value must belong to some real type and must be positive (nonzero).
If the fixed point constraint is used as a real type definition, then it must include a range constraint;
each bound of the specified range must be defined by a static expression of some real type but the two bounds need not have the same real type.
If the fixed point constraint is used in a subtype indication, the range constraint is optional.
A canonical form is defined for any fixed point model number other than zero.
In this form: sign is either +1 or -1;
mantissa is a positive (nonzero) integer;
and any model number is a multiple of a certain positive real number called small, as follows:
For the model numbers defined by a fixed point constraint, the number small is chosen as the largest power of two that is not greater than the delta of the fixed accuracy definition.
Alternatively, it is possible to specify the value of small by a length clause (see 13.2), in which case model numbers are multiples of the specified value.
The guaranteed minimum accuracy of operations of a fixed point type is defined in terms of the model numbers of the fixed point constraint that forms the corresponding real type definition (see 4.5.7).
For a fixed point constraint that includes a range constraint, the model numbers comprise zero and all multiples of small whose mantissa can be expressed using exactly B binary digits, where the value of B is chosen as the smallest integer number for which each bound of the specified range is either a model number or lies at most small distant from a model number.
For a fixed point constraint that does not include a range constraint (this is only allowed after a type mark, in a subtype indication), the model numbers are defined by the delta of the fixed accuracy definition and by the range of the subtype denoted by the type mark.
An implementation must have at least one anonymous predefined fixed point type.
The base type of each such fixed point type is the type itself.
The model numbers of each predefined fixed point type comprise zero and all numbers for which mantissa (in the canonical form) has the number of binary digits returned by the attribute MANTISSA, and for which the number small has the value returned by the attribute SMALL.
A fixed point type declaration of the form:
is, by definition, equivalent to the following declarations:
In these declarations, fixed point type is an anonymous type, and the predefined fixed point type is implicitly selected by the implementation so that its model numbers include the model numbers defined by the fixed point constraint (that is, by D, L, and R, and possibly by a length clause specifying small).
The fixed point declaration is illegal if no predefined type satisfies these requirements.
The safe numbers of a fixed point type are the model numbers of its base type.
The elaboration of a fixed point type declaration consists of the elaboration of the equivalent type and subtype declarations.
If the fixed point constraint follows a type mark in a subtype indication, the type mark must denote a fixed point type or subtype.
The fixed point constraint is compatible with the type mark only if the delta specified by the fixed accuracy definition is not smaller than the delta for the type or subtype denoted by the type mark.
Furthermore, if the fixed point constraint includes a range constraint, the fixed point constraint is compatible with the type mark only if the range constraint is, itself, compatible with the type mark.
The elaboration of such a subtype indication includes the elaboration of the range constraint, if there is one;
it creates a fixed point subtype whose model numbers are defined by the corresponding fixed point constraint and also by the length clause specifying small, if there is one.
A value of a fixed point type belongs to a fixed point subtype if and only if it belongs to the range defined by the subtype.
The same arithmetic operators are predefined for all fixed point types (see 4.5).
Multiplication and division of fixed point values deliver results of an anonymous predefined fixed point type that is called universal fixed in this reference manual;
the accuracy of this type is arbitrarily fine.
The values of this type must be converted explicitly to some numeric type.
If S is a subtype of a fixed point type or subtype T, then the set of model numbers of S is a subset of those of T.
If a length clause has been given for T, then both S and T have the same value for small.
Otherwise, since small is a power of two, the small of S is equal to the small of T multiplied by a nonnegative power of two.
A range constraint is allowed in a fixed point subtype indication, either directly after the type mark, or as part of a fixed point constraint.
In either case the bounds of the range must belong to the base type of the type mark (see 3.5).
The basic operations of a fixed point type include the operations involved in assignment, membership tests, qualification, the explicit conversion of values of other numeric types to the fixed point type, and the implicit conversion of values of the type universal real to the type.
In addition, for every fixed point type or subtype T the basic operations include the attributes listed below.
In this presentation T is referred to as being a subtype (the subtype T) for any property that depends on constraints imposed by T;
other properties are stated in terms of the base type of T.
The first group of attributes yield characteristics of the subtype T.
The attributes of this group are the attributes BASE (see 3.3.2), the attributes FIRST and LAST (see 3.5), the representation attribute SIZE (see 13.7.2) and the following attributes:
Yields the value of the delta specified in the fixed accuracy definition for the subtype T.
The value of this attribute is of the type universal real.
Yields the number of binary digits in the mantissa of model numbers of the subtype T.
(This attribute yields the number B of section 3.5.9.)
The value of this attribute is of the type universal integer.
Yields the smallest positive (nonzero) model number of the subtype T.
The value of this attribute is of the type universal real.
Yields the largest positive model number of the subtype T.
The value of this attribute is of the type universal real.
Yields the minimum number of characters needed for the integer part of the decimal representation of any value of the subtype T, assuming that the representation does not include an exponent, but includes a one-character prefix that is either a minus sign or a space.
(This minimum number does not include superfluous zeros or underlines, and is at least two.)
The value of this attribute is of the type universal integer.
Yields the number of decimal digits needed after the point to accommodate the precision of the subtype T, unless the delta of the subtype T is greater than 0.1, in which case the attribute yields the value one.
(T'AFT is the smallest positive integer N for which (10**N)*T'DELTA is greater than or equal to one.)
The value of this attribute is of the type universal integer.
The attributes of the second group include the following attributes which yield characteristics of the safe numbers:
Yields the smallest positive (nonzero) safe number of the base type of T.
The value of this attribute is of the type universal real.
Yields the largest positive safe number of the base type of T.
The value of this attribute is of the type universal real.
In addition, the attributes A'SIZE and A'ADDRESS are defined for an object A of a fixed point type (see 13.7.2).
Finally, for each fixed point type or subtype T, there are the machine-dependent attributes T'MACHINE_ROUNDS and T'MACHINE_OVERFLOWS (see 13.7.3).
Besides the basic operations, the operations of a fixed point type include the relational operators, and the following predefined arithmetic operators: the binary and unary adding operators - and +, the multiplying operators * and /, and the operator abs.
The operations of a subtype are the corresponding operations of the type except for the following: assignment, membership tests, qualification, explicit conversion, and the attributes of the first group;
the effects of these operations are redefined in terms of the subtype.
The value of the attribute T'FORE depends only on the range of the subtype T.
The value of the attribute T'AFT depends only on the value of T'DELTA.
The following relations exist between attributes of a fixed point type:
An array object is a composite object consisting of components that have the same subtype.
The name for a component of an array uses one or more index values belonging to specified discrete types.
The value of an array object is a composite value consisting of the values of its components.
An array object is characterized by the number of indices (the dimensionality of the array), the type and position of each index, the lower and upper bounds for each index, and the type and possible constraint of the components.
The order of the indices is significant.
A one-dimensional array has a distinct component for each possible index value.
A multidimensional array has a distinct component for each possible sequence of index values that can be formed by selecting one value for each index position (in the given order).
The possible values for a given index are all the values between the lower and upper bounds, inclusive;
this range of values is called the index range.
An unconstrained array definition defines an array type.
For each object that has the array type, the number of indices, the type and position of each index, and the subtype of the components are as in the type definition;
the values of the lower and upper bounds for each index belong to the corresponding index subtype, except for null arrays as explained in section 3.6.1.
The index subtype for a given index position is, by definition, the subtype denoted by the type mark of the corresponding index subtype definition.
The compound delimiter <> (called a box) of an index subtype definition stands for an undefined range
(different objects of the type need not have the same bounds).
The elaboration of an unconstrained array definition creates an array type; this elaboration includes that of the component subtype indication.
A constrained array definition defines both an array type and a subtype of this type:
The array type is an implicitly declared anonymous type; this type is defined by an (implicit) unconstrained array definition, in which the component subtype indication is that of the constrained array definition, and in which the type mark of each index subtype definition denotes the subtype defined by the corresponding discrete range.
The array subtype is the subtype obtained by imposition of the index constraint on the array type.
If a constrained array definition is given for a type declaration, the simple name declared by this declaration denotes the array subtype.
The elaboration of a constrained array definition creates the corresponding array type and array subtype.
For this elaboration, the index constraint and the component subtype indication are elaborated.
The evaluation of each discrete range of the index constraint and the elaboration of the component subtype indication are performed in some order that is not defined by the language.
Examples of type declarations with unconstrained array definitions:
Examples of type declarations with constrained array definitions:
Examples of object declarations with constrained array definitions:
For a one-dimensional array, the rule given means that a type declaration with a constrained array definition such as
is equivalent (in the absence of an incorrect order dependence) to the succession of declarations
where index subtype and array type are both anonymous.
Consequently, T is the name of a subtype and all objects declared with this type mark are arrays that have the same bounds.
Similar transformations apply to multidimensional arrays.
A similar transformation applies to an object whose declaration includes a constrained array definition.
A consequence of this is that no two such objects have the same type.
An index constraint determines the range of possible values for every index of an array type, and thereby the corresponding array bounds.
For a discrete range used in a constrained array definition and defined by a range, an implicit conversion to the predefined type INTEGER is assumed if each bound is either a numeric literal, a named number, or an attribute, and the type of both bounds (prior to the implicit conversion) is the type universal integer.
Otherwise, both bounds must be of the same discrete type, other than universal integer; this type must be determinable independently of the context, but using the fact that the type must be discrete and that both bounds must have the same type.
These rules apply also to a discrete range used in an iteration rule (see 5.5) or in the declaration of a family of entries (see 9.5).
If an index constraint follows a type mark in a subtype indication, then the type or subtype denoted by the type mark must not already impose an index constraint.
The type mark must denote either an unconstrained array type or an access type whose designated type is such an array type.
In either case, the index constraint must provide a discrete range for each index of the array type and the type of each discrete range must be the same as that of the corresponding index.
An index constraint is compatible with the type denoted by the type mark if and only if the constraint defined by each discrete range is compatible with the corresponding index subtype.
If any of the discrete ranges defines a null range, any array thus constrained is a null array, having no components.
An array value satisfies an index constraint if at each index position the array value and the index constraint have the same index bounds.
(Note, however, that assignment and certain other operations on arrays involve an implicit subtype conversion.)
The bounds of each array object are determined as follows:
For a variable declared by an object declaration, the subtype indication of the corresponding object declaration must define a constrained array subtype (and, thereby, the bounds).
The same requirement exists for the subtype indication of a component declaration, if the type of the record component is an array type; and for the component subtype indication of an array type definition, if the type of the array components is itself an array type.
For a constant declared by an object declaration, the bounds of the constant are defined by the initial value if the subtype of the constant is unconstrained;
they are otherwise defined by this subtype
(in the latter case, the initial value is the result of an implicit subtype conversion).
The same rule applies to a generic formal parameter of mode in.
For an array object designated by an access value, the bounds must be defined by the allocator that creates the array object.
(The allocated object is constrained with the corresponding values of the bounds.)
For a formal parameter of a subprogram or entry, the bounds are obtained from the corresponding actual parameter.
(The formal parameter is constrained with the corresponding values of the bounds.)
For a renaming declaration and for a generic formal parameter of mode in out, the bounds are those of the renamed object or of the corresponding generic actual parameter.
For the elaboration of an index constraint, the discrete ranges are evaluated in some order that is not defined by the language.
Examples of array declarations including an index constraint:
Example of array declaration with a constrained array subtype:
Example of record type with a component that is an array:
The elaboration of a subtype indication consisting of a type mark followed by an index constraint checks the compatibility of the index constraint with the type mark (see 3.3.2).
All components of an array have the same subtype.
In particular, for an array of components that are one-dimensional arrays, this means that all components have the same bounds and hence the same length.
The basic operations of an array type include the operations involved in assignment and aggregates (unless the array type is limited), membership tests, indexed components, qualification, and explicit conversion;
for one-dimensional arrays the basic operations also include the operations involved in slices, and also string literals if the component type is a character type.
If A is an array object, an array value, or a constrained array subtype, the basic operations also include the attributes listed below.
These attributes are not allowed for an unconstrained array type.
The argument N used in the attribute designators for the N-th dimension of an array must be a static expression of type universal integer.
The value of N must be positive (nonzero) and no greater than the dimensionality of the array.
Yields the lower bound of the first index range.
The value of this attribute has the same type as this lower bound.
Yields the lower bound of the N-th index range.
The value of this attribute has the same type as this lower bound.
Yields the upper bound of the first index range.
The value of this attribute has the same type as this upper bound.
Yields the upper bound of the N-th index range.
The value of this attribute has the same type as this upper bound.
Yields the first index range, that is, the range A'FIRST ..
A'LAST.
Yields the N-th index range, that is, the range A'FIRST(N) ..
A'LAST(N).
Yields the number of values of the first index range (zero for a null range).
The value of this attribute is of the type universal integer.
Yields the number of values of the N-th index range (zero for a null range).
The value of this attribute is of the type universal integer.
In addition, the attribute T'BASE is defined for an array type or subtype T (see 3.3.3); the attribute T'SIZE is defined for an array type or subtype T, and the attributes A'SIZE and A'ADDRESS are defined for an array object A (see 13.7.2).
Besides the basic operations, the operations of an array type include the predefined comparison for equality and inequality, unless the array type is limited.
For one-dimensional arrays, the operations include catenation, unless the array type is limited;
if the component type is a discrete type, the operations also include all predefined relational operators;
if the component type is a boolean type, then the operations also include the unary logical negation operator not, and the logical operators.
Examples (using arrays declared in the examples of section 3.6.1):
The attributes A'FIRST and A'FIRST(1) yield the same value.
A similar relation exists for the attributes A'LAST, A'RANGE, and A'LENGTH.
The following relations are satisfied (except for a null array) by the above attributes if the index type is an integer type:
An array type is limited if its component type is limited (see 7.4.4).
The values of the predefined type STRING are one-dimensional arrays of the predefined type CHARACTER, indexed by values of the predefined subtype POSITIVE:
String literals (see 2.6 and 4.2) are basic operations applicable to the type STRING and to any other one-dimensional array type whose component type is a character type.
The catenation operator is a predefined operator for the type STRING and for one-dimensional array types;
it is represented as &.
The relational operators <, <=, >, and >= are defined for values of these types, and correspond to lexicographic order (see 4.5.2).
A record object is a composite object consisting of named components.
The value of a record object is a composite value consisting of the values of its components.
Each component declaration declares a component of the record type.
Besides components declared by component declarations, the components of a record type include any components declared by discriminant specifications of the record type declaration.
The identifiers of all components of a record type must be distinct.
The use of a name that denotes a record component other than a discriminant is not allowed within the record type definition that declares the component.
A component declaration with several identifiers is equivalent to a sequence of single component declarations, as explained in section 3.2.
Each single component declaration declares a record component whose subtype is specified by the component subtype definition.
If a component declaration includes the assignment compound delimiter followed by an expression, the expression is the default expression of the record component;
the default expression must be of the type of the component.
Default expressions are not allowed for components that are of a limited type.
If a record type does not have a discriminant part, the same components are present in all values of the type.
If the component list of a record type is defined by the reserved word null and there is no discriminant part, then the record type has no components and all records of the type are null records.
The elaboration of a record type definition creates a record type;
it consists of the elaboration of any corresponding (single) component declarations, in the order in which they appear, including any component declaration in a variant part.
The elaboration of a component declaration consists of the elaboration of the component subtype definition.
For the elaboration of a component subtype definition, if the constraint does not depend on a discriminant (see 3.7.1), then the subtype indication is elaborated.
If, on the other hand, the constraint depends on a discriminant, then the elaboration consists of the evaluation of any included expression that is not a discriminant.
Examples of record type declarations:
Examples of record variables:
The default expression of a record component is implicitly evaluated by the elaboration of the declaration of a record object, in the absence of an explicit initialization (see 3.2.1).
If a component declaration has several identifiers, the expression is evaluated once for each such component of the object
(since the declaration is equivalent to a sequence of single component declarations).
Unlike the components of an array, the components of a record need not be of the same type.
A discriminant part specifies the discriminants of a type.
A discriminant of a record is a component of the record.
The type of a discriminant must be discrete.
A discriminant part is only allowed in the type declaration for a record type, in a private type declaration or an incomplete type declaration (the corresponding full declaration must then declare a record type), and in the generic parameter declaration for a formal private type.
A discriminant specification with several identifiers is equivalent to a sequence of single discriminant specifications, as explained in section 3.2.
Each single discriminant specification declares a discriminant.
If a discriminant specification includes the assignment compound delimiter followed by an expression, the expression is the default expression of the discriminant;
the default expression must be of the type of the discriminant.
Default expressions must be provided either for all or for none of the discriminants of a discriminant part.
The use of the name of a discriminant is not allowed in default expressions of a discriminant part if the specification of the discriminant is itself given in the discriminant part.
Within a record type definition the only allowed uses of the name of a discriminant of the record type are: in the default expressions for record components; in a variant part as the discriminant name; and in a component subtype definition, either as a bound in an index constraint, or to specify a discriminant value in a discriminant constraint.
A discriminant name used in these component subtype definitions must appear by itself, not as part of a larger expression.
Such component subtype definitions and such constraints are said to depend on a discriminant.
A component is said to depend on a discriminant if it is a record component declared in a variant part, or a record component whose component subtype definition depends on a discriminant, or finally, one of the subcomponents of a component that itself depends on a discriminant.
Each record value includes a value for each discriminant specified for the record type;
it also includes a value for each record component that does not depend on a discriminant.
The values of the discriminants determine which other component values are in the record value.
Direct assignment to a discriminant of an object is not allowed;
furthermore a discriminant is not allowed as an actual parameter of mode in out or out, or as a generic actual parameter of mode in out.
The only allowed way to change the value of a discriminant of a variable is to assign a (complete) value to the variable itself.
Similarly, an assignment to the variable itself is the only allowed way to change the constraint of one of its components, if the component subtype definition depends on a discriminant of the variable.
The elaboration of a discriminant part has no other effect.
A discriminant constraint is only allowed in a subtype indication, after a type mark.
This type mark must denote either a type with discriminants, or an access type whose designated type is a type with discriminants.
A discriminant constraint specifies the values of these discriminants.
Each discriminant association associates an expression with one or more discriminants.
A discriminant association is said to be named if the discriminants are specified explicitly by their names;
it is otherwise said to be positional.
For a positional association, the (single) discriminant is implicitly specified by position, in textual order.
Named associations can be given in any order, but if both positional and named associations are used in the same discriminant constraint, then positional associations must occur first, at their normal position.
Hence once a named association is used, the rest of the discriminant constraint must use only named associations.
For a named discriminant association, the discriminant names must denote discriminants of the type for which the discriminant constraint is given.
A discriminant association with more than one discriminant name is only allowed if the named discriminants are all of the same type.
Furthermore, for each discriminant association (whether named or positional), the expression and the associated discriminants must have the same type.
A discriminant constraint must provide exactly one value for each discriminant of the type.
A discriminant constraint is compatible with the type denoted by a type mark, if and only if each discriminant value belongs to the subtype of the corresponding discriminant.
In addition, for each subcomponent whose component subtype specification depends on a discriminant, the discriminant value is substituted for the discriminant in this component subtype specification and the compatibility of the resulting subtype indication is checked.
A composite value satisfies a discriminant constraint if and only if each discriminant of the composite value has the value imposed by the discriminant constraint.
The initial values of the discriminants of an object of a type with discriminants are determined as follows:
For a variable declared by an object declaration, the subtype indication of the corresponding object declaration must impose a discriminant constraint unless default expressions exist for the discriminants;
the discriminant values are defined either by the constraint or, in its absence, by the default expressions.
The same requirement exists for the subtype indication of a component declaration, if the type of the record component has discriminants; and for the component subtype indication of an array type, if the type of the array components is a type with discriminants.
For a constant declared by an object declaration, the values of the discriminants are those of the initial value if the subtype of the constant is unconstrained;
they are otherwise defined by this subtype
(in the latter case, an exception is raised if the initial value does not belong to this subtype).
The same rule applies to a generic parameter of mode in.
For an object designated by an access value, the discriminant values must be defined by the allocator that creates the object.
(The allocated object is constrained with the corresponding discriminant values.)
For a formal parameter of a subprogram or entry, the discriminants of the formal parameter are initialized with those of the corresponding actual parameter.
(The formal parameter is constrained if the corresponding actual parameter is constrained, and in any case if the mode is in or if the subtype of the formal parameter is constrained.)
For a renaming declaration and for a generic formal parameter of mode in out, the discriminants are those of the renamed object or of the corresponding generic actual parameter.
For the elaboration of a discriminant constraint, the expressions given in the discriminant associations are evaluated in some order that is not defined by the language;
the expression of a named association is evaluated once for each named discriminant.
Examples (using types declared in the previous section): 01
The above rules and the rules defining the elaboration of an object declaration (see 3.2) ensure that discriminants always have a value.
In particular, if a discriminant constraint is imposed on an object declaration, each discriminant is initialized with the value specified by the constraint.
Similarly, if the subtype of a component has a discriminant constraint, the discriminants of the component are correspondingly initialized.
A record type with a variant part specifies alternative lists of components.
Each variant defines the components for the corresponding value or values of the discriminant.
Each variant starts with a list of choices which must be of the same type as the discriminant of the variant part.
The type of the discriminant of a variant part must not be a generic formal type.
If the subtype of the discriminant is static, then each value of this subtype must be represented once and only once in the set of choices of the variant part, and no other value is allowed.
Otherwise, each value of the (base) type of the discriminant must be represented once and only once in the set of choices.
The simple expressions and discrete ranges given as choices in a variant part must be static.
A choice defined by a discrete range stands for all values in the corresponding range (none if a null range).
The choice others is only allowed for the last variant and as its only choice;
it stands for all values (possibly none) not given in the choices of previous variants.
A component simple name is not allowed as a choice of a variant
(although it is part of the syntax of choice).
A record value contains the values of the components of a given variant if and only if the discriminant value is equal to one of the values specified by the choices of the variant.
This rule applies in turn to any further variant that is, itself, included in the component list of the given variant.
If the component list of a variant is specified by null, the variant has no components.
Example of record type with a variant part:
Examples of record subtypes:
Examples of constrained record ariables:
Choices with discrete values are also used in case statements and in array aggregates.
Choices with component simple names are used in record aggregates.
The basic operations of a record type include the operations involved in assignment and aggregates (unless the type is limited), membership tests, selection of record components, qualifications, and type conversion (for derived types)
For any object A of a type with discriminants, the basic operations also include the following attribute:
Yields the value TRUE if the discriminant constraint applies to the object A, or if the object is a constant
(including a formal parameter or generic formal parameter of mode in);
yields the value FALSE otherwise.
If A is a generic formal parameter of mode in out, or if A is a formal parameter of mode in out or out and the type mark given in the corresponding parameter specification denotes an unconstrained type with discriminants, then the value of this attribute is obtained from that of the corresponding actual parameter.
The value of this attri- bute is of the predefined type BOOLEAN.
In addition, the attributes T'BASE and T'SIZE are defined for a record type or subtype T (see 3.3.3);
the attributes A'SIZE and A'ADDRESS are defined for a record object A (see 13.7.2).
Besides the basic operations, the operations of a record type include the predefined comparison for equality and inequality, unless the type is limited.
A record type is limited if the type of any of its components is limited (see 7.4.2).
An object declared by an object declaration is created by the elaboration of the object declaration and is denoted by a simple name or by some other form of name.
In contrast, there are objects that are created by the eval- uation of allocators (see 4.8) and that have no simple name.
Access to such an object is achieved by an access value returned by an allocator;
the access value is said to designate the object.
For each access type, there is a literal null which has a null access value designating no object at all.
The null value of an access type is the default initial value of the type.
Other values of an access type are obtained by evaluation of a special operation of the type called an allocator.
Each such access value designates an object of the subtype defined by the subtype indication of the access type definition;
this subtype is called the designated subtype;
the base type of this subtype is called the designated type.
The objects designated by the values of an access type form a collection implicitly associated with the type.
The elaboration of an access type definition consists of the elaboration of the subtype indication and creates an access type.
If an access object is constant, the constrained access value cannot be changed and always designates the same object.
On the other hand, the value of the designated object need not remain the same
(assignment to the designated object is allowed unless the designated type is limited).
The only forms of contraint that are allowed after the name of an access type in a subtype indication are index constraints and discriminant constraints.
(See sections 3.6.1 and 3.7.2 for the rules applicable to these subtype indications.)
An access value belongs to a corresponding subtype of an access type either if the access value is the null value or if the value of the designated object satisfies the constraint.
An access value delivered by an allocator can be assigned to several access objects.
Hence it is possible for an object created by an allocator to be designated by more than one variable or constant of the access type.
An access value can only designate an object created by an allocator; in particular, it cannot designate an object declared by an object declaration.
If the type of the objects designated by the access values is an array type or a type with discriminants, these objects are constrained with either the array bounds or the discriminant values supplied implicitly or explicity for the corresponding allocators (see 4.8).
Access values are called pointers of references in some other languages.
There are no particular limitations on the designated type of an access type.
In particular, the type of a component of the designated type can be another access type, or even the same access type.
This permits mutually dependent and recursive access types.
Their declarations require a prior incomplete (or private) type declaration for one or more types.
For each incomplete type declaration, there must be a corresponding declaration of a type with the same identifier.
The corresponding declaration must be either a full type declaration or the declarations of a task type.
In the rest of this section, explanations are given in terms of full type declarations;
the same rules apply also to declarations of task types.
If the incomplete type declaration occurs immediately within either a declarative part or the visible part of a package specification, then the full type declaration must occur later and immediately within this declarative part or visible part.
If the incomplete type declaration occurs immediately within private part of a package, then the full type declaration must occur later and immediately within either the private part itself, or the declarative part of the corresponding package body.
A discriminant part must be given in the full type declaration if and only if one is given in the incomplete type declaration;
if discriminant parts are given, then they must conform (see 6.3.1 for the conformance rules).
Prior to the end of the full type declaration, the only allowed use of a name that denotes a type declared by an incomplete type declaration is as the type mark in the subtype indication of an access type definition;
the only form of constraint allowed in this subtype indication is a discriminant constraint.
The elaboration of an incomplete type declaration creates a type.
If the incomplete type declaration has a discriminant part, this elaboration includes that of the discriminant part: in such a case, the discriminant part of the full type declaration is not elaborated.
Example of a recursive type:
Examples of mutually dependent access types:
The basic operations of an access type include the operations involved in assignment, allocators for the access type, membership tests, qualification, explicit conversion, and the literal null.
If the designated type is a type with discriminants, the basic operations include the selection of the corresponding discriminants;
if the designated type is a record type, they include the selection of the corresponding components;
if the designated type is an array type, they include the formation of indexed components and slices;
if the designated type is a task type, they include selection of entries and entry families.
Furthermore, the basic operations include the formation of a selected component with the reserved word all (see 4.1.3).
If the designated type is an array type, the basic operations include the attributes that have the attribute designators FIRST, LAST, RANGE, and LENGTH (likewise, the attribute designators of the N-th dimension).
The prefix of each of these attributes must be a value of the access type.
These attributes yield the corresponding characteristics of the designated object (see 3.6.2).
If the designated type is a task type, the basic operations include the attributes that have the attribute designators TERMINATED and CALLABLE (see 9.9).
The prefix of each of these attributes must be a value of the access type.
These attributes yield the corresponding characteristics of the designated task objects.
In addition, the attribute T'BASE (see 3.3.3) and the representation attributes T'SIZE and T'STORAGE_SIZE (see 13.7.2) are defined for an access type or subtype T;
the attributes A'SIZE and A'ADDRESS are defined for an access object A (see 13.7.2).
Besides the basic operations, the operations of an access type include the predefined comparison for equality and inequality.
A declarative part contains declarative items (possibly none).
The elaboration of a declarative part consists of the elaboration of the declarative items, if any, in the order in which they are given in the declarative part.
After its elaboration, a declarative item is said to be elaborated.
Prior to the completion of its elaboration (including before the elaboration), the declarative item is not yet elaborated.
For several forms of declarative item, the language rules (in particular scope and visibility rules) are such that it is either impossible or illegal to use an entity before the elaboration of the declarative item that declares this entity.
For example, it is not possible to use the name of a type for an object declaration if the corresponding type declaration is not yet elaborated.
In the case of bodies, the following checks are performed:
For a subprogram call, a check is made that the body of the subprogram is already elaborated.
For the activation of a task, a check is made that the body of the corresponding task unit is already elaborated.
For the instantiation of a generic unit that has a body, a check is made that this body is already elaborated.
The exception PROGRAM_ERROR is raised if any of these checks fails.
If a subprogram declaration, a package declaration, a task declaration, or a generic declaration is a declarative item of a given declarative part, then the body (if there is one) of the program unit declared by the declarative item must itself be a declarative item of this declarative part (and must appear later).
If the body is a body stub, then a separately compiled subunit containing the corresponding proper body is required for the program unit (see 10.2).
The rules applicable to the different forms of name and expression, and to their evaluation, are given in this chapter.
Names can denote declared entities, whether declared explicitly or implicitly (see 3.1).
Names can also denote objects designated by access values; subcomponents and slices of objects and values; single entries, entry families, and entries in families of entries.
Finally, names can denote attributes of any of the foregoing.
A simple name for an entity is either the identifier associated with the entity by its declaration, or another identifier associated with the entity by a renaming declaration.
Certain forms of name (indexed and selected components, slices, and attributes) include a prefix that is either a name or a function call.
If the type of a prefix is an access type, then the prefix must not be a name that denotes a formal parameter of mode out or a subcomponent thereof.
If the prefix of a name is a function call, then the name denotes a component, a slice, an attribute, an entry, or an entry family, either of the result of the function call, or (if the result is an access value) of the object designated by the result.
A prefix is said to be appropriate for a type in either of the following cases:
The type of the prefix is the type considered.
The type of the prefix is an access type whose designated type is the type considered.
The evaluation of a name determines the entity denoted by the name.
This evaluation has no other effect for a name that is a simple name, a character literal, or an operator symbol.
The evaluation of a name that has a prefix includes the evaluation of the prefix, that is, of the corresponding name or function call.
If the type of the prefix is an access type, the evaluation of the prefix includes the determination of the object designated by the corresponding access value;
the exception CONSTRAINT_ERROR is raised if the value of the prefix is a null access value, except in the case of the prefix of a representation attribute (see 13.7.2).
Examples of simple names:
An indexed component denotes either a component of an array or an entry in a family of entries.
In the case of a component of an array, the prefix must be appropriate for an array type.
The expressions specify the index values for the component; there must be one such expression for each index position of the array type.
In the case of an entry in a family of entries, the prefix must be a name that denotes an entry family of a task object, and the expression (there must be exactly one) specifies the index value for the individual entry.
Each expression must be of the type of the corresponding index.
For the evaluation of an indexed component, the prefix and the expressions are evaluated in some order that is not defined by the language.
The exception CONSTRAINT_ERROR is raised if an index value does not belong to the range of the corresponding index of the prefixing array or entry family.
Examples of indexed components:
Notes on the examples:
Distinct notations are used for components of multidimensional arrays (such as BOARD) and arrays of arrays (such as PAGE).
The components of an array of arrays are arrays and can therefore be indexed.
Thus PAGE(10)(20) denotes the 20th component of PAGE(10).
In the last example NEXT_FRAME(L) is a function call returning an access value which designates a two-dimensional array.
A slice denotes a one-dimensional array formed by a sequence of consecutive components of a one-dimensional array.
A slice of a variable is a variable; a slice of a constant is a constant; a slice of a value is a value.
The prefix of a slice must be appropriate for a one-dimensional array type.
The type of the slice is the base type of this array type.
The bounds of the discrete range define those of the slice and must be of the type of the index;
the slice is a null slice denoting a null array if the discrete range is a null range.
For the evaluation of a name that is a slice, the prefix and the discrete range are evaluated in some order that is not defined by the language.
The exception CONSTRAINT_ERROR is raised by the evaluation of a slice, other than a null slice, if any of the bounds of the discrete range does not belong to the index range of the prefixing array.
(The bounds of a null slice need not belong to the subtype of the index.)
Examples of slices:
For a one-dimensional array A, the name A(N ..
N) is a slice of one component;
its type is the base type of A.
On the other hand, A(N) is a component of the array A and has the corresponding component type.
Selected components are used to denote record components, entries, entry families, and objects designated by access values;
they are also used as expanded names as described below.
The following four forms of selected components are used to denote a discriminant, a record component, an entry, or an object designated by an access value:
A discriminant:
The selector must be a simple name denoting a discriminant of an object or value.
The prefix must be appropriate for the type of this object or value.
A component of a record:
The selector must be a simple name denoting a component of a record object or value.
The prefix must be appropriate for the type of this object or value.
For a component of a variant, a check is made that the values of the discriminants are such that the record has this component.
The exception CONSTRAINT_ERROR is raised if this check fails.
A single entry or an entry family of a task:
The selector must be a simple name denoting a single entry or an entry family of a task.
The prefix must be appropriate for the type of this task.
An object designated by an access value:
The selector must be the reserved word all.
The value of the prefix must belong to an access type.
A selected component of one of the remaining two forms is called an expanded name.
In each case the selector must be either a simple name, a character literal, or an operator symbol.
A function call is not allowed as the prefix of an expanded name.
An expanded name can denote:
An entity declared in the visible part of a package:
The prefix must denote the package.
The selector must be the simple name, character literal, or operator symbol of the entity.
An entity whose declaration occurs immediately within a named construct:
The prefix must denote a construct that is either a program unit, a block statement, a loop statement, or an accept statement.
In the case of an accept statement, the prefix must be either the simple name of the entry or entry family, or an expanded name ending with such a simple name
(that is, no index is allowed).
The selector must be the simple name, character literal, or operator symbol of an entity whose declaration occurs immediately within the construct.
This form of expanded name is only allowed within the construct itself
(including the body and any subunits, in the case of a program unit).
A name declared by a renaming declaration is not allowed as the prefix.
If the prefix is the name of a subprogram or accept statement and if there is more than one visible enclosing subprogram or accept statement of this name, the expanded name is ambiguous, independently of the selector.
If, according to the visibility rules, there is at least one possible interpretation of the prefix of a selected component as the name of an enclosing subprogram or accept statement, then the only interpretations considered are those of rule (f), as expanded names
(no interpretations of the prefix as a function call are then considered).
The evaluation of a name that is a selected component includes the evaluation of the prefix.
Examples of selected components:
Examples of expanded names:
For a record with components that are other records, the above rules imply that the simple name must be given at each level for the name of a subcomponent.
For example, the name NEXT_CAR.OWNER.BIRTH.MONTH cannot be shortened (NEXT_CAR.OWNER.MONTH is not allowed).
An attribute denotes a basic operation of an entity given by a prefix.
The applicable attribute designators depend on the prefix.
An attribute can be a basic operation delivering a value; alternatively it can be a function, a type, or a range.
The meaning of the prefix of an attribute must be determinable independently of the attribute designator and independently of the fact that it is the prefix of an attribute.
The attributes defined by the language are summarized in Annex A.
In addition, an implementation may provide implementation-defined attributes; their description must be given in Appendix F.
The attribute designator of any implementation-defined attribute must not be the same as that of any language-defined attribute.
The evaluation of a name that is an attribute consists of the evaluation of the prefix.
The attribute designators DIGITS, DELTA, and RANGE have the same identifier as a reserved word.
However, no confusion is possible since an attribute designator is always preceded by an apostrophe.
The only predefined attribute designators that have a universal expression are those for certain operations of array types (see 3.6.2).
Examples of attributes:
A literal is either a numeric literal, an enumeration literal, the literal null, or a string literal.
The evaluation of a literal yields the corresponding value.
Numeric literals are the literals of the types universal integer and universal real.
Enumeration literals include character literals and yield values of the corresponding enumeration types.
The literal null yields a null access value which designates no objects at all.
A string literal is a basic operation that combines a sequence of characters into a value of a one-dimensional array of a character type;
the bounds of this array are determined according to the rules for positional array aggregates (see 4.3.2).
For a null string literal, the upper bound is the predecessor, as given by the PRED attribute, of the lower bound.
The evaluation of a null string literal raises the exception CONSTRAINT_ERROR if the lower bound does not have a predecessor (see 3.5.5).
The type of a string literal and likewise the type of the literal null must be determinable solely from the context in which this literal appears, excluding the literal itself, but using the fact that the literal null is a value of an access type, and similarly that a string literal is a value of a one-dimensional array type whose component type is a character type.
The character literals corresponding to the graphic characters contained within a string literal must be visible at the place of the string literal
(although these characters themselves are not used to determine the type of the string literal).
An aggregate is a basic operation that combines component values into a composite value of a record or array type.
Each component association associates an expression with components (possibly none).
A component association is said to be named if the components are specified explicitly by choices; it is otherwise said to be positional.
For a positional association, the (single) component is implicitly specified by position, in the order of the corresponding component declarations for record components, in index order for array components.
Named associations can be given in any order (except for the choice others), but if both positional and named associations are used in the same aggregate, then positional associations must occur first, at their normal position.
Hence once a named association is used, the rest of the aggregate must use only named associations.
Aggregates containing a single component association must always be given in named notation.
Specific rules concerning component associations exist for record aggregates and array aggregates.
Choices in component associations have the same syntax as in variant parts (see 3.7.3).
A choice that is a component simple name is only allowed in a record aggregate.
For a component association, a choice that is a simple expression or a discrete range is only allowed in an array aggregate;
a choice that is a simple expression specifies the component at the corresponding index value;
similarly a discrete range specifies the components at the index values in the range.
The choice others is only allowed in a component association if the association appears last and has this single choice; it specifies all remaining components, if any.
Each component of the value defined by an aggregate must be represented once and only once in the aggregate.
Hence each aggregate must be complete and a given component is not allowed to be specified by more than one choice.
The type of an aggregate must be determinable solely from the context in which the aggregate appears, excluding the aggregate itself, but using the fact that this type must be composite and not limited.
The type of an aggregate in turn determines the required type for each of its components.
The above rule implies that the determination of the type of an aggregate cannot use any information from within the aggregate.
In particular, this determination cannot use the type of the expression of a component association, or the form or the type of a choice.
An aggregate can always be distinguished from an expression enclosed by parentheses: this is a consequence of the fact that named notation is required for an aggregate with a single component.
If the type of an aggregate is a record type, the component names given as choices must denote components (including discriminants) of the record type.
If the choice others is given as a choice of a record aggregate, it must represent at least one component.
A component association with the choice others or with more than one choice is only allowed if the represented components are all of the same type.
The expression of a component association must have the type of the associated record components.
The value specified for a discriminant that governs a variant part must be given by a static expression
(note that this value determines which dependent components must appear in the record value).
For the evaluation of a record aggregate, the expressions given in the component associations are evaluated in some order that is not defined by the language.
The expression of a named association is evaluated once for each associated component.
A check is made that the value of each subcomponent of the aggregate belongs to the subtype of this subcomponent.
The exception CONSTRAINT_ERROR is raised if this check fails.
Example of a record aggregate with positional associations:
Examples of record aggregates with named associations:
Example of component association with several choices:
For an aggregate with positional associations, discriminant values appear first since the discriminant part is given first in the record type declaration;
they must be in the same order as in the discriminant part.
If the type of an aggregate is a one-dimensional array type, then each choice must specify values of the index type, and the expression of each component association must be of the component type.
If the type of an aggregate is a multidimensional array type, an n-dimensional aggregate is written as a one-dimensional aggregate, in which the expression specified for each component association is itself written as an (n-1)-dimensional aggregate which is called a subaggregate;
the index subtype of the one-dimensional aggregate is given by the first index position of the array type.
The same rule is used to write a subaggregate if it is again multidimensional, using successive index positions.
A string literal is allowed in a multidimensional aggregate at the place of a one-dimensional array of a character type.
In what follows, the rules concerning array aggregates are formulated in terms of one-dimensional aggregates.
Apart from a final component association with the single choice others, the rest (if any) of the component associations of an array aggregate must be either all positional or all named.
A named association of an array aggregate is only allowed to have a choice that is not static, or likewise a choice that is a null range, if the aggregate includes a single component association and this component association has a single choice.
An others choice is static if the applicable index constraint is static.
The bounds of an array aggregate that has an others choice are determined by the applicable index constraint.
An others choice is only allowed if the aggregate appears in one of the following contexts
(which defines the applicable index constraint):
The aggregate is an actual parameter, a generic actual parameter, the result expression of a function, or the expression that follows an assignment compound delimiter.
Moreover, the subtype of the corresponding formal parameter, generic formal parameter, function result, or object is a constrained array subtype.
For an aggregate that appears in such a context and contains an association with an others choice, named associations are allowed for other associations only in the case of a (nongeneric) actual parameter or function result.
If the aggregate is a multidimensional array, this restriction also applies to each of its subaggregates.
The aggregate is the operand of a qualified expression whose type mark denotes a constrained array subtype.
The aggregate is the expression of the component association of an enclosing (array or record) aggregate.
Moreover, if this enclosing aggregate is a multidimensional array aggregate then it is itself in one of these three contexts.
The bounds of an array aggregate that does not have an others choice are determined as follows.
For an aggregate that has named associations, the bounds are determined by the smallest and largest choices given.
For a positional aggregate, the lower bound is determined by the applicable index constraint if the aggregate appears in one of the contexts (a) through (c);
otherwise, the lower bound is given by S'FIRST where S is the index subtype;
in either case, the upper bound is determined by the number of components.
The evaluation of an array aggregate that is not a subaggregate proceeds in two steps.
First, the choices of this aggregate and of its subaggregates, if any, are evaluated in some order that is not defined by the language.
Second, the expressions of the component associations of the array aggregate are evaluated in some order that is not defined by the language;
the expression of a named association is evaluated once for each associated component.
The evaluation of a subaggregate consists of this second step
(the first step is omitted since the choices have already been evaluated).
For the evaluation of an aggregate that is not a null array, a check is made that the index values defined by choices belong to the corresponding index subtypes, and also that the value of each subcomponent of the aggregate belongs to the subtype of this subcomponent.
For an n-dimensional multidimensional aggregate, a check is made that all (n-1)-dimensional subaggregates have the same bounds.
The exception CONSTRAINT_ERROR is raised if any of these checks fails.
The allowed contexts for an array aggregate including an others choice are such that the bounds of such an aggregate are always known from the context.
Examples of array aggregates with positional associations:
Examples of array aggregates with named associations:
Examples of two-dimensional array aggregates:
Examples of aggregates as initial values:
An expression is a formula that defines the computation of a value.
Each primary has a value and a type.
The only names allowed as primaries are named numbers; attributes that yield values; and names denoting objects (the value of such a primary is the value of the object) or denoting values.
Names that denote formal parameters of mode out are not allowed as primaries; names of their subcomponents are only allowed in the case of discriminants.
The type of an expression depends only on the type of its constituents and on the operators applied;
for an overloaded constituent or operator, the determination of the constituent type, or the identification of the appropriate operator, depends on the context.
For each predefined operator, the operand and result types are given in section 4.5.
Examples of primaries:
Examples of expressions:
The language defines the following six classes of operators.
The corresponding operator symbols (except /=), and only those, can be used as designators in declarations of functions for user-defined operators.
They are given in the order of increasing precedence.
The short-circuit control forms and then and or else have the same precedence as logical operators.
The membership tests in and not in have the same precedence as relational operators.
For a term, simple expression, relation, or expression, operators of higher precedence are associated with their operands before operators of lower precedence.
In this case, for a sequence of operators of the same precedence level, the operators are associated in textual order from left to right;
parentheses can be used to impose specific associations.
The operands of a factor, of a term, of a simple expression, or of a relation, and the operands of an expression that does not contain a short-circuit control form, are evaluated in some order that is not defined by the language
(but before application of the corresponding operator).
The right operand of a short-circuit control form is evaluated if and only if the left operand has a certain value (see 4.5.1).
For each form of type declaration, certain of the above operators are predefined, that is, they are implicitly declared by the type declaration.
For each such implicit operator declaration, the names of the parameters are LEFT and RIGHT for binary operators;
the single parameter is called RIGHT for unary adding operators and for the unary operators abs and not.
The effect of the predefined operators is explained in subsections 4.5.1 through 4.5.7.
The predefined operations on integer types either yield the mathematically correct result or raise the exception NUMERIC_ERROR.
A predefined operation that delivers a result of an integer type (other than universal integer) can only raise the exception NUMERIC_ERROR if the mathematical result is not a value of the type.
The predefined operations on real types yield results whose accuracy is defined in section 4.5.7.
A predefined operation that delivers a result of a real type (other than universal real) can only raise the exception NUMERIC_ERROR if the result is not within the range of the safe numbers of the type, as explained in section 4.5.7.
Examples of precedence:
The following logical operators are predefined for any boolean type and any one-dimensional array type whose components are of a boolean type;
in either case the two operands have the same type.
The operations on arrays are performed on a component-by-component basis on matching components, if any (as for equality, see 4.5.2).
The bounds of the resulting array are those of the left operand.
A check is made that for each component of the left operand there is a matching component of the right operand, and vice versa.
The exception CONSTRAINT_ERROR is raised if this check fails.
The short-circuit control forms and then and or else are defined for two operands of a boolean type and deliver a result of the same type.
The left operand of a short-circuit control form is always evaluated first.
If the left operand of an expression with the control form and then evaluates to FALSE, the right operand is not evaluated and the value of the expression is FALSE.
If the left operand of an expression with the control form or else evaluates to TRUE, the right operand is not evaluated and the value of the expression is TRUE.
If both operands are evaluated, and then delivers the same result as and, and or else delivers the same result as or.
The conventional meaning of the logical operators is given by the fol- lowing truth table:
Examples of logical operators:
Examples of short-circuit control forms:
The equality and inequality operators are predefined for any type that is not limited.
The other relational operators are the ordering operators < (less than), <= (less than or equal), > (greater than), and >= (greater than or equal).
The ordering operators are predefined for any scalar type, and for any discrete array type, that is, a one-dimensional array type whose components are of a discrete type.
The operands of each predefined relational operator have the same type.
The result type is the predefined type BOOLEAN.
The relational operators have their conventional meaning: the result is equal to TRUE if the corresponding relation is satisfied; the result is FALSE otherwise.
The inequality operator gives the complementary result to the equality operator: FALSE if equal, TRUE if not equal.
Equality for the discrete types is equality of the values.
For real operands whose values are nearly equal, the results of the predefined relational operators are given in section 4.5.7.
Two access values are equal either if they designate the same object, or if both are equal to the null value of the access type.
For two array values or two record values of the same type, the left operand is equal to the right operand if and only if for each component of the left operand there is a matching component of the right operand and vice versa;
and the values of matching components are equal, as given by the predefined equality operator for the component type.
In particular, two null arrays of the same type are always equal; two null records of the same type are always equal.
For comparing two records of the same type, matching components are those which have the same component identifier.
For comparing two one-dimensional arrays of the same type, matching components are those (if any) whose index values match in the following sense: the lower bounds of the index ranges are defined to match, and the successors of matching indices are defined to match.
For comparing two multidimensional arrays, matching components are those whose index values match in successive index positions.
If equality is explicitly defined for a limited type, it does not extend to composite types having subcomponents of the limited type
(explicit definition of equality is allowed for such composite types).
The ordering operators <, <=, >, and >= that are defined for discrete array types correspond to lexicographic order using the predefined order relation of the component type.
A null array is lexicographically less than any array having at least one component.
In the case of nonnull arrays, the left operand is lexicographically less than the right operand if the first component of the left operand is less than that of the right; otherwise the left operand is lexicographically less than the right operand only if their first components are equal and the tail of the left operand is lexicographically less than that of the right
(the tail consists of the remaining components beyond the first and can be null).
The membership tests in and not in are predefined for all types.
The result type is the predefined type BOOLEAN.
For a membership test with a range, the simple expression and the bounds of the range must be of the same scalar type;
for a membership test with a type mark, the type of the simple expression must be the base type of the type mark.
The evaluation of the membership test in yields the result TRUE if the value of the simple expression is within the given range, or if this value belongs to the subtype denoted by the given type mark;
otherwise this evaluation yields the result FALSE (for a value of a real type, see 4.5.7).
The membership test not in gives the complementary result to the membership test in.
No exception is ever raised by a predefined relational operator or by a membership test, but an exception can be raised by the evaluation of the operands.
If a record type has components that depend on discriminants, two values of this type have matching components if and only if their discriminants are equal.
Two nonnull arrays have matching components if and only if the value of the attribute LENGTH(N) for each index position N is the same for both.
The binary adding operators + and - are predefined for any numeric type and have their conventional meaning.
The catenation operators & are predefined for any one-dimensional array type that is not limited.
For real types, the accuracy of the result is determined by the operand type (see 4.5.7).
If both operands are one-dimensional arrays, the result of the catenation is a one-dimensional array whose length is the sum of the lengths of its operands, and whose components comprise the components of the left operand followed by the components of the right operand.
The lower bound of this result is the lower bound of the left operand, unless the left operand is a null array, in which case the result of the catenation is the right operand.
If either operand is of the component type of an array type, the result of the catenation is given by the above rules, using in place of this operand an array having this operand as its only component and having the lower bound of the index subtype of the array type as its lower bound.
The exception CONSTRAINT_ERROR is raised by catenation if the upper bound of the result exceeds the range of the index subtype, unless the result is a null array.
This exception is also raised if any operand is of the component type but has a value that does not belong to the component subtype.
The unary adding operators + and - are predefined for any numeric type and have their conventional meaning.
For each of these operators, the operand and the result have the same type.
The operators * and / are predefined for any integer and any floating point type and have their conventional meaning;
the operators mod and rem are predefined for any integer type.
For each of these operators, the operands and the result have the same base type.
For floating point types, the accuracy of the result is determined by the operand type (see 4.5.7).
Integer division and remainder are defined by the relation
where (A rem B) has the sign of A and an absolute value less than the absolute value of B.
Integer division satisfies the identity
The result of the modulus operation is such that (A mod B) has the sign of B and an absolute value less than the absolute value of B; in addition, for some integer value N, this result must satisfy the relation
For each fixed point type, the following multiplication and division operators, with an operand of the predefined type INTEGER, are predefined.
Integer multiplication of fixed point values is equivalent to repeated addition.
Division of a fixed point value by an integer does not involve a change in type but is approximate (see 4.5.7).
Finally, the following multiplication and division operators are declared in the predefined package STANDARD.
These two special operators apply to operands of all fixed point types
(it is a consequence of other rules that they cannot be renamed or given as generic actual parameters).
Multiplication of operands of the same or of different fixed point types is exact and delivers a result of the anonymous predefined fixed point type universal fixed whose delta is arbitrarily small.
The result of any such multiplication must always be explicitly converted to some numeric type.
This ensures explicit control of the accuracy of the computation.
The same considerations apply to division of a fixed point value by another fixed point value.
No other operators are defined for the type universal fixed.
The exception NUMERIC_ERROR is raised by integer division, rem, and mod if the right operand is zero.
For positive A and B, A/B is the quotient and A rem B is the remainder when A is divided by B.
The following relations are satisfied by the rem operator:
For any integer K, the following identity holds:
The relations between integer division, remainder, and modulus are illustrated by the following table:
The highest precedence unary operator abs is predefined for any numeric type.
The highest precedence unary operator not is predefined for any boolean type and any one-dimensional array type whose components have a boolean type.
The operator not that applies to a one-dimensional array of boolean components yields a one-dimensional boolean array with the same bounds;
each component of the result is obtained by logical negation of the corresponding component of the operand
(that is, the component that has the same index value).
The highest precedence exponentiating operator ** is predefined for each integer type and for each floating point type.
In either case the right operand, called the exponent, is of the predefined type INTEGER.
Exponentiation with a positive exponent is equivalent to repeated multiplication of the left operand by itself, as indicated by the exponent and from left to right.
For an operand of a floating point type, the exponent can be negative, in which case the value is the reciprocal of the value with the positive exponent.
Exponentiation by a zero exponent delivers the value one.
Exponentiation of a value of a floating point type is approximate (see 4.5.7).
Exponentiation of an integer raises the exception CONSTRAINT_ERROR for a negative exponent.
A real subtype specifies a set of model numbers.
Both the accuracy required from any basic or predefined operation giving a real result, and the result of any predefined relation between real operands are defined in terms of these model numbers.
A model interval of a subtype is any interval whose bounds are model numbers of the subtype.
The model interval associated with a value that belongs to a real subtype is the smallest model interval (of the subtype) that includes the value.
(The model interval associated with a model number of a subtype consists of that number only.)
For any basic operation or predefined operator that yields a result of a real subtype, the required bounds on the result are given by a model interval defined as follows:
The result model interval is the smallest model interval (of the result subtype) that includes the minimum and the maximum of all the values obtained by applying the (exact) mathematical operation, when each operand is given any value of the model interval (of the operand subtype) defined for the operand.
The model interval of an operand that is itself the result of an operation, other than an implicit conversion, is the result model interval of this operation.
The model interval of an operand whose value is obtained by implicit conversion of a universal expression is the model interval associated with this value within the operand subtype.
The result model interval is undefined if the absolute value of one of the above mathematical results exceeds the largest safe number of the result type.
Whenever the result model interval is undefined, it is highly desirable that the exception NUMERIC_ERROR be raised if the implementation cannot produce an actual result that is in the range of safe numbers.
This is, however, not required by the language rules, in recognition of the fact that certain target machines do not permit easy detection of overflow situations.
The value of the attribute MACHINE_OVERFLOWS indicates whether the target machine raises the exception NUMERIC_ERROR in overflow situations (see 13.7.3).
The safe numbers of a real type are defined (see 3.5.6) as a superset of the model numbers, for which error bounds follow the same rules as for model numbers.
Any definition given in this section in terms of model intervals can therefore be extended to safe intervals of safe numbers.
A consequence of this extension is that an implementation is not allowed to raise the exception NUMERIC_ERROR when the result interval is a safe interval.
For the result of exponentiation, the model interval defining the bounds on the result is obtained by applying the above rules to the sequence of multiplications defined by the exponent, and to the final division in the case of a negative exponent.
For the result of a relation between two real operands, consider for each operand the model interval (of the operand subtype) defined for the operand;
the result can be any value obtained by applying the mathematical comparison to values arbitrarily chosen in the corresponding operand model intervals.
If either or both of the operand model intervals is undefined (and if neither of the operand evaluations raises an exception) then the result of the comparison is allowed to be any possible value (that is, either TRUE or FALSE).
The result of a membership test is defined in terms of comparisons of the operand value with the lower and upper bounds of the given range or type mark
(the usual rules apply to these comparisons).
For a floating point type the numbers 15.0, 3.0, and 5.0 are always model numbers.
Hence X/Y where X equals 15.0 and Y equals 3.0 yields exactly 5.0 according to the above rules.
In the general case, division does not yield model numbers and in consequence one cannot assume that (1.0/X)*X = 1.0.
The evaluation of an explicit type conversion evaluates the expression given as the operand, and converts the resulting value to a specified target type.
Explicit type conversions are allowed between closely related types as defined below.
The target type of a type conversion is the base type of the type mark.
The type of the operand of a type conversion must be determinable independently of the context
(in particular, independently of the target type).
Furthermore, the operand of a type conversion is not allowed to be a literal null, an allocator, an aggregate, or a string literal;
an expression enclosed by parentheses is allowed as the operand of a type conversion only if the expression alone is allowed.
A conversion to a subtype consists of a conversion to the target type followed by a check that the result of the conversion belongs to the subtype.
A conversion of an operand of a given type to the type itself is allowed.
The other allowed explicit type conversions correspond to the following three cases:
Numeric types
The operand can be of any numeric type; the value of the operand is converted to the target type which must also be a numeric type.
For conversions involving real types, the result is within the accuracy of the specified subtype (see 4.5.7).
The conversion of a real value to an integer type rounds to the nearest integer;
if the operand is halfway between two integers (within the accuracy of the real subtype) rounding may be either up or down.
Derived types
The conversion is allowed if one of the target type and the operand type is derived from the other, directly or indirectly, or if there exists a third type from which both types are derived, directly or indirectly.
Array types
The conversion is allowed if the operand type and the target type are array types that satisfy the following conditions: both types must have the same dimensionality;
for each index position the index types must either be the same or be convertible to each other;
the component types must be the same;
finally, if the component type is a type with discriminants or an access type, the component subtypes must be either both constrained or both unconstrained.
If the type mark denotes an unconstrained array type, then, for each index position, the bounds of the result are obtained by converting the bounds of the operand to the corresponding index type of the target type.
If the type mark denotes a constrained array subtype, then the bounds of the result are those imposed by the type mark.
In either case, the value of each component of the result is that of the matching component of the operand (see 4.5.2).
In the case of conversions of numeric types and derived types, the exception CONSTRAINT_ERROR is raised by the evaluation of a type conversion if the result of the conversion fails to satisfy a constraint imposed by the type mark.
In the case of array types, a check is made that any constraint on the component subtype is the same for the operand array type as for the target array type.
If the type mark denotes an unconstrained array type and if the operand is not a null array, then, for each index position, a check is made that the bounds of the result belong to the corresponding index subtype of the target type.
If the type mark denotes a constrained array subtype, a check is made that for each component of the operand there is a matching component of the target subtype, and vice versa.
The exception CONSTRAINT_ERROR is raised if any of these checks fails.
If a conversion is allowed from one type to another, the reverse conversion is also allowed.
This reverse conversion is used where an actual parameter of mode in out or out has the form of a type conversion of a (variable) name as explained in section 6.4.1.
Apart from the explicit type conversions, the only allowed form of type conversion is the implicit conversion of a value of the type universal integer or universal real into another numeric type.
An implicit conversion of an operand of type universal integer to another integer type, or of an operand of type universal real to another real type, can only be applied if the operand is either a numeric literal, a named number, or an attribute;
such an operand is called a convertible universal operand in this section.
An implicit conversion of a convertible universal operand is applied if and only if the innermost complete context (see 8.7) determines a unique (numeric) target type for the implicit conversion, and there is no legal interpretation of this context without this conversion.
The rules for implicit conversions imply that no implicit conversion is ever applied to the operand of an explicit type conversion.
Similarly, implicit conversions are not applied if both operands of a predefined relational operator are convertible universal operands.
The language allows implicit subtype conversions in the case of array types (see 5.2.1).
An explicit type conversion can have the effect of a change of representation (in particular see 13.6).
Explicit conversions are also used for actual parameters (see 6.4).
Examples of numeric type conversion:
Example of conversion between derived types:
Examples of conversions between array types:
Examples of implicit conversions:
A qualified expression is used to state explicitly the type, and possibly the subtype, of an operand that is the given expression or aggregate.
The operand must have the same type as the base type of the type mark.
The value of a qualified expression is the value of the operand.
The evaluation of a qualified expression evaluates the operand and checks that its value belongs to the subtype denoted by the type mark.
The exception CONSTRAINT_ERROR is raised if this check fails.
Whenever the type of an enumeration literal or aggregate is not known from the context, a qualified expression can be used to state the type explicitly.
For example, an overloaded enumeration literal must be qualified in the following cases: when given as a parameter in a subprogram call to an overloaded subprogram that cannot otherwise be identified on the basis of remaining parameter or result types, in a relational expression where both operands are overloaded enumeration literals, or in an array or loop parameter range where both bounds are overloaded enumeration literals.
Explicit qualification is also used to specify which one of a set of overloaded parameterless functions is meant, or to constrain a value to a given subtype.
The evaluation of an allocator creates an object and yields an access value that designates the object.
The type of the object created by an allocator is the base type of the type mark given in either the subtype indication or the qualified expression.
For an allocator with a qualified expression, this expression defines the initial value of the created object.
The type of the access value returned by an allocator must be determinable solely from the context, but using the fact that the value returned is of an access type having the named designated type.
The only allowed forms of constraint in the subtype indication of an allocator are index and discriminant constraints.
If an allocator includes a subtype indication and if the type of the object created is an array type or a type with discriminants that do not have default expressions, then the subtype indication must either denote a constrained subtype, or include an explicit index or discriminant constraint.
If the type of the created object is an array type or a type with discriminants, then the created object is always constrained.
If the allocator includes a subtype indication, the created object is constrained either by the subtype or by the default discriminant values.
If the allocator includes a qualified expression, the created object is constrained by the bounds or discriminants of the initial value.
For other types, the subtype of the created object is the subtype defined by the subtype indication of the access type definition.
For the evaluation of an allocator, the elaboration of the subtype indication or the evaluation of the qualified expression is performed first.
The new object is then created.
Initializations are then performed as for a declared object (see 3.2.1); the initialization is considered explicit in the case of a qualified expression; any initializations are implicit in the case of a subtype indication.
Finally, an access value that designates the created object is returned.
An implementation must guarantee that any object created by the evaluation of an allocator remains allocated for as long as this object or one of its subcomponents is accessible directly or indirectly, that is, as long as it can be denoted by some name.
Moreover, if an object or one of its subcomponents belongs to a task type, it is considered to be accessible as long as the task is not terminated.
An implementation may (but need not) reclaim the storage occupied by an object created by an allocator, once this object has become inaccessible.
When an application needs closer control over storage allocation for objects designated by values of an access type, such control may be achieved by one or more of the following means:
The total amount of storage available for the collection of objects of an access type can be set by means of a length clause (see 13.2).
The pragma CONTROLLED informs the implementation that automatic storage reclamation must not be performed for objects designated by values of the access type, except upon leaving the innermost block statement, subprogram body, or task body that encloses the access type declaration, or after leaving the main program.
A pragma CONTROLLED for a given access type is allowed at the same places as a representation clause for the type (see 13.1).
This pragma is not allowed for a derived type.
The explicit deallocation of the object designated by an access value can be achieved by calling a procedure obtained by instantiation of the predefined generic library procedure UNCHECKED_DEALLOCATION (see 13.10.1).
The exception STORAGE_ERROR is raised by an allocator if there is not enough storage.
Note also that the exception CONSTRAINT_ERROR can be raised by the evaluation of the qualified expression, by the elaboration of the subtype indication, or by the initialization.
Examples (for access types declared in section 3.8):
Certain expressions of a scalar type are said to be static.
Similarly, certain discrete ranges are said to be static, and the type marks of certain scalar subtypes are said to denote static subtypes.
An expression of a scalar type is said to be static if and only if every primary is one of those listed in (a) through (h) below, every operator denotes a predefined operator, and the evaluation of the expression delivers a value (that is, it does not raise an exception):
An enumeration literal (including a character literal).
A numeric literal.
A named number.
A constant explicitly declared by a constant declaration with a static subtype, and initialized with a static expression.
A function call whose function name is an operator symbol that denotes a predefined operator, including a function name that is an expanded name;
each actual parameter must also be a static expression.
A language-defined attribute of a static subtype;
for an attribute that is a function, the actual parameter must also be a static expression.
A qualified expression whose type mark denotes a static subtype and whose operand is a static expression.
A static expression enclosed in parentheses.
A static range is a range whose bounds are static expressions.
A static range constraint is a range constraint whose range is static.
A static subtype is either a scalar base type, other than a generic formal type; or a scalar subtype formed by imposing on a static subtype either a static range constraint, or a floating or fixed point constraint whose range constraint, if any, is static.
A static discrete range is either a static subtype or a static range.
A static index constraint is an index constraint for which each index subtype of the corresponding array type is static, and in which each discrete range is static.
A static discriminant constraint is a discriminant constraint for which the subtype of each discriminant is static, and in which each expression is static.
The accuracy of the evaluation of a static expression having a real type is defined by the rules given in section 4.5.7.
If the result is not a model number (or a safe number) of the type, the value obtained by this evaluation at compilation time need not be the same as the value that would be obtained by an evaluation at run time.
Array attributes are not static: in particular, the RANGE attribute is not static.
A universal expression is either an expression that delivers a result of type universal integer or one that delivers a result of type universal real.
The same operations are predefined for the type universal integer as for any integer type.
The same operations are predefined for the type universal real as for any floating point type.
In addition, these operations include the following multiplication and division operators:
The accuracy of the evaluation of a universal expression of type universal real is at least as good as that of the most accurate predefined floating point type supported by the implementation, apart from universal real itself.
Furthermore, if a universal expression is a static expression, then the evaluation must be exact.
For the evaluation of an operation of a nonstatic universal expression, an implementation is allowed to raise the exception NUMERIC_ERROR only if the result of the operation is a real value whose absolute value exceeds the largest safe number of the most accurate predefined floating point type (excluding universal real), or an integer value greater than SYSTEM.MAX_INT or less than SYSTEM.MIN_INT.
It is a consequence of the above rules that the type of a universal expression is universal integer if every primary contained in the expression is of this type (excluding actual parameters of attributes that are functions, and excluding right operands of exponentiation operators) and that otherwise the type is universal real.
A statement defines an action to be performed;
the process by which a statement achieves its action is called execution of the statement.
This chapter describes the general rules applicable to all statements.
Some specific statements are discussed in later chapters.
Procedure call statements are described in Chapter 6 on subprograms.
Entry call, delay, accept, select, and abort statements are described in Chapter 9 on tasks.
Raise statements are described in Chapter 11 on exceptions, and code statements in Chapter 13.
The remaining forms of statements are presented in this chapter.
A statement is either simple or compound.
A simple statement encloses no other statement.
A compound statement can enclose simple statements and other compound statements.
A statement is said to be labeled by the label name of any label of the statement.
A label name, and similarly a loop or block name, is implicitly declared at the end of the declarative part of the innermost block statement, subprogram body, package body, task body, or generic body that encloses the labeled statement, the named loop statement, or the named block statement, as the case may be.
For a block statement without a declarative part, an implicit declarative part (and preceding declare) is assumed.
The implicit declarations for different label names, loop names, and block names occur in the same order as the beginnings of the corresponding labeled statements, loop statements, and block statements.
Distinct identifiers must be used for all label, loop, and block names that are implicitly declared within the body of a program unit, including within block statements enclosed by this body, but excluding within other enclosed program units (a program unit is either a subprogram, a package, a task unit, or a generic unit).
Execution of a null statement has no other effect than to pass to the next action.
The execution of a sequence of statements consists of the execution of the individual statements in succession until the sequence is completed, or a transfer of control takes place.
A transfer of control is caused either by the execution of an exit, return, or goto statement; by the selection of a terminate alternative; by the raising of an exception; or (indirectly) by the execution of an abort statement.
Examples of labeled statements:
The scope of a declaration starts at the place of the declaration itself (see 8.2).
In the case of a label, loop, or block name, it follows from this rule that the scope of the implicit declaration starts before the first explicit occurrence of the corresponding name, since this occurrence is either in a statement label, a loop statement, a block statement, or a goto statement.
An implicit declaration in a block statement may hide a declaration given in an outer program unit or block statement (according to the usual rules of hiding explained in section 8.3).
An assignment statement replaces the current value of a variable with a new value specified by an expression.
The named variable and the right-hand side expression must be of the same type; this type must not be a limited type.
For the execution of an assignment statement, the variable name and the expression are first evaluated, in some order that is not defined by the language.
A check is then made that the value of the expression belongs to the subtype of the variable, except in the case of a variable that is an array
(the assignment then involves a subtype conversion as described in section 5.2.1).
Finally, the value of the expression becomes the new value of the variable.
The exception CONSTRAINT_ERROR is raised if the above-mentioned subtype check fails; in such a case the current value of the variable is left unchanged.
If the variable is a subcomponent that depends on discriminants of an unconstrained record variable, then the execution of the assignment is erroneous if the value of any of these discriminants is changed by this execution.
Examples of constraint checks:
The values of the discriminants of an object designated by an access value cannot be changed (not even by assigning a complete value to the object itself) since such objects, created by allocators, are always constrained (see 4.8);
however, subcomponents of such objects may be unconstrained.
If the right-hand side expression is either a numeric literal or named number, or an attribute that yields a result of type universal integer or universal real, then an implicit type conversion is performed, as described in section 4.6.
The determination of the type of the variable of an assignment statement may require consideration of the expression if the variable name can be interpreted as the name of a variable designated by the access value returned by a function call, and similarly, as a component or slice of such a variable
(see section 8.7 for the context of overload resolution).
If the variable of an assignment statement is an array variable (including a slice variable), the value of the expression is implicitly converted to the subtype of the array variable; the result of this subtype conversion becomes the new value of the array variable.
This means that the new value of each component of the array variable is specified by the matching component in the array value obtained by evaluation of the expression (see 4.5.2 for the definition of matching components).
The subtype conversion checks that for each component of the array variable there is a matching component in the array value, and vice versa.
The exception CONSTRAINT_ERROR is raised if this check fails; in such a case the value of each component of the array variable is left unchanged.
Array assignment is defined even in the case of overlapping slices, because the expression on the right-hand side is evaluated before performing any component assignment.
In the above example, an implementation yielding A(1 ..
12) = "tartartartar" would be incorrect.
The implicit subtype conversion described above for assignment to an array variable is performed only for the value of the right-hand side expression as a whole; it is not performed for subcomponents that are array values.
An if statement selects for execution one or none of the enclosed sequences of statements, depending on the (truth) value of one or more corresponding conditions.
An expression specifying a condition must be of a boolean type.
For the execution of an if statement, the condition specified after if, and any conditions specified after elsif, are evaluated in succession (treating a final else as elsif TRUE then), until one evaluates to TRUE or all conditions are evaluated and yield FALSE.
If one condition evaluates to TRUE, then the corresponding sequence of statements is executed; otherwise none of the sequences of statements is executed.
A case statement selects for execution one of a number of alternative sequences of statements;
the chosen alternative is defined by the value of an expression.
The expression must be of a discrete type which must be determinable independently of the context in which the expression occurs, but using the fact that the expression must be of a discrete type.
Moreover, the type of this expression must not be a generic formal type.
Each choice in a case statement alternative must be of the same type as the expression;
the list of choices specifies for which values of the expression the alternative is chosen.
If the expression is the name of an object whose subtype is static, then each value of this subtype must be represented once and only once in the set of choices of the case statement, and no other value is allowed;
this rule is likewise applied if the expression is a qualified expression or type conversion whose type mark denotes a static subtype.
Otherwise, for other forms of expression, each value of the (base) type of the expression must be represented once and only once in the set of choices, and no other value is allowed.
The simple expressions and discrete ranges given as choices in a case statement must be static.
A choice defined by a discrete range stands for all values in the corresponding range (none if a null range).
The choice others is only allowed for the last alternative and as its only choice; it stands for all values (possibly none) not given in the choices of previous alternatives.
A component simple name is not allowed as a choice of a case statement alternative.
The execution of a case statement consists of the evaluation of the expression followed by the execution of the chosen sequence of statements.
The execution of a case statement chooses one and only one alternative, since the choices are exhaustive and mutually exclusive.
Qualification of the expression of a case statement by a static subtype can often be used to limit the number of choices that need be given explicitly.
An others choice is required in a case statement if the type of the expression is the type universal integer (for example, if the expression is an integer literal), since this is the only way to cover all values of the type universal integer.
A loop statement includes a sequence of statements that is to be executed repeatedly, zero or more times.
If a loop statement has a loop simple name, this simple name must be given both at the beginning and at the end.
A loop statement without an iteration scheme specifies repeated execution of the sequence of statements.
Execution of the loop statement is complete when the loop is left as a consequence of the execution of an exit statement, or as a consequence of some other transfer of control (see 5.1).
For a loop statement with a while iteration scheme, the condition is evaluated before each execution of the sequence of statements;
if the value of the condition is TRUE, the sequence of statements is executed, if FALSE the execution of the loop statement is complete.
For a loop statement with a for iteration scheme, the loop parameter specification is the declaration of the loop parameter with the given identifier.
The loop parameter is an object whose type is the base type of the discrete range (see 3.6.1).
Within the sequence of statements, the loop parameter is a constant.
Hence a loop parameter is not allowed as the (left-hand side) variable of an assignment statement.
Similarly the loop parameter must not be given as an out or in out parameter of a procedure or entry call statement, or as an in out parameter of a generic instantiation.
For the execution of a loop statement with a for iteration scheme, the loop parameter specification is first elaborated.
This elaboration creates the loop parameter and evaluates the discrete range.
If the discrete range is a null range, the execution of the loop statement is complete.
Otherwise, the sequence of statements is executed once for each value of the discrete range
(subject to the loop not being left as a consequence of the execution of an exit statement or as a consequence of some other transfer of control).
Prior to each such iteration, the corresponding value of the discrete range is assigned to the loop parameter.
These values are assigned in increasing order unless the reserved word reverse is present, in which case the values are assigned in decreasing order.
Example of a loop statement without an iteration scheme:
Example of a loop statement with a while iteration scheme:
Example of a loop statement with a for iteration scheme:
Example of a loop statement with a loop simple name:
The scope of a loop parameter extends from the loop parameter specification to the end of the loop statement, and the visibility rules are such that a loop parameter is only visible within the sequence of statements of the loop.
The discrete range of a for loop is evaluated just once.
Use of the reserved word reverse does not alter the discrete range, so that the following iteration schemes are not equivalent; the first has a null range.
Loop names are also used in exit statements, and in expanded names (in a prefix of the loop parameter).
A block statement encloses a sequence of statements optionally preceded by a declarative part and optionally followed by exception handlers.
If a block statement has a block simple name, this simple name must be given both at the beginning and at the end.
The execution of a block statement consists of the elaboration of its declarative part (if any) followed by the execution of the sequence of statements.
If the block statement has exception handlers, these service corresponding exceptions that are raised during the execution of the sequence of statements (see 11.2).
If task objects are declared within a block statement whose execution is completed, the block statement is not left until all its dependent tasks are terminated (see 9.4).
This rule applies also to a completion caused by an exit, return, or goto statement; or by the raising of an exception.
Within a block statement, the block name can be used in expanded names denoting local entities such as SWAP.TEMP in the above example (see 4.1.3 (f)).
An exit statement is used to complete the execution of an enclosing loop statement (called the loop in what follows);
the completion is conditional if the exit statement includes a condition.
An exit statement with a loop name is only allowed within the named loop, and applies to that loop;
an exit statement without a loop name is only allowed within a loop, and applies to the innermost enclosing loop (whether named or not).
Furthermore, an exit statement that applies to a given loop must not appear within a subprogram body, package body, task body, generic body, or accept statement, if this construct is itself enclosed by the given loop.
For the execution of an exit statement, the condition, if present, is first evaluated.
Exit from the loop then takes place if the value is TRUE or if there is no condition.
Several nested loops can be exited by an exit statement that names the outer loop.
A return statement is used to complete the execution of the innermost enclosing function, procedure, or accept statement.
A return statement is only allowed within the body of a subprogram or generic subprogram, or within an accept statement, and applies to the innermost (enclosing) such construct;
a return statement is not allowed within the body of a task unit, package, or generic package enclosed by this construct
(on the other hand, it is allowed within a compound statement enclosed by this construct and, in particular, in a block statement).
A return statement for an accept statement or for the body of a procedure or generic procedure must not include an expression.
A return statement for the body of a function or generic function must include an expression.
The value of the expression defines the result returned by the function.
The type of this expression must be the base type of the type mark given after the reserved word return in the specification of the function or generic function
(this type mark defines the result subtype).
For the execution of a return statement, the expression (if any) is first evaluated and a check is made that the value belongs to the result subtype.
The execution of the return statement is thereby completed if the check succeeds; so also is the execution of the subprogram or of the accept statement.
The exception CONSTRAINT_ERROR is raised at the place of the return statement if the check fails.
If the expression is either a numeric literal or named number, or an attribute that yields a result of type universal integer or universal real, then an implicit conversion of the result is performed as described in section 4.6.
A goto statement specifies an explicit transfer of control from this statement to a target statement named by a label.
The innermost sequence of statements that encloses the target statement must also enclose the goto statement
(note that the goto statement can be a statement of an inner sequence).
Furthermore, if a goto statement is enclosed by an accept statement or the body of a program unit, then the target statement must not be outside this enclosing construct; conversely, it follows from the previous rule that if the target statement is enclosed by such a construct, then the goto statement cannot be outside.
The execution of a goto statement transfers control to the named target statement.
The above rules allow transfer of control to a statement of an enclosing sequence of statements but not the reverse.
Similarly, they prohibit transfers of control such as between alternatives of a case statement, if statement, or select statement; between exception handlers; or from an exception handler of a frame back to the sequence of statements of this frame.
Subprograms are one of the four forms of program unit, of which programs can be composed.
The other forms are packages, task units, and generic units.
A subprogram is a program unit whose execution is invoked by a subprogram call.
There are two forms of subprogram: procedures and functions.
A procedure call is a statement;
a function call is an expression and returns a value.
The definition of a subprogram can be given in two parts: a subprogram declaration defining its calling conventions, and a subprogram body defining its execution.
A subprogram declaration declares a procedure or a function, as indicated by the initial reserved word.
The specification of a procedure specifies its identifier and its formal parameters (if any).
The specification of a function specifies its designator, its formal parameters (if any) and the subtype of the returned value (the result subtype).
A designator that is an operator symbol is used for the overloading of an operator.
The sequence of characters represented by an operator symbol must be an operator belonging to one of the six classes of overloadable operators defined in section 4.5
(extra spaces are not allowed and the case of letters is not significant).
A parameter specification with several identifiers is equivalent to a sequence of single parameter specifications, as explained in section 3.2.
Each single parameter specification declares a formal parameter.
If no mode is explicitly given, the mode in is assumed.
If a parameter specification ends with an expression, the expression is the default expression of the formal parameter.
A default expression is only allowed in a parameter specification if the mode is in
(whether this mode is indicated explicitly or implicitly).
The type of a default expression must be that of the corresponding formal parameter.
The use of a name that denotes a formal parameter is not allowed in default expressions of a formal part if the specification of the parameter is itself given in this formal part.
The elaboration of a subprogram declaration elaborates the corresponding formal part.
The elaboration of a formal part has no other effect.
Examples of subprogram declarations:
Examples of in parameters with default expressions:
The evaluation of default expressions is caused by certain subprogram calls, as described in section 6.4.2
(default expressions are not evaluated during the elaboration of the subprogram declaration).
All subprograms can be called recursively and are reentrant.
The value of an object is said to be read when this value is evaluated;
it is also said to be read when one of its subcomponents is read.
The value of a variable is said to be updated when an assignment is performed to the variable, and also (indirectly) when the variable is used as actual parameter of a subprogram call or entry call statement that updates its value;
it is also said to be updated when one of its subcomponents is updated.
A formal parameter of a subprogram has one of the three following modes:
The formal parameter is a constant and permits only reading of the value of the associated actual parameter.
The formal parameter is a variable and permits both reading and updating of the value of the associated actual parameter.
The formal parameter is a variable and permits updating of the value of the associated actual parameter.
The value of a scalar parameter that is not updated by the call is undefined upon return;
the same holds for the value of a scalar subcomponent, other than a discriminant.
Reading the bounds and discriminants of the formal parameter and of its subcomponents is allowed, but no other reading.
For a scalar parameter, the above effects are achieved by copy: at the start of each call, if the mode is in or in out, the value of the actual parameter is copied into the associated formal parameter;
then after normal completion of the subprogram body, if the mode is in out or out, the value of the formal parameter is copied back into the associated actual parameter.
For a parameter whose type is an access type, copy-in is used for all three modes, and copy-back for the modes in out and out.
For a parameter whose type is an array, record, or task type, an implementation may likewise achieve the above effects by copy, as for scalar types.
In addition, if copy is used for a parameter of mode out, then copy-in is required at least for the bounds and discriminants of the actual parameter and of its subcomponents, and also for each subcomponent whose type is an access type.
Alternatively, an implementation may achieve these effects by reference, that is, by arranging that every use of the formal parameter (to read or to update its value) be treated as a use of the associated actual parameter, throughout the execution of the subprogram call.
The language does not define which of these two mechanisms is to be adopted for parameter passing, nor whether different calls to the same subprogram are to use the same mechanism.
The execution of a program is erroneous if its effect depends on which mechanism is selected by the implementation.
For a parameter whose type is a private type, the above effects are achieved according to the rule that applies to the corresponding full type declaration.
Within the body of a subprogram, a formal parameter is subject to any constraint resulting from the type mark given in its parameter specification.
For a formal parameter of an unconstrained array type, the bounds are obtained from the actual parameter, and the formal parameter is constrained by these bounds (see 3.6.1).
For a formal parameter whose declaration specifies an unconstrained (private or record) type with discriminants, the discriminants of the formal parameter are initialized with the values of the corresponding discriminants of the actual parameter;
the formal parameter is unconstrained if and only if the mode is in out or out and the variable name given for the actual parameter denotes an unconstrained variable (see 3.7.1 and 6.4.1).
If the actual parameter of a subprogram call is a subcomponent that depends on discriminants of an unconstrained record variable, then the execution of the call is erroneous if the value of any of the discriminants of the variable is changed by this execution;
this rule does not apply if the mode is in and the type of the subcomponent is a scalar type or an access type.
For parameters of array and record types, the parameter passing rules have these consequences:
If the execution of a subprogram is abandoned as a result of an exception, the final value of an actual parameter of such a type can be either its value before the call or a value assigned to the formal parameter during the execution of the subprogram.
If no actual parameter of such a type is accessible by more than one path, then the effect of a subprogram call (unless abandoned) is the same whether or not the implementation uses copying for parameter passing.
If, however, there are multiple access paths to such a parameter
(for example, if a global variable, or another formal parameter, refers to the same actual parameter),
then the value of the formal is undefined after updating the actual other than by updating the formal.
A program using such an undefined value is erroneous.
The same parameter modes are defined for formal parameters of entries (see 9.5) with the same meaning as for subprograms.
Different parameter modes are defined for generic formal parameters (see 12.1.1).
For all modes, if an actual parameter designates a task, the associated formal parameter designates the same task;
the same holds for a subcomponent of an actual parameter and the corresponding subcomponent of the associated formal parameter.
A subprogram body specifies the execution of a subprogram.
The declaration of a subprogram is optional.
In the absence of such a declaration, the subprogram specification of the subprogram body (or body stub) acts as the declaration.
For each subprogram declaration, there must be a corresponding body
(except for a subprogram written in another language, as explained in section 13.9).
If both a declaration and a body are given, the subprogram specification of the body must conform to the subprogram specification of the declaration (see section 6.3.1 for conformance rules).
If a designator appears at the end of a subprogram body, it must repeat the designator of the subprogram specification.
The elaboration of a subprogram body has no other effect than to establish that the body can from then on be used for the execution of calls of the subprogram.
The execution of a subprogram body is invoked by a subprogram call (see 6.4).
For this execution, after establishing the association between formal parameters and actual parameters, the declarative part of the body is elaborated, and the sequence of statements of the body is then executed.
Upon completion of the body, return is made to the caller
(and any necessary copying back of formal to actual parameters occurs (see 6.2)).
The optional exception handlers at the end of a subprogram body handle exceptions raised during the execution of the sequence of statements of the subprogram body (see 11.4).
It follows from the visibility rules that if a subprogram declared in a package is to be visible outside the package, a subprogram specification must be given in the visible part of the package.
The same rules dictate that a subprogram declaration must be given if a call of the subprogram occurs textually before the subprogram body
(the declaration must then occur earlier than the call in the program text).
The rules given in sections 3.9 and 7.1 imply that a subprogram declaration and the corresponding body must both occur immediately within the same declarative region.
Example of subprogram body:
Whenever the language rules require or allow the specification of a given subprogram to be provided in more than one place, the following variations are allowed at each place:
A numeric literal can be replaced by a different numeric literal if and only if both have the same value.
A simple name can be replaced by an expanded name in which this simple name is the selector, if and only if at both places the meaning of the simple name is given by the same declaration.
A string literal given as an operator symbol can be replaced by a different string literal if and only if both represent the same operator.
Two subprogram specifications are said to conform if, apart from comments and the above allowed variations, both specifications are formed by the same sequence of lexical elements, and corresponding lexical elements are given the same meaning by the visibility and overloading rules.
Conformance is likewise defined for formal parts, discriminant parts, and type marks
(for deferred constants and for actual parameters that have the form of a type conversion (see 6.4.1)).
A simple name can be replaced by an expanded name even if the simple name is itself the prefix of a selected component.
For example, Q.R can be replaced by P.Q.R if Q is declared immediately within P.
The following specifications do not conform since they are not formed by the same sequence of lexical elements:
The pragma INLINE is used to indicate that inline expansion of the subprogram body is desired for every call of each of the named subprograms.
The form of this pragma is as follows:
Each name is either the name of a subprogram or the name of a generic subprogram.
The pragma INLINE is only allowed at the place of a declarative item in a declarative part or package specification, or after a library unit in a compilation, but before any subsequent compilation unit.
If the pragma appears at the place of a declarative item, each name must denote a subprogram or a generic subprogram declared by an earlier declarative item of the same declarative part or package specification.
If several (overloaded) subprograms satisfy this requirement, the pragma applies to all of them.
If the pragma appears after a given library unit, the only name allowed is the name of this unit.
If the name of a generic subprogram is mentioned in the pragma, this indicates that inline expansion is desired for calls of all subprograms obtained by instantiation of the named generic unit.
The meaning of a subprogram is not changed by the pragma INLINE.
For each call of the named subprograms, an implementation is free to follow or to ignore the recommendation expressed by the pragma.
(Note, in particular, that the recommendation cannot generally be followed for a recursive subprogram.)
A subprogram call is either a procedure call statement or a function call;
it invokes the execution of the corresponding subprogram body.
The call specifies the association of the actual parameters, if any, with formal parameters of the subprogram.
Each parameter association associates an actual parameter with a corresponding formal parameter.
A parameter association is said to be named if the formal parameter is named explicitly; it is otherwise said to be positional.
For a positional association, the actual parameter corresponds to the formal parameter with the same position in the formal part.
Named associations can be given in any order, but if both positional and named associations are used in the same call, positional associations must occur first, at their normal position.
Hence once a named association is used, the rest of the call must use only named associations.
For each formal parameter of a subprogram, a subprogram call must specify exactly one corresponding actual parameter.
This actual parameter is specified either explicitly, by a parameter association, or, in the absence of such an association, by a default expression (see 6.4.2).
The parameter associations of a subprogram call are evaluated in some order that is not defined by the language.
Similarly, the language rules do not define in which order the values of in out or out parameters are copied back into the corresponding actual parameters (when this is done).
Examples of procedure calls:
Examples of function calls:
Each actual parameter must have the same type as the corresponding formal parameter.
An actual parameter associated with a formal parameter of mode in must be an expression;
it is evaluated before the call.
An actual parameter associated with a formal parameter of mode in out or out must be either the name of a variable, or of the form of a type conversion whose argument is the name of a variable.
In either case, for the mode in out, the variable must not be a formal parameter of mode out or a subcomponent thereof.
For an actual parameter that has the form of a type conversion, the type mark must conform (see 6.3.1) to the type mark of he formal parameter;
the allowed operand and target types are the same as for type conversions (see 4.6).
The variable name given for an actual parameter of mode in out or out is evaluated before the call.
If the actual parameter has the form of a type conversion, then before the call, for a parameter of mode in out, the variable is converted to the specified type;
after (normal) completion of the subprogram body, for a parameter of mode in out or out, the formal parameter is converted back to the type of the variable.
(The type specified in the conversion must be that of the formal parameter.)
The following constraint checks are performed for parameters of scalar and access types:
Before the call: for a parameter of mode in or in out, it is checked that the value of the actual parameter belongs to the subtype of the formal parameter.
After (normal) completion of the subprogram body: for a parameter of mode in out or out, it is checked that the value of the formal parameter belongs to the subtype of the actual variable.
In the case of a type conversion, the value of the formal parameter is converted back and the check applies to the result of the conversion.
In each of the above cases, the execution of the program is erroneous if the checked value is undefined.
For other types, for all modes, a check is made before the call as for scalar and access types;
no check is made upon return.
The exception CONSTRAINT_ERROR is raised at the place of the subprogram call if either of these checks fails.
For array types and for types with discriminants, the check before the call is sufficient (a check upon return would be redundant) if the type mark of the formal parameter denotes a constrained subtype, since neither array bounds nor discriminants can then vary.
If this type mark denotes an unconstrained array type, the formal parameter is constrained with the bounds of the corresponding actual parameter and no check (neither before the call nor upon return) is needed (see 3.6.1).
Similarly, no check is needed if the type mark denotes an unconstrained type with discriminants, since the formal parameter is then constrained exactly as the corresponding actual parameter (see 3.7.1).
If a parameter specification includes a default expression for a parameter of mode in, then corresponding subprogram calls need not include a parameter association for the parameter.
If a parameter association is thus omitted from a call, then the rest of the call, following any initial positional associations, must use only named associations.
For any omitted parameter association, the default expression is evaluated before the call and the resulting value is used as an implicit actual parameter.
Examples of procedures with default values:
Examples of their calls:
If a default expression is used for two or more parameters in a multiple parameter specification, the default expression is evaluated once for each omitted parameter.
Hence in the above examples, the two calls of PAIR are equivalent.
A function is a subprogram that returns a value (the result of the function call).
The specification of a function starts with the reserved word function, and the parameters, if any, must have the mode in
(whether this mode is specified explicitly or implicitly).
The statements of the function body (excluding statements of program units that are inner to the function body) must include one or more return statements specifying the returned value.
The exception PROGRAM_ERROR is raised if a function body is left otherwise than by a return statement.
This does not apply if the execution of the function is abandoned as a result of an exception.
Two formal parts are said to have the same parameter type profile if and only if they have the same number of parameters, and at each parameter position corresponding parameters have the same base type.
A subprogram or entry has the same parameter and result type profile as another subprogram or entry if and only if both have the same parameter type profile, and either both are functions with the same result base type, or neither of the two is a function.
The same subprogram identifier or operator symbol can be used in several subprogram specifications.
The identifier or operator symbol is then said to be overloaded;
the subprograms that have this identifier or operator symbol are also said to be overloaded and to overload each other.
As explained in section 8.3, if two subprograms overload each other, one of them can hide the other only if both subprograms have the same parameter and result type profile
(see section 8.3 for the other requirements that must be met for hiding).
A call to an overloaded subprogram is ambiguous (and therefore illegal) if the name of the subprogram, the number of parameter associations, the types and the order of the actual parameters, the names of the formal parameters (if named associations are used), and the result type (for functions) are not sufficient to determine exactly one (overloaded) subprogram specification.
Examples of overloaded subprograms:
Examples of calls:
The notion of parameter and result type profile does not include parameter names, parameter modes, parameter subtypes, default expressions and their presence or absence.
Ambiguities may (but need not) arise when actual parameters of the call of an overloaded subprogram are themselves overloaded function calls, literals, or aggregates.
Ambiguities may also (but need not) arise when several overloaded subprograms belonging to different packages are visible.
These ambiguities can usually be resolved in several ways: qualified expressions can be used for some or all actual parameters, and for the result, if any;
the name of the subprogram can be expressed more explicitly as an expanded name;
finally, the subprogram can be renamed.
The declaration of a function whose designator is an operator symbol is used to overload an operator.
The sequence of characters of the operator symbol must be either a logical, a relational, a binary adding, a unary adding, a multiplying, or a highest precedence operator (see 4.5).
Neither membership tests nor the short-circuit control forms are allowed as function designators.
The subprogram specification of a unary operator must have a single parameter.
The subprogram specification of a binary operator must have two parameters;
for each use of this operator, the first parameter takes the left operand as actual parameter, the second parameter takes the right operand.
Similarly, a generic function instantiation whose designator is an operator symbol is only allowed if the specification of the generic function has the corresponding number of parameters.
Default expressions are not allowed for the parameters of an operator
(whether the operator is declared with an explicit subprogram specification or by a generic instantiation).
For each of the operators "+" and "-", overloading is allowed both as a unary and as a binary operator.
The explicit declaration of a function that overloads the equality operator "=", other than by a renaming declaration, is only allowed if both parameters are of the same limited type.
An overloading of equality must deliver a result of the predefined type BOOLEAN;
it also implicitly overloads the inequality operator "/=" so that this still gives the complementary result to the equality operator.
Explicit overloading of the inequality operator is not allowed.
A renaming declaration whose designator is the equality operator is only allowed to rename another equality operator.
(For example, such a renaming declaration can be used when equality is visible by selection but not directly visible.)
Overloading of relational operators does not affect basic comparisons such as testing for membership in a range or the choices in a case statement.
Packages are one of the four forms of program unit, of which programs can be composed.
The other forms are subprograms, task units, and generic units.
Packages allow the specification of groups of logically related entities.
In their simplest form packages specify pools of common object and type declarations.
More generally, packages can be used to specify groups of related entities including also subprograms that can be called from outside the package, while their inner workings remain concealed and protected from outside users.
A package is generally provided in two parts: a package specification and a package body.
Every package has a package specification, but not all packages have a package body.
The simple name at the start of a package body must repeat the package identifier.
Similarly if a simple name appears at the end of the package specification or body, it must repeat the package identifier.
If a subprogram declaration, a package declaration, a task declaration, or a generic declaration is a declarative item of a given package specification, then the body (if there is one) of the program unit declared by the declarative item must itself be a declarative item of the declarative part of the body of the given package.
A simple form of package, specifying a pool of objects and types, does not require a package body.
One of the possible uses of the sequence of statements of a package body is to initialize such objects.
For each subprogram declaration there must be a corresponding body
(except for a subprogram written in another language, as explained in section 13.9).
If the body of a program unit is a body stub, then a separately compiled subunit containing the corresponding proper body is required for the program unit (see 10.2).
A body is not a basic declarative item and so cannot appear in a package specification.
A package declaration is either a library package (see 10.2) or a declarative item declared within another program unit.
The first list of declarative items of a package specification is called the visible part of the package.
The optional list of declarative items after the reserved word private is called the private part of the package.
An entity declared in the private part of a package is not visible outside the package itself
(a name denoting such an entity is only possible within the package).
In contrast, expanded names denoting entities declared in the visible part can be used even outside the package;
furthermore, direct visibility of such entities can be achieved by means of use clauses (see 4.1.3 and 8.4).
The elaboration of a package declaration consists of the elaboration of its basic declarative items in the given order.
The visible part of a package contains all the information that another program unit is able to know about the package.
A package consisting of only a package specification (that is, without a package body) can be used to represent a group of common constants or variables, or a common pool of objects and types, as in the examples below.
Example of a package describing a group of common variables:
Example of a package describing a common pool of objects and types:
In contrast to the entities declared in the visible part of a package specification, the entities declared in the package body are only visible within the package body itself.
As a consequence, a package with a package body can be used for the construction of a group of related subprograms (a package in the usual sense), in which the logical operations available to the users are clearly isolated from the internal entities.
For the elaboration of a package body, its declarative part is first elaborated, and its sequence of statements (if any) is then executed.
The optional exception handlers at the end of a package body service exceptions raised during the execution of the sequence of statements of the package body.
A variable declared in the body of a package is only visible within this body and, consequently, its value can only be changed within the package body.
In the absence of local tasks, the value of such a variable remains unchanged between calls issued from outside the package to subprograms declared in the visible part.
The properties of such a variable are similar to those of an "own" variable of Algol 60.
The elaboration of the body of a subprogram declared in the visible part of a package is caused by the elaboration of the body of the package.
Hence a call of such a subprogram by an outside program unit raises the exception PROGRAM_ERROR if the call takes place before the elaboration of the package body (see 3.9).
Example of a package:
The declaration of a type as a private type in the visible part of a package serves to separate the characteristics that can be used directly by outside program units (that is, the logical properties) from other characteristics whose direct use is confined to the package (the details of the definition of the type itself).
Deferred constant declarations declare constants of private types.
A private type declaration is only allowed as a declarative item of the visible part of a package, or as the generic parameter declaration for a generic formal type in a generic formal part.
The type mark of a deferred constant declaration must denote a private type or a subtype of a private type;
a deferred constant declaration and the declaration of the corresponding private type must both be declarative items of the visible part of the same package.
A deferred constant declaration with several identifiers is equivalent to a sequence of single deferred constant declarations as explained in section 3.2.
Examples of private type declarations:
Example of deferred constant declaration:
If a private type declaration is given in the visible part of a package, then a corresponding declaration of a type with the same identifier must appear as a declarative item of the private part of the package.
The corresponding declaration must be either a full type declaration or the declaration of a task type.
In the rest of this section explanations are given in terms of full type declarations;
the same rules apply also to declarations of task types.
A private type declaration and the corresponding full type declaration define a single type.
The private type declaration, together with the visible part, define the operations that are available to outside program units (see section 7.4.2 on the operations that are available for private types).
On the other hand, the full type declaration defines other operations whose direct use is only possible within the package itself.
If the private type declaration includes a discriminant part, the full declaration must include a discriminant part that conforms (see 6.3.1 for the conformance rules) and its type definition must be a record type definition.
Conversely, if the private type declaration does not include a discriminant part, the type declared by the full type declaration (the full type) must not be an unconstrained type with discriminants.
The full type must not be an unconstrained array type.
A limited type (in particular a task type) is allowed for the full type only if the reserved word limited appears in the private type declaration (see 7.4.4).
Within the specification of the package that declares a private type and before the end of the corresponding full type declaration, a restriction applies to the use of a name that denotes the private type or a subtype of the private type and, likewise, to the use of a name that denotes any type or subtype that has a subcomponent of the private type.
The only allowed occurrences of such a name are in a deferred constant declaration, a type or subtype declaration, a subprogram specification, or an entry declaration;
moreover, occurrences within derived type definitions or within simple expressions are not allowed.
The elaboration of a private type declaration creates a private type.
If the private type declaration has a discriminant part, this elaboration includes that of the discriminant part.
The elaboration of the full type declaration consists of the elaboration of the type definition;
the discriminant part, if any, is not elaborated
(since the conforming discriminant part of the private type declaration has already been elaborated).
It follows from the given rules that neither the declaration of a variable of a private type, nor the creation by an allocator of an object of the private type are allowed before the full declaration of the type.
Similarly before the full declaration, the name of the private type cannot be used in a generic instantiation or in a representation clause.
The operations that are implicitly declared by a private type declaration include basic operations.
These are the operations involved in assignment (unless the reserved word limited appears in the declaration), membership tests, selected components for the selection of any discriminant, qualification, and explicit conversions.
For a private type T, the basic operations also include the attributes T'BASE (see 3.3.3) and T'SIZE (see 13.7.2).
For an object A of a private type, the basic operations include the attribute A'CONSTRAINED if the private type has discriminants (see 3.7.4), and in any case, the attributes A'SIZE and A'ADDRESS (see 13.7.2).
Finally, the operations implicitly declared by a private type declaration include the predefined comparison for equality and inequality unless the reserved word limited appears in the private type declaration.
The above operations, together with subprograms that have a parameter or result of the private type and that are declared in the visible part of the package, are the only operations from the package that are available outside the package for the private type.
Within the package that declares the private type, the additional operations implicitly declared by the full type declaration are also available.
However, the redefinition of these implicitly declared operations is allowed within the same declarative region, including between the private type declaration and the corresponding full declaration.
An explicitly declared subprogram hides an implicitly declared operation that has the same parameter and result type profile
(this is only possible if the implicitly declared operation is a derived subprogram or a predefined operator).
If a composite type has subcomponents of a private type and is declared outside the package that declares the private type, then the operations that are implicitly declared by the declaration of the composite type include all operations that only depend on the characteristics that result from the private type declaration alone.
(For example the operator < is not included for a one-dimensional array type.)
If the composite type is itself declared within the package that declares the private type (including within an inner package or generic package), then additional operations that depend on the characteristics of the full type are implicitly declared, as required by the rules applicable to the composite type
(for example the operator < is declared for a one-dimensional array type if the full type is discrete).
These additional operations are implicitly declared at the earliest place within the immediate scope of the composite type and after the full type declaration.
The same rules apply to the operations that are implicitly declared for an access type whose designated type is a private type or a type declared by an incomplete type declaration.
For every private type or subtype T the following attribute is defined:
Yields the value FALSE if T denotes an unconstrained nonformal private type with discriminants;
also yields the value FALSE if T denotes a generic formal private type, and the associated actual subtype is either an unconstrained type with discriminants or an unconstrained array type;
yields the value TRUE otherwise.
The value of this attribute is of the predefined type BOOLEAN.
A private type declaration and the corresponding full type declaration define two different views of one and the same type.
Outside of the defining package the characteristics of the type are those defined by the visible part.
Within these outside program units the type is just a private type and any language rule that applies only to another class of types does not apply.
The fact that the full declaration might implement the private type with a type of a particular class (for example, as an array type) is only relevant within the package itself.
The consequences of this actual implementation are, however, valid everywhere.
For example: any default initialization of components takes place;
the attribute SIZE provides the size of the full type;
task dependence rules still apply to components that are task objects.
Notes on the example:
Outside of the package KEY_MANAGER, the operations available for objects of type KEY include assignment, the comparison for equality or inequality, the procedure GET_KEY and the operator "<";
they do not include other relational operators such as ">=", or arithmetic operators.
The explicitly declared operator "<" hides the predefined operator "<" implicitly declared by the full type declaration.
Within the body of the function, an explicit conversion of X and Y to the type INTEGER is necessary to invoke the "<" operator of this type.
Alternatively, the result of the function could be written as not (X >= Y), since the operator ">=" is not redefined.
The value of the variable LAST_KEY, declared in the package body, remains unchanged between calls of the procedure GET_KEY.
(See also the Notes of section 7.3.)
If a deferred constant declaration is given in the visible part of a package then a constant declaration (that is, an object declaration declaring a constant object, with an explicit initialization) with the same identifier must appear as a declarative item of the private part of the package.
This object declaration is called the full declaration of the deferred constant.
The type mark given in the full declaration must conform to that given in the deferred constant declaration (see 6.3.1).
Multiple or single declarations are allowed for the deferred and the full declarations, provided that the equivalent single declarations conform.
Within the specification of the package that declares a deferred constant and before the end of the corresponding full declaration, the use of a name that denotes the deferred constant is only allowed in the default expression for a record component or for a formal parameter (not for a generic formal parameter).
The elaboration of a deferred constant declaration has no other effect.
The execution of a program is erroneous if it attempts to use the value of a deferred constant before the elaboration of the corresponding full declaration.
The full declaration for a deferred constant that has a given private type must not appear before the corresponding full type declaration.
This is a consequence of the rules defining the allowed uses of a name that denotes a private type (see 7.4.1).
A limited type is a type for which neither assignment nor the predefined comparison for equality and inequality is implicitly declared.
A private type declaration that includes the reserved word limited declares a limited type.
A task type is a limited type.
A type derived from a limited type is itself a limited type.
Finally, a composite type is limited if the type of any of its subcomponents is limited.
The operations available for a private type that is limited are as given in section 7.4.2 for private types except for the absence of assignment and of a predefined comparison for equality and inequality.
For a formal parameter whose type is limited and whose declaration occurs in an explicit subprogram declaration, the mode out is only allowed if this type is private and the subprogram declaration occurs within the visible part of the package that declares the private type.
The same holds for formal parameters of entry declarations and of generic procedure declarations.
The corresponding full type must not be limited if the mode out is used for any such formal parameter.
Otherwise, the corresponding full type is allowed (but not required) to be a limited type
(in particular, it is allowed to be a task type).
If the full type corresponding to a limited private type is not itself limited, then assignment for the type is available within the package, but not outside.
The following are consequences of the rules for limited types:
An explicit initialization is not allowed in an object declaration if the type of the object is limited.
A default expression is not allowed in a component declaration if the type of the record component is limited.
An explicit initial value is not allowed in an allocator if the designated type is limited.
A generic formal parameter of mode in must not be of a limited type.
The above rules do not exclude a default expression for a formal parameter of a limited type;
they do not exclude a deferred constant of a limited type if the full type is not limited.
An explicit declaration of an equality operator is allowed for a limited type (see 6.7).
Aggregates are not available for a limited composite type (see 3.6.2 and 3.7.4).
Catenation is not available for a limited array type (see 3.6.2).
Notes on the example:
In the example above, an outside subprogram making use of I_O_PACKAGE may obtain a file name by calling OPEN and later use it in calls to READ and WRITE.
Thus, outside the package, a file name obtained from OPEN acts as a kind of password;
its internal properties (such as containing a numeric value) are not known and no other operations (such as addition or comparison of internal names) can be performed on a file name.
This example is characteristic of any case where complete control over the operations of a type is desired.
Such packages serve a dual purpose.
They prevent a user from making use of the internal structure of the type.
They also implement the notion of an encapsulated data type where the only operations on the type are those given in the package specification.
The following example illustrates the use of packages in providing high level procedures with a simple interface to the user.
The problem is to define a table management package for inserting and retrieving items.
The items are inserted into the table as they are supplied.
Each inserted item has an order number.
The items are retrieved according to their order number, where the item with the lowest order number is retrieved first.
From the user's point of view, the package is quite simple.
There is a type called ITEM designating table items, a procedure INSERT for inserting items, and a procedure RETRIEVE for obtaining the item with the lowest order number.
There is a special item NULL_ITEM that is returned when the table is empty, and an exception TABLE_FULL which is raised by INSERT if the table is already full.
A sketch of such a package is given below.
Only the specification of the package is exposed to the user.
The details of implementing such packages can be quite complex;
in this case they involve a two-way linked table of internal items.
A local housekeeping procedure EXCHANGE is used to move an internal item between the busy and the free lists.
The initial table linkages are established by the initialization part.
The package body need not be shown to the users of the package.
This example illustrates a simple text handling package.
The users only have access to the visible part;
the implementation is hidden from them in the private part and the package body (not shown).
From a user's point of view, a TEXT is a variable-length string.
Each text object has a maximum length, which must be given when the object is declared, and a current value, which is a string of some length between zero and the maximum.
The maximum possible length of a text object is an implementation-defined constant.
The package defines first the necessary types, then functions that return some characteristics of objects of the type, then the conversion functions between texts and the predefined CHARACTER and STRING types, and finally some of the standard operations on varying strings.
Most operations are overloaded on strings and characters as well as on the type TEXT, in order to minimize the number of explicit conversions the user has to write.
Example of use of the text handling package:
A program opens an output file, whose name is supplied by the string NAME.
This string has the form
There are standard defaults for device, filename, and extension.
The user-supplied name is passed to EXPAND_FILE_NAME as a parameter, and the result is the expanded version, with any necessary defaults added.
The rules defining the scope of declarations and the rules defining which identifiers are visible at various points in the text of the program are described in this chapter.
The formulation of these rules uses the notion of a declarative region.
A declarative region is a portion of the program text.
A single declarative region is formed by the text of each of the following:
A subprogram declaration, a package declaration, a task declaration, or a generic declaration, together with the corresponding body, if any.
If the body is a body stub, the declarative region also includes the corresponding subunit.
If the program unit has subunits, they are also included.
An entry declaration together with the corresponding accept statements.
A record type declaration, together with a corresponding private or incomplete type declaration if any, and together with a corresponding record representation clause if any.
A renaming declaration that includes a formal part, or a generic parameter declaration that includes either a formal part or a discriminant part.
A block statement or a loop statement.
In each of the above cases, the declarative region is said to be associated with the corresponding declaration or statement.
A declaration is said to occur immediately within a declarative region if this region is the innermost region that encloses the declaration, not counting the declarative region (if any) associated with the declaration itself.
A declaration that occurs immediately within a declarative region is said to be local to the region.
Declarations in outer (enclosing) regions are said to be global to an inner (enclosed) declarative region.
A local entity is one declared by a local declaration;
a global entity is one declared by a global declaration.
Some of the above forms of declarative region include several disjoint parts
(for example, other declarative items can be between the declaration of a package and its body).
Each declarative region is nevertheless considered as a (logically) continuous portion of the program text.
Hence if any rule defines a portion of text as the text that extends from some specific point of a declarative region to the end of this region, then this portion is the corresponding subset of the declarative region
(for example it does not include intermediate declarative items between the two parts of a package).
As defined in section 3.1, the term declaration includes basic declarations, implicit declarations, and those declarations that are part of basic declarations, for example, discriminant and parameter specifications.
It follows from the definition of a declarative region that a discriminant specification occurs immediately within the region associated with the enclosing record type declaration.
Similarly, a parameter specification occurs immediately within the region associated with the enclosing subprogram body or accept statement.
The package STANDARD forms a declarative region which encloses all library units: the implicit declaration of each library unit is assumed to occur immediately within this package (see sections 8.6 and 10.1.1).
Declarative regions can be nested within other declarative regions.
For example, subprograms, packages, task units, generic units, and block statements can be nested within each other, and can contain record type declarations, loop statements, and accept statements.
For each form of declaration, the language rules define a certain portion of the program text called the scope of the declaration.
The scope of a declaration is also called the scope of any entity declared by the declaration.
Furthermore, if the declaration associates some notation with a declared entity, this portion of the text is also called the scope of this notation
(either an identifier, a character literal, an operator symbol, or the notation for a basic operation).
Within the scope of an entity, and only there, there are places where it is legal to use the associated notation in order to refer to the declared entity.
These places are defined by the rules of visibility and overloading.
The scope of a declaration that occurs immediately within a declarative region extends from the beginning of the declaration to the end of the declarative region;
this part of the scope of a declaration is called the immediate scope.
Furthermore, for any of the declarations listed below, the scope of the declaration extends beyond the immediate scope:
A declaration that occurs immediately within the visible part of a package declaration.
An entry declaration.
A component declaration.
A discriminant specification.
A parameter specification.
A generic parameter declaration.
In each of these cases, the given declaration occurs immediately within some enclosing declaration, and the scope of the given declaration extends to the end of the scope of the enclosing declaration.
In the absence of a subprogram declaration, the subprogram specification given in the subprogram body or in the body stub acts as the declaration and rule (e) applies also in such a case.
The above scope rules apply to all forms of declaration defined by section 3.1;
in particular, they apply also to implicit declarations.
Rule (a) applies to a package declaration and thus not to the package specification of a generic declaration.
For nested declarations, the rules (a) through (f) apply at each level.
For example, if a task unit is declared in the visible part of a package, the scope of an entry of the task unit extends to the end of the scope of the task unit, that is, to the end of the scope of the enclosing package.
The scope of a use clause is defined in section 8.4.
The meaning of the occurrence of an identifier at a given place in the text is defined by the visibility rules and also, in the case of overloaded declarations, by the overloading rules.
The identifiers considered in this chapter include any identifier other than a reserved word, an attribute designator, a pragma identifier, the identifier of a pragma argument, or an identifier given as a pragma argument.
The places considered in this chapter are those where a lexical element (such as an identifier) occurs.
The overloaded declarations considered in this chapter are those for subprograms, enumeration literals, and single entries.
For each identifier and at each place in the text, the visibility rules determine a set of declarations (with this identifier) that define possible meanings of an occurrence of the identifier.
A declaration is said to be visible at a given place in the text when, according to the visibility rules, the declaration defines a possible meaning of this occurrence.
Two cases arise.
The visibility rules determine at most one possible meaning.
In such a case the visibility rules are sufficient to determine the declaration defining the meaning of the occurrence of the identifier, or in the absence of such a declaration, to determine that the occurrence is not legal at the given point.
The visibility rules determine more than one possible meaning.
In such a case the occurrence of the identifier is legal at this point if and only if exactly one visible declaration is acceptable for the overloading rules in the given context
(see section 6.6 for the rules of overloading and section 8.7 for the context used for overload resolution).
A declaration is only visible within a certain part of its scope;
this part starts at the end of the declaration except in a package specification, in which case it starts at the reserved word is given after the identifier of the package specification.
(This rule applies, in particular, for implicit declarations.)
Visibility is either by selection or direct.
A declaration is visible by selection at places that are defined as follows.
For a declaration given in the visible part of a package declaration: at the place of the selector after the dot of an expanded name whose prefix denotes the package.
For an entry declaration of a given task type: at the place of the selector after the dot of a selected component whose prefix is appropriate for the task type.
For a component declaration of a given record type declaration: at the place of the selector after the dot of a selected component whose prefix is appropriate for the type; also at the place of a component simple name (before the compound delimiter =>) in a named component association of an aggregate of the type.
For a discriminant specification of a given type declaration: at the same places as for a component declaration; also at the place of a discriminant simple name (before the compound delimiter =>) in a named discriminant association of a discriminant constraint for the type.
For a parameter specification of a given subprogram specification or entry declaration: at the place of the formal parameter (before the compound delimiter =>) in a named parameter association of a corresponding subprogram or entry call.
For a generic parameter declaration of a given generic unit: at the place of the generic formal parameter (before the compound delimiter =>) in a named generic association of a corresponding generic instantiation.
Finally, within the declarative region associated with a construct other than a record type declaration, any declaration that occurs immediately within the region is visible by selection at the place of the selector after the dot of an expanded name whose prefix denotes the construct.
Where it is not visible by selection, a visible declaration is said to be directly visible.
A declaration is directly visible within a certain part of its immediate scope;
this part extends to the end of the immediate scope of the declaration, but excludes places where the declaration is hidden as explained below.
In addition, a declaration occurring immediately within the visible part of a package can be made directly visible by means of a use clause according to the rules described in section 8.4.
(See also section 8.6 for the visibility of library units.)
A declaration is said to be hidden within (part of) an inner declarative region if the inner region contains a homograph of this declaration;
the outer declaration is then hidden within the immediate scope of the inner homograph.
Each of two declarations is said to be a homograph of the other if both declarations have the same identifier and overloading is allowed for at most one of the two.
If overloading is allowed for both declarations, then each of the two is a homograph of the other if they have the same identifier, operator symbol, or character literal, as well as the same parameter and result type profile (see 6.6).
Within the specification of a subprogram, every declaration with the same designator as the subprogram is hidden; the same holds within a generic instantiation that declares a subprogram, and within an entry declaration or the formal part of an accept statement;
where hidden in this manner, a declaration is visible neither by selection nor directly.
Two declarations that occur immediately within the same declarative region must not be homographs, unless either or both of the following requirements are met:
(a) exactly one of them is the implicit declaration of a predefined operation;
(b) exactly one of them is the implicit declaration of a derived subprogram.
In such cases, a predefined operation is always hidden by the other homograph;
a derived subprogram hides a predefined operation, but is hidden by any other homograph.
Where hidden in this manner, an implicit declaration is hidden within the entire scope of the other declaration
(regardless of which declaration occurs first);
the implicit declaration is visible neither by selection nor directly.
Whenever a declaration with a certain identifier is visible from a given point, the identifier and the declared entity (if any) are also said to be visible from that point.
Direct visibility and visibility by selection are likewise defined for character literals and operator symbols.
An operator is directly visible if and only if the corresponding operator declaration is directly visible.
Finally, the notation associated with a basic operation is directly visible within the entire scope of this operation.
Note on the visibility of library units:
The visibility of library units is determined by with clauses (see 10.1.1) and by the fact that library units are implicitly declared in the package STANDARD (see 8.6).
Note on homographs:
The same identifier may occur in different declarations and may thus be associated with different entities, even if the scopes of these declarations overlap.
Overlap of the scopes of declarations with the same identifier can result from overloading of subprograms and of enumeration literals.
Such overlaps can also occur for entities declared in package visible parts and for entries, record components, and parameters, where there is overlap of the scopes of the enclosing package declarations, task declarations, record type declarations, subprogram declarations, renaming declarations, or generic declarations.
Finally overlapping scopes can result from nesting.
Note on immediate scope, hiding, and visibility:
The rules defining immediate scope, hiding, and visibility imply that a reference to an identifier within its own declaration is illegal
(except for packages and generic packages).
The identifier hides outer homographs within its immediate scope, that is, from the start of the declaration;
on the other hand, the identifier is visible only after the end of the declaration.
For this reason, all but the last of the following declarations are illegal:
A use clause achieves direct visibility of declarations that appear in the visible parts of named packages.
For each use clause, there is a certain region of text called the scope of the use clause.
This region starts immediately after the use clause.
If a use clause is a declarative item of some declarative region, the scope of the clause extends to the end of the declarative region.
If a use clause occurs within a context clause of a compilation unit, the scope of the use clause extends to the end of the declarative region associated with the compilation unit.
In order to define which declarations are made directly visible at a given place by use clauses, consider the set of packages named by all use clauses whose scopes enclose this place, omitting from this set any packages that enclose this place.
A declaration that can be made directly visible by a use clause (a potentially visible declaration) is any declaration that occurs immediately within the visible part of a package of the set.
A potentially visible declaration is actually made directly visible except in the following two cases:
A potentially visible declaration is not made directly visible if the place considered is within the immediate scope of a homograph of the declaration.
Potentially visible declarations that have the same identifier are not made directly visible unless each of them is either an enumeration literal specification or the declaration of a subprogram
(by a subprogram declaration, a renaming declaration, a generic instantiation, or an implicit declaration).
The elaboration of a use clause has no other effect.
The above rules guarantee that a declaration that is made directly visible by a use clause cannot hide an otherwise directly visible declaration.
The above rules are formulated in terms of the set of packages named by use clauses.
Consequently, the following lines of text all have the same effect (assuming only one package P).
Example of conflicting names in two packages:
Example of name identification with a use clause:
A renaming declaration declares another name for an entity.
The elaboration of a renaming declaration evaluates the name that follows the reserved word renames and thereby determines the entity denoted by this name (the renamed entity).
At any point where a renaming declaration is visible, the identifier, or operator symbol of this declaration denotes the renamed entity.
The first form of renaming declaration is used for the renaming of objects.
The renamed entity must be an object of the base type of the type mark.
The properties of the renamed object are not affected by the renaming declaration.
In particular, its value and whether or not it is a constant are unaffected;
similarly, the constraints that apply to an object are not affected by renaming
(any constraint implied by the type mark of the renaming declaration is ignored).
The renaming declaration is legal only if exactly one object has this type and can be denoted by the object name.
The following restrictions apply to the renaming of a subcomponent that depends on discriminants of a variable.
The renaming is not allowed if the subtype of the variable, as defined in a corresponding object declaration, component declaration, or component subtype indication, is an unconstrained type; or if the variable is a generic formal object (of mode in out).
Similarly if the variable is a formal parameter, the renaming is not allowed if the type mark given in the parameter specification denotes an nconstrained type whose discriminants have default expressions.
The second form of renaming declaration is used for the renaming of exceptions;
the third form, for the renaming of packages.
The last form of renaming declaration is used for the renaming of subprograms and entries.
The renamed subprogram or entry and the subprogram specification given in the renaming declaration must have the same parameter and result type profile (see 6.6).
The renaming declaration is legal only if exactly one visible subprogram or entry satisfies the above requirements and can be denoted by the given subprogram or entry name.
In addition, parameter modes must be identical for formal parameters that are at the same parameter position.
The subtypes of the parameters and result (if any) of a renamed subprogram or entry are not affected by renaming.
These subtypes are those given in the original subprogram declaration, generic instantiation, or entry declaration (not those of the renaming declaration); even for calls that use the new name.
On the other hand, a renaming declaration can introduce parameter names and default expressions that differ from those of the renamed subprogram;
named associations of calls with the new subprogram name must use the new parameter name;
calls with the old subprogram name must use the old parameter names.
A procedure can only be renamed as a procedure.
Either of a function or operator can be renamed as either of a function or operator;
for renaming as an operator, the subprogram specification given in the renaming declaration is subject to the rules given in section 6.7 for operator declarations.
Enumeration literals can be renamed as functions;
similarly, attributes defined as functions (such as SUCC and PRED) can be renamed as functions.
An entry can only be renamed as a procedure;
the new name is only allowed to appear in contexts that allow a procedure name.
An entry of a family can be renamed, but an entry family cannot be renamed as a whole.
Example of a renaming declaration with new parameter names:
Example of a renaming declaration with a new default expression:
Renaming may be used to resolve name conflicts and to act as a shorthand.
Renaming with a different identifier or operator symbol does not hide the old name;
the new name and the old name need not be visible at the same points.
The attributes POS and VAL cannot be renamed since the corresponding specifications cannot be written;
the same holds for the predefined multiplying operators with a universal fixed result.
Calls with the new name of a renamed entry are procedure call statements and are not allowed at places where the syntax requires an entry call statement in conditional and timed entry calls;
similarly, the COUNT attribute is not available for the new name.
A task object that is declared by an object declaration can be renamed as an object.
However, a single task cannot be renamed since the corresponding task type is anonymous.
For similar reasons, an object of an anonymous array type cannot be renamed.
No syntactic form exists for renaming a generic unit.
A subtype can be used to achieve the effect of renaming a type (including a task type) as in
The predefined types (for example the types BOOLEAN, CHARACTER and INTEGER) are the types that are declared in a predefined package called STANDARD;
this package also includes the declarations of their predefined operations.
The package STANDARD is described in Annex C.
Apart from the predefined numeric types, the specification of the package STANDARD must be the same for all implementations of the language.
The package STANDARD forms a declarative region which encloses every library unit and consequently the main program;
the declaration of every library unit is assumed to occur immediately within this package.
The implicit declarations of library units are assumed to be ordered in such a way that the scope of a given library unit includes any compilation unit that mentions the given library unit in a with clause.
However, the only library units that are visible within a given compilation unit are as follows: they include the library units named by all with clauses that apply to the given unit, and moreover, if the given unit is a secondary unit of some library unit, they include this library unit.
If all block statements of a program are named, then the name of each program unit can always be written as an expanded name starting with STANDARD
(unless this package is itself hidden).
If a type is declared in the visible part of a library package, then it is a consequence of the visibility rules that a basic operation (such as assignment) for this type is directly visible at places where the type itself is not visible (whether by selection or directly).
However this operation can only be applied to operands that are visible and the declaration of these operands requires the visibility of either the type or one of its subtypes.
Overloading is defined for subprograms, enumeration literals, operators, and single entries, and also for the operations that are inherent in several basic operations such as assignment, membership tests, allocators, the literal null, aggregates, and string literals.
For overloaded entities, overload resolution determines the actual meaning that an occurrence of an identifier has, whenever the visibility rules have determined that more than one meaning is acceptable at the place of this occurrence;
overload resolution likewise determines the actual meaning of an occurrence of an operator or some basic operation.
At such a place all visible declarations are considered.
The occurrence is only legal if there is exactly one interpretation of each constituent of the innermost complete context;
a complete context is one of the following: a declaration, a statement, a representation clause.
When considering possible interpretations of a complete context, the only rules considered are the syntax rules, the scope and visibility rules, and the rules of the form described below.
Any rule that requires a name or expression to have a certain type, or to have the same type as another name or expression.
Any rule that requires the type of a name or expression to be a type of a certain class; similarly, any rule that requires a certain type to be a discrete, integer, real, universal, character, boolean, or nonlimited type.
Any rule that requires a prefix to be appropriate for a certain type.
Any rule that specifies a certain type as the result type of a basic operation, and any rule that specifies that this type is of a certain class.
The rules that require the type of an aggregate or string literal to be determinable solely from the enclosing complete context (see 4.3 and 4.2).
Similarly, the rules that require the type of the prefix of an attribute, the type of the expression of a case statement, or the type of the operand of a type conversion, to be determinable independently of the context (see 4.1.4, 5.4, 4.6, and 6.4.1).
The rules given in section 6.6, for the resolution of overloaded subprogram calls; in section 4.6, for the implicit conversions of universal expressions; in section 3.6.1, for the interpretation of discrete ranges with bounds having a universal type; and in section 4.1.3, for the interpretation of an expanded name whose prefix denotes a subprogram or an accept statement.
Subprogram names used as pragma arguments follow a different rule: the pragma can apply to several overloaded subprograms, as explained in section 6.3.2 for the pragma INLINE, in section 11.7 for the pragma SUPPRESS, and in section 13.9 for the pragma INTERFACE.
Similarly, the simple names given in context clauses (see 10.1.1) and in address clauses (see 13.5) follow different rules.
If there is only one possible interpretation, the identifier denotes the corresponding entity.
However, this does not mean that the occurrence is necessarily legal since other requirements exist which are not considered for overload resolution; for example, the fact that an expression is static, the parameter modes, whether an object is constant, conformance rules, forcing occurrences for a representation clause, order of elaboration, and so on.
Similarly, subtypes are not considered for overload resolution.
(the violation of a constraint does not make a program illegal but raises an exception during program execution).
A loop parameter specification is a declaration, and hence a complete context.
Rules that require certain constructs to have the same parameter and result type profile fall under the category (a);
the same holds for rules that require conformance of two constructs since conformance requires that corresponding names be given the same meaning by the visibility and overloading rules.
Rules of the form (a): address clause 13.5, assignment 5.2, choice 3.7.3 4.3.2 5.4, component association 4.3.1 4.3.2, conformance rules 9.5, default expression 3.7 3.7.1 6.1 12.1.1, delay statement 9.6, discrete range 3.6.1 5.5 9.5, discriminant constraint 3.7.2, enumeration representation clause 13.3, generic parameter association 12.3.1, index constraint 3.6.1, index expression 4.1.1 4.1.2 9.5, initial value 3.2.1, membership test 4.5.2, parameter association 6.4.1, parameter and result type profile 8.5 12.3.6, qualified expression 4.7, range constraint 3.5, renaming of an object 8.5, result expression 5.8
Rules of the form (b): abort statement 9.10, assignment 5.2, case expression 5.4, condition 5.3 5.5 5.7 9.7.1, discrete range 3.6.1 5.5 9.5, fixed point type declaration 3.5.9, floating point type declaration 3.5.7, integer type declaration 3.5.4, length clause 13.2, membership test 4.4, number declaration 3.2.2, record representation clause 13.4, selected component 4.1.3, short-circuit control form 4.4, val attribute 3.5.5
Rules of the form (c): indexed component 4.1.1, selected component 4.1.3, slice 4.1.2
Rules of the form (d): aggregate 4.3, allocator 4.8, membership test 4.4, null literal 4.2, numeric literal 2.4, short-circuit control form 4.4, string literal 4.2
The execution of a program that does not contain a task is defined in terms of a sequential execution of its actions, according to the rules described in other chapters of this manual.
These actions can be considered to be executed by a single logical processor.
Tasks are entities whose executions proceed in parallel in the following sense.
Each task can be considered to be executed by a logical processor of its own.
Different tasks (different logical processors) proceed independently, except at points where they synchronize.
Some tasks have entries.
An entry of a task can be called by other tasks.
A task accepts a call of one of its entries by executing an accept statement for the entry.
Synchronization is achieved by rendezvous between a task issuing an entry call and a task accepting the call.
Some entries have parameters;
entry calls and accept statements for such entries are the principal means of communicating values between tasks.
The properties of each task are defined by a corresponding task unit which consists of a task specification and a task body.
Task units are one of the four forms of program unit of which programs can be composed.
The other forms are subprograms, packages and generic units.
The properties of task units, tasks, and entries, and the statements that affect the interaction between tasks (that is, entry call statements, accept statements, delay statements, select statements, and abort statements) are described in this chapter.
Parallel tasks (parallel logical processors) may be implemented on multicomputers, multiprocessors, or with interleaved execution on a single physical processor.
On the other hand, whenever an implementation can detect that the same effect can be guaranteed if parts of the actions of a given task are executed by different physical processors acting in parallel, it may choose to execute them in this way;
in such a case, several physical processors implement a single logical processor.
A task unit consists of a task specification and a task body.
A task specification that starts with the reserved words task type declares a task type.
The value of an object of a task type designates a task having the entries, if any, that are declared in the task specification;
these entries are also called entries of this object.
The execution of the task is defined by the corresponding task body.
A task specification without the reserved word type defines a single task.
A task declaration with this form of specification is equivalent to the declaration of an anonymous task type immediately followed by the declaration of an object of the task type, and the task unit identifier names the object.
In the remainder of this chapter, explanations are given in terms of task type declarations;
the corresponding explanations for single task declarations follow from the stated equivalence.
The simple name at the start of a task body must repeat the task unit identifier.
Similarly if a simple name appears at the end of the task specification or body, it must repeat the task unit identifier.
Within a task body, the name of the corresponding task unit can also be used to refer to the task object that designates the task currently executing the body;
furthermore, the use of this name as a type mark is not allowed within the task unit itself.
For the elaboration of a task specification, entry declarations and representation clauses, if any, are elaborated in the order given.
Such representation clauses only apply to the entries declared in the task specification (see 13.5).
The elaboration of a task body has no other effect than to establish that the body can from then on be used for the execution of tasks designated by objects of the corresponding task type.
The execution of a task body is invoked by the activation of a task object of the corresponding type (see 9.3).
The optional exception handlers at the end of a task body handle exceptions raised during the execution of the sequence of statements of the task body (see 11.4).
Examples of specifications of task types:
Examples of specifications of single tasks:
Example of task specification and corresponding body:
A task specification specifies the interface of tasks of the task type with other tasks of the same or of different types, and also with the main program.
A task type is a limited type (see 7.4.4).
Hence neither assignment nor the predefined comparison for equality and inequality are defined for objects of task types;
moreover, the mode out is not allowed for a formal parameter whose type is a task type.
A task object is an object whose type is a task type.
The value of a task object designates a task that has the entries of the corresponding task type, and whose execution is specified by the corresponding task body.
If a task object is the object, or a subcomponent of the object, declared by an object declaration, then the value of the task object is defined by the elaboration of the object declaration.
If a task object is the object, or a subcomponent of the object, created by the evaluation of an allocator, then the value of the task object is defined by the evaluation of the allocator.
For all parameter modes, if an actual parameter designates a task, the associated formal parameter designates the same task;
the same holds for a subcomponent of an actual parameter and the corresponding subcomponent of the associated formal parameter;
finally, the same holds for generic parameters.
Example of access type designating task objects:
Since a task type is a limited type, it can appear as the definition of a limited private type in a private part, and as a generic actual parameter associated with a formal parameter whose type is a limited type.
On the other hand, the type of a generic formal parameter of mode in must not be a limited type and hence cannot be a task type.
Task objects behave as constants (a task object always designates the same task) since their values are implicitly defined either at declaration or allocation, or by a parameter association, and since no assignment is available.
However the reserved word constant is not allowed in the declaration of a task object since this would require an explicit initialization.
A task object that is a formal parameter of mode in is a constant (as is any formal parameter of this mode).
If an application needs to store and exchange task identities, it can do so by defining an access type designating the corresponding task objects and by using access values for identification purposes (see above example).
Assignment is available for such an access type as for any access type.
Subtype declarations are allowed for task types as for other types, but there are no constraints applicable to task types.
A task body defines the execution of any task that is designated by a task object of the corresponding task type.
The initial part of this execution is called the activation of the task object, and also that of the designated task;
it consists of the elaboration of the declarative part, if any, of the task body.
The execution of different tasks, in particular their activation, proceeds in parallel.
If an object declaration that declares a task object occurs immediately within a declarative part, then the activation of the task object starts after the elaboration of the declarative part
(that is, after passing the reserved word begin following the declarative part);
similarly if such a declaration occurs immediately within a package specification, the activation starts after the elaboration of the declarative part of the package body.
The same holds for the activation of a task object that is a subcomponent of an object declared immediately within a declarative part or package specification.
The first statement following the declarative part is executed only after conclusion of the activation of these task objects.
Should an exception be raised by the activation of one of these tasks, that task becomes a completed task (see 9.4);
other tasks are not directly affected.
Should one of these tasks thus become completed during its activation, the exception TASKING_ERROR is raised upon conclusion of the activation of all of these tasks (whether successfully or not);
the exception is raised at a place that is immediately before the first statement following the declarative part
(immediately after the reserved word begin).
Should several of these tasks thus become completed during their activation, the exception TASKING_ERROR is raised only once.
Should an exception be raised by the elaboration of a declarative part or package specification, then any task that is created (directly or indirectly) by this elaboration and that is not yet activated becomes terminated and is therefore never activated
(see section 9.4 for the definition of a terminated task).
For the above rules, in any package body without statements, a null statement is assumed.
For any package without a package body, an implicit package body containing a single null statement is assumed.
If a package without a package body is declared immediately within some program unit or block statement, the implicit package body occurs at the end of the declarative part of the program unit or block statement;
if there are several such packages, the order of the implicit package bodies is undefined.
A task object that is the object, or a subcomponent of the object, created by the evaluation of an allocator is activated by this evaluation.
The activation starts after any initialization for the object created by the allocator;
if several subcomponents are task objects, they are activated in parallel.
The access value designating such an object is returned by the allocator only after the conclusion of these activations.
Should an exception be raised by the activation of one of these tasks, that task becomes a completed task;
other tasks are not directly affected.
Should one of these tasks thus become completed during its activation, the exception TASKING_ERROR is raised upon conclusion of the activation of all of these tasks (whether successfully or not);
the exception is raised at the place where the allocator is evaluated.
Should several of these tasks thus become completed during their activation, the exception TASKING_ERROR is raised only once.
Should an exception be raised by the initialization of the object created by an allocator (hence before the start of any activation), any task designated by a subcomponent of this object becomes terminated and is therefore never activated.
An entry of a task can be called before the task has been activated.
If several tasks are activated in parallel, the execution of any of these tasks need not await the end of the activation of the other tasks.
A task may become completed during its activation either because of an exception or because it is aborted (see 9.10).
Each task depends on at least one master.
A master is a construct that is either a task, a currently executing block statement or subprogram, or a library package
(a package declared within another program unit is not a master).
The dependence on a master is a direct dependence in the following two cases:
The task designated by a task object that is the object, or a subcomponent of the object, created by the evaluation of an allocator depends on the master that elaborates the corresponding access type definition.
The task designated by any other task object depends on the master whose execution creates the task object.
Furthermore, if a task depends on a given master that is a block statement executed by another master, then the task depends also on this other master, in an indirect manner;
the same holds if the given master is a subprogram called by another master, and if the given master is a task that depends (directly or indirectly) on another master.
Dependences exist for objects of a private type whose full declaration is in terms of a task type.
A task is said to have completed its execution when it has finished the execution of the sequence of statements that appears after the reserved word begin in the corresponding body.
Similarly a block or a subprogram is said to have completed its execution when it has finished the execution of the corresponding sequence of statements.
For a block statement, the execution is also said to be completed when it reaches an exit, return, or goto statement transferring control out of the block.
For a procedure, the execution is also said to be completed when a corresponding return statement is reached.
For a function, the execution is also said to be completed after the evaluation of the result expression of a return statement.
Finally the execution of a task, block statement, or subprogram is completed if an exception is raised by the execution of its sequence of statements and there is no corresponding handler, or, if there is one, when it has finished the execution of the corresponding handler.
If a task has no dependent task, its termination takes place when it has completed its execution.
After its termination, a task is said to be terminated.
If a task has dependent tasks, its termination takes place when the execution of the task is completed and all dependent tasks are terminated.
A block statement or subprogram body whose execution is completed is not left until all of its dependent tasks are terminated.
Termination of a task otherwise takes place if and only if its execution has reached an open terminate alternative in a select statement (see 9.7.1), and the following conditions are satisfied:
The task depends on some master whose execution is completed (hence not a library package).
Each task that depends on the master considered is either already terminated or similarly waiting on an open terminate alternative of a select statement.
When both conditions are satisfied, the task considered becomes terminated, together with all tasks that depend on the master considered.
The rules given for termination imply that all tasks that depend (directly or indirectly) on a given master and that are not already terminated, can be terminated (collectively) if and only if each of them is waiting on an open terminate alternative of a select statement and the execution of the given master is completed.
The usual rules apply to the main program.
Consequently, termination of the main program awaits termination of any dependent task even if the corresponding task type is declared in a library package.
On the other hand, termination of the main program does not await termination of tasks that depend on library packages;
the language does not define whether such tasks are required to terminate.
For an access type derived from another access type, the corresponding access type definition is that of the parent type;
the dependence is on the master that elaborates the ultimate parent access type definition.
A renaming declaration defines a new name for an existing entity and hence creates no further dependence.
Entry calls and accept statements are the primary means of synchronization of tasks, and of communicating values between tasks.
An entry declaration is similar to a subprogram declaration and is only allowed in a task specification.
The actions to be performed when an entry is called are specified by corresponding accept statements.
An entry declaration that includes a discrete range (see 3.6.1) declares a family of distinct entries having the same formal part (if any); that is, one such entry for each value of the discrete range.
The term single entry is used in the definition of any rule that applies to any entry other than one of a family.
The task designated by an object of a task type has (or owns) the entries declared in the specification of the task type.
Within the body of a task, each of its single entries or entry families can be named by the corresponding simple name.
The name of an entry of a family takes the form of an indexed component, the family simple name being followed by the index in parentheses;
the type of this index must be the same as that of the discrete range in the corresponding entry family declaration.
Outside the body of a task an entry name has the form of a selected component, whose prefix denotes the task object, and whose selector is the simple name of one of its single entries or entry families.
A single entry overloads a subprogram, an enumeration literal, or another single entry if they have the same identifier.
Overloading is not defined for entry families.
A single entry or an entry of an entry family can be renamed as a procedure as explained in section 8.5.
The parameter modes defined for parameters of the formal part of an entry declaration are the same as for a subprogram declaration and have the same meaning (see 6.2).
The syntax of an entry call statement is similar to that of a procedure call statement, and the rules for parameter associations are the same as for subprogram calls (see 6.4.1 and 6.4.2).
An accept statement specifies the actions to be performed at a call of a named entry
(it can be an entry of a family).
The formal part of an accept statement must conform to the formal part given in the declaration of the single entry or entry family named by the accept statement
(see section 6.3.1 for the conformance rules).
If a simple name appears at the end of an accept statement, it must repeat that given at the start.
An accept statement for an entry of a given task is only allowed within the corresponding task body; excluding within the body of any program unit that is, itself, inner to the task body; and excluding within another accept statement for either the same single entry or an entry of the same family.
(One consequence of this rule is that a task can execute accept statements only for its own entries.)
A task body can contain more than one accept statement for the same entry.
For the elaboration of an entry declaration, the discrete range, if any, is evaluated and the formal part, if any, is then elaborated as for a subprogram declaration.
Execution of an accept statement starts with the evaluation of the entry index (in the case of an entry of a family).
Execution of an entry call statement starts with the evaluation of the entry name; this is followed by any evaluations required for actual parameters in the same manner as for a subprogram call (see 6.4).
Further execution of an accept statement and of a corresponding entry call statement are synchronized.
If a given entry is called by only one task, there are two possibilities:
If the calling task issues an entry call statement before a corresponding accept statement is reached by the task owning the entry, the execution of the calling task is suspended.
If a task reaches an accept statement prior to any call of that entry, the execution of the task is suspended until such a call is received.
When an entry has been called and a corresponding accept statement has been reached, the sequence of statements, if any, of the accept statement is executed by the called task
(while the calling task remains suspended).
This interaction is called a rendezvous.
Thereafter, the calling task and the task owning the entry continue their execution in parallel.
If several tasks call the same entry before a corresponding accept statement is reached, the calls are queued;
there is one queue associated with each entry.
Each execution of an accept statement removes one call from the queue.
The calls are processed in the order of arrival.
An attempt to call an entry of a task that has completed its execution raises the exception TASKING_ERROR at the point of the call, in the calling task;
similarly, this exception is raised at the point of the call if the called task completes its execution before accepting the call
(see also 9.10 for the case when the called task becomes abnormal).
The exception CONSTRAINT_ERROR is raised if the index of an entry of a family is not within the specified discrete range.
Examples of entry declarations:
Examples of entry calls:
Examples of accept statements:
The formal part given in an accept statement is not elaborated;
it is only used to identify the corresponding entry.
An accept statement can call subprograms that issue entry calls.
An accept statement need not have a sequence of statements even if the corresponding entry has parameters.
Equally, it can have a sequence of statements even if the corresponding entry has no parameters.
The sequence of statements of an accept statement can include return statements.
A task can call its own entries but it will, of course, deadlock.
The language permits conditional and timed entry calls (see 9.7.2 and 9.7.3).
The language rules ensure that a task can only be in one entry queue at a given time.
If the bounds of the discrete range of an entry family are integer literals, the index (in an entry name or accept statement) must be of the predefined type INTEGER (see 3.6.1).
The execution of a delay statement evaluates the simple expression, and suspends further execution of the task that executes the delay statement, for at least the duration specified by the resulting value.
The simple expression must be of the predefined fixed point type DURATION;
its value is expressed in seconds;
a delay statement with a negative value is equivalent to a delay statement with a zero value.
Any implementation of the type DURATION must allow representation of durations (both positive and negative) up to at least 86400 seconds (one day);
the smallest representable duration, DURATION'SMALL must not be greater than twenty milliseconds
(whenever possible, a value not greater than fifty microseconds should be chosen).
Note that DURATION'SMALL need not correspond to the basic clock cycle, the named number SYSTEM.TICK (see 13.7).
The definition of the type TIME is provided in the predefined library package CALENDAR.
The function CLOCK returns the current value of TIME at the time it is called.
The functions YEAR, MONTH, DAY and SECONDS return the corresponding values for a given value of the type TIME; the procedure SPLIT returns all four corresponding values.
Conversely, the function TIME_OF combines a year number, a month number, a day number, and a duration, into a value of type TIME.
The operators "+" and "-" for addition and subtraction of times and durations, and the relational operators for times, have the conventional meaning.
The exception TIME_ERROR is raised by the function TIME_OF if the actual parameters do not form a proper date.
This exception is also raised by the operators "+" and "-" if, for the given operands, these operators cannot return a date whose year number is in the range of the corresponding subtype, or if the operator "-" cannot return a result that is in the range of the type DURATION.
The second example causes the loop to be repeated every INTERVAL seconds on average.
This interval between two successive iterations is only approximate.
However, there will be no cumulative drift as long as the duration of each iteration is (sufficiently) less than INTERVAL.
There are three forms of select statements.
One form provides a selective wait for one or more alternatives.
The other two provide conditional and timed entry calls.
This form of the select statement allows a combination of waiting for, and selecting from, one or more alternatives.
The selection can depend on conditions associated with each alternative of the selective wait.
A selective wait must contain at least one accept alternative.
In addition a selective wait can contain either a terminate alternative (only one), or one or more delay alternatives, or an else part;
these three possibilities are mutually exclusive.
A select alternative is said to be open if it does not start with when and a condition, or if the condition is TRUE.
It is said to be closed otherwise.
For the execution of a selective wait, any conditions specified after when are evaluated in some order that is not defined by the language;
open alternatives are thus determined.
For an open delay alternative, the delay expression is also evaluated.
Similarly, for an open accept alternative for an entry of a family, the entry index is also evaluated.
Selection and execution of one open alternative, or of the else part, then completes the execution of the selective wait;
the rules for this selection are described below.
Open accept alternatives are first considered.
Selection of one such alternative takes place immediately if a corresponding rendezvous is possible, that is, if there is a corresponding entry call issued by another task and waiting to be accepted.
If several alternatives can thus be selected, one of them is selected arbitrarily
(that is, the language does not define which one).
When such an alternative is selected, the corresponding accept statement and possible subsequent statements are executed.
If no rendezvous is immediately possible and there is no else part, the task waits until an open selective wait alternative can be selected.
Selection of the other forms of alternative or of an else part is performed as follows:
An open delay alternative will be selected if no accept alternative can be selected before the specified delay has elapsed
(immediately, for a negative or zero delay in the absence of queued entry calls);
any subsequent statements of the alternative are then executed.
If several delay alternatives can thus be selected (that is, if they have the same delay), one of them is selected arbitrarily.
The else part is selected and its statements are executed if no accept alternative can be immediately selected, in particular, if all alternatives are closed.
An open terminate alternative is selected if the conditions stated in section 9.4 are satisfied.
It is a consequence of other rules that a terminate alternative cannot be selected while there is a queued entry call for any entry of the task.
The exception PROGRAM_ERROR is raised if all alternatives are closed and there is no else part.
Examples of a select statement:
Example of a task body with a select statement:
A selective wait is allowed to have several open delay alternatives.
A selective wait is allowed to have several open accept alternatives for the same entry.
A conditional entry call issues an entry call that is then canceled if a rendezvous is not immediately possible.
For the execution of a conditional entry call, the entry name is first evaluated.
This is followed by any evaluations required for actual parameters as in the case of a subprogram call (see 6.4).
The entry call is canceled if the execution of the called task has not reached a point where it is ready to accept the call
(that is, either an accept statement for the corresponding entry, or a select statement with an open accept alternative for the entry),
or if there are prior queued entry calls for this entry.
If the called task has reached a select statement, the entry call is canceled if an accept alternative for this entry is not selected.
If the entry call is canceled, the statements of the else part are executed.
Otherwise, the rendezvous takes place; and the optional sequence of statements after the entry call is then executed.
The execution of a conditional entry call raises the exception TASKING_ERROR if the called task has already completed its execution
(see also 9.10 for the case when the called task becomes abnormal).
A timed entry call issues an entry call that is canceled if a rendezvous is not started within a given delay.
For the execution of a timed entry call, the entry name is first evaluated.
This is followed by any evaluations required for actual parameters as in the case of a subprogram call (see 6.4).
The expression stating the delay is then evaluated, and the entry call is finally issued.
If a rendezvous can be started within the specified duration
(or immediately, as for a conditional entry call, for a negative or zero delay),
it is performed and the optional sequence of statements after the entry call is then executed.
Otherwise, the entry call is canceled when the specified duration has expired, and the optional sequence of statements of the delay alternative is executed.
The execution of a timed entry call raises the exception TASKING_ERROR if the called task completes its execution before accepting the call
(see also 9.10 for the case when the called task becomes abnormal).
Each task may (but need not) have a priority, which is a value of the subtype PRIORITY (of the type INTEGER) declared in the predefined library package SYSTEM (see 13.7).
A lower value indicates a lower degree of urgency;
the range of priorities is implementation-defined.
A priority is associated with a task if a pragma
appears in the corresponding task specification; the priority is given by the value of the expression.
A priority is associated with the main program if such a pragma appears in its outermost declarative part.
At most one such pragma can appear within a given task specification or for a subprogram that is a library unit, and these are the only allowed places for this pragma.
A pragma PRIORITY has no effect if it occurs in a subprogram other than the main program.
The specification of a priority is an indication given to assist the implementation in the allocation of processing resources to parallel tasks when there are more tasks eligible for execution than can be supported simultaneously by the available processing resources.
The effect of priorities on scheduling is defined by the following rule:
If two tasks with different priorities are both eligible for execution and could sensibly be executed using the same physical processors and the same other processing resources, then it cannot be the case that the task with the lower priority is executing while the task with the higher priority is not.
For tasks of the same priority, the scheduling order is not defined by the language.
For tasks without explicit priority, the scheduling rules are not defined, except when such tasks are engaged in a rendezvous.
If the priorities of both tasks engaged in a rendezvous are defined, the rendezvous is executed with the higher of the two priorities.
If only one of the two priorities is defined, the rendezvous is executed with at least that priority.
If neither is defined, the priority of the rendezvous is undefined.
The priority of a task is static and therefore fixed.
However, the priority during a rendezvous is not necessarily static since it also depends on the priority of the task calling the entry.
Priorities should be used only to indicate relative degrees of urgency;
they should not be used for task synchronization.
For a task object or value T the following attributes are defined:
Yields the value FALSE when the execution of the task designated by T is either completed or terminated, or when the task is abnormal.
Yields the value TRUE otherwise.
The value of this attribute is of the predefined type BOOLEAN.
Yields the value TRUE if the task designated by T is terminated.
Yields the value FALSE otherwise.
The value of this attribute is of the predefined type BOOLEAN.
In addition, the representation attributes STORAGE_SIZE, SIZE, and ADDRESS are defined for a task object T or a task type T (see 13.7.2).
The attribute COUNT is defined for an entry E of a task unit T.
The entry can be either a single entry or an entry of a family
(in either case the name of the single entry or entry family can be either a simple or an expanded name).
This attribute is only allowed within the body of T, but excluding within any program unit that is, itself, inner to the body of T.
Yields the number of entry calls presently queued on the entry E
(if the attribute is evaluated by the execution of an accept statement for the entry E, the count does not include the calling task).
The value of this attribute is of the type universal integer.
Algorithms interrogating the attribute E'COUNT should take precautions to allow for the increase of the value of this attribute for incoming entry calls, and its decrease, for example with timed entry calls.
An abort statement causes one or more tasks to become abnormal, thus preventing any further rendezvous with such tasks.
The determination of the type of each task name uses the fact that the type of the name is a task type.
For the execution of an abort statement, the given task names are evaluated in some order that is not defined by the language.
Each named task then becomes abnormal unless it is already terminated;
similarly, any task that depends on a named task becomes abnormal unless it is already terminated.
Any abnormal task whose execution is suspended at an accept statement, a select statement, or a delay statement becomes completed;
any abnormal task whose execution is suspended at an entry call, and that is not yet in a corresponding rendezvous, becomes completed and is removed from the entry queue;
any abnormal task that has not yet started its activation becomes completed (and hence also terminated).
This completes the execution of the abort statement.
The completion of any other abnormal task need not happen before completion of the abort statement.
It must happen no later than when the abnormal task reaches a synchronization point that is one of the following: the end of its activation; a point where it causes the activation of another task; an entry call; the start or the end of an accept statement; a select statement; a delay statement; an exception handler; or an abort statement.
If a task that calls an entry becomes abnormal while in a rendezvous, its termination does not take place before the completion of the rendezvous (see 11.5).
The call of an entry of an abnormal task raises the exception TASKING_ERROR at the place of the call.
Similarly, the exception TASKING_ERROR is raised for any task that has called an entry of an abnormal task, if the entry call is still queued or if the rendezvous is not yet finished
(whether the entry call is an entry call statement, or a conditional or timed entry call);
the exception is raised no later than the completion of the abnormal task.
The value of the attribute CALLABLE is FALSE for any task that is abnormal (or completed).
If the abnormal completion of a task takes place while the task updates a variable, then the value of this variable is undefined.
An abort statement should be used only in extremely severe situations requiring unconditional termination.
A task is allowed to abort any task, including itself.
The normal means of communicating values between tasks is by entry calls and accept statements.
If two tasks read or update a shared variable (that is, a variable accessible by both), then neither of them may assume anything about the order in which the other performs its operations, except at the points where they synchronize.
Two tasks are synchronized at the start and at the end of their rendezvous.