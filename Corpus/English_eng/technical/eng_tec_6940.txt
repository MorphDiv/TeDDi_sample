# language_name_wals:	English
# language_name_glotto:	English
# ISO_6393:	eng
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/en.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

All windows and dialogs.
SÃ©bastien Granjoux
seb.sfo@free.fr
Windows and dialogs
Start a program without the debugger.
Philip Chimento
philip.chimento@gmail.com
Run a program
If
From the
The current program and several parameters can be set on the
From the
If your program needs data files, you probably have to install it at least one time before running it. See
Run parameters dialog
Run Parameters Dialog
The
Program
This is the program that will be executed if you run a program with or without the debugger. The drop-down list allows you to select programs created by the current project, but you can click on the
Arguments
These are the command line arguments used by your program. The drop-down list keeps an history of the last arguments used.
Working Directory
The working directory is the current directory when your program will be run.
Environment Variables
You can click on the drop-down section, to display all environment variables those will be accessible by your program. By default, it includes all the current environment variables, they are display in light gray.
You can click on the
You can click on the
You can click on the
When a variable has not the same value than in the current environment, it is displayed in black.
Run in Terminal
This has to be checked to run the program in a terminal allowing you to provide inputs and see its outputs using the standard Unix streams. It is not necessary for programs having a graphical interface.
Project wizard template.
Project wizard template
A project template is composed of a bunch of files which can be processed by a powerful template processing engine called
This
Create a new project from scratch.
Create a project
New projects are created from templates.
From the
Or from the drop-down list of the
Select the icon representing the type of the project you want to create and click on
Leave the mouse over a project icon for a second and a small pop-up message will appear showing more information about this type of project.
Depending on the selected project type, you will have to enter different information. When you are done, click on
All informations are grouped in pages, typically you will have to fill two or three pages. You can go back at any time using the button
Keep the mouse over the button or typing area for a second to get a small pop-up message with more details about the corresponding setting.
After filling out all the information pages, you will get a summary page listing the main information about your project. Nothing has been written to your disk yet at this point. Click on
Each project type corresponds to a template.
Add or remove a target from a project.
Add or remove targets
If the project backend supports it, you can add or remove targets in your project without editing the project file. A target groups files together. It is typically used to represent a program, with all its source files as its children.
Add a target
Select the directory where you want to add the new target in the
Or from the
You can select another directory in the bottom
Enter a target name and select the type of the target in the drop-down list below. Depending on your project backend, various types of target are possible.
Target names are typically restricted to letters, digits and the underscore, so it's safer to avoid other characters.
When you have chosen the target name, type and parent, click on the
Remove a target
Select the target you want to remove in the
Confirm the removal. The target and all its properties will be removed from the project file. All its files stay untouched on your hard disk.
Project manager.
Project manager plugin

Whatever the underlying backend, the graphical interface is the same but some functions might be disabled.
Project Backend Plugin
Add or remove packaged libraries from a target.
Add or remove packaged libraries
When you have created a module containing one or more libraries, you can add it to a target.
Add a packaged library to a target
Libraries cannot be added directly to a target. You need to put them into a module first and add this module to the target.
Select the program where you want to add the new library in the
Or from the
You need to select the target where you want to add the module in the
When you are done, click on the
Remove a packaged library from a target
Select the library you want to remove in the
Confirm the removal. This library will be removed from the target.
Add or remove libraries from a project.
Add or remove new libraries
On Linux, most libraries are packaged to be easily used. When you need one of these libraries,
Add packaged libraries in a new module
A library cannot be added directly to your program; you first need to create a module for it, which is just a group of libraries.
Select the program where you want to add the new library in the
Or from the
You will get a list of all the packaged libraries installed on your system. You can check one or more libraries.
If the library you want does not appear here, perhaps it is because it is not installed on your system. Launch the application you use to install new programs and search for the library name. The package you need often has a "dev" or "devel" suffix and should include header files and a pkg-config file with a
After selecting one library, a module name will be automatically generated but you can change it. When you are done, click on the
Read the
Add packaged libraries in an existing module
Select the module where you want to add the new library in the
In the list of all packaged libraries, check the additional libraries wanted. Check that expected module name is selected in the bottom text box. Then click on the
Read the
Remove a packaged library from a module
Select the library you want to remove in the
Confirm the removal. This library will be removed from the project file.
Add or remove non-packaged libraries from a project.
Add or remove non-packaged libraries
Add a non-packaged library to a target
In order to use a library in C, you need to tell the compiler where the header files are, and tell the linker where to find the needed libraries. The issue is that your program will not compile on another computer if the header and the libraries are elsewhere.
Select the directory containing the program where you want to add the library in the
Or from the
If the header files are installed in a standard location (
You might have to expand the
Next, you need to add the library to a target. Select the target where you want to add the library in the
You need to set the
If the library is in not in a standard directory,
Remove a non packaged library from a target
Select the target that has the library you want to remove in the
Remove the library from the
Add or remove files from a project.
Add or remove files
If the project backend supports it, you can add or remove files in your project without editing the project file.
Add files
Select the target where you want to add the new source file in the
Or from the
The target allows you to group files, and has a type which defines how the files are used inside. A program target contains source files, which will be compiled to create the target. On the other hand, a data target only groups data files which will be installed in the same place.
You can select another target in the top
Click on the
When you have chosen the target and the files, click on the
Some project formats require the file to be under the project directory. Added source files outside the project directory are automatically copied inside to fulfill this requirement.
Remove a file
Select the file you want to remove in the
Confirm the removal. The file will only be removed from the project, not from your disk.
Import an existing project.
Import a project

From the
Select
Or Select
After selecting an existing project, the

Makefile project backend.
Makefile project backend plugin
A makefile is probably the most common way to build software on all kinds of platforms. A makefile contains a list or rules describing which commands have to be run in order to generate a target from a list of dependencies. When building a program, the target is an object file and the dependencies are the source files. The target of one rule can be a dependency of another one, allowing several rules to be chained in order to make a final target.
It is a low-level, general tool, making it difficult to find all source files and targets of a project. So
If the project backend is not able to find all the source files, you can try to use the directory backend instead. It does not recognize any targets but should get all source files.
Changing properties, or adding or removing targets and source files are disabled with this backend, as automatically editing the makefile is not implemented. It has to be changed by hand using the text editor. When the makefile is saved, it is automatically reloaded though.
@@image: 'figures/anjuta-in-action.png'; md5=a31f1c85a4a14032fcd30ab6f6d6b3c0
Introduction
Introduction to



We hope you will have a good time using
The following screenshot illustrates some of the things you will find in


All help topics.
Index
Directory project backend.
Directory project backend plugin
This is the simplest project backend. There is no project file. It works like a file viewer, considering all files matching typical source extensions (for example
This backend is a useful workaround if your project does not have a corresponding backend in
It is not possible to add or change anything with a project using this backend. But if you create a source file in the project directory, with the right extension, it will be added automatically.
Monitor expressions and variables.
Watch expressions
Watch expressions, or watches for short, are expressions that the debugger evaluates and prints the result of every time the program is stopped; for example, after every
List watched expressions
From the
Like local variables, all watch expressions are displayed in a tree with children used to represent structure or array members.
Variable
The name of the variable or the expression.
Value
The variable or expression value.
Type
The type of the variable or of the expression result.
Update watches
Watch expressions can be updated automatically as soon as the program is stopped or on user request.
To set a watch expression to update automatically:
In the
To update a watch expression manually:
In the
To update all watch expressions manually at once:
In the
Add a watch on an expression
To add an expression to the watch list:
From the
Enter the expression to watch. Check
An expression can be evaluated and then added as a watch like this:
From the
Click on
Remove a watch
You can remove an expression from the watches list.
In the
All watches can be removed at the same time.
In the
Changing the value of a variable
If a watch expression corresponds to a variable, you can change its value.
In the
Enter the new value.
Debugging tips and tricks.
Debugging tips
Fixing GLib/GTK+ critical errors
Sometimes it can be difficult to track down where GLib critical errors are occurring, since they do not stop the program. You can set the program to stop as soon as it gets a GLib critical error, by setting the environment variable
Open the
Click the plus sign next to
Click
Fill in
Click
Run the program with the debugger by selecting
Use the program until the critical error occurs.
When the debugger stops your program, look at the
The top function with frame number 0 is in GLib, so you have to look down in the stack. Typically the error originates from the topmost function that belongs to your program.
Examine threads.
Threads
List threads
A program can be composed of several threads. All these threads are executed independently, having their own registers, stack and local variables, but sharing global variables.
From the
The window shows the following information about each thread:
Active
This contains a yellow arrow that points to the active thread.
ID
This is a number corresponding to each thread.
File
The name of the file containing the function corresponding to the current frame of the current thread.
Line
The line number of the function corresponding to the current frame of the current thread.
Function
The name of the function corresponding to the frame of the current thread.
Address
The address of the function corresponding to the frame of the current thread.
Change current thread
The current thread is the thread whose stack and local variables are currently displayed in the debugger.
In the
Right-click and select
View current function
Double-click, or right-click and select
Stopping and continuing.
Stop and step
Like a video editing session, the program can be executed in slow motion with the ability to go forward, pause, stop, and so on. This is essential for tracking program behavior. You cannot go backward yet, though.
Step in
From the
Single stepping executes only one statement of the program (from the place where it has stopped) and then returns control. If the statement that is executed contains one function, the debugger tries to step inside the functions (in the sequence in which the functions are executed). Once the statement is executed and control is passed back, you can study your program's state.
If the
Step over
From the
Stepping over is similar to stepping except that it does not stop inside any function in the statement being executed.
If the
Step out
From the
Stepping out executes the current function until it returns to the calling function.
Run and continue
From the
This command restarts the program and lets it run until a breakpoint is encountered or the program exits.
Run To
From the
This restarts the program and lets it run until the line or the address (if the
Stopping the Program
From the
This interrupts the program and returns control to the debugger, allowing you to perform debugging tasks, like inspecting data or adding breakpoints.
Examine the stack.
Stack
List stack frames
A stack frame is the area of the stack associated to each function call. It lists all functions and their arguments in the sequence they were called. Each stack frame is numbered starting from 0 for the current function. You can only view the stack frames while the debugger is running.
From the
Each stack frame contains the following information:
This contains a yellow arrow to represent the active stack frame. By default it is frame 0, the current function. All evaluations and local variables are relative to this active frame. You can change the active stack frame to examine local variables in other functions.
Frame
This is the frame number starting from 0 for the current function. The first function of your program, for example
The name of the file containing the function corresponding to this frame.
The line number of the function corresponding to this frame.
The name of the function corresponding to this frame.
The address of the function corresponding to this frame.
The function arguments.
Change the current stack frame
In the
Right-click and select
View the current function
Get a stack trace
In the
Start a program with the debugger.
Debug a program
Start a program in the debugger
The current program is defined in the
From the
A program can be more difficult to debug if it is highly optimized or if debugging information is missing. Whether optimization and debugging information are enabled, is defined in the configure step. Normally, there is a Debug configuration available, that turns off optimization and includes all debugging information. Anjuta displays a warning if this configuration is not used. See
Debug an already running application
The debugger can be used on an already running application.
From the
Select a process in the
Debug a remote application
The debugger can be used to debug an application running on another computer connected through a TCP or serial connection.
From the
Select the type of the connection to the remote application,
For a TCP connection, fill in the
For a serial connection, fill in the text box below with the serial device name, for example
Click on
Stop the debugger
The debugger and the program can be stopped at any time like this:
From the
Attach to process dialog
Attach to Process Dialog
The
Hide paths
This hides command paths in the process list if checked.
Hide process parameters
This hides the command line arguments in the process list if checked.
Display process tree
If unchecked, the processes are displayed in a list. If checked, the processes are displayed in a tree.
Examine local variables.
Local variables
Local variables of the current frame (the current function in which the program control is present) are displayed in the
Listing local variables
From the
All local variables are displayed in a tree view with children used to represent structure or array members.
The name of the variable.
The variable value.
The type of the variable.
In the
Type the new value.
Examine additional program information.
Miscellaneous information
The debugger can tell you various information about the program while it is running.
View shared libraries
From the
This opens a window which will list all shared libraries the program has loaded and their locations in memory. It also shows whether each library's symbol table is loaded or not.
View signals
From the
This lists all available signals with a small description and three columns to specify what to do when a signal is received:
Stop
The debugger stops the program execution when the program receives this signal.
Print
The debugger displays the received signal.
Pass
The debugger passes the signal to the program.
The context menu that is displayed when you click the right mouse button has all its items disabled because the corresponding functions are not implemented yet.
Evaluate expressions and modify variables.
Examine expressions
Inspect an expression and modify a variable
While you are debugging a program, you can find out the value of an expression or variable while the program is paused. It is also sometimes useful to change the value of a variable.
From the
If the expression is a variable name, you can change its value by clicking on the
Control program execution.
Control execution
Examine program Data.
Examine data
Use custom debugger command.
Custom command
You can send a custom command to the debugger like this:
From the
Enter your command.
The output of the command is displayed in the message window used by the debugger.
The command is sent directly to the debugger without performing any checks. For example, if you set a breakpoint like this, it will not appear in the
Examine CPU information.
CPU
View CPU registers
From the
Registers whose values have changed since the last stop are in red. It is possible to change the value of any register by clicking in the value column and entering a new value.
View memory
From the
The first column displays memory addresses in hexadecimal, the second displays memory contents in hexadecimal and the last column shows memory contents in ASCII.
The addressing space of even a 32-bit microprocessor is very large (4 gigabytes), so it is very difficult to go to a particular address with the scrollbar. But you can click the right mouse button and select
View Disassembly
From the
The first column displays addresses in hexadecimal. In the second column, you can have a label starting at the beginning of the line and ending with a colon or a assembly-language instruction indented by 4 space characters.
The position in the disassembly window will be changed to the program counter value when the program is stopped.
Managing breakpoints.
Breakpoints
Breakpoints are used to stop the execution of the program at a particular point so that the state of the program can be examined at those locations.
Listing breakpoints
From the
This view has the following columns:
Location
This is the position of the breakpoint in the source file. When the breakpoint is set by the debugger, you can get additional information such as the function containing the breakpoint.
This field is filled with the address of the breakpoint when it is set by the debugger.
This always displays
Condition
This is the breakpoint condition. It is empty if no condition is defined.
Pass count
When the debugger is not running, this column displays the pass count of the breakpoint, or zero if it is not defined.
When the debugger is running, if the pass count is zero, this column displays the number of times this breakpoint has been triggered. If the pass count is not zero, both numbers are displayed. The pass count is the second number.
State
This is the state of the breakpoint. It may be
Pending:
the breakpoint is not set in your program.
Permanent:
the breakpoint is set (its id number is displayed in parentheses).
Temporary:
the breakpoint is set but will be deleted if reached.
All breakpoints are kept across Anjuta sessions even if they correspond to a non-existing locations, for example in a source file of a shared library not loaded yet. In this case their states are set as pending.
Setting breakpoints
From the
Fill in the
Another solution is to use the toggle breakpoint function. If there is no breakpoint on the current line, it will add one. Otherwise, it will remove it.
From the
Editing breakpoints
You can't change the location of a breakpoint; create a new breakpoint instead. However, you can change the break condition or the pass count. To edit a breakpoint:
Select a breakpoint in the
Right click in the
Change the
Removing breakpoints
You can remove a breakpoint using the toggle breakpoint function described above. However, if you want to remove more than one breakpoint or the breakpoint is in a different file than the one you are editing, you can use the breakpoint window:
Right click in the
To remove all breakpoints:
From the
Enabling and disabling breakpoints
Sometimes you might want to disable a breakpoint temporarily instead of deleting it altogether. To disable or re-enable a breakpoint:
Click on the
You can disable all breakpoints using:
From the
Used to create or edit a breakpoint
Breakpoint Dialog
This is the position of the breakpoint. For an existing breakpoint, you cannot change this. You can set a breakpoint at a certain line number, or at the beginning of a function. Use one of the following formats:

function_name

The break condition is an expression which should evaluate to a boolean value
If you leave this field blank the condition is always considered
Pass Count
The debugger can also skip the breakpoint a certain number of times before breaking. If the pass count is not zero, then the debugger will have to encounter the breakpoint this number of times before breaking.
The pass count has a higher priority than the condition. Only when the pass count has been reached will the debugger evaluate the condition if it is present and break the program's execution.
Autotools build preferences dialog.
Autotools Build Preferences Dialog
The dialog allows you to set global options for building files.
Run several commands at a time

Continue on errors
By default
Translate messages
By default errors and warnings message are translated. It has two drawbacks though. In order to recognize errors and warnings the translation of
Highlight build warnings and errors in editor
Errors and warnings during the build are displayed and highlighted in the message window. By checking this option, they are higlighted in the editor too.
Install as root
Installing a program needs to copy files in system directory which are often not writable by the user. If this check box is checked, you can choose to use
Autotools build plugin
This plugin is targeted at autotools projects but as they use make it is useful for other kind of projects using make.
Make command used
Here is a list of the targets used by the plugin. They are implemented in all autotools projects but you need to implement them if you use a custom makefile.
object_file_name
make
Use to compile an source file. The object file name is found by replacing the source file extension with the corresponding object extension.
make
Use to build all targets in a directory.
make install
Use to install all targets in a directory.
make clean
Use to delete all file built in a directory.
make dist
Use to build a distributation package, called only in the project directory.
As make comes with default rules allowing it to compile and link a C program without needing a makefile. You can compile a C program from a single source file without a makefile nor a project.
Install targets or project.
Install targets
Unless your project is very simple, it needs some data files like user interface description files. These files are typically copied in standard directories and read from there. It means that you cannot run your program from the build directory. You need to install it in order to copy all these files in the final place, by example in a subdirectory of
There are several possibilities to install targets or a project.
From the
From the
From the
Click on the right mouse button to make the
From the
Click on the right mouse button to make the
If you install the program in a system directory, you can have to use
Create a distribution package.
Create a distribution package
The standard way to distribute a autotools project is as a compressed tar archive containing all source files. The user will have to decompress it, then compile and install it on his system using the command sequence
From the
Configure an autotools project and manage configurations.
Configure a project
Before compiling and building files, an autotools project has to be configured. This step is needed to set global options, to check that all required libraries and programs are installed on your system and to generate appropriate build scripts.
Configure the project
From the
Keep the default configuration, select a new configuration or create a new one. You can inspect and modify all configuration options. See
Click on
The configuration could fail if some libraries or programs are not installed or do not have the right version. The error message tell you what is missing.
Change the configuration
From the
If the project has not been already configured, it will be automatically configured before building any file.
Remove configuration
It is a like cleaning the project but it removes even more files. You need to re-configure your project to build it afterward.
From the
Autotools configure dialog
Autotools Configure Dialog
The
Regenerate Project
If checked, the project will be completely regenerated, else only the configure step is done.
Configuration
You can have several configurations having their own options and build directory, this text box allows to name them. Typically you have already defined a Default configuration, a Debug configuration making programs easier to debug (keeping intermediate variables and code ordering) and an Optimized configuration generating faster programs but increasing build time. You can define additional custom configurations.
Build Directory
Select here the build directory, it can be the project directory or a subdirectory. This is particularly useful when switching between different configurations to avoid rebuilding the whole project.
With autotools, you cannot have one configuration using a different directory if you already have one configuration using the project directory. You need to remove it first.
Some autotools project cannot be built outside the project directory. You can still use different configurations but they all have to use the project directory and everything will be recompiled on each change of the configuration.
Configure Options
This text box list all command line arguments used by the configure step. All arguments are separated by spaces and must be quoted if they contains a space. Each configuration fills this text box with default values that you can modify.
Each autotools project supports a common list of arguments but can have specify arguments. You can have a list of all accepted arguments by running
Compile files.
Compile files
Most programming language allow you to compile an individual source file. It reads the file, checks for errors and convert into an intermediate object file. Most errors happens in this step, so it is useful to compile a file after modifying it to check for errors. There are several ways to do it.
From the
From the
Click on the right mouse button to make the
From the
Click on the right mouse button to make the
You do not need to save your file before compiling it, it will be done automatically by
Remove built files.
Clean targets
It can be useful to delete all files created by the build process. By example if the all dependencies are not taken into account and a modified file does not trigger a recompiling as it should, deleting all files will fix this. There are several way to do this
From the
From the
Click on the right mouse button to make the
Click on the right mouse button to make the
Build targets or project.
Build targets
A target is a file created from source files. Typically, it is a program or a library, but it could also be documentation if the documentation needs processing, for example.
The build command compiles all needed source files, and possibly links them with some other files, like libraries, in order to create the target. If some source files are already compiled and haven't been modified, they are not be recompiled, in order to save time. There are several ways to trigger a build.
From the
From the
Click on the right mouse button to make the
Click on the right mouse button to make the
Johannes Schmid
jhs@gnome.org
Getting started with the user interface editor
Start the user-interface editor
Create a new user-interface file
Open an existing user-interface file
Add widgets
Organize widgets in containers
Common widgets and what they are used for
Add widget properties
Autoconnecting signals
Add signals to the signal editor
Create the signal handler
C
Python
Vala
Code navigation using the symbol browser
Using the symbol browser
Navigating in the editor
Auto-indentation
Configuring auto-indentation
Manual configuration
Modelines
Indenting blocks of code
Using the API reference
Browsing the API reference
Jump to the API reference using shortcuts in the editor
Autocompletion and calltips
Autocompletion is not working
Effective coding using calltips
@@image: 'figures/anjuta_logo.png'; md5=82636133d39ac4a688facd76954b8b29
Help for Anjuta DevStudio.
Anjuta
Anjuta DevStudio

Project Management
Coding and code navigation
Building Project
Debugging Program
User interface editor
Reference
translator-credits