# language_name_wals:	Russian
# language_name_glotto:	Russian
# ISO_6393:	rus
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Cyrl
# special_characters:	NA
# short_description:	ada83
# source:	https://object.pouta.csc.fi/OPUS-ada83/v1/raw/ru.zip
# copyright_short:	http://opus.nlpl.eu/ada83.php
# copyright_long:	http://opus.nlpl.eu/ada83.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	part
# comments:	NA

В языке не определено, что происходит с внешними файлами после завершения работы главной программы
(в частности, если соответствующие файлы не были закрыты).
Результат выполнения ввода-вывода над ссылочными типами зависит от реализации.
Открытый файл имеет текущий вид, который является значением одного из перечисленных типов: ,,
Эти значения соответствуют случаям, когда можно осуществить либо только чтение, либо чтение и запись, либо только запись.
Вид файла может быть изменён.
Некоторые из операций управления файлами являются общими для всех трёх пакетов ввода-вывода.
Эти операции над последовательными файлами и файлами прямого доступа описаны в разд.
14.2.1.
Дополнительные особенности ввода-вывода текстов описаны в разд.
14.3.1.
В пакете IO_EXCEPTIONS определены все исключения, которые могут быть возбуждены при вызове подпрограммы ввода-вывода;
ситуации их возбуждения описаны либо при описании подпрограмм ввода и вывода (и в разд.
14.4), либо в приложении F для ошибочных ситуаций, зависящих от реализации.
Каждая конкретизация настраиваемых пакетов SEQUENTIAL_IO и DIRECT_IO задаёт разные типы FILE_TYPE;
уникальным является тип FILE_TYPE в пакете TEXT_IO.
Устройство с двусторонней связью часто может быть промоделировано двумя файлами с последовательным доступом, связанными с этим устройством; один — вида IN_FILE, а другой — вида OUT_FILE.
Реализация может ограничить число файлов, которые могут быть связаны с данным внешним файлом.
В этом случае результат такого разделения внешнего файла несколькими объектами файлового типа зависит от реализации.
Для внешних файлов определены два сорта доступа: последовательный доступ и прямой доступ.
В настраиваемых пакетах SEQUENTIAL_IO и DIRECT_IO описаны соответствующие файловые типы и связанные с ними операции.
Объект файлового типа, используемый для последовательного доступа, называется последовательным файлом, а используемый для прямого доступа — прямым файлом.
При последовательном доступе файл рассматривается как последовательность значений, которые передаются в порядке их поступления (от программы или из окружения).
Если файл открыт, то передача начинается с начала файла.
При прямом доступе файл рассматривается как набор элементов, занимающих последовательные позиции в линейном порядке;
значение может быть передано в элемент файла (или из него), находящийся в любой выбранной позиции.
Позиция элемента задаётся его индексом, который является положительным числом определяемого реализацией целого типа COUNT.
Индекс первого элемента в файле (если он есть) равен единице;
индекс последнего элемента (если он есть) называется текущим размером;
текущий размер файла, не содержащего ни одного элемента, равен нулю.
Текущий размер — это характеристика внешнего файла.
Открытый прямой файл имеет текущий индекс, который будет использован следующей операцией для чтения или записи.
По открытии прямого файла значение текущего индекса устанавливается равным единице.
Текущий индекс прямого файла — это характеристика не внешнего файла, а связанного с ним объекта файлового типа.
Для прямых файлов допустимы все три вида файла.
Для последовательных файлов допустимы только виды IN_FILE и OUT_FILE.
В этом разделе описаны процедуры и функции, предназначенные для управления внешними файлами;
их описания повторены в каждом из трёх пакетов последовательного, прямого и текстового ввода-вывода.
Процедуры CREATE, OPEN и RESET при вводе-выводе текстов имеют дополнительные эффекты, описанные в разд.
14.3.1.
Устанавливает новый внешний файл с данным именем и формой и связывает его с данным файлом (FILE).
После этого данный файл открывается.
Текущий вид файла устанавливается в заданный вид доступа (MODE).
По умолчанию для последовательного и текстового ввода-вывода устанавливается вид OUT_FILE, а для прямого ввода-вывода — INOUT_FILE.
Для прямого доступа размер созданного файла зависит от реализации.
Пустая строка под именем (NAME) задаёт внешний файл, который не доступен после окончания главной программы (временный файл).
Пустая строка для формы (FORM) задаёт параметры по умолчанию, определяемые реализацией для внешнего файла.
Если данный файл уже открыт, то возбуждается исключение STATUS_ERROR.
Если указанная в качестве параметра NAME строка не допускает идентификацию внешнего файла, то возбуждается исключение NAME_ERROR.
Если для заданного вида файла окружение не может обеспечить создание внешнего файла с заданными именем и формой, то возбуждается исключение USE_ERROR (в отсутствие возбуждения исключения NAME_ERROR).
Связывает данный файл с существующим внешним файлом, имеющим данные имя и форму, а текущий вид данного файла устанавливается параметром MODE.
Данный файл открывается.
Если данный файл уже открыт, то возбуждается исключение STATUS_ERROR.
Если строка, заданная параметром NAME, не допускает идентификацию внешнего файла, то возбуждается исключение NAME_ERROR;
в частности, это исключение возбуждается, если внешнего файла с указанным именем не существует.
Если для заданного вида файла окружение не может обеспечить открытие внешнего файла с данными именем и формой, то возбуждается исключение USE_ERROR (в отсутствие возбуждения исключения NAME_ERROR).
Уничтожает связь между данным файлом и соответствующим ему внешним файлом.
Данный файл закрывается.
Если данный файл не открыт, то возбуждается исключение STATUS_ERROR.
Уничтожает внешний файл, связанный с данным файлом.
Данный файл закрывается, внешний файл прекращает существование.
Если данный файл не открыт, то возбуждается исключение STATUS_ERROR.
Если уничтожение внешнего файла не может быть обеспечено окружением, то возбуждается исключение USE_ERROR (все такие случаи должны быть описаны в приложении F).
Устанавливает данный файл в состояние, позволяющее возобновить чтение или запись значений его элементов с начала файла;
в частности, для прямого доступа это означает, что текущий индекс становится равным единице.
Если задан параметр MODE, то в соответствии с ним устанавливается текущий вид данного файла.
Если файл не открыт, то возбуждается исключение STATUS_ERROR.
Если для внешнего файла окружение не может осуществить возврат к началу файла или установку данного вида, то возбуждается исключение USE_ERROR.
Возвращает текущий вид данного файла.
Если файл не открыт, то возбуждается исключение STATUS_ERROR.
Возвращает строку, которая однозначно идентифицирует внешний файл, связанный с данным файлом (она может быть использована в операции OPEN).
Если окружение допускает альтернативные спецификации имени (например, сокращения), то возвращаемая функцией строка обязана соответствовать полной спецификации имени.
Если данный файл не открыт, то возбуждается исключение STATUS_ERROR.
Возвращает строку, определяющую форму внешнего файла, связанного в этот момент с данным файлом.
Если окружение допускает альтернативные спецификации форм (например, сокращения, использующие возможности по умолчанию), то возвращаемая функцией строка обязана соответствовать полной спецификации
(т.е. она обязана явно содержать все выбранные возможности, включая возможности по умолчанию).
Если данный файл не открыт, то возбуждается исключение STATUS_ERROR.
Если файл открыт (т.е. связан с внешним файлом), то возвращает значение TRUE, в противном случае — FALSE.
В этом разделе описаны операции для последовательного ввода и вывода.
В случае применения любой из этих операций к закрытому файлу возбуждается исключение STATUS_ERROR.
Оперирует над файлом вида IN_FILE.
Читает элемент данного файла и возвращает значение этого элемента через параметр ITEM.
Если вид файла не IN_FILE, то возбуждает исключение MODE_ERROR.
Если из файла нельзя больше читать ни одного элемента, то возбуждает исключение END_ERROR.
Если прочитанный элемент не может быть интерпретирован как значение типа ELEMENT_TYPE, то возбуждается исключение DATA_ERROR;
однако для реализации допустимо опускать такую проверку в случае, если она слишком сложна.
Оперирует над файлом вида OUT_FILE.
Записывает в данный файл значение параметра ITEM.
Если вид файла не OUT_FILE, то возбуждается исключение MODE_ERROR.
Если внешний файл уже заполнен до конца, то возбуждается исключение USE_ERROR.
Оперирует над файлом вида IN_FILE.
Если из файла больше нельзя читать ни одного элемента, то возвращает значение TRUE, в противном случае — FALSE.
Если вид файла не IN_FILE, то возбуждается исключение MODE_ERROR.
В этом разделе описаны операции для прямого ввода и вывода.
При применении любой из этих операций к файлу, который не открыт, возбуждается исключение STATUS_ERROR.
Оперируют над файлами вида IN_FILE или INOUT_FILE.
Первая из операций предварительно устанавливает текущий индекс данного файла равным значению параметра FROM.
Затем (для обеих подпрограмм) через параметр ITEM возвращает значение элемента файла, позиция которого задана текущим индексом файла;
наконец, увеличивает текущий индекс на единицу.
Если вид данного файла — OUT_FILE, то возбуждается исключение MODE_ERROR.
Если используемое при чтении значение индекса оказалось больше размера внешнего файла, то возбуждается исключение END_ERROR.
Если прочитанный элемент нельзя интерпретировать как значение типа ELEMENT_TYPE, то возбуждается исключение DATA_ERROR;
однако для реализации допустимо опускать такую проверку в случае, если она слишком сложна.
Оперируют над файлами вида INOUT_FILE или OUT_FILE.
Первая из операций предварительно устанавливает индекс данного файла равным значению параметра ТО.
Затем (для обеих подпрограмм) элементу данного файла, позиция которого указана текущим индексом, присваивается значение параметра ITEM;
наконец, увеличивается текущий индекс на единицу.
Если вид данного файла — IN_FILE, то возбуждается исключение MODE_ERROR.
Если внешний файл заполнен до конца, то возбуждается исключение USE_ERROR.
Оперирует над файлом любого вида.
Устанавливает текущий индекс данного файла равным значению параметра ТО
(которое может превышать текущий размер файла).
Оперирует над файлом любого вида.
Возвращает текущий индекс данного файла.
Оперирует над файлом любого вида.
Возвращает текущий размер внешнего файла, связанного с данным файлом.
Оперирует над файлом вида IN_FILE или INOUT_FILE.
Если значение текущего индекса больше размера внешнего файла, то возвращает значение TRUE, в противном случае — FALSE.
Если вид данного файла — OUT_FILE, то возбуждается исключение MODE_ERROR.
В этом разделе описывается пакет TEXT_IO, который обеспечивает возможности ввода и вывода в удобной для читателя форме.
Каждый файл читается или записывается последовательно посимвольно, символы последовательно группируются в строчки, последовательность строчек — в страницы.
В разд.
14.3.10 приведена спецификация этого пакета.
Возможности управления файлами, описанные в разд.
14.2.1 и 14.2.2, применимы и для текстового ввода-вывода.
Однако вместо процедур READ и WRITE используются процедуры GET и PUT, которые осуществляют ввод и вывод значений соответствующих типов для текстовых файлов.
Эти значения передаются процедурами PUT и возвращаются процедурами GET через параметр ITEM.
Существует несколько совмещённых процедур с такими именами, но с различными типами параметра ITEM.
Процедуры GET анализируют вводимые последовательности символов как лексемы (см. гл. 2) и возвращают соответствующие значения;
процедуры PUT выводят данные значения в виде соответствующих лексем.
Процедуры GET и PUT могут также вводить и выводить отдельные символы, рассматриваемые не как лексемы, а как значения символьного типа.
Для числового и перечислимого типов параметра ITEM помимо процедур PUT и GET, записывающих в текстовой файл или читающих из него, существуют аналогичные процедуры с параметром типа STRING.
Эти процедуры производят точно такие же анализ и формирование последовательности символов, как и подобные им процедуры с файловым параметром.
Для всех процедур GET и PUT, оперирующих над текстовыми файлами, а также для многих других подпрограмм существуют формы как с параметром файлового типа, так и без него.
Каждая процедура GET оперирует над файлом ввода; каждая процедура PUT — над файлом вывода.
Если файл не задан, то работа производится над файлом ввода по умолчанию или над файлом вывода по умолчанию.
В начале выполнения программы файлами ввода и вывода по умолчанию являются так называемые стандартный файл ввода и стандартный файл вывода.
Эти файлы всегда открыты и имеют текущие виды IN_FILE и OUT_FILE соответственно, они связаны с двумя определяемыми реализацией внешними файлами.
Существуют процедуры для замены текущего файла ввода по умолчанию и текущего файла вывода по умолчанию.
Логически текстовой файл представляет собой последовательность страниц, страница — последовательность строчек, а строчка — последовательность символов;
конец строчки помечается признаком конца строчки;
конец страницы помечается комбинацией признака конца строчки, за которым непосредственно следует признак конца страницы;
конец файла помечается комбинацией следующих непосредственно друг за другом признака конца строчки, признака конца страницы и признака конца файла.
Признаки конца генерируются во время вывода; либо при вызове специально предусмотренных для этого процедур, либо неявно — как составная часть других операций, например когда для файла заданы ограничения длины строчки, длины страницы или оба этих ограничения.
Язык не определяет, что фактически представляют из себя признаки конца; это зависит от реализации.
Некоторые из описанных ниже процедур могут опознавать или сами генерировать признаки конца, которые не обязаны всегда быть реализованы именно как символы или последовательности символов.
Пользователю безразлично, представлены ли в данной конкретной реализации признаки конца как символы (и если да, то какие именно), так как он никогда явно не вводит и явно не выводит управляющие символы.
Язык не определяет результата ввода или вывода управляющих символов (кроме символа горизонтальной табуляции).
Символы строчки пронумерованы начиная с единицы;
номер символа называется номером столбца.
Для признака конца строчки также определён номер столбца; его значение на единицу больше числа символов в строчке.
Строчки страницы и страницы файла пронумерованы аналогично.
Текущий номер столбца — это номер следующего (передаваемого) символа или признака конца строчки.
Текущий номер строчки — это номер текущей строчки в текущей странице.
Текущий номер страницы — это номер текущей страницы в файле.
Все эти номера являются значениями подтипа POSITIVE_COUNT типа COUNT
(нулевое значение типа COUNT по соглашению используется для специальных целей).
Для файла вывода могут быть заданы максимальная длина строчки и максимальная длина страницы.
Если они заданы, а значение не помещается на текущей строчке, то автоматически до вывода значения будет начата новая строчка;
если далее эта новая строчка не может быть размещена на текущей странице, то автоматически до вывода будет начата новая страница.
Имеются функции для определения максимальной длины строчки и максимальной длины страницы.
После открытия файла вида OUT_FILE оба этих значения равны нулю; это значит, что длина страницы и длина строчки считаются неограниченными.
(Следовательно, весь файл вывода состоит из одной строчки, если только не используются подпрограммы явного управления структурой строчек и страниц файла.)
Для этих целей служит константа UNBOUNDED.
Для текстовых файлов допустимы только виды IN_FILE и OUT_FILE.
К ним также применимы приведённые в разд.
14.2.1 подпрограммы управления внешними файлами и приведённая в разд.
14.2.2 функция END_OF_FILE для последовательного ввода-вывода.
Имеется также вариант функции END_OF_FILE, который выдаёт результат для текущего файла ввода по умолчанию.
Указанные процедуры для текстовых файлов характеризуются следующим:
Процедуры CREATE и OPEN: после открытия файла вида OUT_FILE длина страницы и длина строчки не ограничены (имеют по соглашению значение 0).
После открытия файла вида IN_FILE или OUT_FILE текущие номера столбца, строчки и страницы устанавливаются равными единице.
Процедура CLOSE: если файл имеет текущий вид OUT_FILE, а текущая страница ещё не завершена, то результат эквивалентен вызову подпрограммы NEW_PAGE;
затем выводится признак конца файла.
Процедура RESET: если файл имеет текущий вид OUT_FILE, а текущая страница ещё не завершена, то результат эквивалентен вызову подпрограммы NEW_PAGE;
затем выводится признак конца файла.
Если новый вид файла — OUT_FILE, то длина строчки и длина страницы становятся неограниченными.
Для всех видов файла текущие номера столбца, строчки и страницы устанавливаются равными единице.
При попытке изменить вид текущего файла ввода по умолчанию или текущего файла вывода по умолчанию процедура RESET возбуждает исключение MODE_ERROR.
Следующие подпрограммы служат для управления файлами по умолчанию, используемыми при отсутствии параметра-файла в процедурах PUT, GET или в других описанных ниже операциях текстового ввода-вывода.
Оперирует над файлом вида IN_FILE.
Устанавливает текущим файлом ввода по умолчанию файл, заданный параметром FILE.
Если данный файл не открыт, то возбуждается исключение STATUS_ERROR.
Если вид данного файла отличен от IN_FILE, то возбуждается исключение MODE_ERROR.
Оперирует над файлом вида OUT_FILE.
Устанавливает текущим файлом вывода по умолчанию файл, заданный параметром FILE.
Если данный файл не открыт, то возбуждается исключение STATUS_ERROR.
Если вид данного файла отличен от OUT_FILE, то возбуждается исключение MODE_ERROR.
Возвращает стандартный файл ввода (см. 14.3).
Возвращает стандартный файл вывода (см. 14.3).
Возвращает текущий файл ввода по умолчанию.
Возвращает текущий файл вывода по умолчанию.
Стандартные файлы ввода и вывода не могут быть открыты, закрыты, переустановлены и уничтожены, потому что в соответствующих процедурах параметр FILE имеет вид In out.
Описанные в этом разделе подпрограммы связаны со структурой строчек и страниц файла вида OUT_FILE.
Они оперируют либо над файлом, заданным первым параметром, либо при отсутствии такого параметра над текущим файлом вывода по умолчанию.
Эти подпрограммы служат для вывода текста с заданными максимальными длинами строчки или страницы.
В этих случаях признаки конца строчки и страницы выводятся неявно и автоматически, по мере необходимости.
Когда длины строчки и страницы не ограничены (т.е. когда они имеют по соглашению значение нуль), как в случае заново открытого файла, новые строчки или страницы можно начать лишь в результате явного вызова соответствующих подпрограмм.
Во всех случаях, если заданный файл не открыт, то возбуждается исключение STATUS_ERROR;
если вид этого файла отличен от OUT_FILE, то возбуждается исключение MODE_ERROR.
Устанавливает максимальную длину строчки заданного файла вывода равной числу символов, задаваемому значением параметра ТО.
Нулевое значение параметра ТО задаёт неограниченную длину строчки.
Если заданное значение длины строчки не подходит для связанного с ней внешнего файла, то возбуждается исключение USE_ERROR.
Устанавливает максимальную длину страницы заданного файла вывода равной числу строчек, задаваемому значением параметра ТО.
Нулевое значение параметра ТО задаёт неограниченную длину страницы.
Если данное значение длины страницы не подходит для связанного с данным внешним файлом, то возбуждается исключение USE_ERROR.
Возвращает максимальную длину строчки, установленную для заданного файла вывода, или нуль, если длина строчки не ограничена.
Возвращает максимальную длину страницы, установленную для данного файла, или нуль, если длина страницы не ограничена.
Описанные в этом разделе подпрограммы предназначены для явного управления структурой строчек и страниц файла;
они оперируют либо над файлом, заданным первым параметром, либо при отсутствии такого параметра-файла над текущим файлом (ввода или вывода) по умолчанию.
Если используемый в этих подпрограммах файл не открыт, то возбуждается исключение STATUS_ERROR.
Оперирует над файлом вида OUT_FILE.
Если SPACING равно единице, то выводит признак конца строчки, а текущий номер столбца устанавливается равным единице.
Затем увеличивает текущий номер строчки на единицу, кроме случая, когда текущий номер строчки уже был равен или превышал максимальную длину страницы;
в этом случае сначала выводит признак конца страницы, затем увеличивает текущий номер страницы на единицу, а текущий номер строчки устанавливает равным единице.
Если SPACING больше единицы, то указанные действия повторяются SPACING раз.
Если вид файла не OUT_FILE, то возбуждается исключение MODE_ERROR.
Оперирует над файлом вида IN_FILE.
Если SPACING равен единице, то считывает из файла и пропускает (игнорирует) все символы до признака конца строчки, а текущий номер столбца устанавливает равным единице.
Если непосредственно за признаком конца строчки не следует признак конца страницы, то увеличивает текущий номер строчки на единицу.
В противном случае, когда за признаком конца строчки непосредственно следует признак конца страницы, пропускает признак конца страницы, увеличивает текущий номер страницы на единицу, а текущий номер строчки устанавливает равным единице.
Если SPACING больше единицы, указанные действия повторяются SPACING раз.
Если вид файла не IN_FILE, то возбуждается исключение MODE_ERROR.
При попытке прочитать признак конца файла возбуждается исключение END_ERROR.
Оперирует над файлом вида IN_FILE.
Возвращает значение TRUE, если текущий элемент файла — это признак конца строчки или признак конца файла;
в противном случае возвращает значение FALSE.
Если вид файла не IN_FILE, то возбуждается исключение MODE_ERROR.
Оперирует над файлом вида OUT_FILE.
Выводит признак конца строчки, если текущая строчка не завершена или текущая страница пустая
(т.е. текущие номера строчки или столбца оба равны единице).
Затем выводит признак конца страницы, который завершает текущую страницу.
Увеличивает номер текущей страницы на единицу, а текущие номера столбца и строчки устанавливает равными единице.
Если вид файла не OUT_FILE, то возбуждается исключение MODE_ERROR.
Оперирует над файлами вида IN_FILE.
Из файла читает и пропускает (игнорирует) все символы и признаки конца строчки, кончая признаком конца страницы.
Увеличивает текущий номер страницы на единицу, текущие номера столбца и строчки устанавливает равными единице.
Если вид файла не IN_FILE, то возбуждается исключение MODE_ERROR.
При попытке прочитать признак конца файла возбуждается исключение END_ERROR.
Оперирует над файлом вида IN_FILE.
Возвращает значение TRUE, если очередными элементами файла является последовательность из признаков конца строчки и страницы или если очередным элементов является признак конца файла;
в противном случае возвращает значение FALSE.
Если вид файла отличен от IN_FILE, то возбуждается исключение MODE_ERROR.
Оперирует над файлом вида IN_FILE.
Возвращает значение TRUE, если очередным элементом файла является признак конца файла или последовательность из признаков конца строчки, страницы и файла;
в противном случае возвращает значение FALSE.
Если вид файла отличен от IN_FILE, то возбуждается исключение MODE_ERROR.
Следующие подпрограммы предназначены для управления текущей позицией чтения или записи в файл.
Во всех этих подпрограммах в качестве файла по умолчанию используется текущий файл вывода.
Для файла вида OUT_FILE:
Если значение параметра ТО больше текущего номера столбца, то выводит пробелы, причём после вывода каждого пробела увеличивает текущий номер столбца на единицу, пока текущий номер столбца не станет равным значению параметра ТО.
Если значение параметра ТО было равно текущему номеру столбца, то никаких действий не производит.
Если значение параметра ТО меньше текущего номера столбца, то сначала выполняет действия, эквивалентные вызову процедуры NEW_LINE( SPACING = 1), затем выводит (ТО — 1) пробелов и текущий номер столбца устанавливает равным значению параметра ТО.
Если при ограниченной длине строчки (т.е. LINE_LENGTH для этого файла имеет ненулевое значение) значение параметра ТО оказалось больше LINE_LENGTH, то возбуждается исключение LAYOUT_ERROR.
Для файла вида IN_FILE:
Читает и пропускает (игнорирует) отдельные символы, признаки конца строчки и страницы до тех пор, пока номер столбца очередного, подлежащего чтению символа не станет равным значению параметра ТО.
Если текущий номер столбца с самого начала равен этому значению, то никаких действий не производит.
При передаче каждого символа или признака конца должным образом корректирует текущие номера столбца, строчки и страницы, как при работе процедуры GET (см. 14.3.5).
(Короткие строчки будут пропущены целиком, пока не встретится строчка, содержащая символ в указанной позиции от начала строчки.)
При попытке чтения признака конца файла возбуждается исключение END_ERROR.
Для файла вида OUT_FILE:
Если значение параметра ТО больше текущего номера строчки, то эта процедура эквивалентна повторным вызовам NEW_LINE (SPACING = 1) до тех пор, пока текущий номер строчки не станет равным значению параметра ТО.
Если значение параметра ТО было равно текущему номеру строчки, то никаких действий не производит.
Если значение параметра ТО меньше текущего номера строчки, то эта процедура эквивалентна вызову NEW_PAGE, за которым следует вызов NEW_LINE с параметром SPACING, равным (ТО — 1).
Если при ограниченной длине страницы (т.е. PAGE_LENGTH для этого файла имеет ненулевое значение) значение параметра ТО оказалось больше PAGE_LENGTH, то возбуждается исключение LAYOUT_ERROR.
Для файла вида IN_FILE:
Результат эквивалентен повторным вызовам процедуры SKIP_LINE (SPACING = 1) до тех пор, пока текущий номер строчки не примет значение параметра ТО.
Если текущий номер строчки с самого начала был равен значению параметра ТО, то никаких действий не производит.
(Короткие страницы будут пропущены целиком, пока не встретится страница, содержащая строчку в указанной позиции от начала страницы.)
При попытке чтения признака конца файла возбуждается исключение END_ERROR.
Возвращает текущий номер столбца.
Если этот номер больше значения COUNT'LAST, это возбуждается исключение LAYOUT_ERROR.
Возвращает текущий номер строчки.
Если этот номер больше значения COUNT'LAST, то возбуждается исключение LAYOUT_ERROR.
Возвращает текущий номер страницы.
Если этот номер больше значения COUNT'LAST, то возбуждается исключение LAYOUT_ERROR.
Номера столбца, строчки или страницы, вообще говоря, могут превысить значение COUNT'LAST
(в результате ввода или вывода достаточно большого числа символов, строчек или страниц).
При этом никакое исключение не возбуждается.
Однако при вызове функции COL, LINE или PAGE если соответствующий номер оказался больше COUNT'LAST, то возбуждается исключение LAYOUT_ERROR.
Признак конца страницы пропускается, если пропускается предшествующий ему признак конца строчки.
Реализация может представить последовательность из таких двух признаков конца одним символом при условии, что он будет распознаваться при вводе.
В разд.
14.3.5—14.3.10 описаны процедуры GET и PUT для элементов типов CHARACTER, STRING, числового и перечислимого.
В данном разделе описаны возможности этих процедур, общие для большинства таких типов.
Процедуры GET и PUT для элементов типов CHARACTER и STRING передают отдельные символьные значения, а для числовых и перечислимых типов передают лексемы.
Первым параметром всех процедур GET и PUT является файл.
Если он опущен, то подразумевается, что используется текущий файл (ввода или вывода) по умолчанию.
Каждая процедура GET оперирует над файлом вида IN_FILE.
Каждая процедура PUT оперирует над файлом вида OUT_FILE.
Все процедуры GET и PUT меняют для заданного файла текущие номера столбца, строчки и страницы: эффект каждой из этиф процедур такойже, как от передачи каждого символа, передачи или пропускт соответствующего признака конца.
Каждая передача символа увеличивает на единицу текущий номер столбца.
Каждый вывод признака конца строчки устанавливает текущий номер столбца равным единице и добавляет единицу к текущему номеру строчки.
Каждый вывод признака конца страницы устанавливает текущие номера столбца и строчки равными единице и добавляет единицу к текущему номеру страницы.
При вводе каждый пропуск признака конца строчки устанавливает текущий номер столбца равным единице и добавляет единицу к текущему номеру строчки;
каждый пропуск признака конца страницы устанавливает текущие номера столбца и строчки равными единице и добавляет единицу к текущему номеру страницы.
Аналогичным образом определяется семантика процедур GET_LINE, PUT_LINE и SET_COL
Некоторые процедуры GET и PUT для числовых и перечислимых типов имеют параметры, задающие формат; он указывает длины полей; эти параметры принадлежат неотрицательному подтипу FIELD типа INTEGER.
Ввод-вывод значений перечислимых типов использует синтаксис соответствующих лексем.
Любая процедура GET для перечислимого типа сначала пропускает все ведущие пропуски или признаки концов строчки и страницы;
пропуск — это символ пробела или символ горизонтальной табуляции.
Затем символы вводятся до тех пор, пока введённая последовательность является началом лексемы, соответствующей -идентификатору или символьному литералу
(в частности, ввод прекращается при достижении признака конца строчки).
Символ или признак конца строчки, вызвавшие прекращение ввода, остаются доступными для следующего ввода.
Процедуры GET для числовых типов имеют параметр WIDTH, задающий формат.
Если он имеет нулевое значение, то процедура GET выполняется так же, как для перечислимых типов, но вместо синтаксиса литералов перечисления используется синтаксис числовых литералов.
При ненулевом значении параметра WIDTH вводится ровно WIDTH символов или, если ранее встретился признак конца строчки, все символы до признака конца строчки;
в это число включаются и все ведущие пропуски.
Для числовых литералов используется расширенный синтаксис, в котором допускается знак числа
(но не пропуски или признаки конца строчки или страницы внутри литерала).
Любая процедура PUT для элемента числового или перечислимого типа выводит значение элемента соответственно как числовой литерал, идентификатор или символьный литерал.
Перед ними могут быть выведены пробелы, если этого требуют параметры формата WIDTH или FORE (это описано ниже), и для отрицательных значений — знак минус;
в случае перечислимого типа пробелы выводятся не перед литералом, а после него.
Если формат в процедуре PUT задаёт недостаточную ширину, то он игнорируется.
Следующие две ситуации могут возникнуть при выполнении процедуры PUT для числового или перечислимого типа в случае ограниченной длины строчки используемого файла вывода
(т.е. длина строчки имеет ненулевое значение).
Если число выводимых символов не превышает максимальной длины строчки, но при выводе этих символов, начиная с текущего столбца, они не помещаются в текущей строчке, то перед их выводом выполняются действия, эквивалентные вызову NEW_LINE с параметром SPACING, равным единице.
Если же число выводимых символов больше максимальной длины строчки, то возбуждается исключение LAYOUT_ERROR, при этом символы не выводятся.
Если используемый в процедурах GET, GET_LINE, PUT и PUT_LINE файл не открыт, то возбуждается исключение STATUS_ERROR.
Если в процедурах GET и GET_LINE вид используемого файла отличен от IN_LINE или в процедурах PUT и PUT_LINE вид используемого файла отличен от OUT_FILE, то возбуждается исключение MODE_ERROR.
В процедуре GET при попытке пропуска признака конца файла возбуждается исключение END_ERROR.
Если вся введённая процедурой GET последовательность символов не является лексемой соответствующего типа, то возбуждается исключение DATA_ERROR;
в частности, оно возбуждается, если не было введено ни одного символа;
для числового типа если был введён знак, то это правило относится к следующему за ним числовому литералу.
В случае процедуры PUT, выводящей элемент типа STRING, если длина строки файла недостаточна для вывода заданного элемента, то возбуждается исключение LAYOUT_ERROR.
В примерах этого раздела и в разд.
14.3.7 и 14.3.8 кавычки и строчная буква b не вводятся и не выводятся; они даны только для того, чтобы показать расположение и пробелы.
Пример игнорирования параметра ширины:
Для элемента типа CHARACTER определены следующие процедуры:
В заданном файле ввода процедуры пропускают признаки конца строчки и страницы и читают следующий за ними символ; значение этого символа возвращают параметру ITEM вида out.
При попытке пропустить признак конца файла возбуждается исключение END_ERROR.
Если длина строчки заданного файла вывода ограничена (т.е. не равна нулю по соглашению), а текущий номер столбца превышает эту длину, то выполняют действия, эквивалентные вызову процедуры NEW_LINE с параметром SPACING, равным единице.
Затем в любом случае в файл выводят заданный символ.
Для элемента типа STRING определены следующие процедуры:
Определяют длину (число символов) данной строки; затем для последовательных символов строки соответствующее число раз выполняют операцию GET
(в частности, для пустой строки никаких действий не выполняют).
Определяют длину (число символов) данной строки; затем для последовательных символов строки соответствующее число раз выполняют операцию PUT
(в частности, для пустой строки никаких действий не выполняют).
Заменяют последовательные символы, содержащиеся в указанной строке, символами, читаемыми из заданного файла.
Чтение заканчивается при достижении конца строчки файла; в этом случае выполняют действия, эквивалентные действиям процедуры SKIP_LINE с параметром SPACING, равным единице.
Чтение также заканчивается при достижении конца строки, заданной параметром ITEM.
Символы, которые не были заменены, остаются неопределёнными.
Если символы прочитаны, то в параметр LAST возвращается индекс последнего замененного символа так, что индексированная компонента ITEM (LAST) — это значение последнего заменённого символа
(индекс первого заменённого символа равен атрибуту ITEM'FIRST).
Если не было прочитано ни одного символа, то в LAST выдаётся значение индекса, на единицу меньшее атрибута ITEM'FIRST.
При попытке пропустить признак конца файла возбуждается исключение END_ERROR.
Вызывают процедуру PUT для заданной строки, затем процедуру NEW_LINE с параметром SPACING, равным единице.
Внешние кавычки строкового литерала, являющегося параметром процедуры PUT, не выводятся.
Каждый сдвоенный символ кавычки, приведённый внутри такого литерала, выводится как один символ кавычки; это следует из правил для строковых литералов (см. 2.6).
Строка, считываемая процедурой GET или записываемая процедурой PUT, в файле может занимать несколько строчек.
Описанные ниже процедуры определены в настраиваемом пакете INTEGER_IO.
Он должен быть конкретизован с соответствующим целым типом (указанным в спецификации параметром настройки NUM).
Значения выводятся в виде десятичных литералов или литералов с основанием, без подчёркиваний и порядка, с предшествующим знаком минус для отрицательных чисел.
Формат, определяющий ширину поля (включая ведущие пробелы и знак минус), может быть задан необязательным параметром WIDTH.
Его значение принадлежит неотрицательному целому подтипу FIELD.
Значения основания принадлежат целому подтипу NUMBER_BASE.
В процедурах вывода могут использоваться ширина поля и основание по умолчанию; они задаются переменными, описанными в настраиваемом пакете INTEGER_IO:
Определены следующие процедуры:
При нулевом значении параметра WIDTH пропускают все ведущие пропуски, признаки конца строчки и страницы, читают знак плюс или минус (если он есть), затем производят чтение в соответствии с синтаксисом целого литерала
(он может быть литералом с основанием).
При нулевом значении WIDTH вводят ровно WIDTH символов, или если раньше встретится признак конца строки, то вводят лишь символы до этого признака конца (возможно, ни одного);
в это количество включаются и все ведущие пропуски.
В параметр ITEM типа NUM возвращают значение, соответствующее введённой последовательности.
Если введённая последовательность не соответствует правилам синтаксиса или если полученное значение не принадлежит подтипу NUM, то возбуждается исключение DATA_ERROR.
Значение параметра ITEM выводят в виде целого литерала без подчёркиваний, порядка и ведущих нулей (если значение равно нулю, выводят один нуль), с предшествующим знаком минус, если значение отрицательное.
Если число символов выводимой последовательности меньше значения WIDTH, то она дополняется ведущими пробелами.
Если параметр BASE (заданный явно указанным значением или переменной DEFAULT_BASE) имеет значение десять, то числа выводятся по синтаксису десятичного литерала, в противном случае — по синтаксису литерала с основанием и всеми прописными буквами.
Читает с начала строки, заданной параметром FROM, целое значение по тем же правилам, что и процедура GET, которая читает целое значение из файла; при этом рассматривает конец строки как признак конца файла.
Через параметр ITEM возвращает значение типа NUM, соответствующее введённой последовательности.
Через параметр LAST возвращает значение индекса, соответствующее последнему читаемому символу (следовательно, этот символ имеет значение индексированной компоненты FROM(LAST)).
Если введённая последовательность не соответствует правилам синтаксиса или если полученное значение не принадлежит подтипу NUM, то возбуждается исключение DATA_ERROR.
Через параметр ТО выводит значение параметра ITEM по тем же правилам, что и при выводе в файл; в качестве значения параметра WIDTH используется длина указанной строки.
Следующие процедуры определены в настраиваемых пакетах FLOAT_IO и FIXED_IO, которые должны быть конкретизованы с соответствующим плавающим или фиксированным типом (указанным в спецификации параметром NUM).
Значения выводятся как десятичные литералы без подчёркиваний.
Формат каждого выводимого значения состоит из поля FORE, десятичной точки, поля AFT, а также (при ненулевом значении параметра ЕХР) буквы Е и поля ЕХР.
Таким образом, возможны два формата:
и
без всяких пробелов между этими полями.
Поле FORE может включать предшествующие пробелы и знак минус для отрицательных значений.
Поле AFT состоит из одних лишь десятичных цифр (оно может оканчиваться нулями).
Поле ЕХР состоит из знака (плюс или минус) и порядка (возможно, с предшествующими нулями).
Для плавающих типов длины этих полей по умолчанию определены переменными, описанными в пакете FLOAT_IO:
Для фиксированных типов длины по умолчанию для этих полей задаются переменными, описанными в пакете FIXED_IO:
Определены следующие процедуры:
При нулевом значении параметра WIDTH опускают все ведущие пропуски, признак конца строчки или признак конца страницы, читают знак плюс или минус (если он есть); затем производят чтение в соответствии с синтаксисом вещественного литерала
(он может быть литералом с основанием).
При ненулевом значении параметра WIDTH вводят или ровно WIDTH символов, или, если раньше встретился признак конца строчки, лишь символы, читаемые до этого признака конца (возможно, ни одного символа);
в это количество включаются и все предшествующие пропуски.
Через параметр ITEM возвращают значение типа NUM, соответствующее введённой последовательности.
Если введённая последовательность не удовлетворяет требованиям синтаксиса или если полученное значение не принадлежит подтипу NUM, то возбуждается исключение DATA_ERROR.
Выводят значение параметра ITEM в виде десятичного литерала в формате, определяемом параметрами FORE, AFT и ЕХР.
Если значение ITEM отрицательное, то в целую часть включён знак минус.
При нулевом значении параметра ЕХР целая часть представляется таким количеством цифр, которое требуется для представления целой части значения ITEM; при необходимости значение FORE игнорируется.
Если в значении ITEM нет целой части, то целая часть представляется цифрой 0.
Если значение ЕХР больше нуля, то целая часть представляется одной цифрой, отличной от нуля, за исключением случая, когда значение ITEM равно 0.0.
В обоих случаях, если целая часть, включая знак минус, содержит менее FORE символов, она дополняется до этого количества ведущими нулями.
Дробная часть состоит из AFT цифр или при AFT, равном нулю, из одной цифры.
Значение округляется;
остаток, равный половине последнего разряда, может быть округлён как с избытком, так и с недостатком.
При нулевом значении ЕХР число выводится без порядка.
Если ЕХР больше нуля, то при выводе порядка выводится столько цифр, сколько необходимо для представления порядка значения ITEM (для представления целой части этого значения используется один символ); первым символом является знак плюс или минус.
Если для представления порядка, включая знак, используется менее ЕХР символов, то это представление дополняется до требуемого количества символов ведущими нулями.
Для значения ITEM, равного 0.0, порядок равен нулю.
Читает с начала строки, заданной параметром FROM, вещественное значение по тем же правилам, что и процедура GET, читающая вещественное значение из файла; при этом конец строки рассматривается как признак конца файла.
Через параметр ITEM возвращает значение типа NUM, соответствующее введённой последовательности.
Через параметр LAST возвращает значение индекса, соответствующее последнему читаемому символу (следовательно, этот символ имеет значение индексируемой компоненты FROM (LAST)).
Если введённая последовательность не соответствует правилам синтаксиса или если полученное значение не принадлежит подтипу NUM, то возбуждает исключение DATA_ERROR.
Через параметр ТО выводит значение параметра ITEM по тем же правилам, что и при выводе в файл; при этом в качестве FORE использует такое значение, чтобы общее число выводимых символов, включая предшествующие пробелы, соответствовало длине строки параметра ТО.
Если положительное число, выводимое процедурой PUT в строку, заполняет строку целиком, без использования ведущих пробелов, то при выводе такого же отрицательного числа будет возбуждено исключение LAYOUT_ERROR.
Описанные ниже процедуры определены в настраиваемом пакете ENUMERATION_IO, который должен быть конкретизован с соответствующим перечислимым типом (указанным в спецификации параметром настройки ENUM).
При выводе значений для представления идентификаторов используются либо строчные, либо прописные буквы.
Это задаётся параметром SET, который принадлежит перечислимому типу TYPE_SET:
Формат (в который включаются и заключительные пробелы) может быть задан необязательным параметром ширины поля.
Ширина поля по умолчанию и представление букв задаются описанными в настраиваемом пакете ENUMERATION_IO переменными:
Определены следующие процедуры:
После игнорирования предшествующих пропусков, признака конца строчки и признака конца страницы читают или идентификатор (строчные и прописные буквы считаются эквивалентными), или символьный литерал (включая апострофы); чтение производится в соответствии с синтаксисом соответствующих лексем.
Через параметр ITEM возвращают значение, соответствующее введённой последовательности.
Если введённая последовательность не удовлетворяет правилам синтаксиса или если идентификатор или символьный литерал не соответствуют никакому значению подтипа ENUM, то возбуждается исключение DATA_ERROR.
Выводят значение параметра ITEM как литерал перечисления (либо идентификатор, либо символьный литерал).
Необязательный параметр SET указывает, какие буквы — строчные или прописные — следует использовать для представления идентификаторов (для символьных литералов он игнорируется).
Если число выводимых символов меньше значения параметра WIDTH, то после них выводятся пробелы, дополняющие число символов до WIDTH.
Читает с начала строки, заданной параметром FROM, значение перечислимого типа по тем же правилам, что и процедура GET, читающая значение перечислимого типа из файла; при этом конец строки рассматривается как признак конца файла.
Через параметр ITEM возвращает значение типа ENUM, соответствующее введённой последовательности.
Через параметр LAST возвращает значение индекса, соответствующее последнему читаемому символу (следовательно, этот символ имеет значение индексируемой компоненты FROM (LAST)).
Если введённая последовательность не соответствует правилам синтаксиса или если идентификатор или символьный литерал не соответствуют никакому значению подтипа ENUM, то возбуждает исключение DATA_ERROR.
Выводит в строку, заданную параметром ТО, значение параметра ITEM по тем же правилам, что и при выводе в файл; в качестве значения параметра WIDTH используется длина указанной строки.
Хотя спецификация пакета ENUMERATION_IO допускает конкретизацию с соответствующим целым типом, это не является целью данного пакета; язык не определяет результата такой конкретизации.
Процедуры PUT для символов и для перечислимых значений имеют определённые различия:
Тип BOOLEAN является перечислимым типом, поэтому пакет ENUMERATION_IO может быть настроен на этот тип.
В этом разделе описаны исключения, которые могут быть возбуждены при выполнении операций ввода-вывода.
Они описаны в пакете IO_EXCEPTIONS; определение этого пакета приведено в разд.
14.5.
Этот пакет упоминается в спецификаторах контекста каждого из трёх описанных пакетов ввода-вывода.
Для исключений NAME_ERROR, USE_ERROR и DEVICE_ERROR описаны общие характеристики условий возбуждения этих исключений;
детальное описание должно быть приведено в приложении F.
Если существует более чем одно ошибочное условие, соответствующее одному исключению, то возбуждается то из них, которое раньше описано в данном ниже списке исключений.
Исключение STATUS_ERROR возбуждается при попытке выполнить действия над ещё не открытым файлом или при попытке открыть уже открытый файл.
Исключение MODE_ERROR возбуждается при попытке чтения или проверке конца файла с текущим видом OUT_FILE, а также при попытке записи в файл с текущим видом IN_FILE.
Для пакета TEXT_IO исключение MODE_ERROR возбуждается также при использовании файла с текущим видом OUT_FILE в качестве параметра подпрограмм SET_INPUT, SKIP_LINE, END_OF_LINE, SKIP_PAGE и END_OF_PAGE и при использовании файла с текущим видом IN_FILE в качестве параметра подпрограммы SET_OUTPUT, SET_LINE_LENGTH, SET_PAGE_LENGTH, LINE_LENGTH, PAGE_LENGTH, NEW_LINE или NEW_PAGE.
Исключение NAME_ERROR возбуждается при вызове процедур CREATE и OPEN, если строка, заданная параметром NAME, не позволяет идентифицировать внешний файл.
Например, это исключение возбуждается, если такая строка вообще недопустима или если ей либо не соответствует ни один внешний файл, либо соответствует несколько внешних файлов.
Исключение USE_ERROR возбуждается при попытке выполнить операцию, не разрешённую по причинам, зависящим от характеристик внешнего файла.
Например, процедурой CREATE такое исключение может быть возбуждено при задании параметром MODE вида OUT_FILE, а параметром FORM устройства, допускающего только ввод, либо при задании параметром FORM неверных прав доступа, либо если внешний файл с данным именем уже существует и перезапись недопустима.
Исключение DEVICE_ERROR возбуждается при невозможности завершения операции ввода-вывода из-за неисправностей в используемой системе.
Исключение END_ERROR возбуждается при попытке пропустить признак конца файла (чтение за концом файла).
Исключение DATA_ERROR может быть возбуждено процедурой READ, если читаемый элемент нельзя интерпретировать как значение требуемого типа.
Это же исключение возбуждается процедурой GET (определённой в пакете TEXT_IO), если введённая последовательность символов не соответствует требуемому синтаксису или если введённое значение не принадлежит диапазону требуемого типа или подтипа.
Исключение LAYOUT_ERROR возбуждается (в текстовом вводе-выводе) при вызове функции COL, LINE или PAGE, если возвращаемое значение превышает COUNT'LAST.
Это же исключение возбуждается при выводе: при попытке установить номер столбца или строчки, превышающий заданную максимальную длину строчки или страницы (кроме случая неограниченной длины строчки или страницы).
Оно также возбуждается процедурой PUT при попытке вывести в строку слишком большое количество символов.
В этом пакете определены исключения, необходимые для работы пакетов SEQUENTIAL_IO, DIRECT_IO и TEXT_IO.
Операция ввода-вывода низкого уровня — это операция, выполняющаяся на физическом устройстве.
Для выполнения таких операций используется одна из (совмещённых) предопределённых процедур SEND_CONTROL и RECEIVE_CONTROL
Процедура SEND_CONTROL может быть использована для посылки управляющей информации физическому устройству.
Процедура RECEIVE_CONTROL может быть использована для организации выполнения операции ввода-вывода, связанной с запросом информации от физического устройства.
Эти процедуры описаны в стандартном пакете LOW_LEVEL_IO.
Каждая из них имеет два параметра, задающие устройство и данные.
Однако сорт и формат управляющей информации зависят от физических характеристик машины и устройств; поэтому типы параметров зависят от реализации.
Возможно определение совмещённых подпрограмм, управляющих различными устройствами.
Видимый раздел пакета, определяющего такие процедуры, имеет следующую структуру:
Тела процедур SEND_CONTROL и RECEIVE_CONTROL для различных устройств могут быть размещены в теле пакета LOW_LEVEL_IO.
Эти тела процедур могут быть записаны операторами кода.
В примере показано использование некоторых средств ввода-вывода текстов в режиме диалога.
Пользователю предлагается выбрать цвет; программа в соответствии с описью выдаёт число предметов этого цвета на складе.
Используются файлы ввода и вывода по умолчанию.
Для простоты все необходимые конкретизации настройки заданы в одной подпрограмме;
на практике для этого мог бы использоваться самостоятельный пакет.
Пример диалога (набранное пользователем выделено курсивом):
Префикс Р обозначает объект, программный модуль, метку или вход.
Вырабатывает адрес первого кванта памяти, отведённой под Р.
Для подпрограммы, пакета, задачи или метки это значение ссылается на машинный код, связанный с соответствующим телом или оператором.
Для входа, для которого задан спецификатор адреса, это значение ссылается на соответствующее аппаратное прерывание.
Значение этого атрибута имеет предопределённый в пакете SYSTEM тип ADDRESS (см. 13.7.2).
Префикс Р обозначает фиксированный подтип.
Вырабатывает число десятичных цифр после точки, необходимых для обеспечения точности подтипа Р, если только атрибут DELTA подтипа Р не превышает 0.1, в этом случае атрибут вырабатывает значение единицы.
(P'AFT — это наименьшее положительное число N, для которого (10 ** N)*P' DELTA больше или равно 1.)
Значение этого атрибута имеет универсальный целый тип (см. 3.5.10).
Префикс Р обозначает тип или подтип.
Этот атрибут обозначает базовый тип Р
Он может быть только префиксом имени другого атрибута, например P'BASE'FIRST (см. 3.3.3).
Префикс Р — это объект задачного типа.
Вырабатывает значение FALSE, когда выполнение задачи Р либо закончено, либо завершено, либо задача находится в аварийном состоянии.
В остальных случаях вырабатывает значение TRUE.
Значение этого атрибута имеет предопределённый тип BOOLEAN (см. 9.9).
Префикс Р обозначает объект некоторого типа с дискриминантами.
Вырабатывает значение TRUE, если ограничение дискриминантов наложено на объект Р или если объект — константа
(включая формальный параметр или формальный параметр настройки вида in).
В остальных случаях вырабатывает значение FALSE.
Если Р — формальный параметр настройки вида in out или если Р — формальный параметр вида in out или out, а обозначение типа, заданное в соответствующей спецификации параметра, обозначает неограниченный тип с дискриминантами, то значение этого атрибута получается из значения атрибута соответствующего фактического параметра.
Значение атрибута имеет предопределённый тип BOOLEAN (см. 3.7.4).
Префикс Р обозначает личный тип или подтип.
Вырабатывает значение FALSE, если Р обозначает неограниченный неформальный личный тип с дискриминантами; вырабатывает это же значение, если Р обозначает настраиваемый формальный личный тип, а соответствующий фактический подтип — это либо неограниченный тип с дискриминантами, либо неограниченный индексируемый тип.
В остальных случаях вырабатывается значение TRUE.
Значение этого атрибута имеет предопределённый тип BOOLEAN (см. 7.4.2).
Префикс Р обозначает вход задачи.
Вырабатывает число вызовов входа, присутствующих в очереди этого входа, (если атрибут вычисляется внутри оператора принятия входа Р, то в это число не входит вызывающая задача).
Значение этого атрибута имеет универсальный целый тип (см. 9.9).
Префикс Р обозначает фиксированный подтип.
Вырабатывает значение дельты, заданной в определении точности фиксированного типа для подтипа Р.
Значение этого атрибута имеет универсальный вещественный тип (см. 3.5.10)
Префикс Р обозначает плавающий подтип.
Вырабатывает число десятичных цифр в десятичной мантиссе модельных чисел подтипа Р.
(Этот атрибут вырабатывает число D, определённое в разд.
3.5.7.)
Значение этого атрибута имеет универсальный целый тип (см. 3.5.8).
Префикс Р обозначает плавающий подтип.
Вырабатывает наибольшее значение порядка двоичной канонической формы модельных чисел подтипа Р.
(Этот атрибут вырабатывает произведение 4*В.)
Значение этого атрибута имеет универсальный целый тип (см. 3.5.8).
Префикс Р обозначает плавающий подтип.
Вырабатывает абсолютное значение разности между модельным числом 1.0 и следующим модельным числом подтипа Р.
Значение этого атрибута имеет универсальный вещественный тип (см. 3.5.8).
Префикс Р обозначает скалярный тип или подтип скалярного типа.
Вырабатывает значение нижней границы Р.
Значение этого атрибута имеет тип Р (см. 3.5).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает значение нижней границы диапазона первого индекса.
Значение этого атрибута имеет тот же тип, что и тип значения нижней границы (см. 3.6.2 и 3.8.2).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает значение нижней границы диапазона N-го индекса.
Значение этого атрибута имеет тот же тип, что и указанная нижняя граница.
Аргумент N должен быть статическим выражением типа универсальный целый.
Значение N должно быть положительным (ненулевым) и не превосходить размерности массива (см. 3.6.2 и 3.8.2).
Префикс Р обозначает компоненту записи.
Вырабатывает величину смещения первого бита относительно начала первого кванта памяти, занимаемой этой компонентой.
Величина смещения измеряется числом битов.
Значение этого атрибута имеет тип универсальный целый (см. 13.7.2).
Префикс Р обозначает фиксированный подтип.
Вырабатывает минимальное число символов, необходимых для десятичного представления целой части любого значения подтипа Р в предположении, что это представление не включает порядок, но включает односимвольный префикс, который является либо знаком минус, либо пробелом.
(Это минимальное число не учитывает предшествующие нули и символы подчёркивания и по меньшей мере равно двум.)
Значение этого атрибута имеет универсальный целый тип (см. 3.5.10).
Префикс Р обозначает дискретный тип или подтип.
Этот атрибут представляет собой функцию с одним параметром.
Фактический параметр Х должен быть значением базового типа Р.
Тип результата — предопределённый тип STRING.
Результат представляет собой образ значения X, т.е. последовательность символов, представляющих изображение значения.
Образу целого значения соответствуют десятичный литерал без символов подчёркивания, предшествующих нулей, порядка и последующих пробелов, но с одним символом слева, который представляет собой либо минус, либо пробел.
Образом литерала перечисления является либо соответствующий идентификатор из прописных букв, либо соответствующий символьный литерал (включая два апострофа) без предшествующих и последующих пробелов.
Образ символа, отличного от графического, определяется реализацией (см. 3.5.5).
Префикс Р обозначает вещественный подтип.
Вырабатывает наибольшее положительное модельное число подтипа Р.
Значение этого атрибута имеет универсальный вещественный тип (см. 3.5.8 и 3.5.10).
Префикс Р обозначает скалярный тип или подтип скалярного типа.
Вырабатывает значение верхней границы Р.
Значение этого атрибута имеет тип Р (см. 3.5).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает значение верхней границы диапазона первого индекса.
Значение атрибута имеет тип верхней границы (см. 3.6.2 и 3.8.2).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает значение верхней границы диапазона N-го индекса.
Значение этого атрибута имеет тот же тип, что и верхняя граница.
Аргумент N должен быть статическим выражением типа универсальный целый.
Значение N должно быть положительным (ненулевым) и не превышать размерности массива (см. 3.6.2 и 3.8.2).
Префикс Р обозначает компоненту записи.
Вырабатывает величину смещения последнего бита относительно первого кванта памяти, занимаемой этой компонентой.
Величина смещения измеряется числом битов.
Значение атрибута имеет тип универсальный целый (см. 13.7.2).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает число значений диапазона первого индекса (нуль для пустого диапазона).
Значение этого атрибута имеет универсальный целый тип (см. 3.6.2).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает число значений в диапазоне N-го индекса (нуль для пустого диапазона).
Значение этого атрибута имеет универсальный целый тип.
Аргумент N должен быть статическим выражением типа универсальный целый.
Значение N должно быть положительным (ненулевым) и не должно превышать размерности массива (см. 3.6.2 и 3.8.2).
Префикс Р обозначает плавающий тип или подтип.
Вырабатывает наибольшее значение порядка машинного представления базового типа Р.
Значение этого атрибута имеет универсальный целый тип (см. 13.7.3).
Префикс Р обозначает плавающий тип или подтип.
Вырабатывает наименьшее (наибольшее по модулю отрицательное) значение порядка машинного представления базового типа Р.
Значение этого атрибута имеет универсальный целый тип (см. 13.7.3).
Префикс Р обозначает плавающий тип или подтип.
Вырабатывает число цифр в мантиссе машинного представления базового типа Р
(цифры являются расширенными цифрами из диапазона 0 ..
P'MACHINE_RADIX - 1).
Значение этого атрибута имеет универсальный целый тип (см. 13.7.3).
Префикс Р обозначает вещественный тип или подтип.
Вырабатывает значение TRUE, если каждая предопределённая операция над значениями базового типа Р либо возвращает точный результат, либо возбуждение исключения NUMERIC_ERROR при переполнении.
В противном случае вырабатывает значение FALSE.
Значение этого атрибута имеет предопределённый тип BOOLEAN (см. 13.7.3).
Префикс Р обозначает плавающий тип или подтип.
Вырабатывает значение основания, используемое в машинном представлении базового типа Р.
Значение этого атрибута имеет тип универсальный целый (см. 13.7.3).
Префикс Р обозначает вещественный тип или подтип.
Вырабатывает значение TRUE, если каждая предопределённая арифметическая операция над значениями базового типа Р либо возвращает точный результат, либо осуществляет округление.
В противном случае вырабатывает значение FALSE.
Значение этого атрибута имеет предопределённый тип BOOLEAN (см. 13.7.3).
Префикс Р обозначает вещественный подтип.
Вырабатывает число двоичных цифр мантиссы модельных чисел подтипа Р.
(Этот атрибут вырабатывает число В, введённое в разд.
3.5.7 для плавающего типа и в разд.
3.5.9 для фиксированного типа.)
Значение этого атрибута имеет универсальный целый тип (см. 3.5.8 и 3.5.10).
Префикс Р обозначает дискретный тип или подтип.
Этот атрибут является функцией с одним параметром.
Фактический параметр Х должен быть значением базового типа Р.
Тип результата — универсальный целый.
Результатом является порядковый номер позиции для значения фактического параметра (см. 3.5.5),
Префикс Р обозначает компоненту записи.
Вырабатывает величину смещения первого кванта памяти, занятого этой компонентой, относительно первого кванта памяти, занимаемого записью.
Величина смещения измеряется числом квантов.
Значение этого атрибута имеет универсальный целый тип (см. 13.7.2).
Префикс Р обозначает дискретный тип или подтип.
Этот атрибут является функцией с одним параметром.
Фактический параметр Х должен быть значением базового типа Р.
Тип результата — базовый тип Р.
Результатом является значение с номером позиции, на единицу меньшим номера позиции для значения X.
Если Х равен P'BASE'FIRST, то возбуждается исключение CONSTRAINT_ERROR (см. 3.5.5).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает диапазон первого индекса Р, т.е. диапазон Р'FIRST ..
P'LAST (см.3.6.2).
Префикс Р соответствует индексируемому типу или обозначает ограниченный индексируемый подтип.
Вырабатывает диапазон N-го индекса Р, т.е. диапазон P'FIRST (N) ..
P'LAST (N) (см. 3.6.2).
Префикс Р обозначает плавающий тип или подтип.
Вырабатывает наибольшее значение порядка двоичной канонической формы хранимых чисел базового типа Р.
(Этот атрибут вырабатывает число Е, определённое в разд.
3.5.7.)
Значение этого атрибута имеет универсальный целый тип (см. 3.5.8).
Префикс Р обозначает вещественный тип или подтип.
Вырабатывает наибольшее положительное хранимое число базового типа Р.
Значение этого атрибута имеет универсальный вещественный тип (см. 3.5.8 и 3.5.10).
Префикс Р обозначает вещественный тип или подтип.
Вырабатывает наименьшее положительное (ненулевое) хранимое число базового типа Р.
Значение этого атрибута имеет универсальный вещественный тип (см. 3.5.8 и 3.5.10).
Префикс Р обозначает тип или подтип.
Вырабатывает минимальное число битов, необходимое реализации для представления любого возможного значения объекта типа или подтипа Р.
Значение этого атрибута имеет универсальный целый тип (см. 13.7.2).
Префикс Р обозначает объект.
Вырабатывает число битов, отведённых для размещения объекта.
Значение этого атрибута имеет универсальный целый тип (см.13.7.2).
Префикс Р обозначает вещественный подтип.
Вырабатывает наименьшее положительное (ненулевое) число подтипа Р.
Значение этого атрибута имеет универсальный вещественный тип (см. 3.5.8 и 3.5.10).
Префикс Р обозначает ссылочный тип или подтип.
Вырабатывает общее число квантов памяти, резервируемых для соответствующего базовому типу Р набора.
Значение этого атрибута имеет универсальный целый тип (см.13.7.2).
Префикс обозначает задачный тип или задачу.
Вырабатывает общее число квантов памяти, резервируемых для каждой активизации задачи типа Р или объекта Р задачного типа.
Значение этого атрибута имеет универсальный целый тип (см. 13.7.2).
Префикс Р обозначает дискретный тип или подтип.
Этот атрибут является функцией с одним параметром.
Фактический параметр Х должен быть значением базового типа Р.
Тип результата является базовым типом Р.
Результат представляет собой значение с номером позиции, на единицу большим номера позиции для значения X.
Если Х равен P'BASE'LAST, то возбуждается исключение CONSTRAINT_ERROR (см. 3.5.5).
Префикс Р соответствует задачному типу.
Вырабатывает значение TRUE, если задача Р завершена, иначе вырабатывает значение FALSE.
Значение этого атрибута имеет предопределённый тип BOOLEAN (см. 9.9).
Префикс Р обозначает дискретный тип или подтип.
Этот атрибут является специальной функцией с одним параметром X, который может быть любого целого типа.
Тип результата является базовым типом Р.
Результат представляет собой значение, чьим номером позиции является значение типа универсальный целый, и это значение соответствует X.
Если соответствующее Х универсальное целое значение не принадлежит диапазону P'POS (P'BASE'FIRST)..P'POS (P'BASE'LAST), то возбуждается исключение CONSTRAINT_ERROR (см. 3.5.5).
Префикс Р обозначает дискретный тип или подтип.
Этот атрибут является функцией с одним параметром.
Фактический параметр Х должен быть значением предопределённого типа STRING.
Тип результата — базовый тип Р.
Любые предшествующие и последующие пробелы последовательности символов, соответствующей X, игнорируются.
Если для перечислимого типа последовательность символов имеет синтаксис литерала перечисления и если этот литерал существует для базового типа Р, то результатом является соответствующее значение перечислимого типа.
Если для целого типа последовательность символов имеет синтаксис целого литерала, возможно с дополнительным символом плюс или минус, и если соответствующее значение принадлежит базовому типу Р, то результатом является именно это значение.
Во всех остальных случаях возбуждается исключение CONSTRAINT_ERROR (см. 3.5.5).
Префикс Р обозначает дискретный подтип.
Вырабатывает максимальную длину образа по всем значениям подтипа Р.
(Образ — это последовательность символов, вырабатываемых атрибутом IMAGE.)
Значение этого атрибута имеет универсальный целый тип (см. 3.5.5).