# language_name_wals:	Russian
# language_name_glotto:	Russian
# ISO_6393:	rus
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Cyrl
# special_characters:	NA
# short_description:	ada83
# source:	https://object.pouta.csc.fi/OPUS-ada83/v1/raw/ru.zip
# copyright_short:	http://opus.nlpl.eu/ada83.php
# copyright_long:	http://opus.nlpl.eu/ada83.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	part
# comments:	NA

Ада — это язык программирования, разработанный в соответствии с так называемыми стилмановскими требованиями, определёнными МО США.
Более того, эти требования определили язык с мощными выразительными возможностями, пригодный для широкого класса задач.
Вследствие этого языку Ада присущи как свойства классических языков, подобных языку Паскаль, так и свойства, характерные для специализированных языков.
Таким образом, этот язык является современным алгоритмическим языком с традиционными управляющими структурами и средствами определения типов и подпрограмм.
Он также удовлетворяет требованию модульности; данные, типы и подпрограммы могут образовывать пакеты.
Модульность понимается и в физическом смысле, что обеспечивается раздельной компиляцией модулей.
В дополнение к указанному язык обеспечивает программирование задач реального времени с возможностями моделирования параллельных задач и обработки исключений.
Он пригоден также для системного программирования;
это требует прецизионного управления представлением данных и доступа к зависимым от системы параметрам.
Наконец, в языке определены пользовательский и машинный уровни ввода-вывода.
В данном стандарте описаны форма представления и семантика программных модулей, написанных на языке Ада.
Цель стандарта — повысить переносимость Ада-программ.
Данный стандарт определяет:
форму представления программного модуля, написанного на языке Ада;
результаты трансляции и выполнения такого программного модуля;
способ получения Ада-программ из набора программных модулей;
предопределённые программные модули, которые должна обеспечивать согласованная со стандартом реализация (далее в тексте — согласованная реализация);
допустимые в рамках стандарта изменения и способы их задания;
те нарушения стандарта, которые обязана обнаруживать согласованная реализация, а также результат попытки транслировать или выполнить программный модуль, содержащий такие нарушения;
те нарушения стандарта, которые согласованная реализация не обязана обнаруживать.
Этот стандарт не определяет:
средства преобразования программного модуля, написанного на языке Ада, в объектный код, выполняемый процессором;
средства запуска трансляции, выполнения программных модулей и управления ими;
размер и скорость выполнения объектного кода, а также относительную скорость выполнения различных языковых конструкций;
форму и содержание любых листингов, создаваемых реализациями, в частности форму и содержание сообщений об ошибках или предупреждающих сообщений;
результат выполнения программного модуля, содержащего любое нарушение стандарта, которое согласованная реализация не обязана обнаруживать;
предельный размер программы или программного модуля для конкретной согласованной реализации.
Там, где стандарт предписывает, что программный модуль, написанный на языке Ада, имеет точный результат, этот результат является функциональным значением данного программного модуля, и его должны обеспечить все согласованные реализации.
Там, где стандарт допускает неоднозначность результата выполнения программного модуля, под функциональным значением программного модуля в целом понимается множество возможных результатов, и согласованная реализация может обеспечить любой из этих возможных результатов.
Примерами допустимых неоднозначностей являются:
значения фиксированных и плавающих числовых величин, а также результаты операций над ними;
порядок выполнения операторов в различных параллельных задачах при отсутствии явной синхронизации.
Согласованная реализация должна:
корректно транслировать и выполнять правильные программные модули, написанные на языке Ада, если только их объем находится в допустимых для реализации пределах;
отвергать все программные модули, объем которых больше допускаемого реализацией;
отвергать все программные модули, содержащие ошибки, обнаружение которых предусмотрено стандартом;
обеспечивать всеми предопределёнными программными модулями, предусмотренными стандартом;
содержать только те изменения, которые допускает стандарт;
описывать допустимые изменения способом, разрешённым стандартом.
Это справочное руководство содержит четырнадцать глав, три дополнения, три приложения, указатель терминов и синтаксис.
Каждая глава делится на разделы, которые имеют общую структуру.
В каждом разделе вводятся соответствующие понятия, даются все необходимые синтаксические правила и описывается семантика соответствующих конструкций.
В конце раздела могут быть даны примеры, примечания и ссылки.
Примеры предназначены для иллюстрации возможных форм описанных конструкций.
Примечание предназначено для пояснения следствий из правил, описанных в данном или других разделах.
Ссылки нужны, чтобы обратить внимание читателей на термины и терминологические обороты, имеющие специальный смысл и определённые в других разделах.
Определение стандарта языка программирования Ада, состоящее из четырнадцати глав и трёх дополнений, предполагает, следующее ограничение: материал каждого из перечисленных ниже пунктов носит информативный характер и не является частью определения стандарта языка.
1.3.
Цели и источники разработки
1.4.
Обзор свойств языка
Примеры, примечания и ссылки, приведённые в конце любого раздела
Каждый подраздел, заголовок которого начинается со слов «Пример» или «Примеры»
Язык был разработан, исходя из трёх противоречивых требований: обеспечить надёжность и сопровождение программ, поддерживать программирование как вид человеческой деятельности и обеспечить эффективность программ.
Необходимость в языках, повышающих надёжность и упрощающих сопровождение, является установленным фактом.
В языке Ада предпочтение было отдано удобочитаемости программы по сравнению с лёгкостью её написания.
Например, правила языка требуют, чтобы все переменные и их типы были явно описаны в программе.
Далее, тип переменной неизменен, и компилятор может гарантировать совместимость операций над переменными со свойствами, присущими объектам этого типа.
Более того, чтобы избежать обозначений, которые могут привести к ошибкам, в синтаксисе языка было отдано предпочтение конструкциям, которые ближе к естественному языку, чем к каким-то кодированным формам.
Наконец, язык поддерживает раздельную компиляцию программных модулей способом, облегчающим разработку и сопровождение программ и обеспечивающим один и тот же уровень контроля для межмодульных и внутримодульных связей.
При разработке языка также учитывался человеческий фактор в программировании.
Прежде всего была сделана попытка ограничить язык настолько, насколько это позволяла широкая область его применения.
Мы попытались путём систематизации и выявления однородности охватить всю область применения небольшим числом основных понятий.
Тем не менее мы постарались вложить в языковые конструкции такую семантику, которая совпадает с интуитивным представлением о них у пользователя.
Как и многие другие виды человеческой деятельности, разработка программ становится все более децентрализованной и разобщённой.
Следовательно, одной из центральных идей при разработке языка было обеспечение возможности составлять программу из независимо разработанных компонент.
Концепции пакетов, личных типов и настраиваемых модулей прямо служат этой идее, которая повлияла на многие другие аспекты языка.
При создании любого языка нельзя избежать проблемы эффективности.
Языки, которые требуют сверхсложных компиляторов или приводят к неэффективному использованию памяти и времени выполнения программы, дают неэффективные результаты на всех машинах и для всех программ.
При создании языка Ада каждая его конструкция оценивалась с точки зрения современных методов реализации.
Отвергались все те конструкции, которые были недостаточно ясными или требовали чрезмерных машинных ресурсов.
Ни одна из указанных выше целей разработки языка не откладывалась на будущее.
Все они учитывались одновременно и с самого начала разработки.
При разработке любого языка трудность заключается в том, что необходимо определить не только возможности, которыми должен обладать язык и которые диктует предполагаемая область применения, но и собственно разработать средства языка, обеспечивающие эти возможности.
Подобная трудность существовала и при разработке языка Ада, хотя благодаря стилмановским требованиям она была меньше, чем обычно.
Стилмановские требования, коль скоро требования уже существуют, позволяли сконцентрировать внимание собственно на создании системы, удовлетворяющей этим требованиям, что часто упрощало процесс разработки.
Другое обстоятельство, существенно упростившее разработку, было следствием приобретённого ранее опыта реализации удачных проектов с целями, подобными указанным выше, на базе языка Паскаль.
Такими языками являются языки Евклид, Лис, Меса, Модула и Сью.
Многие из ключевых идей и синтаксических форм этих языков имеют аналоги в языке Ада.
Некоторые существующие языки, такие как Алгол-68 и Симула, а также современные проекты языков Альфард и Клу, также повлияли на разработку языка, хотя и в меньшей степени, чем языки семейства Паскаль.
Наконец, большое значение для определения стандарта языка имели его начальная разработка (язык «Зелёный»), проекты языков «Красный», «Голубой» и «Жёлтый», рассмотрение различных стадий проекта и тысячи замечаний, полученных из 15 стран на предварительных этапах разработки и в процессе голосования при стандартизации, — все это оказало значительное влияние на определение стандарта языка.
Ада-программа представляет собой один или несколько программных модулей.
Эти программные модули могут компилироваться раздельно.
Программные модули — это подпрограммы (определяющие выполняемый алгоритм), пакеты (определяющие наборы понятий), модули-задачи (определяющие параллельные вычисления) или настраиваемые модули (определяющие параметризованные пакеты и подпрограммы).
Каждый модуль обычно состоит из двух частей: спецификации, содержащей видимую для других модулей информацию, и тела, содержащего детали реализации, о которых другие модули не обязаны знать.
Это различие между спецификацией и телом, а также возможность компилировать модули раздельно позволяют разрабатывать, кодировать и тестировать программу как множество в достаточной степени независимых программных компонент.
Ада-программа обычно будет использовать библиотеку программных модулей общего назначения.
Язык предоставляет средства, с помощью которых отдельные организации могут создавать свои собственные библиотеки.
В тексте раздельно компилируемого программного модуля должны быть указаны имена библиотечных модулей, которые ему требуются.
Программные модули
Подпрограмма является основным модулем для представления алгоритма.
Существует два вида подпрограмм: процедуры и функции.
Процедура — это средство вызова последовательности действий.
Например, она может считывать данные, изменять значения переменных или выводить информацию.
Процедура может иметь параметры для управления механизмом передачи информации между процедурой и точкой вызова.
Функция — это средство вызова действий по вычислению значения.
Она подобна процедуре, но в результате выполнения ещё и возвращает значение.
Пакет — это основной модуль для определения набора логически связанных понятий.
Например, пакет может быть использован для определения общей группы данных и типов, набора взаимосвязанных подпрограмм или же множества описаний типов и соответствующих операций.
Части пакета могут быть скрыты от пользователя, разрешая, таким образом, доступ только к тем логическим свойствам, которые описаны в спецификации пакета.
Задачный модуль — это основной модуль для определения задачи, последовательность действий которой может выполняться параллельно с выполнением других задач.
Такие задачи могут быть реализованы на многомашинной или многопроцессорной системе либо чередованием выполнения задач на одном процессоре.
Задачный модуль может определить или одну выполняемую задачу, или задачный тип, позволяющий создать любое количество подобных задач.
Описания и операторы
Тело программного модуля, как правило, содержит две части: раздел описаний, который определяет логические понятия, используемые в программном модуле, и последовательность операторов, определяющую выполнение этого программного модуля.
Раздел описаний связывает имена с описанными понятиями.
Например, имя может обозначать тип, константу, переменную или исключение.
Раздел описаний также может вводить имена и параметры других вложенных подпрограмм, пакеты, задачные модули и настраиваемые модули, используемые в этом программном модуле.
Последовательность операторов описывает последовательность действий, которые должны быть выполнены.
Операторы выполняются последовательно
(если только оператор возврата, перехода, выхода или возбуждения исключения не вызовет продолжения выполнения с другого места).
Оператор присваивания изменяет значение переменной.
Вызов процедуры инициирует выполнение процедуры после сопоставления каждого фактического параметра, заданного в вызове, соответствующему формальному параметру.
Оператор выбора и условный оператор позволяют выполнить одну из входящих в них последовательностей операторов, определяемую значением выражения или значением условия.
Оператор цикла обеспечивает основной итерационный механизм в языке.
Оператор цикла задаёт повторение выполнения некоторой последовательности операторов по заданной итерационной схеме или до выполнения оператора выхода.
Оператор блока включает в себя последовательность операторов, которым предшествуют описания локальных понятий, используемых в этих операторах.
Некоторые операторы применимы только к задачам.
Оператор задержки приостанавливает выполнение задачи на указанный интервал времени.
Оператор вызова входа записывается как оператор вызова процедуры;
он показывает, что выполнившая этот вызов задача готова для рандеву с другой задачей, имеющей указанный вход.
Вызываемая задача готова принять вызов входа, когда её выполнение достигает соответствующего оператора принятия, который определяет выполняемые далее действия.
После завершения рандеву обе задачи, как вызывающая, так и имеющая вход, продолжают своё параллельное выполнение.
Одна из форм оператора отбора допускает отбор с ожиданием для одного из нескольких альтернативных рандеву.
Другие формы оператора отбора допускают условные или временные вызовы входа.
Выполнение программного модуля может привести к ошибочным ситуациям, вследствие чего продолжение нормального выполнения программы невозможно.
Например, результат арифметического вычисления может превысить максимально допустимое числовое значение или предпринята попытка доступа к компоненте массива с неправильным значением индекса.
Для работы с такими ошибочными ситуациями текстуально за операторами программного модуля могут следовать обработчики исключений, определяющие предпринимаемые при возникновении ошибочных ситуаций действия.
Исключения могут быть возбуждены и явно оператором возбуждения.
Типы данных
Каждый объект языка имеет тип, характеризующий множество значений и множество применимых к ним операций.
Основные классы типов — это скалярные типы (включающие перечислимые и числовые типы), составные, ссылочные и личные типы.
Перечислимый тип определяет упорядоченное множество различных литералов перечисления, например список состояний или перечень символов.
Перечислимые типы BOOLEAN и CHARACTER предопределены.
Числовые типы обеспечивают средства выполнения точных или приближенных числовых вычислений.
Для точных вычислений используются целые типы, которые обозначают множества последовательных целых чисел.
В приближенных вычислениях используются либо фиксированные типы (типы чисел с фиксированной точкой), представимые с абсолютной погрешностью, либо плавающие типы (типы чисел с плавающей точкой), представимые с относительной погрешностью.
Числовые типы INTEGER, FLOAT и DURATION предопределены.
Составные типы допускают определения структурных объектов из сгруппированных компонент.
Составные типы в языке представлены массивами и записями.
Массив — это объект с индексируемыми компонентами одного и того же типа.
Запись — это объект с именованными компонентами, возможно, различных типов.
Индексируемый тип STRING предопределён.
Запись может иметь специальные компоненты, называемые дискриминантами.
В записях можно определить альтернативные структуры, зависящие от значений дискриминантов.
Ссылочные типы позволяют вычислением генератора создавать связанные ссылками структуры данных.
Они позволяют нескольким переменным ссылочного типа указывать на один и тот же объект, а компонентам одного объекта указывать на тот же самый или другие объекты.
Элементы такой связанной ссылками структуры данных и их связи с другими элементами могут быть изменены во время выполнения программы.
Личные типы могут быть определены в пакете, скрывающем внутреннюю структуру, несущественную вне пакета.
Пользователю таких типов видны логически существенные их свойства (включая дискриминанты).
Концепция типа уточняется концепцией подтипа, благодаря чему пользователь может ограничить множество допустимых значений данного типа.
Подтипы могут быть использованы для определения поддиапазонов скалярных типов, массивов с ограниченным множеством значений индексов, а также именованных и личных типов с конкретными значениями дискриминантов.
Другие свойства языка
Для определения отображения типов на архитектуру объектной машины можно использовать спецификаторы представления.
Например, пользователь может задать число битов для представления объектов данного типа или размещение в памяти машины компонент записи.
Другие свойства языка допускают управляемое использование особенностей, связанных с низким уровнем, непереносимостью или зависимостью от реализации, включая прямое использование машинного кода.
Ввод-вывод в языке определён средствами предопределённых библиотечных пакетов.
Предоставляются средства для ввода-вывода значений типов, определённых пользователем, а также значений предопределённых типов.
Обеспечивается представление изображений значений в стандартной форме.
Наконец, язык предоставляет мощные средства параметризации программных модулей, называемых настраиваемыми программными модулями.
Параметрами настройки могут быть типы и подпрограммы (а также объекты), и, таким образом, допустимы общие алгоритмы, применимые для всех типов данного класса.
Контекстно-свободный синтаксис программных модулей языка Ада вместе с контекстно-зависимыми требованиями выражается правилами в повествовательной форме.
Семантика программных модулей описана правилами определения результата выполнения каждой конструкции и правилами их построения.
В изложении используются термины, точное определение которых дано в тексте
(ссылки на содержащие определения разделы помещены в конце каждого использующего понятие раздела).
Все другие понятия имеют своё естественное значение, определённое в словаре русского языка Ушакова .
Контекстно-свободный синтаксис языка описывается с помощью простого варианта форм Бэкуса-Наура.
В частности:
Записанные строчными буквами слова, возможно содержащие в некоторых случаях символ подчёркивания, используются для обозначения синтаксических понятий, например:
В названиях синтаксических понятий, используемых вне контекста синтаксических правил, вместо символа подчёркивания используется пробел (например, аддитивная операция).
Полужирным шрифтом выделены зарезервированные слова, например:
В квадратные скобки заключены необязательные элементы.
Поэтому два следующих правила эквивалентны:
Повторяющиеся элементы заключаются в фигурные скобки.
Этот элемент может встретиться нуль или более раз;
повторение осуществляется слева направо в соответствии с правилом левой рекурсии.
Таким образом, два следующих правила эквивалентны:
Вертикальная черта разделяет альтернативные элементы, кроме тех случаев, когда черта встречается непосредственно за открывающейся фигурной скобкой, тогда она обозначает знак вертикальной черты:
Если название какого-нибудь синтаксического понятия содержит выделенную курсивом часть, оно эквивалентно названию синтаксического понятия без выделенной курсивом части.
Выделенная курсивом часть предназначена для выражения некоторой семантической информации.
Например, имя типа и имя задачи эквивалентны просто понятию имя.
Описывающие структурные конструкции синтаксические правила представлены в форме, соответствующей рекомендованному делению на абзацы.
Например, условный оператор определяется так:
Синтаксические правила записываются в несколько строчек, если соответствующие части конструкции рекомендуется располагать на разных строчках.
Все отступы от начала строчки рекомендованы в правилах для сдвига соответствующих частей конструкции.
Все отступы должны быть кратны базовому шагу отступа
(число пробелов в базовом шаге не определяется).
Переход на новую строчку рекомендуется после точки с запятой.
С другой стороны, если вся конструкция умещается на одной строчке, то это также допустимо.
Определение языка делит ошибки на несколько различных категорий:
Ошибки, которые должны быть обнаружены во время компиляции любым компилятором с языка Ада.
Эти ошибки соответствуют любому нарушению правил, данных в этом стандарте, кроме нарушений, соответствующим пунктам б) и в).
В частности, к этой категории относятся нарушения правил, в которых использованы слова должно, допустимо, правильный или неправильный.
Любая содержащая такую ошибку Ада-программа не является правильной;
с другой стороны, тот факт, что программа правильна в этом смысле, не означает, что в ней нет других ошибок.
Ошибки, которые должны быть обнаружены во время выполнения Ада-программы.
Соответствующим ошибочным ситуациям сопоставлены имена предопределённых исключений.
Каждый компилятор с языка Ада должен генерировать код, возбуждающий соответствующее исключение, если такая ошибочная ситуация встретится во время выполнения программы.
Если исключение обязательно будет возбуждаться при выполнении данной программы, то компиляторы могут (но не обязательно) сообщить об этом во время компиляции.
Ошибочное выполнение.
В языке определён ряд правил, которым должна подчиняться Ада-программа, хотя от компилятора и не требуется обнаружение нарушений этих правил ни во время компиляции, ни во время выполнения программы.
Слово ошибочный квалифицирует выполнение конструкций, содержащих ошибки этой категории.
Результат выполнения ошибочной конструкции непредсказуем.
Некорректная зависимость от порядка.
Когда в справочном руководстве указывается, что различные части данной конструкции должны быть выполнены в порядке, который не определён в языке, это означает, что реализация допускает выполнение этих частей в любом порядке, но не параллельно.
Более того, конструкция некорректна, если выполнение этих частей в различном порядке даёт различный результат.
Во время компиляции и во время выполнения программы (этот процесс называется выполнением) компилятор не всегда обеспечивает проверку некорректной зависимости результата от порядка.
Термин выполнение в равной мере применим к процессам, которые называют вычислением и предвыполнением.
Если компилятор способен распознать во время компиляции, что конструкция ошибочна или содержит некорректную зависимость от порядка, то допускается, чтобы компилятор генерировал код, заменяющий конструкцию кодом, возбуждающим предопределённое исключение PROGRAM_ERROR.
Компилятор также может сгенерировать код, который во время выполнения проверяет ошибочность конструкции, некорректную зависимость от порядка или и то и другое.
Предопределённое исключение PROGRAM_ERROR возбуждается, если проверка покажет наличие такой ошибки.
Текст программы состоит из текстов одной или нескольких компиляций.
Текст компиляции — это последовательность лексических элементов (лексем), каждая из которых состоит из символов.
В этой главе приведены правила составления лексем.
Кроме того, в ней описаны прагмы, задающие определённую информацию для компилятора.
Символами в тексте программы должны быть только графические символы и символы управления форматом.
Каждый графический символ соответствует единственному коду из набора символов ISO, кодируемых семью разрядами (стандарт ISO 646), и представляется (визуально) графическим знаком.
Некоторые графические символы представляются различными графическими знаками в национальных представлениях набора символов ISO.
При описании определения языка в данном справочном руководстве используются графические знаки ASCII, представляющие собой национальное представление ANSI набора символов ISO.
Набор основных символов достаточен для написания любой программы.
Основные графические символы подразделяются на следующие категории: прописные буквы, цифры, специальные символы, символ пробела.
Символы управления форматом — это символы ISO (и ASCII), называющиеся горизонтальной табуляцией, вертикальной табуляцией, возвратом каретки, переводом строчки и переводом формата.
Остальные категории графических символов определяются следующим образом: строчные буквы, дополнительные специальные символы.
В разд.
2.10 определены допустимые замены для специальных символов вертикальной черты (|), номера (#) и кавычки (").
Графическому символу номера в представлении ASCII соответствует символ фунта стерлингов в представлении национальных стандартов Франции, Германии и Великобритании.
Шрифтовые выделения графических символов (например, курсив или полужирный шрифт) не являются частью стандарта ISO.
Под использованными в этом разделе акронимами понимают следующее: ANSI — Американский национальный институт стандартов, ASCII — Американский стандартный код для обмена информацией, ISO — Международная организация по стандартизации.
Для ссылок на специальные и дополнительные специальные символы используются следующие их наименования:
Текст программы состоит из текстов одной или нескольких компиляций.
Текст каждой компиляции — это последовательность отдельных лексем.
Лексема (лексический элемент) — это ограничитель, идентификатор (который может быть зарезервированным словом), числовой литерал, символьный литерал, строковый литерал или комментарий.
Результат выполнения программы зависит только от конкретной последовательности лексем, исключая возможные комментарии.
В некоторых случаях необходим явный разделитель между соседними лексемами
(в противном случае они могут быть восприняты как одна).
Разделителем может быть символ пробела, символ управления форматом или конец строчки.
Символ пробела не является разделителем в комментарии, строковом литерале или символьном литерале.
Символ управления форматом (кроме символа горизонтальной табуляции, когда он употребляется в комментариях) всегда является разделителем.
Горизонтальная табуляция является разделителем, если он не находится в комментариях.
Конец строчки всегда является разделителем.
Язык не определяет, что является концом строчки.
Если в данной реализации конец строчки обозначается одним или несколькими символами, то эти символы должны быть символами управления форматом, отличными от символа горизонтальной табуляции.
Во всяком случае, последовательность из одного или нескольких символов управления форматом, отличных от символа горизонтальной табуляции, должна заменить по крайней мере один конец строчки.
Один или несколько разделителей допустимы между соседними, перед первой или после последней лексемы.
По крайней мере один разделитель необходим между идентификатором или числовым литералом и соседними идентификаторами или числовыми литералами.
Ограничитель — это один из следующих специальных символов из набора основных символов:
или один из следующих составных ограничителей, представляющих собой пару специальных символов:
Каждый специальный символ является простым ограничителем, за исключением тех случаев, когда он встречается в составном ограничителе, в комментарии, в строковом, символьном или числовом литералах.
Остальные формы лексем описаны в других разделах данной главы.
Каждая лексема должна располагаться в одной строчке, поскольку конец строчки — разделитель.
Символы кавычки, решётки, подчёркивания и два соседних дефиса не являются ограничителями, но могут входить в лексемы в качестве её частей.
Наименования составных ограничителей даны ниже:
Идентификаторы используются в качестве имён и зарезервированных слов.
Все символы идентификатора существенны, включая символ подчёркивания между соседними буквами или цифрами.
Идентификаторы, различающиеся только размерами букв, считаются совпадающими.
Пробел внутри идентификатора недопустим, поскольку он является разделителем.
Числовые литералы подразделяются на два класса: вещественные литералы и целые литералы.
Вещественный литерал — это числовой литерал, который включает точку;
целый литерал — это числовой литерал без точки.
Вещественные литералы являются литералами типа универсальный вещественный.
Целые литералы — литералы типа универсальный целый.
Десятичный литерал — это числовой литерал, выраженный в общепринятой десятичной системе (основание по умолчанию равно десяти).
Символ подчёркивания между соседними цифрами десятичного литерала не влияет на значение числового литерала.
Буква Е в порядке может быть строчной или прописной буквой с одним и тем же назначением.
Для получения значения десятичного литерала с порядком следует умножить значение десятичного литерала без порядка на степень десяти, заданную порядком.
Порядок для целого литерала не должен содержать знак минус.
Ведущие нули допускаются.
Пробел в числовом литерале недопустим даже между составными частями порядка, поскольку пробел является разделителем.
Нулевой порядок для целого литерала допустим.
Литерал с основанием — это числовой литерал, в котором явно указано основание.
Основание должно принимать значение от 2 до 16.
Символ подчёркивания, заключенный между соседними цифрами литерала с основанием, не влияет на значение этого числового литерала.
Основание и порядок записываются в десятичной системе.
В качестве расширенных цифр от 10 до 15 допускаются только латинские буквы от А до F.
Буква в литерале с основанием (расширенная цифра или буква Е в порядке) может быть строчной или прописной с одним и тем же смыслом.
Предполагается обычный смысл обозначения литерала с основанием;
в частности, значение каждой расширенной цифры литерала с основанием должно быть меньше основания.
Для получения значения литерала с основанием и порядком следует умножить значение литерала с основанием без порядка на основание, возведённое в указанную порядком степень.
Символьный литерал — это один из 95 графических символов (включая пробел), заключенный между двумя символами апострофа.
Символьный литерал имеет значение символьного типа.
Строковый литерал образуется из последовательности (возможно, пустой) графических символов, заключённой между двумя символами кавычки — строковыми скобками.
Строковый литерал имеет значение последовательности значений символов, соответствующих графическим символам строкового литерала, кроме внешних символов кавычки.
Для представления кавычки в последовательности значений символов необходимо в соответствующем месте внутри строкового литерала поместить пару соседних символов кавычки.
(это означает, что строковый литерал, включающий два соседних символа кавычки, никогда не рассматривается как два строковых литерала).
Длина строкового литерала — это количество значений символьного типа в представленной последовательности.
(каждые два соседних символа кавычки в строке считаются одним символом).
Строковый литерал должен помещаться на одной строчке, поскольку он является лексемой (см. 2.2).
Более длинные последовательности значений графических символов могут быть получены катенацией строковых литералов.
Равным образом катенация констант, описанных в пакете ASCII, может быть использована для получения последовательности значений символьного типа, которая включает значения неграфических символов (так называемых управляющих символов).
Ниже даны примеры использования катенации:
Комментарий начинается с двух соседних дефисов и продолжается до конца строчки.
Комментарий может помещаться в любой строчке программы.
Присутствие или отсутствие комментария не влияет ни на правильность, ни на неправильность программы.
Более того, комментарии не влияют на смысл программы;
их единственное назначение — сделать программу более понятной.
Горизонтальная табуляция может быть использована в комментариях после двух дефисов, это эквивалентно одному или нескольким пробелам (см. 2.2).
Прагма используется для задания информации компилятору.
Прагма начинается зарезервированным словом pragma, за которым следует идентификатор — имя прагмы.
Прагмы допустимы только в следующих местах программы:
После ограничителя точки с запятой, но не внутри раздела формальных параметров или раздела дискриминантов.
В любом месте, где синтаксические правила допускают синтаксические понятия, в названии которых содержатся слова «описание», «оператор», «спецификатор» или «альтернатива», или одно из синтаксических понятий — вариант и обработчик исключений, но не вместо соответствующих конструкций.
А также в любом месте, где допустим компилируемый модуль.
На месторасположение отдельных прагм могут накладываться дополнительные ограничения.
Некоторые прагмы имеют аргументы.
Сопоставления аргументов могут быть либо позиционными, либо именованными, как и при сопоставлении параметров в вызовах подпрограмм (см. 6.4).
Однако именованные сопоставления возможны, если определены идентификаторы аргументов.
Именем аргумента должно быть либо имя, видимое в месте употребления прагмы, либо идентификатор, специфический для этой прагмы.
Предопределённые прагмы описаны в приложении В; они должны поддерживаться в каждой реализации.
Реализация может определить дополнительные прагмы, которые должны быть описаны в приложении F.
Реализация не должна допускать определение прагм, наличие или отсутствие которых влияет на правильность текста программы.
Следовательно, правильность программы не зависит от наличия или отсутствия прагм, определённых реализацией.
Прагма, не определённая в языке, не даёт никакого результата, если её идентификатор не распознан (данной) реализацией.
Более того, прагма (как определённая в языке, так и определённая реализацией) не даёт никакого результата, если её размещение или её аргументы не соответствуют допустимым для прагмы.
Участок текста, на который распространяется действие прагмы, зависит от прагмы.
Рекомендуется (но не требуется), чтобы реализация выдавала предупреждающие сообщения о прагмах, которые не распознаны и поэтому проигнорированы.
Понятие со словом «описание»: описание входа 9.5, описание компоненты 3.7, описание параметра настройки 12.1, основное описание 3.1.
Понятие со словом «спецификатор>: спецификатор выравнивания 13.4, спецификатор использования 8.4, спецификатор компоненты 13.4, спецификатор контекста 10.1.1, спецификатор представления 13.1, спецификатор совместности 10.1.1.
Понятие со словом «альтернатива»: альтернатива завершения 9.7.1, альтернатива задержки 9.7.1, альтернатива оператора выбора 5.4, альтернатива отбора 9.7.1, альтернатива отбора с ожиданием 9.7.1, альтернатива принятия 9.7.1.
Перечисленные ниже идентификаторы называются зарезервированными словами, они зарезервированы в языке для специального назначения.
Для удобства чтения этого руководства зарезервированные слова пишутся строчными буквами полужирным шрифтом (после тире указан перевод слова).
Зарезервированные слова не должны использоваться в качестве описываемого идентификатора.
Зарезервированные слова, отличающиеся только соответствующими строчными или прописными буквами, рассматриваются как одинаковые (см. 2.3).
Идентификаторы некоторых атрибутов, стоящие после апострофа, совпадают с зарезервированными словами (DELTA, DIGITS и RANGE).
Для основных символов — вертикальной черты, номера и кавычки — допустимы следующие замены:
Символ вертикальной черты (|) можно заменить восклицательным знаком (!) там, где он используется как ограничитель.
Символ номера (#) в литерале с основанием можно заменить двоеточием (:) при условии, что в этом литерале заменяются оба символа номера.
Символ кавычки ("), использованный как строковая скобка на обоих концах строкового литерала, можно заменить символом процента (%), если последовательность символов строкового литерала не содержит символа кавычки и если в этом литерале заменяются обе строковые скобки.
Для представления символа процента внутри последовательности символов строкового литерала должна использоваться пара соседних символов процента, которая рассматривается как один символ процента.
Эти замены не изменяют смысла программы.
Рекомендуется, чтобы замена символов вертикальной черты, номера и кавычки была ограничена случаями, когда соответствующих графических символов нет на терминалах.
Заметим, что вертикальная черта изображается на некоторых устройствах прерывистой линией, замена в этом случае не рекомендуется.
Правила для идентификаторов и числовых литералов таковы, что строчные и прописные буквы эквивалентны;
эти лексемы могут быть записаны только символами основного набора.
Если строковый литерал предопределённого типа STRING содержит символы не из основного набора, та же самая последовательность значений символов может быть получена катенацией строковых литералов, содержащих символы основного набора, и символьных констант, описанных в предопределённом пакете ASCII.
Таким образом, строковый литерал "AB$CD" можно заменить на "АВ" & ASCII.DOLLAR & "CD".
Аналогично, строковый литерал "ABcd" со строчными буквами можно заменить на "АВ" & ASCII.LC_C & ASCII.LC_D.
Эта глава описывает типы и правила описания констант, переменных и именованных чисел.
В языке определены понятия, объявляемые явно или неявно описаниями.
К таким понятиям относятся, например: числовой литерал, объект, дискриминант, компонента записи, параметр цикла, исключение, тип, подтип, подпрограмма, пакет, задачный модуль, настраиваемый модуль, одиночный вход, семейство входов, формальный параметр (подпрограммы, входа, настраиваемой подпрограммы), формальный параметр настройки, именованный блок или цикл, помеченный оператор, а также операция (в частности, атрибут или литерал перечисления, см. 3.3.3).
Существует, несколько форм описаний.
Основное описание — это форма описания, определённая следующим образом:
Некоторые формы описания всегда являются (явно) частью основного описания, а именно: спецификация дискриминантов, описание компонент, описание входов, спецификация параметров, описание параметров настройки и спецификации литералов перечисления.
Спецификация параметра цикла — это конструкция, которая входит только в некоторые формы оператора цикла.
Остальные формы описания являются неявными: имя блока, имя цикла и метка оператора.
Некоторые операции описываются неявно (см. 3.3.3).
Для каждой формы описания правила языка определяют некоторый участок текста, называемый областью действия описания (см. 8.2).
Несколько форм описания связывают идентификатор с описанным понятием.
Внутри его области действия, и только в ней, существуют места, где возможно использование идентификатора для связи его с описанным понятием;
эти места определяются правилами видимости (см. 8.3.).
В таких местах идентификатор называют именем понятия (простым именем);
говорят, что имя обозначает связанное с ним понятие.
Определённые формы спецификации литерала перечисления связывают символьный литерал с соответствующим описываемым понятием.
Некоторые формы описаний связывают символ операции или другие обозначения с явно или неявно описанной операцией.
Процесс, в результате которого описание вступает в силу, называется предвыполнением описания;
этот процесс протекает во время выполнения программы.
Говорят, что после своего предвыполнения описание становится предвыполненным.
До завершения своего предвыполнения (как и до его начала) описание считается ещё не предвыполненным.
Предвыполнение любого описания даёт всегда по крайней мере один эффект: описание из ещё не предвыполненного становится предвыполненным.
Фраза Предвыполнение не даёт другого эффекта используется тогда, когда происходит только изменение статуса описания.
Процесс предвыполнения определяется также для разделов описаний, элементов описания и компилируемых модулей (см. 3.9 и 10.5).
Описания объекта, числа, типа и подтипа даны в этой главе.
Остальные основные описания изложены в последующих главах.
Синтаксические правила используют термин идентификатор для первого вхождения идентификатора в некоторую форму описания;
термин простое имя используется для любого вхождения идентификатора, который уже обозначает какое-либо описанное понятие.
Объект — это понятие языка; объект имеет (содержит) значение данного типа.
Объектом может быть:
объект, объявленный в описании объекта или в описании одиночной задачи;
формальный параметр подпрограммы, входа или настраиваемой подпрограммы;
формальный объект настройки;
параметр цикла;
объект, указанный значением ссылочного типа;
компонента или отрезок другого объекта.
Описание числа — это специальная форма описания объекта, которая связывает идентификатор со значением типа универсальный целый или универсальный вещественный.
Описание объекта называется единичным описанием объекта, если список его идентификаторов имеет единственный идентификатор;
оно называется групповым описанием объектов, если его список имеет два или несколько идентификаторов.
Групповое описание объектов эквивалентно последовательности соответствующего числа единичных описаний объектов.
Для каждого идентификатора из списка в такой эквивалентной последовательности единичное описание объекта формируется из идентификатора, двоеточия и всего того, что стоит справа от двоеточия в групповом описании объекта;
описания в эквивалентной последовательности идут в том же порядке, что и список идентификаторов.
Аналогичная эквивалентность имеет место также для списка идентификаторов описания числа, описаний компонент, спецификаций дискриминантов, спецификаций параметров и описаний параметров настройки, исключений и субконстант.
В остальной части описания языка все пояснения даны для описаний с единственным идентификатором;
соответствующие пояснения для описаний с несколькими идентификаторами следуют из эквивалентности, установленной выше.
Описание объектов вводит объект, тип которого задан либо указанием подтипа, либо определением индексируемого типа.
Если описание объекта включает составной ограничитель-присваивание, за которым следует выражение, то это выражение определяет начальное значение описываемого объекта;
тип выражения должен быть тем же, что и тип объекта.
Описываемый объект — константа, если в описании объекта присутствует зарезервированное слово constant.
В этом случае описание должно включать явную инициализацию.
Значение константы не может быть изменено после инициализации.
Формальные параметры вида in подпрограмм и входов, а также формальные параметры настройки вида in являются константами;
параметр цикла — константа в соответствующем цикле;
подкомпонента или отрезок константы тоже константа.
Объект, не являющийся константой, называется переменной
(в частности, объект, заданный описанием объекта без зарезервированного слова constant, является переменной).
Для изменения значения переменной существует только два пути: непосредственное присваивание и косвенное изменение (см. 6.2) оператором вызова процедуры или входа
(это действие может быть выполнено над самой переменной, над подкомпонентой переменной либо над другой переменной, для которой данная является подкомпонентой).
Предвыполнение описания объекта происходит следующим образом:
Сначала предвыполняется указания подтипа или определения ограниченного индексируемого типа.
Результат устанавливает подтип объекта.
Если описание объекта включает явную инициализацию, то его начальное значение получается вычислением соответствующего выражения.
В противном случае вычисляются неявные начальные значения (если они есть) объекта или его подкомпонент.
Создаётся объект.
Начальное значение (заданное явно или по умолчанию) присваивается объекту или соответствующей подкомпоненте.
Неявные начальные значения определяются для объектов, заданных описанием объекта, и для компонент таких объектов в следующих случаях:
Для объекта ссылочного типа — его неявное начальное значение равно пустому значению ссылочного типа.
Для объекта задачного типа — неявное начальное (и единственное) значение обозначает соответствующую задачу.
Если тип объекта является типом с дискриминантами и его подтип ограничен, то неявное начальное (и единственное) значение каждого дискриминанта определяется подтипом объекта.
Для объекта составного типа неявное начальное значение каждой компоненты, имеющей выражение по умолчанию, получается вычислением этого выражения, если только компонента не дискриминант ограниченного объекта (предыдущий случай).
Если компонента сама является составным объектом, значение которой не определено ни явной инициализацией, ни выражением по умолчанию, то неявное начальное значение компонент составного объекта определяется теми же самыми правилами, что и для описанного объекта.
Шаги от а до г выполняются в указанном порядке.
Если на шаге б вычисляется выражение по умолчанию для дискриминанта, то это вычисление выполняется до вычисления выражений по умолчанию для зависимых от дискриминанта подкомпонент, а также до вычисления выражений по умолчанию, содержащих имя дискриминанта.
Кроме предыдущего правила, порядок вычисления выражений по умолчанию языком не определён.
При инициализации описанного объекта или одной из его подкомпонент проверяется принадлежность начального значения подтипу объекта;
для массива, описанного описанием объекта, сначала применяется неявное преобразование подтипа, как при выполнении оператора присваивания, если только объект не является константой с подтипом неограниченного индексируемого типа.
При отрицательном результате проверки возбуждается исключение CONSTRAINT_ERROR.
Значение скалярной переменной после предвыполнения соответствующего описания объекта не определено, если начальное значение не было присвоено переменной при (явной или неявной) инициализации.
Если операнд преобразования типа или квалифицированного выражения является составной переменной с неопределёнными значениями скалярных подкомпонент, то значения соответствующих подкомпонент результата неопределённы.
Выполнение программы ошибочно, если делается попытка вычислить скалярную переменную с неопределённым значением.
Аналогично выполнение программы ошибочно, если делается попытка применить предопределённую операцию к составной переменной, имеющей скалярную подкомпоненту с неопределённым значением.
Примеры описаний переменных:
Примеры описаний констант:
Выражение для инициализации константы не обязательно является статическим выражением (см. 4.9).
В приведённых выше примерах LIMIT и LOW-LIMIT инициализированы статическими выражениями, а TOLERANCE - нет, если DISPERSION - определённая пользователем функция.
Описание числа — это специальная форма описания константы.
Тип статического выражения, заданного для инициализации в описании числа, должен быть либо типом универсальный целый, либо типом универсальный вещественный.
Константа, объявленная описанием числа, называется именованным числом и имеет тот же тип, что и статическое выражение.
Относящиеся к выражениям универсального типа правила изложены в разделе 4.10.
Из этих правил следует, что именованное число имеет универсальный целый тип, если каждое содержащееся в выражении первичное имеет этот тип.
Аналогично если каждое первичное имеет тип универсальный вещественный, то именованное число имеет этот тип.
Примеры описаний чисел:
Тип характеризуется множеством значений и множеством операций.
Существует несколько классов типов.
Скалярные типы — это целые и вещественные типы и типы, определённые перечислением своих значений;
значения этих типов не имеют компонент.
Индексируемый и именуемый типы являются составными.
Значение составного типа состоит из значений компонент.
Ссылочный тип — это тип, значения которого обеспечивают доступ к объектам.
Личные типы — это типы, для которых полностью определяется набор возможных значений, но непосредственный доступ к ним пользователей невозможен.
Наконец, существуют задачные типы.
(Личные типы описаны в гл. 7, задачные — в гл. 9, остальные — в гл. 3.)
Именуемые и личные типы могут иметь специальные компоненты, называемые дискриминантами, значения которых различают альтернативные формы значений одного из этих типов.
Если личный тип имеет дискриминанты, они известны пользователям типа.
Следовательно, личный тип известен только своим именем, своими дискриминантами, если они есть, и соответствующим набором операций.
Набор возможных значений данного типа может зависеть от условия, которое называется ограничением
(сюда не относятся случаи без ограничения),
значение удовлетворяет ограничению, если оно удовлетворяет соответствующему условию.
Подтип — это тип вместе с ограничением;
говорят, что значение принадлежит подтипу, если оно принадлежит типу и удовлетворяет ограничению;
данный тип называется базовым типом подтипа.
Тип является подтипом самого себя; такой подтип называется неограниченным; он соответствует условию, которое не налагает никаких ограничений.
Базовым типом является он сам.
Множество операций, определённых над конкретным типом, определено и для любого его подтипа;
однако переменной данного подтипа можно присвоить значение только этого подтипа.
Дополнительные операции, например квалификация (в квалификационном выражении), неявно определяются описанием подтипа.
Для объектов некоторых типов определено начальное значение по умолчанию, некоторые другие типы имеют выражения по умолчанию, определённые для всех или части своих компонент.
Некоторые операции над типами и подтипами называются атрибутами;
эти операции обозначаются именами, описанными в разд.
4.1.4.
Термин подкомпонента используется в описании языка вместо термина компонента, чтобы указать компоненту другой компоненты или подкомпоненты.
Если нет других подкомпонент, используется термин компонента.
Подкомпонента значения данного типа не должна быть этого же типа.
Имя класса типов используется в описании языка для квалификации объектов и значений, принадлежащих к типу рассматриваемого класса.
Например, термин индексируемый объект используется для объекта индексируемого типа;
аналогично термин ссылочное значение используется для значения ссылочного типа.
Набор значений подтипа — это подмножество значений базового типа.
Это подмножество не обязано быть собственным подмножеством;
оно может быть пустым.
Описание типа объявляет тип.
Предвыполнение полного описания типа состоит из предвыполнения раздела дискриминантов, если он есть (исключая случай использования полного описания типа для неполного описания типа или описания личного типа), и предвыполнения определения типа.
Типы, созданные в результате предвыполнения различных определений, являются различными.
Более того, Предвыполнение определения типа для числовых или производных типов создаёт как базовый тип, так и подтип базового типа;
то же самое выполняется для определения ограниченного индексируемого типа (одной из двух форм определения индексируемого типа).
Простое имя в полном описании типа обозначает описанный тип, если только описание типа не объявляет базовый тип и подтип базового типа; в этом случае простое имя обозначает подтип, а базовый тип является анонимным.
Тип называется анонимным, если он не имеет простого имени.
Для наглядности в этом стандарте время от времени используется псевдоимя анонимного типа, написанное курсивом, там, где обычно по синтаксису требуется идентификатор.
Примеры определений типов:
Примеры описаний типов:
Два определения типа всегда определяют два различных типа, даже если они текстуально идентичны.
Таким образом, данные ниже описания А и В задают различные индексируемые типы:
Если А и В описаны в групповом описании объектов, то их типы (анонимные) тем не менее различны, так как это групповое описание объектов эквивалентно двум приведённым выше единичным описаниям.
Неполные описания типов используются для определения рекурсивных и взаимосвязанных типов (см. 3.8.1).
Описания личных типов используются в спецификациях пакетов и в описаниях параметров настройки .(см. 7.4 и 12.1).
Описание подтипа объявляет подтип.
Обозначение типа обозначает тип или подтип.
Если обозначение типа — имя типа, то оно обозначает этот тип, а также соответствующий неограниченный подтип.
Базовым типом, соответствующим обозначению типа, является по определению базовый тип типа или подтипа, указанного обозначением типа.
Указание подтипа определяет подтип базового типа, соответствующего обозначению типа.
Если в указании подтипа после обозначения типа стоит ограничение индекса, то обозначение типа не должно обозначать подтип с уже ограниченным индексом.
Аналогично для ограничения дискриминанта: обозначение типа не должно иметь ограничение дискриминанта.
Предвыполнение описания подтипа состоит из предвыполнения указания подтипа.
Это предвыполнение создаёт подтип.
Если указание подтипа не включает ограничение, то определяемый подтип тот же, что и указанный обозначением типа подтип.
Предвыполнение указания подтипа, содержащего ограничение, происходит следующим образом:
вначале предвыполняется ограничение;
ограничение проверяется на совместимость с типом или подтипом, заданным обозначением типа.
После предвыполнения ограничения получается условие, наложенное ограничением.
(Правила предвыполнения ограничения таковы, что выражения и диапазоны ограничений вычисляются при предвыполнении всех этих ограничений.)
Правила определения совместимости даны в соответствующих разделах для каждой формы ограничения.
Эти правила таковы, что если ограничение совместимо с подтипом, то наложенное ограничением условие не может противоречить никакому условию, уже заданному для значений этого подтипа.
В противном случае возбуждается исключение CONSTRAINT_ERROR.
Примеры описаний подтипов:
Описание подтипа не определяет нового типа.
Множество операций над типом включает явно описанные подпрограммы с параметром или результатом этого типа;
такие подпрограммы необходимо описывать после описания типа.
Остальные операции неявно описываются сразу после каждого описания типа.
К ним относятся базовые операции, предопределённые операции (см. 4.5) и литералы перечисления.
Описанием производного типа неявно задаются операции, включающие производные подпрограммы.
Считается, что описания операций расположены между описанием типа и последующим описанием, если таковое имеется.
Неявные описания производных подпрограмм расположены последними.
Базовыми операциями являются:
Присваивание (в операторах присваивания и инициализациях), генератор, проверка принадлежности или форма управления с промежуточной проверкой.
Именуемая компонента, индексируемая компонента или отрезок.
Квалификация (в квалифицированных выражениях), явное преобразование типа или неявное преобразование значения типа универсальный целый или универсальный вещественный в соответствующее значение другого числового типа.
Числовой литерал (для универсального типа), литерал null (для ссылочного типа), строковый литерал, агрегат или атрибут.
Для каждого типа или подтипа Т определён следующий атрибут:
Базовый тип Т.
Этот атрибут допустим только в качестве префикса имени другого атрибута, например T'BASE'FIRST.
Каждый литерал — это операция, в результате выполнения которой вырабатывается соответствующее значение (см. 4.2).
Подобно этому, агрегат — это операция, в результате выполнения которой вырабатывается значение составного типа (см. 4.3).
Некоторые операции оперируют со значениями данного типа, например предопределённые операции и некоторые подпрограммы и атрибуты.
Некоторые операции возвращают значение данного типа, например литералы и некоторые функции, атрибуты и предопределённые операции.
Присваивание — это операция, которая оперирует с объектом и значением.
В результате вычисления операции, соответствующей именуемой компоненте, индексируемой компоненте или отрезку, вырабатывается объект или значение, обозначенное этой формой имени.
Определение производного типа задаёт новый (базовый) тип, свойства которого наследуют свойства родительского типа: новый тип называется производным типом.
Определение производного типа создаёт одновременно производный подтип, являющийся подтипом производного типа.
Указание подтипа после зарезервированного слова new определяет родительский подтип.
Родительский тип является базовым для родительского подтипа.
Если для родительского подтипа существует ограничение, то подобное ограничение существует и для производного подтипа;
разница состоит только в том, что для ограничения диапазона и для ограничения плавающего или фиксированного типов, которое включает ограничение диапазона, значение каждой границы заменяется на соответствующее значение производного типа.
Производный тип обладает следующими свойствами:
Производный тип относится к тому же самому классу типов, что и родительский тип.
Набор возможных значений для производного типа есть копия набора возможных значений для родительского типа.
Если родительский тип составной, то такие же компоненты существуют и у производного типа, а подтип соответствующих компонент тот же самый.
Для каждой базовой операции над родительским типом существует соответствующая базовая операция над производным типом.
Допускается явное преобразование значения родительского типа в соответствующее значение производного типа и наоборот, как поясняется в разд.
4.6.
Для каждого литерала перечисления или предопределённой операции над родительским типом существует соответствующая операция над производным типом.
Если родительский тип — задачный тип, то для каждого входа родительского типа существует соответствующий вход производного типа.
Если выражение по умолчанию существует для компоненты объекта, имеющего родительский тип, то то же самое выражение используется для соответствующей компоненты объекта производного типа.
Если родительский тип — ссылочный тип, то родительский и производный типы имеют один и тот же набор;
существует пустое ссылочное значение для производного типа, которое по умолчанию является значением этого типа.
Если существует явный спецификатор представления для родительского типа и если этот спецификатор расположен до (но не после) определения производного типа, то соответствующий спецификатор представления неявно задан и для производного типа.
Подпрограммы, которые являются операциями над родительским типом, называются наследуемыми.
Для каждой наследуемой подпрограммы родительского типа имеется соответствующая производная подпрограмма над производным типом.
Могут быть выделены два сорта наследуемых подпрограмм.
Во-первых, если родительский тип описан непосредственно в видимом разделе пакета, то подпрограмма, явно описанная непосредственно в видимом разделе, становится наследуемой после конца видимого раздела (если подпрограмма — операция над родительским типом).
(Явное описание — это описание подпрограммы, описание переименования подпрограммы или конкретизация настройки.)
Во-вторых, если родительский тип сам является производным и не описан в видимом разделе пакета, то подпрограмма, которая стала наследуемой, и она не скрыта наследуемой подпрограммой первого сорта, является далее наследуемой.
Описание производного типа неявно описывает операции над производным типом.
Неявные описания любых производных подпрограмм следуют за описанием производного типа.
Спецификация производной подпрограммы неявно получается систематическим замещением родительского типа на производный тип в спецификации наследуемой подпрограммы.
Любой подтип родительского типа подобным образом замещается подтипом производного типа с аналогичными ограничениями
(как при замене ограничения родительского подтипа на соответствующее ограничение производного подтипа).
Наконец, любое выражение родительского типа можно использовать как операнд преобразования типа, которое вырабатывает результат производного типа.
Вызов производной подпрограммы эквивалентен вызову соответствующей подпрограммы родительского типа, в котором каждый фактический параметр производного типа заменяется преобразованием типа этого фактического параметра на родительский тип
(это означает, что преобразование к родительскому типу происходит перед вызовом параметров вида in и in out;
обратное преобразование к производному типу происходит после вызова параметров вида in out и out, см. 6.4.1).
Дополнительно, если результат вызванной функции имеет родительский тип, то он преобразуется к производному типу.
Если производный или личный тип описан непосредственно в видимом разделе пакета, то в нем этот тип не должен использоваться как родительский тип в определении производного типа.
(Для личных типов см. также разд.
7.4.1.)
При предвыполнении определения производного типа сначала предвыполняется указание подтипа, затем создаётся производный подтип.
Из правил наследования базовых операций и литералов перечисления следует, что обозначения для литерала или агрегата производного типа те же самые, что и для родительского типа;
такие литералы и агрегаты называются совмещёнными.
Из правил также следует, что обозначения компоненты, дискриминанта, входа, отрезка или атрибута одинаковы для производного и родительского типов.
Скрытие производной подпрограммы допустимо даже в одной и той же зоне описания (см. 8.3).
Производная подпрограмма скрывает предопределённую операцию, имеющую тот же профиль типа параметров и результата (см. 6.6).
Описание настраиваемой подпрограммы не наследуется, поскольку оно описывает настраиваемый модуль, а не подпрограмму.
С другой стороны, конкретизация настраиваемой подпрограммы является (ненастраиваемой) подпрограммой, которая является наследуемой, если она удовлетворяет требованиям наследуемости подпрограмм.
Если родительский тип является логическим, то предопределённые операции отношения над производным типом дают результаты предопределённого типа BOOLEAN (см. 4.5.2).
Если спецификатор представления дан для родительского типа и помещён за описанием производного типа, то соответствующий спецификатор представления неприменим к производному типу;
следовательно, для такого производного типа допускается явный спецификатор представления.
Если параметр производной подпрограммы принадлежит производному типу, подтип этого параметра не обязан иметь значение, общее с производным подтипом.
Под скалярными типами подразумеваются перечислимые, целые и вещественные типы.
Перечислимые и целые типы называются дискретными типами;
каждое значение дискретного типа имеет номер позиции — целое значение.
Целые и вещественные типы называются числовыми типами.
Все скалярные типы упорядочены, т.е. для их значений предопределены все операции отношения.
Диапазон определяет подмножество значений скалярного типа.
Диапазон L..R определяет значения от L до R включительно, если истинно отношение L < = R.
Значения L и R называются соответственно нижней границей и верхней границей диапазона.
Значение V удовлетворяет ограничению диапазона, если оно принадлежит диапазону;
говорят, что значение V принадлежит диапазону, если одновременно истинны отношения L<=V и V<=R.
Пустой диапазон — это диапазон, для которого истинно отношение R < L;
пустому диапазону не принадлежит никакое значение.
Операции < = и < в вышеприведённых определениях являются предопределёнными операциями над скалярными типами.
Если ограничение диапазона используется в указании подтипа либо непосредственно, либо как часть ограничения плавающего или фиксированного типа, тип простых выражений (а также границ атрибута диапазона) должен быть тем же, что и базовый тип в обозначении типа указания подтипа.
Ограничение диапазона совместимо с подтипом, если каждая граница диапазона принадлежит подтипу или если ограничение диапазона определяет пустой диапазон;
иначе ограничение диапазона не совместимо с подтипом.
Предвыполнение ограничения диапазона состоит из вычисления диапазона.
Вычисление диапазона определяет его нижнюю и верхнюю границы.
Если границы заданы простыми выражениями, вычисление диапазона вычисляет эти выражения в порядке, который не определён в языке.
Атрибуты
Для любого скалярного типа Т или для любого подтипа Т скалярного типа определены следующие атрибуты:
Вырабатывает значение нижней границы Т.
Значение этого атрибута имеет тип Т.
Вырабатывает значение верхней границы Т.
Значение этого атрибута имеет тип Т.
Индексирование и правила итерации используют значения дискретных типов.
Определение перечислимого типа задаёт перечислимый тип
Идентификаторы и символьные литералы, перечисленные в определении перечислимого типа, должны быть различными.
Каждая спецификация литерала перечисления является его описанием; это описание эквивалентно описанию функции без параметров, обозначение которой — литерал перечисления, а тип результата — перечислимый тип.
Предвыполнение определения перечислимого типа создаёт перечислимый тип;
это Предвыполнение включает предвыполнение каждой спецификации литерала перечисления.
Каждый литерал перечисления вырабатывает отличное от других перечислимое значение.
Предопределённые операции отношения упорядоченности между перечислимыми значениями следуют порядку, соответствующему номерам позиций.
Номер позиции первого значения в списке литералов перечисления равен нулю;
номер каждого следующего литерала перечисления на единицу больше номера предыдущего литерала в списке.
Если один и тот же идентификатор или символьный литерал задан в нескольких определениях перечислимого типа, соответствующие литералы называются совмещёнными.
В тексте программы тип совмещённого литерала перечисления должен быть определимым из контекста (см. 8.7).
Если литерал перечисления встречается в контексте, недостаточном для определения типа литерала, то один из путей разрешения неоднозначности — это применение квалифицированного выражения с именем перечислимого типа (см. 4.7).
Перечислимый тип называется символьным, если хотя бы один из его литералов перечисления является символьным литералом.
Предопределённый тип CHARACTER — символьный тип, значения которого представляют собой 128 символов стандартного набора ASCII.
Каждый из 95 графических символов этого символьного набора обозначен соответствующим символьным литералом.
Предопределённый пакет ASCII включает описания констант, обозначающих управляющие символы, а также констант, обозначающих графические символы, не входящие в основной набор символов.
Другой символьный набор, например EBCDIC, можно описать как символьный тип;
внутренние коды символов можно задать спецификатором представления перечислимых, как пояснено в разд.
13.3.
Существует предопределённый перечислимый тип, именуемый BOOLEAN.
Он содержит два литерала FALSE и TRUE, упорядоченные соотношением FALSE < TRUE.
Логический тип — это тип BOOLEAN или производный непосредственно или косвенно от логического типа.
Определение целого типа задаёт целый тип, набор значений которого включает значения заданного диапазона.
Границы диапазона должны определяться статическими выражениями некоторого, не обязательно одного и того же, целого типа.
(Допускаются отрицательные границы.)
Описание типа в форме
по определению эквивалентно следующим описаниям:
где целый тип — это анонимный тип, а предопределённый целый тип выбран реализацией и содержит значения от L до R включительно.
Описание целого типа неправильно, если ни один из предопределённых целых типов не удовлетворяет этому требованию, за исключением типа универсальный целый.
Предвыполнение описания целого типа состоит из предвыполнения эквивалентных описаний типа и подтипа.
Предопределённые целые типы включают тип INTEGER.
Реализация может также иметь предопределённые типы SHORT_INTEGER и LONG_INTEGER, диапазоны которых соответственно (существенно) уже и шире, чем у типа INTEGER.
Диапазон этих типов должен быть симметричным относительно нуля, кроме наименьшего из отрицательных значений, которое может существовать в некоторых реализациях.
Базовым для каждого из этих типов является он сам.
Целые литералы — это литералы анонимного предопределённого целого типа, который в данном руководстве называется универсальным целым.
Другие целые типы не имеют литералов.
Однако для каждого целого типа существует неявное преобразование универсального целого значения в соответствующее значение (если оно есть) целого типа.
Обстоятельства, в которых применяются такие неявные преобразования, описаны в разд.
4.6.
Номер позиции целого значения — это соответствующее значение типа универсальный целый.
Для всех целых типов предопределены одни и те же арифметические операции (см. 4.5).
Исключение NUMERIC_ERROR возбуждается при выполнении операции (в частности, неявного преобразования), которая не может передать корректный результат
(т.е. значение, соответствующее математическому результату, не является значением целого типа).
Однако от реализации не требуется возбуждения исключения NUMERIC_ERROR, если операция является частью большего выражения, результат которого может быть вычислен корректно, как пояснено в разд.
11.6.
Имя в описании целого типа — это имя подтипа.
С другой стороны, предопределённые операции над целым типом определяют результат, который принадлежит диапазону, определяемому родительским предопределённым типом;
такой результат не обязательно принадлежит описанному подтипу, и попытка присвоить такой результат переменной целого подтипа возбуждает исключение CONSTRAINT_ERROR.
Наименьшее (наибольшее по модулю отрицательное) значение, поддержанное реализацией для предопределённых целых типов, есть именованное число SYSTEM.MIN_INT, а наибольшее (из положительных) значение — SYSTEM.MAX_INT (см. 13.7).
Базовые операции над дискретными типами включают присваивание, проверку на принадлежность и квалификацию;
для логических типов — управление с промежуточной проверкой;
для целого типа — явное преобразование значений других числовых типов к целому типу и неявное преобразование значения типа универсальный целый к значению заданного типа.
Для каждого дискретного типа или подтипа Т базовые операции включают перечисленные ниже атрибуты.
В этом перечислении Т ссылается на подтип (подтип Т) для любого свойства, зависящего от ограничений для Т;
другие свойства установлены в терминах базового типа Т.
Первая группа атрибутов вырабатывает характеристики подтипа Т.
Эта группа включает атрибут BASE (см. 3.3.3), атрибуты FIRST и LAST (см. 3.5), атрибут представления SIZE (см. 13.7.2) и атрибут WIDTH, определённый следующим образом:
Вырабатывает максимальную длину образа по всем значениям подтипа Т
(образ — это последовательность символов, вырабатываемая атрибутом IMAGE, см. ниже).
Вырабатывает нуль для пустого диапазона.
Значения этого атрибута имеют тип универсальный целый.
Все атрибуты второй группы — это функции с одним параметром.
Соответствующий фактический параметр обозначен ниже идентификатором X.
Параметр Х должен быть значением базового типа Т.
Тип результата — универсальный целый.
Результат — номер позиции для значения параметра.
Параметр Х может быть любого целого типа.
Тип результата — базовый тип Т.
По заданному значению Х — номеру позиции — функция вырабатывает значение в этой позиции.
Если соответствующее Х — универсальное целое значение — не принадлежит диапазону T'POS(T'BASE'FIRST) ..
T'POS(T'BASE'LAST), то возбуждается исключение CONSTRAINT_ERROR.
Параметр X должен быть значением базового типа Т.
Тип результата — базовый тип Т.
Результат — значение с номером позиции, на единицу большим номера позиции для значения X.
Если Х равен T'BASE'LAST, то возбуждается исключение CONSTRAINT_ERROR.
Параметр Х должен быть значением базового типа Т.
Тип результата — базовый тип Т.
Результат — значение с номером позиции, на единицу меньшим номера позиции для значения X.
Если Х равно T'BASE'FIRST, то возбуждается исключение CONSTRAINT_ERROR.
Параметр Х должен быть значением базового типа Т.
Тип результата — предопределённый тип STRING.
Результат — образ значения X, т.е. последовательность символов, представляющих изображение значения.
Образу целого значения соответствует десятичный литерал без подчёркиваний, предшествующих нулей, порядка и пробелов справа, но с одним символом минус или пробелом слева.
Нижняя граница образа есть единица.
Образ литерала перечисления — это либо соответствующий идентификатор из прописных букв, либо соответствующий символьный литерал (включая два апострофа);
пробелы не включаются ни слева, ни справа.
Образ символа С, отличного от графического символа, зависит от реализации;
должно выполняться равенство СНАRАСТЕR'VАLUЕ(СНАRАСТЕR'IМАGЕ(С))=С.
Параметр Х должен быть значением предопределённого типа STRING.
Тип результата — базовый тип Т.
Игнорируются любые пробелы слева и справа от последовательности символов, соответствующих параметру.
Если для перечислимого типа последовательность символов имеет синтаксис литерала перечисления и если этот литерал существует для базового типа Т, то результат — соответствующее значение перечислимого типа.
Если для целого типа последовательность символов имеет синтаксис целого литерала с возможным знаком минус или плюс слева и если существует соответствующее значение базового типа Т, то результат есть это значение.
Во всех остальных случаях возбуждается исключение CONSTRAINT_ERROR.
Кроме того, для объекта А дискретного типа определены атрибуты A'SIZE и A'ADDRESS (см. 13.7.2).
Кроме базовых операции над дискретными типами включают предопределённые операции отношения.
Для перечислимых типов операции включают литералы перечисления.
Для логических типов операции включают предопределённую унарную логическую операцию отрицания not и предопределённые логические операции.
Для целых типов операции включают предопределённые арифметические операции: унарные и бинарные аддитивные операции - и +, все мультипликативные операции, унарную операцию abs и операцию возведения в степень.
Операции над подтипом — это операции над его базовым типом, кроме следующих: присваивания, проверки принадлежности, квалификации, явного преобразования типа и атрибутов первой группы;
результат каждой из этих операций зависит от подтипа
(присваивание, проверка принадлежности, квалификация и преобразование включают проверку подтипа;
атрибуты первой группы вырабатывают характеристику подтипа).
Для подтипа дискретного типа переданные атрибутами SUCC, PRED, VAL и VALUE результаты не обязательно принадлежат подтипу;
аналогично фактические параметры атрибутов POS, SUCC, PRED и IMAGE не обязаны принадлежать подтипу.
Эти атрибуты удовлетворяют (при отсутствии исключения) следующим соотношениям:
Вещественные типы обеспечивают приближение вещественных чисел с относительной погрешностью для плавающих типов и с абсолютной погрешностью для фиксированных типов.
С каждым вещественным типом связан набор чисел, называемых модельными числами.
Границы ошибок в предопределённых операциях даны в терминах модельных чисел.
Реализация типа должна включать по крайней мере эти модельные числа и представлять их точно.
С каждым вещественным типом связан зависящий от реализации набор чисел, называемых хранимыми числами.
Набор хранимых чисел вещественного типа должен включать по крайней мере набор модельных чисел типа.
Допустимо, чтобы диапазон хранимых чисел был больше диапазона модельных чисел, но границы ошибок предопределённых операций над хранимыми числами определены теми же правилами, что и для модельных чисел.
Хранимые числа по этой причине обеспечивают гарантированные границы ошибок для операций над зависящим от реализации диапазоном чисел;
напротив, диапазон модельных чисел зависит только от определения вещественного типа и поэтому не зависит от реализации.
Вещественные литералы — это литералы анонимного предопределённого вещественного типа, называемого в этом руководстве универсальным вещественным.
Другие вещественные типы не имеют литералов.
Для каждого вещественного типа существует неявное преобразование, которое преобразует универсальное вещественное значение в значение этого вещественного типа.
Условия, в которых вызываются эти преобразования, описаны в разд.
4.6.
Если универсальное вещественное значение — хранимое число, то неявное преобразование вырабатывает соответствующее значение;
если оно принадлежит диапазону хранимых чисел, но не является хранимым числом, то преобразуемое значение может быть любым значением в диапазоне, определённом ближайшими хранимыми предыдущим и последующим числами универсального вещественного значения.
Выполнение операции типа вырабатывает значение вещественного типа и может возбудить исключение NUMERIC_ERROR, как поясняется в разд.
4.5.7, если она не может вырабатывать корректный результат
(т.е. соответствующее одному из возможных математических результатов значение не принадлежит диапазону хранимых чисел);
в частности, это исключение может быть возбуждено неявным преобразованием.
Однако от реализации не требуется возбуждать исключение NUMERIC_ERROR, если операция — часть большего выражения, которое может быть корректно вычислено (см. 11.6).
Предвыполнение определения вещественного типа включает предвыполнение ограничения плавающего или фиксированного типа и создаёт вещественный тип.
Алгоритм, использующий только минимальные свойства чисел, которые гарантированы определением типа для модельных чисел, будет переносимым без каких-либо предосторожностей.
Для плавающих типов граница ошибки определяется заданием относительной погрешности в виде требуемого минимального числа значащих десятичных цифр.
Минимальное число значащих десятичных цифр определяется значением статического простого выражения в определении точности плавающего типа.
Это значение должно быть некоторым целым типом и должно быть положительным (ненулевым);
в дальнейшем оно обозначено буквой D.
Если ограничение плавающего типа использовано как определение вещественного типа и включает ограничение диапазона, то каждая граница диапазона должна быть определена статическим выражением некоторого вещественного типа, но две границы не обязаны иметь один и тот же вещественный тип.
Для данного основания определена следующая каноническая форма отличного от нуля модельного числа плавающего типа:
В этой форме: знак — либо +1, либо -1;
мантиссавыражена в системе счисления, заданной основанием;
порядок — целое число (возможно, отрицательное), такое, что целая часть мантиссы равна нулю, а первая цифра её дробной части не равна нулю.
Число D — минимальное требуемое число десятичных цифр после точки в десятичной мантиссе
(т.е. если основание равно десяти).
Значение D в свою очередь определяет число В — минимальное требуемое число двоичных цифр после точки в двоичной мантиссе
(т.е. если основание равно двум).
Число В связано с D и равно такому минимальному значению, что относительная точность двоичной формы не меньше точности для десятичной формы.
(Число В равно ближайшему целому, превышающему (D*log(10)/log(2)) +1.)
Модельные числа, заданные определением точности плавающего типа, включают нуль и все числа, у которых двоичная каноническая форма имеет точно В цифр после точки в мантиссе и порядок в диапазоне -4*В.. +4*В.
Гарантированная минимальная точность операций над плавающим типом определена в терминах его модельных чисел с ограничением плавающего типа, которое формирует соответствующее определение вещественного типа (см. 4.5.7).
Предопределённые плавающие типы включают тип FLOAT.
Реализация может иметь также предопределённые типы SHORT_FLOAT и LONG_FLOAT с точностью (существенно) меньшей и большей соответственно, чем у FLOAT.
Базовым типом каждого предопределённого плавающего типа является он сам.
Модельные числа каждого предопределённого плавающего типа определены числом D десятичных цифр, вырабатываемых атрибутом DIGITS (см. 3.5.8).
Для каждого предопределённого плавающего типа (а следовательно, и для каждого производного от него типа) набор хранимых чисел определён следующим образом.
Хранимые числа имеют то же самое число цифр В мантиссы, что и модельные числа типа, а порядок — в диапазоне -Е.. +Е, где Е зависит от реализации и равно по крайней мере 4*В для модельных чисел.
(Следовательно, хранимые числа включают модельные числа.)
Правила определения точности операций над модельными и хранимыми числами Даны в разд.
4.5.7.
Хранимые числа подтипа те же, что и для его базового типа.
Описание плавающего типа, представленное в одной из двух форм
(т.е. с возможным ограничением диапазона, обозначенным квадратными скобками, или без него):
по определению эквивалентно следующим описаниям:
где плавающий тип является анонимным, а предопределённый плавающий тип неявно выбран реализацией так, что его модельные числа определяются значением D;
кроме того, если добавлен диапазон L..R, то L и R должны принадлежать диапазону хранимых чисел.
Описание плавающего типа неправильно, если ни один из предопределённых плавающих типов не удовлетворяет этим требованиям, кроме типа универсальный вещественный.
Максимальное число цифр, которое может быть задано определением точности плавающего типа, определяется именованным числом SYSTEM.MAX_DIGITS (см. 13.7.1).
Предвыполнение описания плавающего типа состоит из предвыполнения эквивалентных описаний типа и подтипа.
Если ограничение плавающего типа следует за обозначением типа в указании подтипа, то обозначение типа должно задавать плавающий тип или подтип.
Ограничение плавающего типа совместимо с обозначением типа, только если число D в определении точности плавающего типа не больше соответствующего числа D для типа или подтипа в обозначении типа.
Кроме того, если ограничение плавающего типа включает ограничение диапазона, то ограничение плавающего типа совместимо с обозначением типа, только если ограничение диапазона совместимо с обозначением типа.
Предвыполнение такого указания подтипа включает Предвыполнение ограничения диапазона, если оно есть;
оно создаёт подтип плавающего типа, модельные числа которого определены соответствующим определением точности плавающего типа.
Значение плавающего типа принадлежит плавающему подтипу тогда у только тогда, когда оно принадлежит диапазону подтипа.
Одни и те же арифметические операции предопределены для всех плавающих типов (см. 4.5).
Ограничение диапазона допустимо в указании плавающего подтипа непосредственно после обозначения типа либо как часть ограничения плавающего типа.
В обоих случаях границы диапазона должны принадлежать базовому типу обозначения типа (см. 35).
Наложение ограничения плавающего типа на обозначение типа в указании подтипа не может уменьшить допустимый диапазон значений, если оно не включает ограничение диапазона
(диапазон модельных чисел, которые соответствуют заданному числу цифр, может быть меньше, чем диапазон чисел обозначения типа).
Принадлежащее плавающему подтипу значение не обязательно является модельным числом подтипа.
Примечание к примерам.
Реализованная точность для типа COEFFICIENT — это точность предопределённого типа, имеющего по меньшей мере 10 цифр мантиссы.
Следовательно, спецификация пяти цифр точности для подтипа SHORT_COEFF допустима.
Наибольшее модельное число для типа MASS равно приблизительно 1.ОЕ21 и, следовательно, меньше, чем заданная верхняя граница, (1.0Е35).
Следовательно, описание этого типа правильно, только если эта верхняя граница принадлежит диапазону хранимых чисел предопределённого плавающего типа, имеющего по меньшей мере 7 цифр точности.
Базовые операции над плавающим типом включают присваивание, проверку принадлежности, квалификацию, явное преобразование значений других числовых типов в значения этого плавающего типа и неявное преобразование значений типа универсальный вещественный в значения этого типа.
Кроме того, для каждого плавающего типа или подтипа Т базовые операции включают перечисленные ниже атрибуты.
В этом представлении Т — это подтип (подтип Т) для любого свойства, зависящего от наложенных на Т ограничений;
другие свойства формулируются через базовый тип Т.
Первая группа атрибутов вырабатывает характеристики подтипа Т.
К атрибутам этой группы относятся атрибут ВАSЕ (см. 3.3.3), атрибуты FIRST и LAST (см. 3.5), атрибут представления SIZE (см. 13.7.2), а также следующие атрибуты:
Вырабатывает число десятичных цифр в десятичной мантиссе модельных чисел подтипа Т.
(Этот атрибут вырабатывает число D, см. разд.
3.5.7.)
Значение этого атрибута имеет тип универсальный целый.
Вырабатывает число двоичных цифр в двоичной мантиссе модельных чисел подтипа Т.
(Этот атрибут вырабатывает число В, см. разд.
3.5.7.)
Значение этого атрибута имеет тип универсальный целый.
Вырабатывает абсолютное значение разности между модельным числом 1.0 и следующим модельным числом подтипа Т.
Значение этого атрибута имеет тип универсальный вещественный.
Вырабатывает наибольшее значение порядка двоичной канонической формы модельных чисел подтипа Т.
(Этот атрибут вырабатывает произведение 4*В, см. разд.
3.5.7.)
Значение этого атрибута имеет тип универсальный целый.
Вырабатывает наименьшее положительное (ненулевое) модельное число подтипа Т.
Значение этого атрибута имеет тип универсальный вещественный.
Вырабатывает наибольшее положительное модельное - число подтипа Т.
Значение этого атрибута имеет тип универсальный_ вещественный.
Атрибуты второй группы вырабатывают характеристики хранимых чисел и включают следующие атрибуты:
Вырабатывает наибольшее значение порядка двоичной канонической формы хранимых чисел базового типа Т.
(Этот атрибут вырабатывает число Е, см. разд.
3.5.7.)
Значение этого атрибута имеет тип универсальный целый.
Вырабатывает наименьшее положительное (ненулевое) хранимое число базового типа Т.
Значение этого атрибута имеет тип универсальный вещественный.
Вырабатывает наибольшее положительное хранимое число базового типа Т.
Значение этого атрибута имеет тип универсальный - вещественный.
Кроме этого, для объекта А плавающего типа определены атрибуты A'SIZE и A'ADDRESS (см. 13.7.2).
Для каждого плавающего типа существуют машинно-зависимые атрибуты, которые не относятся к модельным и хранимым числам.
Они соответствуют обозначениям атрибутов MACHINE_EMAX, MACHINE_EMIN, MACHINE_RADIX, MACHINE_MANTISSA, MACHINE_ROUNDS и MACHINE_OVERFLOWS (см. 13.7.3).
Кроме базовых операций над плавающим типом определены операции отношения и следующие предопределённые арифметические операции: унарные и бинарные аддитивные операции - и +, мультипликативные операции » и /, унарная операция abc и операция возведения в степень.
Операции над подтипом соответствуют операциям над типом, кроме следующих: присваивания, проверки принадлежности, квалификации, явного преобразования и атрибутов первой группы;
результаты этих операций переопределены в терминах подтипа.
Атрибуты ЕМАХ, SMALL, LARGE и EPSILON связаны с атрибутом MANTISSA следующими формулами:
Атрибут MANTISSA, дающий число двоичных цифр в мантиссе, сам связан с атрибутом DIGITS.
Между характеристиками модельных и хранимых чисел справедливы следующие соотношения:
Атрибуты T'FIRST и T'LAST не обязательно вырабатывают модельные или хранимые числа.
Если некоторое число цифр определено описанием типа или подтипа Т, то атрибут DIGITS вырабатывает это число.
Для фиксированных типов граница ошибки определяется абсолютной погрешностью, называемой дельтой фиксированного типа.
Дельта определяется значением статического простого выражения в определении точности фиксированного типа.
Это значение должно принадлежать некоторому вещественному типу и быть положительным (ненулевым).
Если ограничение для фиксированного типа использовано как определение вещественного типа, то оно должно включать ограничение диапазона;
каждая граница диапазона должна быть определена статическим выражением некоторого вещественного типа, но эти две границы не обязаны иметь один и тот же тип.
Если ограничение для фиксированного типа использовано в указании подтипа, то ограничение диапазона необязательно.
Для любого ненулевого модельного числа фиксированного типа определена каноническая форма.
В этой форме: знак — это либо +1, либо -1;
мантисса — положительное (ненулевое) целое;
любое модельное число кратно некоторому положительному вещественному числу, называемому дискретом, определённому следующим образом:
Для модельных чисел фиксированного типа дискрет выбран как наибольшая степень двух, которая не превышает дельту определения точности фиксированного типа.
Дискрет можно также задать спецификатором длины (см. 13.2), в этом случае модельные числа кратны заданному значению.
Гарантированная минимальная точность операций над фиксированным типом определена в терминах модельных чисел из ограничения для фиксированного типа, которое образует соответствующее определение вещественного типа (см. 4.5.7).
Для ограничения фиксированного типа с ограничением диапазона модельные числа включают нуль и все числа, кратные дискрету, мантисса которых может быть выражена точно В двоичными цифрами, а значение В выбрано как наименьшее целое число, для которого каждая граница заданного диапазона — либо модельное число, либо отличается не более чем на дискрет от модельного числа.
Если ограничение для фиксированного типа не включает ограничение диапазона (это допустимо только после обозначения типа в указании подтипа), модельные числа определены дельтой определения точности фиксированного типа и диапазоном подтипа, заданного обозначением типа.
Реализация должна иметь по крайней мере один анонимный предопределённый фиксированный тип.
Базовый тип каждого такого фиксированного типа — это сам этот тип.
Модельные числа каждого предопределённого фиксированного типа включают нуль и все числа, для которых мантисса (в канонической форме) имеет число двоичных цифр, вырабатываемое атрибутом MANTISSA, и для которых дискрет имеет значение, возвращаемое атрибутом SMALL
Описание фиксированного типа в форме
по определению эквивалентно следующим описаниям:
В этих описаниях фиксированный тип — это анонимный тип, а предопределённый фиксированный тип неявно выбран реализацией так, чтобы его модельные числа включали описанные ограничением для фиксированного типа модельные числа (т.е. с помощью D, L и R, а возможно и спецификатора длины, определяющего дискрет).
Описание фиксированного типа неправильно, если не существует предопределённого типа, удовлетворяющего этим требованиям.
Хранимые числа фиксированного типа — это модельные числа его базового типа.
Предвыполнение описания фиксированного типа состоит из предвыполнения эквивалентных описаний типа и подтипа.
Если ограничение для фиксированного типа следует за обозначением типа в указании подтипа, то обозначение типа должно задавать фиксированный тип или подтип.
Ограничение для фиксированного типа совместимо с обозначением типа, только если дельта из определения точности фиксированного типа не меньше дельты для типа или подтипа, заданного обозначением типа.
Более того, если ограничение для фиксированного типа включает ограничение диапазона, то ограничение для фиксированного типа совместимо с обозначением типа, только если само ограничение совместимо с обозначением типа.
Предвыполнение такого указания подтипа включает Предвыполнение ограничения диапазона, если оно есть;
оно создаёт фиксированный подтип, модельные числа которого определены соответствующим ограничением для фиксированного типа, а также спецификатором длины, задающим дискрет, если он есть.
Значение фиксированного типа принадлежит фиксированному подтипу тогда и только тогда, когда оно принадлежит диапазону, определённому подтипом.
Для всех фиксированных типов предопределены одни и те же арифметические операции (см. 4.5).
Умножение и деление значений фиксированного типа дают результаты анонимного предопределённого фиксированного типа, который в данном стандарте называется универсальный фиксированный;
точность этого типа произвольна.
Значения этого типа должны быть явно преобразованы в значения некоторого числового типа.
Если S — подтип фиксированного типа или подтипа Т, то набор модельных чисел S — это подмножество модельных чисел Т.
Если для Т был задан спецификатор длины, то Т и S имеют одно и то же значение дискрета.
В противном случае поскольку дискрет равен степени двух, то дискрет для S равен дискрету для Т, умноженному на неотрицательную степень двух.
Ограничение диапазона допустимо в указании фиксированного подтипа либо непосредственно за обозначением типа, либо как часть ограничения для фиксированного типа.
В обоих случаях границы диапазона должны принадлежать базовому типу обозначения типа (см. 3.5).
Базовые операции над фиксированным типом включают присваивание, проверку принадлежности, квалификацию, явное преобразование значений других числовых типов в значения этого фиксированного типа и неявное преобразование значений типа универсальный вещественный в значение этого типа.
Кроме того, для каждого фиксированного типа или подтипа Т базовые операции включают перечисленные ниже атрибуты.
В этом представлении атрибутов Т ссылается на подтип (подтип Т) для любого свойства, зависящего от ограничений, наложенных Т;
другие свойства установлены в терминах базового типа Т.
Первая группа атрибутов вырабатывает характеристики подтипа Т.
К этой группе относятся атрибуты BASE (см. 3.3.3), FIRST и LAST (см. 3.5), атрибут представления SIZE (см. 13.7.2) и следующие атрибуты:
Вырабатывает значение дельты, заданной в определении точности фиксированного типа для подтипа Т.
Значение этого атрибута имеет тип универсальный вещественный.
Вырабатывает число двоичных цифр в мантиссе модельных чисел подтипа Т.
(Этот атрибут вырабатывает число В, см. 3.5.9.)
Значение этого атрибута имеет тип универсальный целый.
Вырабатывает наименьшее положительное (ненулевое) модельное число подтипа Т.
Значение этого атрибута имеет тип универсальный вещественный.
Вырабатывает наибольшее модельное число подтипа Т.
Значение этого атрибута имеет тип универсальный,вещественный.
Вырабатывает минимальное число символов, необходимых для десятичного представления целой части любого значения подтипа Т в предположении, что это представление не включает порядок, но включает один символ, который является либо знаком минус, либо пробелом.
(Это минимальное число не учитывает предшествующие нули и подчёркивания и по меньшей мере равно двум.)
Значение этого атрибута имеет тип универсальный целый.
Вырабатывает число десятичных цифр после точки, необходимых для обеспечения точности подтипа Т, если только DELTA подтипа Т не превышает 0.1, а для этого значения атрибут вырабатывает значение единицы.
(T'AFT — это самое малое положительное целое К, для которого (10«*К)*Т'ОЕ1ТА больше или равно единице.)
Значение этого атрибута имеет тип универсальный целый.
Вторая группа включает следующие атрибуты, которые вырабатывают характеристики хранимых чисел:
Вырабатывает наименьшее положительное (ненулевое) хранимое число базового типа Т.
Значение этого атрибута имеет тип универсальный вещественный.
Вырабатывает наибольшее положительное хранимое число базового типа Т.
Значение этого атрибута имеет тип универсальный_ вещественный.
Кроме того, для объекта А фиксированного типа определены атрибуты A'SIZE и A'ADDRESS (см. 13.7.2).
Для каждого фиксированного типа или подтипа Т существуют машинно-зависимые атрибуты T'MACHINE_ROUNDS и T'MACHINE_OVERFLOWS (см. 13.7.3).
Кроме базовых в состав операций над фиксированным типом входят операции отношения и следующие предопределённые арифметические операции: унарные и бинарные аддитивные операции - и +, мультипликативные операции * и / и операция abs.
Операции над подтипом — это соответствующие операции над типом, кроме следующих: присваивания, проверки принадлежности, квалификации, явного преобразования и атрибутов первой группы;
результат этих операций определён в терминах подтипа.
Значение атрибута T'FORE зависит только от диапазона подтипа Т.
Значение атрибута T'AFT зависит только от значения T'DELTA.
Между атрибутами фиксированного типа существуют следующие соотношения:
Индексируемый объект (массив) — это составной объект, содержащий компоненты, имеющие один и тот же подтип.
В имени компоненты массива используется одно или несколько индексных значений, принадлежащих заданным дискретным типам.
Значение массива — это составное значение, состоящее из значений его компонент
Массив характеризуется числом индексов (размерность массива), типом и позицией каждого индекса, верхней и нижней границами каждого индекса, а также типом и возможным ограничением компонент.
Порядок индексов существен.
Для каждого возможного значения индекса одномерный массив имеет отдельную компоненту.
Многомерный массив имеет отдельную компоненту для каждой возможной последовательности значений индексов, которая может быть образована фиксацией значений для каждой позиции индекса (в данном порядке).
Возможными значениями индекса являются все значения между нижней и верхней границами включительно;
этот диапазон значений называется диапазоном индекса.
Определение неограниченного индексируемого типа определяет индексируемый тип.
Для каждого объекта индексируемого типа число индексов, тип и позиция каждого индекса, а также подтип компонент будут такими, как в определении типа;
значение нижней и верхней границ для каждого индекса принадлежит соответствующему подтипу индекса, кроме пустых массивов, как пояснено в разд.
3.6.1.
Подтипом индекса для данной позиции индекса по определению является подтип, указанный обозначением типа соответствующего определения подтипа индекса.
Составной ограничитель < > (бокс) в определении подтипа индекса помещается для неопределённого диапазона
(различные объекты данного типа не обязательно имеют одни и те же границы).
Предвыполнение определения неограниченного индексируемого типа создаёт индексируемый тип: оно включает Предвыполнение указания подтипа компонент.
Определение ограниченного индексируемого типа определяет индексируемый тип и подтип этого типа:
Индексируемый тип — это неявно описанный анонимный тип, этот тип определён (неявно) определением неограниченного индексируемого типа, в котором указание подтипа компонент берётся из определения ограниченного индексируемого типа и обозначение типа каждого определения подтипа индекса определяется соответствующим дискретным диапазоном.
Индексируемый подтип — это подтип, полученный наложением ограничения индекса на индексируемый тип.
Если определение ограниченного индексируемого типа дано для описания типа, то простое имя, введённое этим описанием, обозначает индексируемый подтип.
Предвыполнение определения ограниченного индексируемого типа создаёт соответствующий индексируемый тип и индексируемый подтип.
При этом предвыполняются ограничение индекса и указание подтипа компонент.
Вычисление каждого дискретного диапазона ограничения индекса и Предвыполнение указания подтипа компонент осуществляются в порядке, не определяемом языком.
Примеры описаний типа с определениями неограниченного индексируемого типа:
Примеры описаний типа с определениями ограниченного индексируемого типа:
Примеры описаний объектов с определениями ограниченного индексируемого типа:
Данное для одномерного массива правило означает, что описание с определением ограниченного индексируемого типа, например
эквивалентно (при отсутствии некорректной зависимости от порядка) последовательности описаний:
где подтип - индекса и индексируемый тип оба анонимны.
Следовательно, Т — имя подтипа, и все объекты, описанные с этим обозначением типа, — массивы, имеющие одни и те же границы.
Аналогичные преобразования применяются к многомерным массивам.
Подобное преобразование применяется к объекту, описание которого включает определение ограниченного индексируемого типа.
Следствием этого является то, что нет двух таких объектов одного и того же типа.
Ограничение индекса определяет диапазон возможных значений каждого индекса индексируемого типа и, таким образом, соответствующие границы массива.
Для дискретного диапазона, использованного в определении ограниченного индексируемого типа и определённого диапазоном, неявное преобразование к предопределённому типу INTEGER производится в том случае, если каждая граница — это либо числовой литерал, либо именованное число, либо атрибут, а тип обеих границ (до неявного преобразования) является универсальным целым.
В остальных случаях обе границы должны быть одного и того же дискретного типа, отличного от типа универсальный целый', этот тип должен определяться независимо от контекста, но с учётом того, что тип должен быть дискретным и обе границы должны иметь один и тот же тип.
Эти правила применимы также к дискретному диапазону, используемому в правиле итерации (см. 5.5) или в описании семейства входов (см. 9.5).
Если ограничение индекса следует за обозначением типа в указании подтипа, то тип и подтип, указанный обозначением типа, не должен содержать ограничение индекса.
Обозначение типа должно указывать либо неограниченный индексируемый тип, либо ссылочный тип, указываемый тип которого — такой же индексируемый тип.
В любом случае ограничение индекса должно задавать дискретный диапазон для каждого индекса индексируемого типа и тип каждого дискретного диапазона должен быть тем же самым, что и у соответствующего индекса.
Ограничение индекса совместимо с типом, указанным в обозначении типа, если и только если ограничение, определённое каждым дискретным диапазоном, совместимо с соответствующим подтипом индекса.
Если какой-нибудь из дискретных диапазонов определяет пустой диапазон, то ограниченный таким образом массив является пустым массивом, не имеющим компонент.
Значение массива удовлетворяет ограничению индекса, если в каждой позиции индекса значение массива и ограничение индекса имеют одни и те же границы индекса.
(Заметим, однако, что присваивание и некоторые другие операции над массивами включают неявное преобразование подтипа.)
Границы каждого массива определены следующим образом:
Для заданной описанием объекта переменной указание подтипа соответствующего описания объекта должно определять подтип ограниченного индексируемого типа (и, таким образом, границы).
То же самое требуется от указания подтипа описания компоненты, если тип компоненты записи — индексируемый тип, а также от указания подтипа компоненты определения индексируемого типа, если тип компонент массива является сам индексируемым типом.
Для заданной описанием объекта константы индексируемого типа границы определены начальным значением, если подтип константы не ограничен;
иначе они определены подтипом
(в последнем случае начальное значение — это результат неявного преобразования подтипа).
То же правило применимо к формальному параметру настройки вида in.
Для указанного ссылочным значением массива границы должны быть определены генератором, создающим массив.
(Созданный объект ограничен соответствующими значениями границ.)
Для формального параметра подпрограммы или входа границы получены от соответствующего фактического параметра.
(Формальный параметр ограничен соответствующими значениями границ.)
Для описания переименования и для формального параметра настройки вида in out границы берутся у переименованного объекта или у соответствующего фактического параметра настройки.
Порядок вычисления дискретных диапазонов при предвыполнении ограничения индекса в языке не определён.
Примеры описания массивов, включающих ограничения индексов:
Пример описания массива с ограниченным индексируемым подтипом:
Пример именуемого типа с компонентой индексируемого типа:
Предвыполнение указания подтипа, состоящего из обозначения типа, за которым следует ограничение индекса, контролирует совместимость ограничения индекса с обозначением типа (см. 3.3.2).
Все компоненты массива имеют один и тот же подтип.
В частности, для массива компонент, которые являются одномерными массивами, это означает, что все компоненты имеют одни и те же границы и, следовательно, одинаковую длину.
Базовые операции над индексируемым типом включают присваивание, агрегаты (если индексируемый тип не является лимитируемым личным типом), проверку принадлежности, индексируемые компоненты, квалификацию и явное преобразование;
для одномерных массивов базовые операции включают также отрезки и строковые литералы, если тип компонент — символьный тип.
Если А — объект, являющийся массивом, значением массива или подтипом ограниченного индексируемого типа, то базовые операции включают также атрибуты, которые перечислены ниже.
Эти атрибуты недопустимы для неограниченного индексируемого типа.
Аргумент N, использованный в обозначении атрибута для N-ro измерения массива, должен быть положительным статическим выражением типа универсальный целый.
Значение N должно быть положительным, не больше размерности массива.
Вырабатывает нижнюю границу диапазона первого индекса.
Значение этого атрибута имеет тот же тип, что и эта граница.
Вырабатывает значение нижней границы диапазона N-ro индекса.
Значение этого атрибута имеет тот же тип, что и эта нижняя граница.
Вырабатывает верхнюю границу диапазона первого индекса.
Значение этого атрибута имеет тот же тип, что и эта верхняя граница.
Вырабатывает верхнюю границу диапазона М-го индекса.
Значение этого атрибута имеет тот же тип, что и эта верхняя граница.
Вырабатывает диапазон первого индекса, т.е. диапазон A'FIRST..
A'LAST.
Вырабатывает диапазон N-ro индекса, т.е. диапазон A'FIRST(N) ..
A'LAST(N).
Вырабатывает количество значений в диапазоне первого индекса (нуль для пустого диапазона).
Значение этого атрибута имеет тип универсальный целый.
Вырабатывает количество значений в диапазоне N-ro индекса (нуль для пустого диапазона).
Значение этого атрибута имеет тип универсальный целый.
Кроме того, для индексируемого типа или подтипа Т определены атрибуты Т'ВАSЕ и T'SIZE (см. 3.3.3), а для массива А определены атрибуты A'SIZE и A'ADDRESS (см. 13.7.2).
Кроме базовых в состав операций над индексируемым типом входят предопределённые операции сравнения на равенство или неравенство, если индексируемый тип не является лимитируемым типом.
Для одномерных массивов к этим операциям относится катенация, если индексируемый тип не является лимитируемым типом;
если тип компоненты — дискретный тип, то операции включают также все предопределённые операции отношения;
если тип компоненты — логический тип, то операции также включают унарную логическую операцию отрицания и логические операции.
Примеры (использующие массивы, описанные в примерах раздела 3.6.1):
Атрибуты A'FIRST и A'FIRST(1) вырабатывают одно и то же значение.
То же можно сказать об атрибутах A'LAST, A'RANGE и A'LENGTH.
Для приведённых атрибутов удовлетворяются следующие соотношения (исключая пустой массив) если тип индекса — целый тип:
Индексируемый тип — лимитируемый, если тип его компонент — лимитируемый (см. 7.4.4).
Значения предопределённого типа STRING — это одномерные массивы компонент предопределённого типа CHARACTER, индексируемые значениями предопределённого подтипа POSITIVE:
Строковые литералы (см. 2.6 и 4.2) — базовые операции над типом STRING и любым другим одномерным индексируемым типом, тип компонент которого — символьный тип.
Операция катенации — предопределённая операция над типом STRING и для одномерных индексируемых типов;
она представляется знаком &.
Операции отношения <, < =, > и > = определены для значений этих типов в соответствии с лексикографическим порядком (см. 4.5.2).
Объект именуемого типа (запись) — это составной объект, состоящий из именованных компонент.
Значение записи — составное значение, состоящее из значений своих компонент.
Каждое описание компоненты задаёт компоненту именуемого типа.
Кроме этих компонент в компоненты именуемого типа включаются любые компоненты, описанные спецификациями дискриминантов описания именуемого типа.
Идентификаторы всех компонент именуемого типа должны быть различными.
Использование имени, обозначающего компоненту записи, отличную от дискриминанта, недопустимо в определении именуемого типа, который описывает эту компоненту.
Описание компоненты с несколькими идентификаторами эквивалентно последовательности единичных описаний компонент, как пояснено в разд.
3.2.
Каждое единичное описание компоненты объявляет компоненту записи, подтип которой задан определением подтипа компоненты.
Если описание компоненты включает составной ограничитель присваивания, за которым следует выражение, то это выражение является выражением по умолчанию компоненты записи;
выражение по умолчанию должно иметь тип компоненты.
Выражения по умолчанию недопустимы для компонент лимитируемого типа.
Если именуемый тип не имеет раздела дискриминантов, то одни и те же компоненты присутствуют во всех значениях этого типа.
Если список компонент именуемого типа определён зарезервированным словом null и раздел дискриминантов отсутствует, то именуемый тип не имеет компонент и все записи этого типа — пустые записи.
Предвыполнение определения именуемого типа создаёт именуемый тип;
оно состоит из предвыполнения соответствующих (единичных) описаний компонент в порядке их следования, включая описания компонент в разделе вариантов.
Предвыполнение описания компоненты состоит из предвыполнения определения подтипа компоненты.
Для предвыполнения определения подтипа компоненты в случае, когда ограничение не зависит от дискриминанта, предвыполняется указание подтипа.
Если, с другой стороны, ограничение зависит от дискриминанта, то Предвыполнение состоит из вычисления каждого входящего в ограничение выражения, которое не является дискриминантом.
Примеры описаний именуемого типа:
Примеры переменных именуемого типа:
Выражения по умолчанию для компоненты записи при отсутствии явной инициализации неявно вычисляются предвыполнением описания записи (см. 3.2.1).
Если описание компоненты имеет несколько идентификаторов, то выражение вычисляется один раз для каждой такой компоненты записи
(поскольку это описание эквивалентно последовательности единичных описаний компонент).
В отличие от компонент массива компоненты записи не обязательно имеют один и тот же тип.
Раздел дискриминантов специфицирует дискриминанты типа.
Дискриминант записи — это компонента записи.
Тип дискриминанта должен быть дискретным.
Раздел дискриминантов допустим только в описании именуемого типа, в описании личного типа или в неполном описании типа (соответствующее полное описание должно тогда описывать именуемый тип), а также в описании параметра настройки для формального личного типа.
Спецификация дискриминанта с несколькими идентификаторами эквивалентна последовательности единичных спецификаций дискриминантов, как пояснено в разд.
3.2.
Каждая единичная спецификация дискриминанта описывает дискриминант.
Если спецификация дискриминанта включает составной ограничитель присваивания, за которым следует выражение, то это — выражение по умолчанию для дискриминанта;
тип выражения по умолчания должен быть типом дискриминанта.
Выражения по умолчанию должны быть заданы либо для всех, либо не заданы ни для одного из дискриминантов раздела дискриминантов.
Использование имени дискриминанта недопустимо в выражениях по умолчанию раздела дискриминантов, если спецификация дискриминанта сама дана в этом разделе дискриминантов.
В определении именуемого типа допустимы только следующие случаи использования имени дискриминанта: в выражениях по умолчанию для компонент записи, в разделе вариантов в качестве имени дискриминанта, а также в определении подтипа компоненты — либо как границы в ограничении индекса, либо для задания значения дискриминанта в ограничении дискриминанта.
Использованное в этих определениях подтипа компоненты имя дискриминанта должно встречаться само по себе, а не как часть выражения.
Такие определения подтипа компонент и такие ограничения называются зависимыми от дискриминанта.
Компонента называется зависимой от дискриминанта, если она — либо компонента записи, описанная в разделе вариантов, либо компонента записи, чьё определение подтипа компоненты зависит от дискриминанта, либо, наконец, одна из подкомпонент, зависящих от дискриминанта.
Каждое значение записи включает значение каждого дискриминанта, заданного для именуемого типа;
оно также включает значение для каждой компоненты записи, которая не зависит от дискриминанта.
Значения дискриминантов определяют, значения каких компонент, зависящих от дискриминантов, присутствуют в значении записи.
Непосредственное присваивание дискриминанту объекта недопустимо;
более того, дискриминант недопустим как фактический параметр вида in out или out либо как фактический параметр настройки вида in out.
Единственным путём изменения значения дискриминанта переменной является присваивание (полного) значения самой переменной.
Аналогично присваивание самой переменной является единственным путём изменения одной из её компонент, если определение подтипа компоненты зависит от дискриминанта переменной.
Предвыполнение раздела дискриминантов не имеет другого эффекта.
Ограничение дискриминанта допустимо только в указании подтипа за обозначением типа.
Это обозначение типа должно указывать либо тип дискриминанта, либо ссылочный тип, обозначающий тип с дискриминантом.
Ограничение дискриминанта задаёт значения этих дискриминантов.
Каждое сопоставление дискриминанта связывает выражение с одним или несколькими дискриминантами.
Сопоставление дискриминанта называется именованным, если дискриминанты заданы явно своими именами;
иначе оно называется позиционным.
Для позиционного сопоставления (единственный) дискриминант неявно задан позицией в текстуальном порядке.
Именованные сопоставления могут быть даны в любом порядке, но если в одном и том же ограничении дискриминанта использованы позиционные и именованные сопоставления, то позиционные сопоставления должны стоять первыми, в их обычной позиции.
Следовательно, если однажды было использовано именованное сопоставление, то в остальной части ограничения дискриминанта должны употребляться только именованные сопоставления.
Для именованного сопоставления дискриминанта имена дискриминантов должны обозначать дискриминанты того типа, для которого дано ограничение дискриминанта.
Сопоставление дискриминанта с более чем одним именем дискриминанта допустимо, только если все дискриминанты имеют один и тот же тип.
Более того, для каждого сопоставления дискриминанта (именованного или позиционного) выражение и связанные дискриминанты должны иметь один и тот же тип.
Ограничение дискриминанта должно задавать точно одно значение для каждого дискриминанта типа.
Ограничение дискриминанта совместимо с типом, указанным обозначением типа, если и только если каждое значение дискриминанта принадлежит подтипу соответствующего дискриминанта.
Более того, для каждой подкомпоненты, спецификация подтипа которой зависит от дискриминанта, дискриминант в этой спецификации подтипа компоненты заменяется значением дискриминанта и производится проверка совместимости результирующего указания подтипа.
Составное значение удовлетворяет ограничению дискриминанта, если и только если каждый дискриминант составного значения имеет налагаемое ограничением дискриминанта значение.
Начальные значения дискриминантов объекта, имеющего тип с дискриминантами, определены следующим образом:
Для объявленной описанием объекта переменной указание подтипа должно быть ограничено ограничением дискриминанта, если выражения по умолчанию для дискриминантов отсутствуют;
значения дискриминантов определены либо ограничением, либо при отсутствии его выражением по умолчанию.
То же самое требование существует для указания подтипа в описании компоненты, если тип компоненты записи имеет дискриминанты, а также для указания подтипа компоненты индексируемого типа, если тип компоненты массива — тип с дискриминантами.
Для объявленной описанием объекта константы значения дискриминантов берутся из начального значения, если подтип константы не ограничен;
иначе они определяются из этого подтипа
(в последнем случае возбуждается исключение, если начальное значение не принадлежит этому подтипу).
То же правило применяется к параметру настройки вида in.
Для указанного ссылочным значением объекта значения дискриминантов должны быть определены генератором, создающим объект.
(Созданный объект ограничен соответствующими значениями дискриминантов.)
Для формального параметра подпрограммы или входа дискриминанты формального параметра инициализированы значениями дискриминантов соответствующего фактического параметра.
(Формальный параметр ограничен, если соответствующий фактический параметр ограничен, и ограничен в любом случае, если его вид in или если подтип формального параметра ограничен.)
Для описания переименования и для формального параметра настройки вида in out дискриминанты — это дискриминанты переименованного объекта или соответствующего фактического параметра настройки.
Порядок вычислений выражений, данных в сопоставлениях дискриминантов, при предвыполнении ограничения дискриминанта в языке не определён;
выражение именованного сопоставления вычисляется по одному разу для каждого именованного дискриминанта.
Примеры {использующие типы, описанные в предыдущем разделе}:
Приведённые правила и правила, определяющие предвыполнение описания объекта (см. 3.2), гарантируют, что дискриминанты всегда имеют значения.
В частности, если ограничение дискриминанта входит в описание объекта, то каждый дискриминант инициализирован значением, определяемым ограничением.
Аналогично если подтип компоненты имеет ограничение дискриминанта, то дискриминанты этой компоненты соответственно инициализированы.
Именуемый тип с разделом вариантов задаёт альтернативные списки компонент.
Каждый вариант определяет компоненты для соответствующего значения или значений дискриминанта.
Каждый вариант начинается со списка выборов, которые должны быть того же типа, что и дискриминант раздела вариантов.
Тип дискриминанта раздела вариантов не должен быть настраиваемым формальным типом настройки.
Если подтип дискриминанта статический, то каждое значение этого подтипа должно быть представлено в наборе выборов раздела вариантов один и только один раз и другие значения недопустимы.
Другими словами, каждое значение (базового) типа дискриминанта должно быть представлено один и только один раз в наборе вариантов.
Простые выражения и дискретные диапазоны, данные как выборы в разделе вариантов, должны быть статическими.
Определённый дискретным диапазоном выбор задаёт все значения соответствующего диапазона (и ни одного, если диапазон пустой).
Выбор others допустим только для последнего варианта и только как его единственный выбор;
он задаёт все остальные значения (возможно, и ни одного), не упомянутые в выборах предыдущих вариантов.
Простое имя компоненты недопустимо в качестве выбора варианта
(хотя оно присутствует в синтаксисе выбора).
Значение записи содержит значения компонент данного варианта тогда и только тогда, когда значение дискриминанта равно одному из значений, заданных выборами варианта.
Это правило применимо в свою очередь к любому вложенному варианту, который сам включён в список компонент данного варианта.
Если список компонент варианта задан как null, то вариант не имеет компонент.
Примеры именуемого типа с разделом вариантов:
Примеры подтипов записей:
Примеры ограниченных переменных именуемого типа:
Выборы с дискретными значениями используются также в операторах выбора и в агрегатах массива.
Выборы с простыми именами компонент используются в агрегатах записей.
Базовые операции над именуемым типом включают присваивание и агрегаты (если тип не лимитируемый тип), проверку принадлежности, именование компонент записи, квалификацию и преобразование типа (для производных типов).
Для любого объекта А типа с дискриминантами базовые операции включают также следующий атрибут:
Вырабатывает значение TRUE, если ограничение дискриминанта наложено на объект А или если объект — константа
(включая формальный параметр или формальный параметр настройки вида in);
вырабатывает значение FALSE в противном случае.
Если А — формальный параметр настройки вида in out или если А — формальный параметр вида in out или out и данное в соответствующей спецификации параметра обозначение типа обозначает неограниченный тип с дискриминантами, то значение этого атрибута получается из значения атрибута соответствующего фактического параметра.
Значение этого атрибута имеет предопределённый тип BOOLEAN.
Кроме того, атрибуты T'BASE и T'SIZE определены для именуемого типа или подтипа Т (см. 3.3.3);
атрибуты A'SIZE и A'ADDRESS определены для записи А (см. 13.7.2).
Кроме базовых операции над именуемым типом включают предопределённое сравнение на равенство и неравенство, если тип не является лимитируемым.
Именуемый тип — лимитируемый, если тип хотя бы одной из его компонент — лимитируемый (см. 7.4.4).
Объявленный описанием объект создаётся предвыполнением этого описания и обозначается простым именем или некоторой другой формой имени.
В противоположность этому существуют объекты, создаваемые вычислением генераторов (см. 4.8) и не имеющие простого имени.
Доступ к такому объекту осуществляется посредством возвращаемого генератором ссылочного значения;
говорят, что ссылочное значение указывает объект.
Для каждого ссылочного типа существует литерал null, имеющий пустое ссылочное значение, вообще не указывающее объект.
Пустое значение ссылочного типа — начальное значение этого типа по умолчанию.
Другие значения ссылочного типа получаются вычислением специальной операции над типом, называемой генератором.
Каждое такое ссылочное значение указывает объект подтипа, обозначенного указанием подтипа определения ссылочного типа;
этот подтип называется указываемым подтипом;
базовый тип этого подтипа называется указываемым типом.
Указанные значением ссылочного типа объекты образуют набор, неявно связанный с типом.
Предвыполнение определения ссылочного типа состоит из предвыполнения указания подтипа и создания ссылочного типа.
Если ссылочный объект — константа, то ссылочное значение не может быть изменено и всегда указывает один и тот же объект.
С другой стороны, значение указываемого объекта не обязательно остаётся одним и тем же
(присваивание указываемому объекту допустимо, если указываемый тип нелимитируемый).
Единственные формы ограничения, которые допустимы после имени ссылочного типа в указании подтипа, — это ограничения индексов и ограничения дискриминантов.
(см. разд.
3.6.1 и 3.7.2 для правил, применимых к этим указаниям подтипа).
Ссылочное значение принадлежит соответствующему подтипу ссылочного типа, если либо ссылочное значение — пустое значение, либо если значение указываемого объекта удовлетворяет ограничению.
Ссылочное значение, передаваемое генератором, может быть присвоено нескольким ссылочным объектам.
Следовательно, объект, созданный генератором, может быть указан более чем одной переменной или константой ссылочного типа.
Ссылочное значение может указывать только объект, созданный генератором, в частности, оно не может указывать объект, объявленный описанием объекта.
Если тип объектов, указанных ссылочными значениями, — индексируемый тип или тип с дискриминантами, то эти объекты ограничены либо границами массива, либо значениями дискриминантов, заданными неявно или явно соответствующими генераторами (см. 4.8).
Ссылочные значения в некоторых других языках называются указателями или ссылками.
Никаких конкретных ограничений на тип, указываемый ссылочным типом, не существует.
В частности, тип компоненты указываемого типа может быть другим ссылочным типом или даже тем же самым ссылочным типом.
Это позволяет вводить взаимозависимые и рекурсивные ссылочные типы.
Их описания требуют предварительного неполного описания типа (или описания личного типа) для одного или нескольких типов.
Для каждого неполного описания типа должно быть соответствующее описание типа с тем же идентификатором.
Соответствующее описание должно быть либо полным описанием, либо описанием задачного типа.
В оставшейся части главы пояснения даны в терминах полных описаний типа;
те же правила применяются к описаниям задачного типа.
Если неполное описание типа встречается непосредственно в разделе описаний или видимом разделе спецификации пакета, то полное описание типа должно встретиться позже непосредственно в этом разделе описаний или видимом разделе.
Если неполное описание типа встречается непосредственно в личном разделе пакета, то полное описание типа должно быть позже непосредственно в самом личном разделе или же в разделе описаний соответствующего тела пакета.
Раздел дискриминантов должен быть дан в полном описании типа тогда и только тогда, когда он дан в неполном описании типа;
если разделы дискриминантов даны, то они должны быть согласованы (см. 6.3.1 для правил согласования).
До конца полного описания типа использование имени, обозначающего тип, объявленный неполным описанием типа, допустимо только как обозначение типа в указании подтипа определения ссылочного типа;
единственной формой ограничения, допустимой в указании подтипа, являются ограничения дискриминанта.
Предвыполнение неполного описания типа создаёт тип.
Если неполное описание типа имеет раздел дискриминантов, то это Предвыполнение включает Предвыполнение раздела дискриминантов: в этом случае раздел дискриминантов полного описания типа не предвыполняется.
Пример рекурсивного типа:
Примеры взаимозависимых ссылочных типов:
Базовые операции над ссылочным типом включают присваивание, генераторы для этого ссылочного типа, проверку принадлежности, явное преобразование, квалификацию и литерал null.
Если указываемый тип — тип с дискриминантами, то базовые операции включают именование соответствующих дискриминантов;
если указываемый тип — именуемый тип, то они включают именование соответствующих компонент;
если указываемый тип — индексируемый тип, то они включают образование индексируемых компонент и отрезков;
если указываемый тип — задачный тип, то они включают именование входов и семейств входов.
Кроме того, базовые операции включают образование именуемой компоненты с зарезервированным словом аll (см. 4.1.3).
Если указываемый тип — индексируемый тип, то базовые операции включают атрибуты с обозначениями FIRST, LAST, RANGE и LENGTH (и эти же атрибуты с параметром N для номера измерения).
Префикс каждого из этих атрибутов должен быть значением ссылочного типа.
Эти атрибуты вырабатывают соответствующие характеристики указываемого объекта (см. 3.6.2).
Если указываемый тип — задачный тип, то базовые операции включают атрибуты с обозначениями TERMINATED и CALLABLE (см. 9.9).
Префикс каждого из этих атрибутов должен быть значением ссылочного типа.
Эти атрибуты вырабатывают соответствующие характеристики задачных объектов.
Кроме того, атрибут T'BASE (см. 3.3.3) и атрибуты представления T'SIZE и T'STORAGE_SIZE (см. 13.7.2) определены для ссылочного типа или подтипа Т;
атрибуты A'SIZE и A'ADDRESS определены для ссылочного объекта А (см. 13.7.2).
Кроме базовых операции над ссылочным типом включают предопределённое сравнение на равенство и неравенство.
Раздел описаний содержит элементы описания (возможно, и ни одного).
Предвыполнение раздела описаний состоит из предвыполнения элементов описания, если они есть, в порядке их следования в разделе описаний.
После своего предвыполнения элемент описания называется предвыполненным.
До окончания своего предвыполнения (включая фазу перед предвыполнением) элемент описания ещё не предвыполнен.
Для нескольких форм элементов описания правила языка (в частности, правило определения области действия и правила видимости) таковы, что использование понятия до предвыполнения элемента описания, который объявляет это понятие, либо невозможно, либо является неправильным.
Например, невозможно использование имени типа для описания объекта, если соответствующее описание типа ещё не предвыполнено.
В случае тел осуществляются следующие проверки:
При вызове подпрограммы проверяется, предвыполнено ли уже тело подпрограммы.
При активизации задачи проверяется, предвыполнено ли уже тело соответствующего задачного модуля.
При конкретизации настраиваемого модуля, имеющего тело, проверяется, предвыполнено ли уже тело настраиваемого модуля.
Если одна из этих проверок даёт отрицательный результат, возбуждается исключение PROGRAM_ERROR.
Если описание подпрограммы, описание пакета, описание задачи или описание настраиваемого понятия являются элементами описания данного раздела описаний, то тело (если оно существует) программного модуля, описанного элементом описания, должно само быть элементом описания этого раздела описаний (и должно помещаться ниже).
Если тело представлено следом тела, то для этого программного модуля необходим раздельно компилируемый субмодуль, содержащий соответствующее тело (см. 10.2).
В этой главе приведены правила, применяемые к различным формам имён и выражений, а также к их вычислению.
Имена могут обозначать понятия, описанные явно или неявно (см. 3.1).
Имена могут обозначать также объекты, указанные ссылочными значениями, подкомпоненты и отрезки объектов и значений, одиночные входы, семейства входов и входы семейства входов.
Наконец, имена могут обозначать атрибуты этих понятий и объектов.
Простое имя понятия — это либо идентификатор, связанный с понятием описанием, либо другой идентификатор, связанный с понятием описанием переименования.
Определённые формы имени (индексируемые и именуемые компоненты, отрезки и атрибуты) включают в себя префикс, который может быть именем или вызовом функции.
Если тип префикса — ссылочный тип, то префикс не должен быть именем, которое обозначает формальный параметр вида out или его подкомпоненту.
Если префикс имени — вызов функции, то имя обозначает компоненту, отрезок, вход или семейство входов результата вызова функции либо (если результат — ссылочное значение) объект, указанный результатом.
Говорят, что префикс соответствует некоторому типу в одном из следующих случаев:
Тип префикса — это рассматриваемый тип.
Тип префикса — ссылочный тип, который указывает на рассматриваемый тип.
Вычисление имени определяет понятие, обозначенное этим именем.
Для простого имени, символьного литерала или знака операции вычисление имени не имеет другого результата.
Вычисление имени, имеющего префикс, включает в себя вычисление префикса, т.е. соответствующего имени или вызова функции.
Если тип префикса — ссылочный тип, то вычисление префикса включает в себя определение объекта, указанного соответствующим ссылочным значением;
если значение префикса является пустым ссылочным значением, исключая случай префикса атрибута представления (см. 13.7.2), то возбуждается исключение CONSTRAINED_ERROR (см. 13.7.2).
Примеры простых имён:
Индексируемая компонента обозначает компоненту массива или вход семейства входов.
Для компонент массива тип префикса должен соответствовать индексируемому типу.
Значения индексов компоненты задаются выражениями, каждой позиции индекса должно соответствовать одно такое выражение.
Для входа семейства входов префикс должен быть именем, которое обозначает семейство входов задачного объекта, а выражение (оно должно, быть только одно) задаёт значение индекса конкретного входа.
Тип каждого выражения должен соответствовать типу индекса.
В языке не определяется порядок вычисления префикса и выражений при вычислении индексируемой компоненты.
Если значение индекса не принадлежит диапазону индекса массива или семейства входов, определяемых префиксом, то возбуждается исключение CONSTRAINT_ERROR.
Примеры индексируемых компонент:
Примечание к примеру.
Для компонент многомерных массивов (таких, как BOARD) и массива массивов (таких, как PAGE) используются различные обозначения.
Компонентами массива массивов являются массивы, и они могут быть индексированы.
Так, РАGЕ(10) (20) задаёт двадцатую компоненту массива РАGЕ(10).
В последнем примере NEXT_FRAME(L) — вызов функции, возвращающей ссылочное значение, указывающее двумерный массив.
Отрезок обозначает одномерный массив нескольких последовательных компонент одномерного массива.
Отрезок переменной — переменная, отрезок константы — константа, отрезок значения — значение.
Префикс отрезка должен соответствовать одномерному индексируемому типу.
Тип отрезка — это базовый тип этого индексируемого типа.
Границы дискретного диапазона определяют границы отрезка и должны быть того же типа, что и тип индекса;
отрезок является пустым, т.е. обозначает пустой массив, если дискретный диапазон является пустым.
Порядок вычисления префикса и дискретного диапазона при вычислении имени отрезка в языке не определяется.
Если при вычислении отрезка хотя бы одна из границ дискретного диапазона не принадлежит диапазону индексов, определяемому префиксом отрезка, то (кроме случая пустого отрезка) возбуждается исключение CONSTRAINT_ERROR.
(Границы пустого отрезка могут не принадлежать подтипу индекса.)
Примеры отрезков:
Для одномерного массива А имя A(N..N) задаёт отрезок, состоящий из одной компоненты;
его тип соответствует базовому типу массива А.
С другой стороны, A(N) — компонента массива и имеет соответствующий тип.
Именуемые компоненты используются для обозначения компонент записей, входов, семейств входов и объектов, указанных ссылочными значениями;
они используются также в качестве расширенных имён, как это описано ниже.
Для обозначения дискриминанта, компоненты записи, входа или объекта, указанного ссылочным значением, используются следующие четыре формы именуемых компонент:
Дискриминант.
Постфикс должен быть простым именем, обозначающим дискриминант объекта или значения.
Префикс должен соответствовать типу этого объекта или значения.
Компонента записи.
Постфикс должен быть простым именем, обозначающим компоненту именуемого объекта или значения.
Префикс должен соответствовать типу этого объекта или значения.
Для компонент варианта делается проверка: являются ли значения дискриминантов такими, что запись имеет эту компоненту.
В противном случае возбуждается исключение CONSTRAINT_ERROR.
Одиночный вход или семейство входов задачи.
Постфикс должен быть простым именем, обозначающим одиночный вход или семейство входов задачи.
Префикс должен соответствовать типу этой задачи.
Объект, указанный ссылочным значением.
Постфикс должен быть зарезервированным словом аll.
Значение префикса должно принадлежать ссылочному типу.
Именуемая компонента одной из двух нижеуказанных форм называется расширенным именем.
В каждом случае постфикс должен быть либо простым именем, либо символьным литералом, либо знаком операции.
Вызов функции в качестве префикса расширенного имени не допускается.
Расширенное имя может обозначать:
Понятие, описанное в видимом разделе описания пакета.
Префикс должен обозначать пакет.
Постфикс должен быть простым именем, символьным литералом или знаком операции понятия.
Понятие, описание которого находится непосредственно в поименованной конструкции.
Префикс должен обозначать конструкцию, т.е. программный модуль, оператор блока, оператор цикла или оператор принятия.
Для оператора принятия префикс должен быть либо простым именем входа или семейства входов, либо расширенным именем, заканчивающимся таким простым именем
(т.е. индекс не допускается).
Постфикс должен быть простым именем, символьным литералом или знаком операции такого понятия, чьё описание находится непосредственно в конструкции.
Данная форма расширенного имени допустима только в самой конструкции
(включая тело и любые субмодули в случае программного модуля).
Не допускается использование в качестве префикса имён, описанных с помощью описания переименования.
Если префикс — это имя подпрограммы или оператора принятия и если существует более одной видимой объемлющей подпрограммы или оператора принятия с таким именем, то расширенное имя не определено, независимо от постфикса.
Если в соответствии с правилами видимости возможна по крайней мере одна интерпретация префикса именуемой компоненты как имени объемлющей подпрограммы или оператора принятия, то рассматриваются только те интерпретации, которые соответствуют правилу е, т.е. расширенные имена
(Интерпретация префикса как вызова функции не рассматривается).
Вычисление имени, являющегося именуемой компонентой, включает вычисление префикса.
Примеры именованных компонент:
Примеры расширенных имён:
Для записей, компонентами которых являются другие записи, перечисленные правила означают, что простое имя должно быть дано для каждого уровня имени подкомпоненты.
Например, имя NEXT_CAR.OWNER.BIRTH.MONTH не может быть укорочено (имя NEXT_CAR.OWNER.MONTH недопустимо).
Атрибут обозначает базовую операцию над понятием, задаваемым префиксом.
Применимые обозначения атрибутов зависят от конкретного префикса.
Атрибут может быть базовой операцией, вырабатывающей значение, но может быть и функцией, типом или диапазоном.
Смысл префикса атрибута должен быть определим независимо от обозначения атрибута и независимо от того, что это есть префикс именно атрибута.
Определённые в языке атрибуты приведены в приложении А.
Конкретная реализация может ввести дополнительные атрибуты, описание которых должно быть дано в приложении F.
Обозначения таких атрибутов должны отличаться от обозначений атрибутов, определённых в языке.
Вычисление имени, являющегося атрибутом, состоит из вычисления префикса.
Обозначения атрибутов DIGITS, DELTA и RANGE им&ют идентификаторы, совпадающие с зарезервированными словами.
Однако неоднозначность устранится, если перед обозначением атрибута будет стоять апостроф.
Единственными предопределёнными обозначениями атрибутов, содержащими универсальное выражение, являются те, которые соответствуют некоторым определённым операциям типа над индексируемыми типами (см. 3.6.2).
Примеры атрибутов:
Литерал — это либо числовой литерал, либо литерал перечисления, либо литерал null, либо строковый литерал, либо символьный литерал.
Вычисление литерала вырабатывает соответствующее значение.
Числовые литералы — это литералы типов универсальный целый и универсальный вещественный.
Литералы перечисления включают символьные литералы и вырабатывают значения соответствующих перечислимых типов.
Литерал null вырабатывает пустое ссылочное значение, которое не указывает ни на какой объект вообще.
Строковый литерал — это базовая операция, которая преобразует последовательность символов в значение одномерного массива символьного типа;
границы этого массива определяются в соответствии с правилами для позиционных агрегатов массива (см. 4.3.2).
Для пустого строкового литерала верхняя граница массива совпадает с нижней границей предшественника задаваемого атрибутом PRED.
Вычисление пустого строкового литерала возбуждает исключение CONSTRAINT_ERROR, если нижняя граница не имеет предшественника (см. 3.5.5).
Тип строкового литерала и тип литерала null должны определяться исключительно из контекста, в котором эти литералы встречаются, без учёта самого литерала, но используя при этом только тот факт, что литерал null — это значение ссылочного типа, а строковый литерал — значение одномерного массива, тип компонент которого — символьный.
Символьные литералы, содержащиеся в строковом литерале и соответствующие графическим символам, должны быть видимы в месте нахождения строкового литерала
(Хотя сами эти символы для определения типа данного строкового литерала не используются).
Агрегат — это базовая операция, которая объединяет значения компонент в составное значение именуемого или индексируемого типа.
Каждое сопоставление компонент связывает выражение с компонентами.
Сопоставление компонент называется именованным, если компоненты явно определены выборами, и позиционным в противном случае.
При позиционном сопоставлении каждой отдельно взятой компоненте неявно соответствует некоторая позиция: именуемым компонентам — в порядке следования их описаний, индексируемым компонентам — по возрастанию индекса.
Именованные сопоставления могут стоять в произвольном порядке (исключая выбор others), но если в агрегате одновременно используются позиционные и именованные сопоставления, то первыми должны стоять позиционные сопоставления, каждое на своём месте.
Следовательно, за именованными сопоставлениями в агрегате могут следовать только именованные сопоставления.
В агрегатах, содержащих единственное сопоставление, должно всегда использоваться именованное сопоставление.
Правила для сопоставления компонент агрегатов именуемого типа и агрегатов индексируемого типа определены в разд.
4.3.1 и 4.3.2.
Синтаксис выборов сопоставления компонент совпадает с синтаксисом разделов вариантов (см. 3.7.3).
Выбор, являющийся простым именем компоненты, допустим только в агрегатах именуемого типа.
Выбор, являющийся выражением или дискретным диапазоном, допустим только в агрегатах индексируемого типа;
выбор, являющийся простым выражением, задаёт значение индекса;
дискретный диапазон задаёт диапазон значений индекса.
Выбор others допустим только в последнем сопоставлении компонент в качестве единственного выбора и определяет все оставшиеся компоненты, если они есть.
Каждая компонента значения, определяемого агрегатом, должна встретиться в агрегате один и только один раз.
Следовательно, каждый агрегат должен быть полным, и не допускается, чтобы данная компонента была задана более чем одним выбором.
Тип агрегата должен быть определим исключительно из контекста, в котором встречается агрегат, без учёта самого агрегата, используя только тот факт, что его тип должен быть составным и нелимитированным.
Тип агрегата в свою очередь определяет требуемый тип для каждой его компоненты.
Приведённое выше правило означает, что для определения типа агрегата не может быть использована информация, которую несёт в себе агрегат.
В частности, это определение не может использовать тип выражения в сопоставлении компонент, формы или типы выборов.
Агрегат с одной компонентой всегда можно отличить от выражения, заключённого в скобки, благодаря обязательному именованию компоненты такого агрегата.
Для агрегата именуемого типа (агрегата записи) имена компонент, заданные выборами, должны обозначать компоненты (включая дискриминанты) именуемого типа.
Выбор others в агрегатах записей должен представлять хотя бы одну компоненту.
Сопоставление компонент с выбором others или более чем с одним выбором допускается только тогда, когда представленные компоненты имеют один и тот же тип.
Выражение в сопоставлении компонент должно иметь тип соответствующей компоненты записи.
Значение, определяющее дискриминант, должно быть задано статическим выражением
(заметим, что это значение определяет, какие из зависимых компонент должны присутствовать в значении записи).
При вычислении агрегатов записи порядок вычисления выражений в сопоставлениях компонент в языке не определён.
Выражение в именованном сопоставлении вычисляется один раз для каждой сопоставленной компоненты.
Производится проверка на принадлежность значения каждой подкомпоненты агрегата подтипу этой подкомпоненты.
При нарушении проверки возбуждается исключение CONSTRAINT_ERROR.
Пример агрегата записи с позиционным сопоставлением:
Примеры агрегатов записи с именованными сопоставлениями:
Примеры сопоставления компонент с несколькими выборами:
В агрегате с позиционными сопоставлениями первыми идут значения дискриминантов, так как раздел дискриминантов идёт первым в описании именуемого типа;
они должны быть в том же порядке, что и в разделе дискриминантов.
Если тип агрегата — одномерный индексируемый тип, то каждый выбор должен задавать значения индекса, а выражение в каждом сопоставлении компонент должно иметь тип соответствующей компоненты.
Если тип агрегата — многомерный индексируемый тип, то n-мерный агрегат записывается как одномерный, в котором выражения, задающие сопоставления компонент, сами записываются как (n - 1)-мерный агрегат, называемый подагрегатом;
подтип индекса одномерного агрегата задаётся первой позицией индекса индексируемого типа.
То же правило используется для следующей позиции индекса при записи подагрегатов, если они опять многомерные.
В многомерном агрегате допустимо использование строкового литерала в качестве одномерного массива символьного типа.
В дальнейшем связанные с агрегатами массивов правила формулируются в терминах одномерных агрегатов.
За исключением последнего сопоставления компонент с единственным выбором others, остальные сопоставления (если они есть) агрегата массива должны быть либо все позиционными, либо все именованными.
Для агрегата массива, имеющего одно именованное сопоставление компонент с одним выбором, допускается задание только такого выбора, который не является статическим или является пустым диапазоном.
Выбор others является статическим, если статическим является соответствующее ограничение индекса.
Границы агрегата массива, имеющего выбор others, определяются соответствующим ограничением индекса.
Использование выбора others допускается только тогда, когда агрегат находится в одном из следующих контекстов
(контекст определяет соответствующее ограничение индекса):
Агрегат — это фактический параметр, фактический параметр настройки, выражение, являющееся результатом функции, или выражение, которое следует за составным ограничителем присваивания.
При этом подтип соответствующего формального параметра, формального параметра настройки, результат функции или объекта — ограниченный индексируемый подтип.
Для агрегата, помещённого в такой контекст и содержащего сопоставление с выбором others, другие именованные сопоставления допускаются только в случае фактического параметра (не являющегося фактическим параметром настройки) или результата функции.
Если' агрегат — многомерный массив, то это ограничение распространяется и на все подагрегаты.
Агрегат — это операнд квалифицированного выражения, обозначение типа которого указывает ограниченный индексируемый подтип.
Агрегат — это выражение в сопоставлении компонент другого агрегата индексируемого или именуемого типа.
При этом, если этот объемлющий агрегат — многомерный агрегат индексируемого типа, то сам он заключён в один из этих трёх видов контекста.
Границы агрегата массива без выбора others определяются следующим образом.
Для агрегата с именованными сопоставлениями границы определяются наименьшим и наибольшим из заданных выборов.
Нижняя граница позиционного агрегата определяется соответствующим ограничением индекса, если агрегат помещён в один из контекстов а), б) или в);
в противном случае нижняя граница задаётся как S'FIRST, где S — подтип индекса;
в обоих случаях верхняя граница определяется числом компонент.
Вычисление агрегата массива, не являющегося подагрегатом, производится в два шага.
На первом шаге вычисляются выборы данного агрегата и его подагрегатов, если они есть, в порядке, не определённом в языке.
На втором — вычисляются выражения в сопоставлениях компонент в порядке, также не определённом в языке.
Выражение в именованном сопоставлении вычисляется один раз для каждой сопоставляемой компоненты.
Вычисление подагрегатов состоит из этого второго шага
(первый шаг пропускается, так как выборы уже были вычислены).
При вычислении непустого агрегата массива производится проверка того, что значения задаваемых выборами индексов принадлежат соответствующему подтипу индекса, а также того, что значение каждой подкомпоненты агрегата принадлежит подтипу этой подкомпоненты.
Для n-мерного агрегата производится проверка того, что все (n - 1)-мерные подагрегаты имеют одинаковые границы.
Если хотя бы одна из этих проверок даёт отрицательный результат, возбуждается исключение CONSTRAINT_ERROR.
Допустимыми константами агрегата массива с выбором others являются те, в которых границы такого агрегата всегда известны из контекста.
Примеры агрегатов массивов с позиционными сопоставлениями:
Примеры агрегатов массивов с именованными сопоставлениями:
Примеры агрегатов двумерных массивов:
Примеры агрегатов в качестве значений инициализации:
Выражение — это формула, которая определяет процесс вычисления значения.
Каждое первичное имеет значение и тип.
Использование имён в качестве первичного допускается только для именованных чисел, атрибутов, которые вырабатывают значения, а также имён, обозначающих объекты (значением такого первичного является значение объекта) или обозначающих значения.
Не допускается в качестве первичных использование имён формальных параметров вида out, а использование имён их подкомпонент допускается только в случае дискриминантов.
Тип выражения зависит только от типа его составных частей и применяемых операций;
для совмещённых операндов или операций определение типа операнда или идентификация операции зависят от контекста.
Для каждой предопределённой операции типы операндов и результата приведены в разд.
4.5.
Примеры первичных:
Примеры выражений:
В языке определяется шесть классов операций.
При описании функций, определяющих пользовательские операции, 6 качестве обозначений могут быть использованы приведённые ниже знаки операций (исключая /=).
Шесть классов операций приведены в порядке возрастания их старшинства.
Формы управления промежуточной проверкой and then и ог else имеют тот же порядок старшинства, что и логические операции.
Проверки принадлежности in и not in имеют то же старшинство, что и операции отношения.
В слагаемом, простом выражении, отношении или выражении группирование операций с их операндами проводится сначала для операций с большим старшинством, а затем для операций с меньшим старшинством.
В случае последовательных операций с одинаковым старшинством группирование операций с их операндами производится в порядке их текстуального следования слева направо;
для изменения порядка группирования могут использоваться скобки.
В языке не определяется порядок вычисления операндов множителя, слагаемого, простого выражения или отношения и операндов выражения, которое не содержит форм управления промежуточной проверки
(но вычисление производится до применения соответствующей операции).
Правый операнд формы управления промежуточной проверкой вычисляется тогда и только тогда, когда левый операнд имеет определённое значение (см. 4.5.1).
Для каждой формы описания типа некоторые из перечисленных операций являются предопределёнными, т.е. неявно вводятся описанием типа.
Для каждого такого неявного описания операции именами параметров являются LEFT и RIGHT для бинарных операций;
для унарных аддитивных операций и унарных операций abs и not их единственный параметр именуется RIGHT.
В разд.
4.5.1 — 4.5.7 поясняются результаты предопределённых операций.
Предопределённые операции над целыми типами либо вырабатывают математически корректный результат, либо возбуждают исключение NUMERIC_ERROR.
Предопределённая операция, вырабатывающая результат целого типа (отличного от универсального целого), может возбуждать исключение NUMERIC_ERROR, только если математический результат не является значением этого целого типа.
Предопределённые операции над вещественными типами вырабатывают результаты, точность которых определяется в разд.
4.5.7.
Предопределённая операция, вырабатывающая результат вещественного типа (отличного от универсального вещественного), может возбуждать исключение NUMERIC_ERROR, только если её результат не принадлежит диапазону хранимых чисел этого типа, как это поясняется в разд.
4.5.7.
Примеры старшинства:
Приводимые ниже логические операции предопределены для логических типов и одномерных индексируемых типов с компонентами логического типа.
В обоих случаях операнды должны иметь один и тот же тип.
Операции над массивами выполняются покомпонентно, если компоненты имеются (как для равенства, см. 4.5.2).
Границы массива-результата совпадают с границами левого операнда.
Для каждой компоненты левого операнда проверяется наличие соответствующей компоненты правого операнда, и наоборот.
При нарушении соответствия компонент возбуждается исключение CONSTRAINT_ERROR.
Формы управления промежуточной проверкой and then и or else определены для двух операндов логического типа и вырабатывают результат того же самого типа.
Левый операнд формы управления промежуточной проверкой всегда вычисляется первым.
Если левый операнд выражения с формой and then даёт значение FALSE, то правый операнд не вычисляется и значением выражения является FALSE.
Если левый операнд с формой or else даёт TRUE то правый операнд не вычисляется и значением выражения является TRUE.
Если вычисляются оба операнда, то результат and then такой же, как and, а результат or else — как or.
Обычный смысл логических операций задаётся следующей таблицей истинности:
Примеры логических операций:
Примеры форм управления с промежуточной проверкой:
Операции равенство и неравенство предопределены для любого типа, не являющегося лимитируемым.
Остальные операции отношения являются операциями упорядочивания:< (меньше), < = (меньше или равно), > (больше), > = (больше или равно).
Операции упорядочивания предопределены для любого скалярного типа и любого дискретного индексируемого типа (одномерного индексируемого типа с компонентами дискретного типа).
Операнды каждой предопределённой операции отношения имеют один и тот же тип.
Тип результата — предопределённый тип — BOOLEAN.
Смысл операций отношения традиционный: результат равен TRUE, если соответствующее отношение удовлетворено, результат равен FALSE в противном случае.
Операция неравенства даёт результат, противоположный результату операции равенства: FALSE, если операнды равны; TRUE — если не равны.
Равенство для дискретных типов — это равенство значений.
Результаты предопределённых операций отношения для вещественных операндов, значения которых равны приблизительно, приводятся в разд.
4.5.7.
Два ссылочных значения равны, когда они указывают на один и тот же объект либо когда они равны пустому значению ссылочного типа.
Для двух значений одного и того же индексируемого типа или именуемого типа левый операнд равен правому, если и только если для каждой компоненты левого операнда имеется сопоставленная компонента правого операнда, и наоборот;
значения сопоставленных компонент равны в смысле предопределённой операции равенства для типа этих компонент.
В частности, всегда равны два пустых массива одного и того же типа, всегда равны две пустые записи одного и того же типа.
Для сравнения двух записей одинакового типа сопоставленными компонентами являются компоненты с одинаковыми идентификаторами компонент.
При сравнении двух одномерных массивов одинакового типа сопоставленными являются компоненты (если они есть), значения индексов которых сопоставляются друг с другом следующим образом: сопоставляются нижние границы диапазонов индексов друг с другом, следующие за сопоставленными индексами также сопоставляются.
При сравнении двух многомерных массивов сопоставленными являются компоненты, у которых значения индексов сопоставлены в порядке позиций индексов.
Если равенство явно определено для лимитируемого типа, оно не распространяется на составные типы, имеющие подкомпоненты лимитируемого типа
(допускается явное определение равенства для таких составных типов).
Операции упорядочивания <, <=, > и >=, которые определены для дискретных индексируемых типов, соответствуют лексикографическому порядку, основанному на предопределённом отношении порядка для типов компонент.
Пустой массив лексикографически меньше массива, имеющего по крайней мере одну компоненту.
Для непустых массивов левый операнд лексикографически меньше правого операнда, если первая компонента левого операнда меньше первой компоненты правого операнда или если их первые компоненты равны, а хвост левого операнда лексикографически меньше правого
(хвост состоит из оставшихся компонент, исключая первую, и может быть пустым).
Проверки принадлежности in и not in предопределены для всех типов.
Типом результата является предопределённый тип BOOLEAN.
Для проверки принадлежности диапазону простое выражение и границы диапазона должны быть одного и того же скалярного типа;
для проверки принадлежности с обозначением типа тип простого выражения должен быть базовым для этого обозначения.
Вычисление проверок принадлежности in вырабатывает результат TRUE, если значение простого выражения принадлежит данному диапазону или это значение принадлежит подтипу, заданному обозначением типа;
в противном случае вычисление вырабатывает результат FALSE (для значений вещественного типа см. 4.5.7).
Проверка принадлежности not in вырабатывает результат, противоположный результату проверки принадлежности in.
Предопределённые операции отношения и проверка принадлежности не возбуждают исключений, но исключение может быть возбуждено при вычислении операндов этих операций.
Если именуемый тип имеет компоненты, зависящие от дискриминантов, то компоненты двух значений сопоставлены тогда и только тогда, когда равны их дискриминанты.
Компоненты непустых массивов сопоставлены, если и только если значения атрибута LENGTH(N) для каждой позиции индекса одинаковы у обоих массивов.
Бинарные аддитивные операции + и - предопределены для любого числового типа и имеют свой обычный смысл.
Операция катенации & предопределена для любого одномерного нелимитируемого индексируемого типа.
Для вещественных типов точность результата определяется типом операндов (см. 4.5.7).
Если оба операнда — одномерные массивы, то результатом катенации является одномерный массив, длина которого равна сумме длин операндов, а его компоненты составлены из компонент левого операнда и следующих за ними компонент правого операнда.
Нижняя граница этого результата совпадает с нижней границей левого операнда, если левый операнд — не пустой массив; в противном случае результатом катенации является правый операнд.
Если один из операндов имеет тип компоненты индексируемого типа, то результат катенации определяется по приведённым выше правилам, где вместо этого операнда используется массив, имеющий этот операнд в качестве своей единственной компоненты, и с нижней границей, совпадающей с нижней границей подтипа индекса.
Операцией катенации возбуждается исключение CONSTRAINT_ERROR, если верхняя граница результата выходит за диапазон подтипа индекса, кроме того случая, когда результат — не пустой массив.
Также исключение возбуждается когда какой-либо операнд, тип которого есть тип компоненты, имеет значение, не принадлежащее данному подтипу компоненты.
Унарные аддитивные операции + и - предопределены для любого числового типа и имеют свой обычный смысл.
Для этих операций операнд и результат имеют один и тот же тип.
Операции * и / предопределены для любого целого и любого плавающего типа и понимаются в обычном смысле.
Операции mod и геm предопределены для любого целого типа.
Для каждой из этих операций операнды и результат имеют один и тот же базовый тип.
Для плавающих типов точность результата определяется типом операндов (см. 4.5.7).
Деление нацело и остаток связаны следующим соотношением:
где (А rem В) имеет знак значения А и абсолютное значение, меньшее абсолютного значения В.
Деление нацело удовлетворяет следующему тождеству:
Результат операции вычета по модулю таков, что (А mod В) имеет знак значения В и абсолютное значение, меньшее абсолютного значения В, и существует целое значение N такое, что должно удовлетворяться следующее соотношение:
Для каждого фиксированного типа предопределены операции умножения и деления на операнд предопределённого типа INTEGER.
Умножение значения фиксированного типа на целое эквивалентно повторению операции сложения.
Деление значения фиксированного типа на целое является приближенным и не меняет типа (см. 4.5.7).
Наконец, следующие операции умножения и деления описаны в предопределённом пакете STANDARD.
Эти две специальные операции применимы к операндам любых фиксированных типов,
(они не могут быть переименованы или даны в качестве фактических параметров настройки).
Операнды умножения могут быть одного и того же или различных фиксированных типов, а тип результата — анонимный предопределённый универсальный фиксированный тип, дельта которого произвольно мала.
Результат любого такого умножения всегда должен быть явно преобразован в значение некоторого числового типа.
Это обеспечивает явное управление точностью вычислений.
То же относится к делению значения фиксированного типа на значение фиксированного типа.
Никакие другие операции для типа универсальный фиксированный не определены.
Исключение NUMERIC_ERROR возбуждается операциями целого деления rem и mod, если правый операнд равен нулю.
Для положительных А и В частное задаётся выражением А/В, а остаток от деления А на В задаётся А rem В.
Операция rem удовлетворяет следующим соотношениям:
Для некоторого целого К справедливо следующее тождество:
Соотношения между делением нацело, остатком и вычетом по модулю иллюстрируются следующей таблицей:
Унарная операция высшего приоритета abs предопределена для любого числового типа.
Унарная операция высшего приоритета not предопределена для любого логического типа и одномерного индексируемого типа с компонентами логического типа.
Операция not, применяемая к одномерному массиву с логическими компонентами, вырабатывает одномерный логический массив с теми же самыми границами;
каждая компонента результата получается как логическое отрицание соответствующей компоненты операнда
(т.е. компоненты с тем же значением индекса).
Операция возведения в степень ** предопределена для каждого целого и для каждого плавающего типов.
В обоих случаях правый операнд, называемый показателем степени, имеет предопределённый тип INTEGER.
Возведение в степень с положительным показателем эквивалентно кратному умножению левого операнда на себя слева направо в соответствии со значением показателя.
Для операнда плавающего типа порядок может быть отрицательным, в этом случае результат — обратная величина результата с положительной степенью.
Возведение в нулевую степень даёт в результате единицу.
Возведение в степень значения плавающего типа является приближенным (см. 4.5.7).
При возведении целого значения в отрицательную степень возбуждается исключение CONSTRAINT_ERROR.
Вещественный подтип определяет множество модельных чисел.
В терминах модельных чисел определяются точность, с которой базовые и предопределённые операции вырабатывают вещественный результат, и результат предопределённых операций отношения с вещественными операндами.
Модельный интервал подтипа — это интервал с границами, заданными модельными числами этого подтипа.
Связанный с принадлежащими вещественному подтипу значениями модельный интервал является наименьшим модельным интервалом (данного подтипа), который содержит эти значения.
(модельный интервал, связанный с модельным числом некоторого подтипа, состоит только из этого числа).
Для любой базовой или предопределённой операции, вырабатывающей результат вещественного подтипа, требуемые границы результата задаются модельным интервалом, который определяется следующим образом:
Модельный интервал результата — это наименьший модельный интервал (подтипа результата), который включает в себя минимальное и максимальное из всех значений, получаемых при применении (точной) математической операции, где каждый операнд,— это любое значение из модельного интервала (подтипа операнда), определённого для этого операнда.
Модельный интервал операнда, который сам является результатом операции, отличной от неявного преобразования, является модельным интервалом результата этой операции.
Модельный интервал операнда, значение которого получено неявным преобразованием универсального выражения, является модельным интервалом, соответствующим этому значению из подтипа операнда.
Модельный интервал результата не определён, если абсолютное значение хотя бы одного из упомянутых выше математических результатов превышает наибольшее хранимое число типа результата.
Всякий раз, когда модельный интервал результата не определён и реализация не может обеспечить, чтобы фактический результат лежал в диапазоне хранимых чисел, крайне желательно возбуждение исключения NUMERIC_ERROR.
Правила языка, однако, этого не требуют, так как для некоторых объектных машин нет простых методов обнаружения переполнения.
Значение атрибута MACHINE_OVERFLOWS указывает, возбуждает ли объектная машина исключение NUMERIC_ERROR в ситуациях переполнения (см. 13.7.3).
Хранимые числа вещественного типа определены (см. 3.5.6) как надмножество модельных чисел, границы ошибок которых подчиняются тем же правилам, что и для модельных чисел.
Любое задаваемое в этом разделе в терминах модельных интервалов определение может поэтому быть распространено на хранимые интервалы хранимых чисел.
Следствием такого распространения является то, что для реализации не допускается возбуждение исключения NUMERIC_ERROR, если интервал результата является хранимым интервалом.
Для результата операции возведения в степень модельный интервал, определяющий границы результата, определяется по приведённым выше правилам, которые применяются к последовательным умножениям при вычислении степени и к заключительному делению, если показатель степени — отрицательное число.
Для результата операции отношения между двумя вещественными операндами рассмотрим модельный интервал (подтипа операнда), определённый для каждого такого операнда;
результат может быть любым значением, полученным при применении математической операции сравнения к значениям, произвольно выбранным в соответствующих модельных интервалах операндов.
Если один или оба модельных интервала операндов не определены (и если при вычислении операндов не было возбуждено исключение), то в качестве результата сравнения допустимо любое возможное значение (т.е. либо TRUE, либо FALSE).
Результат проверки принадлежности определён в терминах сравнения значения операнда с нижней и верхней границами заданного диапазона или обозначения типа
(к таким сравнениям применяются обычные правила).
Для плавающего типа числа 15.0, 3.0 и 5.0 всегда являются модельными числами.
Следовательно, X/Y, где Х равно 15.0, а Y — 3.0, согласно приведённым выше правилам, вырабатывает в результате точно 5.0.
В общем случае деление не вырабатывает в результате модельные числа, и, следовательно, нельзя рассчитывать, что выполнено равенство (1.0/Х)'Х =1.0.
Вычисление явного преобразования типа — это вычисление выражения, заданного в качестве операнда, и преобразование результата в значение указанного целевого типа.
Явные преобразования типов допустимы между взаимосвязанными типами.
Целевой тип преобразования типа — это базовый тип обозначения типа.
Тип операнда преобразования типа должен быть определимым независимо от контекста
(в частности, независимо от целевого- типа).
Более того, недопустимо, чтобы операнд преобразования типа был литералом null, генератором, агрегатом или строковым литералом;
задание в качестве операнда преобразования типа выражения, заключённого в скобки, допускается, только если само выражение является допустимым.
Преобразование к подтипу состоит в преобразовании к целевому типу с последующей проверкой принадлежности результата этому подтипу.
Допускается преобразование операнда заданного типа к тому же самому типу.
Другие явные преобразования типов допустимы в следующих трёх случаях:
Числовые типы.
Операнд может быть любого числового типа, значение операнда преобразуется в значение целевого типа, который должен быть также числовым.
Для преобразования вещественных типов точность результата лежит в пределах точности заданного подтипа (см. 4.5.7).
Преобразование значения вещественного типа в значение целого типа состоит в его округлении до ближайшего целого;
для вещественного операнда, равноотстоящего от двух целых (с точностью этого вещественного подтипа), округление может быть произведено как в ту, так и в другую сторону.
Производные типы.
Преобразование допустимо, если целевой тип и тип операнда являются производными один от другого, непосредственно или косвенно, или если существует третий тип, от которого производными являются тип операнда и целевой тип, непосредственно или косвенно.
Индексируемые типы.
Преобразование допустимо, если тип операнда и целевой тип — индексируемые типы, которые удовлетворяют следующим условиям: оба типа должны иметь одну и ту же размерность;
в каждой позиции индекса типы индексов должны быть либо одинаковыми, либо взаимопреобразуемыми;
типы компонент должны быть одинаковыми;
наконец, если тип компоненты — тип с дискриминантами или ссылочный тип, то подтипы компонент должны быть оба либо ограниченными, либо неограниченными.
Если обозначение типа задаёт неограниченный индексируемый тип, то для каждой позиции индекса границы результата преобразования определены преобразованием границ операнда в значения соответствующего типа индекса целевого типа.
Если обозначение типа задаёт ограниченный индексируемый тип, то границы результата совпадают с границами, указанными в обозначении типа.
В обоих случаях значение каждой компоненты результата определяется соответствующей компонентой операнда (см. 4.5.2).
При вычислении преобразований числовых и производных типов возбуждается исключение CONSTRAINT_ERROR, если результат преобразования не удовлетворяет заданным в обозначении типа ограничениям.
При преобразовании индексируемых типов проверяется тот факт, что любое ограничение подтипа компоненты одинаково для индексируемого типа операнда и для целевого индексируемого типа.
Если обозначение типа задаёт неограниченный индексируемый тип и если операнд не является пустым массивом, то для каждой позиции индекса проверяется принадлежность границ результата соответствующему подтипу индекса целевого типа.
Если обозначение типа задаёт ограниченный индексируемый подтип, то для каждой компоненты операнда проверяется наличие соответствующей компоненты целевого подтипа, и наоборот.
Если хотя бы одна из этих проверок даёт отрицательный результат, возбуждается исключение CONSTRAINT_ERROR.
Если допустимо преобразование одного типа в другой, то также допустимым является и обратное преобразование.
Это обратное преобразование используется тогда, когда фактический параметр вида in out или out имеет форму преобразования типа имени (переменной), как это поясняется в разд.
6.4.1.
Единственной допустимой формой неявного преобразования типа является преобразование значения универсального целого или универсального вещественного типов в значение другого числового типа.
Неявное преобразование операнда универсального целого типа в другой целый тип или операнда универсального вещественного типа в другой вещественный тип возможно только для операнда, являющегося либо числовым литералом, либо именованным числом, либо атрибутом;
в этом разделе такой операнд называется преобразуемым универсальным операндом.
Неявное преобразование преобразуемого универсального операнда применимо тогда и только тогда, когда самый сложный полный контекст (см. 8.7) определяет единственный (числовой) целевой тип для этого неявного преобразования и, кроме этого преобразования, не существует иной, предписанной языком правильной интерпретации этого контекста.
Правила для неявных преобразований подразумевают, что для операнда явного преобразования типа не производится никаких неявных преобразований.
Аналогично не производится никаких неявных преобразований для операндов предопределённых операций отношения, являющихся преобразуемыми универсальными операндами.
Для индексируемых типов в языке допускается неявное преобразование подтипов (см. 5.2.1).
Последствием явного преобразования типа может быть изменение представления (в частности, см. 13.6).
Явные преобразования используются также для фактических параметров (см. 6.4).
Примеры преобразования числовых типов:
Примеры преобразования производных типов:
Примеры преобразования индексируемых типов:
Примеры неявных преобразований:
Квалифицированное выражение используется для явного указания типа и, возможно, подтипа операнда, заданного выражением или агрегатом.
Тип операнда должен совпадать с базовым типом обозначения типа.
Значение квалифицированного выражения — это значение операнда.
Вычисление квалифицированного выражения выдаёт операнд и проверяет, принадлежит ли его значение подтипу, заданному в обозначении типа.
При отрицательном результате проверки возбуждается исключение CONSTRAINT_ERROR.
Когда тип литерала перечисления или агрегата неизвестен из контекста, квалифицированное выражение может быть использовано для явного установления типа.
Например, совмещённый литерал перечисления должен быть квалифицирован в следующих случаях: при использовании его в качестве параметра в вызове совмещённой подпрограммы, которая не может быть идентифицирована на основе типов остальных параметров и типа результата; в отношении, в котором оба операнда — совмещённые литералы перечисления; в массиве или диапазоне параметра цикла, в которых обе границы — совмещённые литералы перечисления.
Явная квалификация используется также для определения совмещённой функции без параметров или для ограничения значения данным подтипом.
Вычисление генератора создаёт объект и вырабатывает ссылочное значение, которое указывает на этот объект.
Тип порождённого генератором объекта — это базовый тип обозначения типа, заданного либо в указании подтипа, либо в квалифицированном выражении.
Для генератора с квалифицированным выражением это выражение задаёт начальное значение создаваемого объекта.
Тип ссылочного значения, вырабатываемого генератором, должен быть определимым только из контекста с учётом того, что это значение является ссылкой на указанный в генераторе тип.
Ограничение индекса и ограничение дискриминанта являются единственными допустимыми формами ограничения в указателе подтипа генератора.
Если в генераторе есть указание подтипа и если порождаемый объект имеет индексируемый тип или тип с дискриминантами, которые не содержат выражений по умолчанию, то указание подтипа должно либо обозначать ограниченный подтип, либо содержать явное ограничение индекса или дискриминанта.
Создаваемый объект индексируемого типа или типа с дискриминантами всегда ограничен.
Для генератора с указанием подтипа создаваемый объект ограничен либо этим подтипом, либо значениями дискриминанта по умолчанию.
Для генератора с квалифицированным выражением создаваемый объект ограничен границами или дискриминантами начального значения.
Для других типов создаваемый объект имеет подтип, определённый указанием подтипа в определении ссылочного типа.
При вычислении генератора сначала производится предвыполнение указания подтипа или вычисление квалифицированного выражения.
Затем создаётся новый объект.
Далее осуществляется инициализация, как для описанного объекта (см. 3.2.1): явно — для квалифицированного выражения, неявно — для указания подтипа.
Наконец, возвращается ссылочное значение, указывающее на созданный объект.
Реализация должна гарантировать сохранение объекта, созданного при вычислении генератора, до тех пор, пока объект, или хотя бы одна из его подкомпонент, доступен непосредственно или косвенно, т.е. пока он может быть обозначен некоторым именем.
Кроме того, если объект или одна из его подкомпонент принадлежит задачному типу, он считается доступным, пока не завершена эта задача.
Реализация может (но не обязана) освобождать память, занятую объектом, созданным генератором, как только этот объект становится недоступным.
В случаях когда требуется более точное управление распределением памяти под указанные значениями ссылочного типа объекты, оно может быть обеспечено следующими средствами:
Общий объем памяти, доступный для набора объектов ссылочного типа, может быть установлен с помощью спецификатора длины (см. 13.2).
Прагма CONTROLLED указывает реализации на то, что для объектов, указанных значениями ссылочного типа, автоматическое возвращение памяти производиться не должно, исключая случаи выхода из самого вложенного оператора блока, тела подпрограммы или тела задачи, содержащих описание этого ссылочного типа, или выхода из главной программы.
Прагма CONTROLLED для данного ссылочного типа допустима в тех же местах, что и спецификатор представления этого типа (см. 13.1).
Эта прагма не допускается для производного типа.
Явного освобождения памяти, занимаемой объектом, указанным ссылочным значением, можно достичь вызовом процедуры, полученной настройкой предопределённой библиотечной процедуры UNCHECKED_DEALLOCATION (см. 13.10.1).
При исчерпании памяти генератором возбуждается исключение STORAGE_ERROR.
Заметим также, что исключение CONSTRAINT_ERROR может быть возбуждено при вычислении квалифицированного выражения, во время предвыполнения указания подтипа или при инициализации.
Примеры (ссылочных типов, описанных в разд.
3.8):
Некоторые выражения скалярного типа называются статическими.
Аналогично статическими называют некоторые дискретные диапазоны, а обозначения типов для некоторых скалярных подтипов называют обозначающими статические подтипы.
Выражение скалярного типа называется статическим тогда и только тогда, когда каждое первичное является одним из перечисленных в пунктах от а до з, а каждая операция — это предопределённая операция и вычисление выражения даёт значение (т.е. не возбуждает исключения).
Литерал перечисления (включая символьный литерал).
Числовой литерал.
Именованное число.
Заданная явным описанием константа статического подтипа и инициализированная статическим выражением.
Вызов функции, имя которой — знак операции, обозначающий предопределённую операцию, включая расширенное имя;
каждый фактический параметр должен быть статическим выражением.
Определяемый в языке атрибут статического подтипа;
если атрибут — функция, фактические параметры должны быть также статическими выражениями.
Квалифицированное выражение, обозначение типа которого задаёт статический подтип, а операнд — статическое выражение.
Заключённое в скобки статическое выражение.
Статическим является диапазон, границы которого — статические выражения.
Статическим является ограничение диапазона, если составляющие его атрибут или простое выражение являются статическими.
Статический подтип — это либо скалярный базовый тип, отличный от формального типа настройки, либо скалярный подтип, образованный наложением на статический подтип либо ограничения статическим диапазоном, либо ограничения плавающего или фиксированного типа, ограничение диапазона которого, если оно есть, является статическим.
Статический дискретный диапазон — это либо статический подтип, либо статический диапазон.
Статическое ограничение индекса — это ограничение индекса, для которого статическим является каждый подтип индекса соответствующего индексируемого типа и для которого статическим является каждый дискретный диапазон.
Статическое ограничение дискриминанта — это ограничение дискриминанта, для которого статическим является подтип каждого дискриминанта и в котором статическим является каждое выражение.
Точность вычисления статического выражения вещественного типа определена правилами, данными в разд.
4.5.7.
Если результат не является модельным (или хранимым) числом этого типа, то значение выражения, полученное при вычислении во время компиляции, не обязано совпадать со значением, которое получится при вычислении во время счета.
Атрибуты массивов не являются статическими, в частности статическим не является атрибут RANGE.
Универсальное выражение — это выражение, вырабатывающее результат универсального целого или универсального вещественного типа.
Для универсального целого типа предопределены те же операции, что и для любого целого типа.
Для универсального вещественного типа предопределены те же операции, что и для любого плавающего типа.
Кроме того, эти операции включают операции умножения и деления.
Точность вычисления универсального выражения типа универсальный вещественный обязана быть не ниже точности любого из предопределённых плавающих типов, поддержанных в реализации, исключая сам универсальный вещественный тип.
Более того, если универсальное выражение — статическое, то вычисление также должно быть точным.
При вычислении операций универсального выражения, не являющегося статическим, возбуждение исключения NUMERIC_ERROR реализацией допускается только в том случае, если результат операции — вещественное число с абсолютным значением, превышающим наибольшее хранимое число самого точного предопределённого плавающего типа (исключая универсальный вещественный), или целое значение, большее, чем SYSTEM.MAX_INT, либо меньшее, чем SYSTEM.MIN_INT.
Следствием приведённых выше правил является то, что тип универсального выражения — универсальный целый, если этот тип имеет каждое первичное, содержащееся в выражении (исключая фактические параметры атрибутов — функций и правые операнды операций возведения в степень), в противном случае тип универсального выражения — универсальный вещественный.
Оператор определяет действие, которое предстоит выполнить;
процесс реализации этого действия называется выполнением оператора.
В данной главе описываются общие правила, применимые ко всем операторам.
Специфические операторы обсуждаются в последующих главах.
Оператор вызова процедуры описывается в гл. 6.
Операторы вызова входа, задержки, принятия, отбора и прекращения описываются в гл. 9.
Оператор возбуждения — в гл. 11, а оператор кода — в гл. 13.
Все остальные операторы представленны в этой главе.
Оператор может быть или простым, или составным.
Простой оператор не содержит других операторов.
Составной оператор содержит простые операторы и другие составные операторы.
Говорят, что имя каждой метки, стоящей перед оператором, помечает этот оператор.
Имя метки (а также имя цикла или блока) неявно описано в конце раздела описаний самого внутреннего блока, тела подпрограммы, тела пакета, тела задачи или настраиваемого тела, которые содержат данный помеченный оператор (именованный оператор цикла или именованный оператор блока).
При отсутствии в операторе блока раздела описаний подразумевается, что оператор блока содержит неявный раздел описаний (с предшествующим declare).
Имена меток, циклов и блоков неявно описываются в порядке появления в тексте программы начал соответствующих помеченных операторов, операторов цикла и операторов блока.
Для имён меток, циклов и блоков, неявно описанных в теле программного модуля, включая вложенные в это тело операторы блока, но исключая другие вложенные программные модули (т.е. подпрограммы, пакеты, задачи или настраиваемые модули), должны использоваться различные идентификаторы.
Выполнение пустого оператора заключается в переходе к выполнению следующего оператора.
Выполнение последовательности операторов состоит в поочерёдном выполнении отдельных операторов последовательности, пока они все не будут закончены или пока не произойдёт передача управления.
Передача управления вызывается выполнением операторов выхода, возврата или перехода, выбором альтернативы завершения, возбуждением исключения или (неявно) выполнением оператора прекращения.
Примеры помеченных операторов:
Область действия описания начинается самим описанием (см. 8.2).
Область действия неявного описания имени метки, цикла или блока начинается до первого явного появления соответствующего имени, поскольку это появление возможно лишь в качестве метки оператора, в операторе блока, операторе цикла или операторе перехода.
Неявное описание в операторе блока может скрыть описание, данное во внешнем программном модуле или операторе блока (согласно обычным правилам скрытия, изложенным в разд.
8.3).
Оператор присваивания заменяет текущее значение переменной новым значением, задаваемым выражением.
Переменная в левой части оператора присваивания и выражение в его правой части должны быть одного и того же типа, однако он не должен быть лимитируемым.
При выполнении оператора присваивания вначале вычисляются имя переменной и выражение в порядке, не определённом в языке.
Затем, если переменная не является массивом, проверяется принадлежность значения выражения подтипу переменной
(если же переменная — массив, то при присваивании производится преобразование подтипа, как описано в разд.
5.2.1).
Наконец, значение выражения становится новым значением переменной.
При отрицательном результате упомянутой выше проверки принадлежности подтипу возбуждается исключение CONSTRAINT_ERROR, а текущее значение переменной не изменяется.
Выполнение присваивания ошибочно, если переменная является подкомпонентой, зависящей от дискриминантов неограниченной именуемой переменной, и при этом выполнении изменяется значение любого из упомянутых дискриминантов.
Примеры проверок ограничений:
Значения дискриминантов объекта, указанного ссылочным значением, не могут быть изменены (даже присваиванием составного значения всему объекту), поскольку такие объекты, созданные генераторами, всегда являются ограниченными (см. 4.8);
подкомпоненты таких объектов могут и не быть ограниченными.
Если выражение в правой части является числовым литералом, именованным числом или атрибутом, вырабатывающим результат типа универсальный целый или универсальный вещественный, то производится неявное преобразование типа, описанное в разд.
4.6.
Определение типа переменной в левой части оператора присваивания может потребовать рассмотрения выражения, если имя переменной может интерпретироваться как имя переменной, указанной ссылочным значением, возвращаемым вызовом функции, а также как компонента или отрезок такой переменной
(см. разд.
8.7 о контексте разрешения совмещения).
Если переменная в левой части оператора присваивания является индексируемой (в частности, отрезком), значение выражения неявно преобразуется в значение подтипа индексируемой переменной, после чего результат преобразования становится новым значением переменной.
Это значит, что новое значение каждой компоненты индексируемой переменной задаётся сопоставляемой ей компонентой индексируемого значения, полученного при вычислении выражения (см. определение сопоставляемых компонент в 4.5.2).
При преобразовании подтипа для каждой компоненты индексируемой переменной проверяется наличие сопоставляемой компоненты индексируемого значения, и наоборот.
При отрицательном результате этой проверки возбуждается исключение CONSTRAINT_ERROR, а значение каждой компоненты переменной не изменяется.
Присваивание массива определено даже в случае перекрывающихся отрезков, поскольку выражение в правой части вычисляется До присваивания компонент.
Так, в случае последнего из приведённых примеров реализация, вырабатывающая А(1 ..
12) = = "tartartartar", была бы некорректной.
Описанное выше явное преобразование подтипа выполняется только на уровне значения всего выражения правой части, но не для его подкомпонент, являющихся индексируемыми значениями.
Условный оператор выбирает для выполнения одну или ни одной из входящих в него последовательностей операторов в зависимости от значения (истинности) одного или нескольких условий.
Выражение, задающее условие, должно быть логического типа.
Для выполнения условного оператора вычисляются последовательно условия после if и elsif (трактуя заключительное else как elsif TRUE then) до тех пор, пока одно из них не окажется истинным или не будут исчерпаны все условия.
При нахождении условия со значением TRUE выполняется соответствующая последовательность операторов, в противном случае не выполняется ни одна из последовательностей операторов.
Оператор выбора выбирает для выполнения одну из нескольких альтернативных последовательностей операторов;
выбор альтернативы осуществляется в зависимости от значения выражения.
Выражение должно быть дискретного типа, который должен быть определимым независимо от контекста выражения, но с учётом того факта, что тип выражения должен быть дискретным.
Более того, тип этого выражения не должен быть настраиваемым формальным типом.
Каждый выбор в альтернативе оператора выбора должен быть того же типа, что и выражение;
перечень выборов определяет, для каких значений выражения выбирается соответствующая альтернатива.
Если выражение является именем объекта статического подтипа, то каждое значение этого подтипа должно быть представлено один и только один раз в наборе выборов оператора выбора и никакие другие значения недопустимы;
это правило применяется также, если выражение является квалифицированным выражением или преобразованием типа, обозначение типа которого указывает статический подтип.
В остальных случаях, для других форм выражения, каждое значение (базового) типа выражения должно быть представлено только один раз в наборе выборов и никакие другие значения недопустимы.
Используемые в качестве выборов в операторе выбора простые выражения и дискретные диапазоны должны быть статическими.
Выбор, являющийся дискретным диапазоном, задаёт все значения из этого диапазона (ни одного значения в случае пустого диапазона).
Выбор others допустим только в качестве единственного выбора для последней альтернативы и задаёт все значения (возможно, и ни одного), не приведённые в выборах предыдущих альтернатив.
В качестве выбора в альтернативе оператора выбора не допускается использование простого имени компоненты.
Выполнение оператора выбора заключается в вычислении выражения, в выборе последовательности операторов и в выполнении выбранной последовательности операторов.
При выполнении оператора выбора выбирается одна и только одна альтернатива, так как выборы являются исчерпывающими и взаимно исключающими.
Квалификацией выражения в операторе выбора статическим подтипом можно ограничить количество выборов, которые необходимо указать явно.
Выбор others обязателен в операторе выбора, если выражение имеет тип универсальный целый (например, выражение является целым литералом), так как это единственный способ учесть все значения типа универсальный целый.
Оператор цикла содержит последовательность операторов, выполнение которой повторяется несколько раз или ни одного раза.
Если в операторе цикла используется простое имя цикла, то оно должно задаваться как в начале, так и в конце этого оператора.
Оператор цикла без схемы итерации определяет повторяемое выполнение последовательности операторов.
Выполнение такого оператора цикла заканчивается выходом из цикла вследствие выполнения оператора выхода или какой-либо другой передачи управления (см. 5.1).
Для оператора цикла со схемой итерации while перед каждым выполнением последовательности операторов вычисляется условие;
если значением условия является TRUE, то последовательность операторов выполняется, если FALSE, то выполнение оператора цикла заканчивается.
Для оператора цикла со схемой итерации for спецификация параметра цикла является описанием параметра цикла с заданным в схеме итерации идентификатором.
Параметр цикла — это объект, типом которого является базовый тип дискретного диапазона (см. 3.6.1).
В пределах последовательности операторов параметр цикла считается константой.
Поэтому его использование в качестве переменной в левой части оператора присваивания недопустимо.
Параметр цикла не должен использоваться в качестве параметра вида out или in out оператора вызова процедуры или входа, а также в качестве параметра вида in out конкретизации настройки.
Для выполнения оператора цикла с итерационной схемой for сначала предвыполняется спецификация параметра цикла.
При этом создаётся параметр цикла и вычисляется дискретный диапазон.
Если дискретный диапазон пуст, то выполнение оператора цикла заканчивается.
В противном случае последовательность операторов выполняется по одному разу для каждого значения из дискретного диапазона
(при условии, что не происходит выхода из цикла из-за выполнения оператора выхода или какой-либо другой передачи управления).
Перед каждой такой итерацией параметру цикла присваивается соответствующее значение из дискретного диапазона.
При отсутствии зарезервированного слова reverse эти значения присваиваются в порядке возрастания, при наличии этого слова — в порядке убывания.
Пример оператора цикла без схемы итерации:
Пример оператора цикла со схемой итерации while:
Пример оператора цикла со схемой итерации for:
Пример оператора цикла с простым именем цикла:
Область действия параметра цикла простирается от спецификации параметра цикла до конца оператора цикла, а правила видимости таковы, что параметр цикла видим только в пределах последовательности операторов в цикле.
Дискретный диапазон цикла вычисляется только один раз.
Использование зарезервированного слова reverse не изменяет дискретный диапазон, так что следующие схемы итерации не эквивалентны (в первой — диапазон пуст):
Имена циклов используются также в операторах выхода и в расширенных именах (в качестве префикса имени параметра цикла).
Оператор блока содержит последовательность операторов, которой может предшествовать раздел описаний и за которой могут следовать обработчики исключений.
Если в операторе блока используется простое имя блока, то оно должно задаваться как в начале, так и в конце.
Выполнение оператора блока заключается в предвыполнении раздела описаний (при его наличии) и последующем выполнении последовательности операторов.
Если оператор блока содержит обработчики исключений, то они выполняются при возбуждении соответствующих исключений во время выполнения последовательности операторов (см. 11.2).
Если в операторе блока, выполнение последовательности операторов которого окончено, описаны объекты задачного типа, то оператор блока не заканчивается до тех пор, пока не будут завершены все его подчинённые задачи (см. 9.4).
Это правило применяется также при окончании из-за выполнения операторов выхода, возврата или перехода или из-за возбуждения исключения.
Внутри оператора блока его имя может использоваться в расширенных именах локальных понятий, таких как в приведённом выше примере (см. 4.1.3, пункт е).
Оператор выхода используется для окончания выполнения объемлющего оператора цикла (называемого в дальнейшем просто циклом);
окончание может быть условным, если оператор выхода содержит условие.
Оператор выхода с именем цикла допустим только в именованном цикле и применяется к этому циклу;
оператор выхода без имени цикла допускается в некотором цикле и применяется к самому внутреннему объемлющему циклу (именованному или нет).
Кроме этого, применяемый к конкретному циклу оператор выхода не должен появляться в теле подпрограммы, теле пакета, теле задачи, в настраиваемом теле или в операторе принятия, если эта конструкция вложена в рассматриваемый цикл.
Для выполнения оператора выхода сначала вычисляется условие, если оно есть.
Выход из цикла происходит, если значением условия является TRUE или условие отсутствует.
Выход из нескольких вложенных циклов можно осуществить с помощью оператора выхода с именем внешнего цикла.
Оператор возврата используется для окончания выполнения самой внутренней объемлющей конструкции, которая может быть функцией, процедурой или оператором принятия.
Оператор возврата допустим только в теле подпрограммы или настраиваемой подпрограммы или в операторе принятия и применяется к самой внутренней (объемлющей его) такой конструкции;
оператор возврата недопустим в теле модуля-задачи, пакета или настраиваемого пакета, объемлемого одной из указанных конструкций
(с другой стороны, он допустим в составном операторе, вложенном в такую конструкцию, и в частности в операторе блока).
Оператор возврата в операторе принятия, в теле процедуры или настраиваемой процедуры не должен содержать выражения.
Оператор возврата в теле функции или настраиваемой функции должен содержать выражение.
Значение выражения определяет результат, возвращаемый функцией.
Тип этого выражения должен быть базовым для обозначения типа, приводимого после зарезервированного слова return в спецификации функции или настраиваемой функции
(это обозначение типа определяет подтип результата).
Для выполнения оператора возврата сначала вычисляется выражение (при его наличии) и проверяется принадлежность его значения подтипу результата.
При положительном итоге проверки заканчивается вычисление оператора возврата и одновременно подпрограммы или оператора принятия.
При отрицательном — в месте оператора возврата возбуждается исключение CONSTRAINT_ERROR1.
Если выражение является числовым литералом, именованным числом или атрибутом, который вырабатывает результат типа универсальный целый или универсальный вещественный, то выполняется неявное преобразование результата, как описано в разд.
4.6.
Оператор перехода определяет явную передачу управления на помеченный меткой оператор.
Самая вложенная последовательность операторов, объемлющая помеченный меткой оператор, должна также охватывать и оператор перехода на эту метку
(в частности, оператор перехода может входить в ещё более вложенную последовательность операторов).
Кроме того, если оператор перехода содержится в операторе принятия или теле программного модуля, то соответствующий помеченный оператор не должен быть вне этой конструкции, и, наоборот (как следует из предыдущего правила), если помеченный оператор содержится в такой конструкции, то оператор перехода не может быть вне её.
Выполнение оператора перехода заключается в передаче управления на помеченный соответствующей меткой оператор.
Приведённые выше правила допускают передачу управления на оператор из некоторой объемлющей последовательности операторов, но не наоборот.
Аналогично они запрещают передачу управления между альтернативами оператора выбора, условного оператора или оператора отбора, между обработчиками исключений или из обработчика исключения некоторого окружения обратно на последовательность операторов этого окружения.
Подпрограммы являются одной из четырёх форм программных модулей, из которых могут быть составлены программы.
Другие формы — это пакеты, задачные модули и настраиваемые модули.
Подпрограмма — это программный модуль, выполнение которого инициируется вызовом подпрограммы.
Существуют две формы подпрограмм: процедуры и функции.
Вызов процедуры — это оператор;
вызов функции является выражением и возвращает значение.
Определение подпрограммы может состоять из двух частей: описания подпрограммы, определяющего соглашения о её вызове, и тела подпрограммы, определяющего её выполнение.
Описание подпрограммы объявляет процедуру или функцию в зависимости от указанного начального зарезервированного слова.
Спецификация процедуры определяет её идентификатор и её формальные параметры (если они есть).
Спецификация функции определяет её обозначение, её формальные параметры (если они есть) и подтип возвращаемого значения (подтип результата).
Обозначение, являющееся знаком операции, используется для совмещения операций.
Последовательность символов, представляющая знак операции, должна представлять операцию, принадлежащую одному из шести классов совмещаемых операций, определённых в разд.
4.5
(пробелы недопустимы, а относительно букв ограничений нет).
Спецификация параметра с несколькими идентификаторами эквивалентна последовательности спецификаций с одним параметром, как поясняется в разд.
3.2.
Каждая спецификация одного параметра описывает формальный параметр.
Если вид явно не задан, то предполагается вид in.
Если спецификация параметра оканчивается выражением, то оно является выражением по умолчанию формального параметра.
Выражение по умолчанию допустимо только в спецификации параметра вида in
(независимо от явного или неявного его указания).
Тип выражения по умолчанию должен совпадать с типом соответствующего формального параметра.
Не допускается использование имени, обозначающего формальный параметр, в выражении по умолчанию, если спецификация этого параметра дана в том же разделе формальных параметров.
Предвыполнение описания подпрограммы предвыполняет соответствующий раздел формальных параметров.
Предвыполнение раздела формальных параметров не даёт другого эффекта.
Примеры описания подпрограмм:
Примеры параметров с выражениями по умолчанию:
Вычисление выражений по умолчанию начинается при определённых вызовах подпрограмм, как пояснено в разд.
6.4.2
(выражения по умолчанию не вычисляются при предвыполнении описания подпрограммы).
Все подпрограммы могут быть вызваны рекурсивно и являются реентерабельными.
Говорят, что значение объекта читается, когда это значение вычисляется;
оно также читается, когда читается одна из его подкомпонент.
Говорят, что значение переменной изменяется, когда выполняется присваивание этой переменной, а также (косвенно) когда эта переменная используется в качестве фактического параметра оператора вызова подпрограммы или оператора вызова входа, которые изменяют её значение;
говорят также, что оно изменяется, когда изменяется одна из его подкомпонент.
Формальный параметр подпрограммы бывает одного из следующих трёх видов:
Формальный параметр — константа, разрешается только чтение значения соответствующего фактического параметра.
Формальный параметр — переменная, разрешается как чтение, так и изменение значения соответствующего фактического параметра.
Формальный параметр — переменная, разрешается изменение значения соответствующего фактического параметра.
Значение скалярного параметра, которое не изменяется при вызове, после возврата не определено;
то же самое имеет место для значения скалярной подкомпоненты, отличной от дискриминанта.
Допускается чтение границ и дискриминантов формального параметра и его подкомпонент; никакое другое чтение не допускается.
Для скалярного параметра такой эффект достигается копированием: в начале каждого вызова значение фактического параметра, соответствующего формальному параметру вида in или in out, копируется в этом формальном параметре (прямое копирование);
затем после нормального окончания тела подпрограммы значение формального параметра вида in out или out копируется обратно в соответствующем фактическом параметре (обратное копирование).
Для параметра ссылочного типа прямое копирование используется для всех трёх видов, а обратное — для видов in out и out.
Для параметров индексируемого, именуемого или задачного типов реализация может достигнуть такого же эффекта копированием, как и для скалярных типов.
Кроме того, если копирование используется для параметра вида out, то прямое копирование требуется по крайней мере для границ и дискриминантов фактического параметра и его подкомпонент, а также для каждой подкомпоненты ссылочного типа.
Другой вариант — вызов ссылкой, когда каждое использование формального параметра (чтение или изменение его значения) рассматривается как использование соответствующего фактического параметра при выполнении вызова подпрограммы.
В языке не определяется, какой из этих двух механизмов следует применять для передачи параметров; не определяется также, что различные вызовы одной и той же подпрограммы должны использовать один и тот же механизм.
Выполнение программы ошибочно, если её результат зависит от механизма, выбираемого реализацией.
Для параметра личного типа вышеуказанный эффект достигается по правилу, которое применяется к соответствующему полному описанию типа.
В теле подпрограммы формальный параметр отвечает любому ограничению, вытекающему из обозначения типа, данного в спецификации этого параметра.
В качестве границ формального параметра неограниченного индексируемого типа берутся границы фактического параметра (см. 3.6.2).
Для формального параметра, описание которого задаёт неограниченный (личный или именуемый) тип с дискриминантами, дискриминанты этого формального параметра инициализируются значениями соответствующих дискриминантов фактического параметра;
формальный параметр не ограничен тогда и только тогда, когда его вид in out или out и имя переменной, являющейся фактическим параметром, обозначает неограниченную переменную (см. 3.7.1 и 6.4.1).
Если фактический параметр вызова подпрограммы является подкомпонентой, которая зависит от дискриминантов переменной неограниченного именуемого типа, то выполнение вызова ошибочно, если значение любого дискриминанта переменной изменяется при этом выполнении;
это правило не применяется, если вид параметра in и тип подкомпоненты — скалярный тип или ссылочный тип.
Из правил передачи параметров индексируемого и именуемого типов следует:
Если выполнение подпрограммы прекращено в результате исключения, конечное значение фактического параметра такого типа может быть либо тем же, что и до вызова, либо значением, присвоенным формальному параметру во время выполнения подпрограммы.
Если доступ ко всем фактическим параметрам такого типа осуществляется одним способом, то результат вызова подпрограммы (при отсутствии исключения) не зависит от того, использует ли реализация для передачи параметров копирование.
Если, однако, доступ к фактическому параметру осуществляется несколькими способами
(например, если глобальная переменная или другой формальный параметр ссылается на один и тот же фактический параметр),
то значение формального параметра после изменения фактического способом, отличным от изменения формального, неопределённо.
Программа, использующая такое неопределённое значение, является ошибочной.
Такие же виды параметров определены и для формальных параметров входов (см. 9.5) с тем же смыслом, что и для подпрограмм.
Для формальных параметров настройки определены другие виды параметров (см. 12.1.1).
Для всех видов справедливо, что если фактический параметр указывает задачу, то соответствующий формальный параметр указывает ту же задачу;
то же самое имеет место для подкомпоненты фактического параметра и соответствующей подкомпоненты формального параметра.
Тело подпрограммы определяет её выполнение.
Описание подпрограммы необязательно.
При отсутствии описания спецификация подпрограммы в её теле (или в следе тела) играет роль описания.
Для каждого описания подпрограммы должно быть соответствующее тело
(кроме подпрограмм, написанных на другом языке, как поясняется в разд.
13.9).
Если даны и описание, и тело, то спецификация подпрограммы в теле должна быть согласована со спецификацией подпрограммы в описании (см. разд.
6.3.1 о правилах согласования).
Если в конце тела подпрограммы присутствует обозначение, то оно должно совпадать с обозначением в спецификации подпрограммы.
Предвыполнение тела подпрограммы не имеет никакого другого эффекта, кроме установления факта, что тело может быть использовано для выполнения вызовов подпрограммы.
Выполнение тела подпрограммы инициируется вызовом подпрограммы (см. 6.4).
Для этого после установления соответствия между формальными и фактическими параметрами предвыполняется раздел описаний тела и выполняется последовательность операторов тела подпрограммы.
По окончании выполнения тела осуществляется возврат в место вызова
(и необходимое обратное копирование значений формальных параметров в фактические (см. 6.2)).
Необязательные обработчики исключений, заданные в конце тела подпрограммы, выполняются при возбуждении исключений во время выполнения последовательности операторов тела подпрограммы (см. 11.4).
Из правил видимости следует, что если описанная в пакете подпрограмма обязана быть видимой вне пакета, то спецификация подпрограммы должна быть дана в видимой части пакета.
Эти же правила предписывают, что описание подпрограммы должно быть дано, если вызов подпрограммы возникает текстуально до тела подпрограммы
(описание должно помещаться в тексте программы раньше вызова).
Данные в разд.
3.9 и 7.1 правила подразумевают, что описание подпрограммы и соответствующее тело должны находиться непосредственно в одной и той же зоне описаний.
Пример тела подпрограммы:
Всякий раз, когда правила языка требуют или допускают появления спецификации данной подпрограммы более одного раза, в каждом месте допустимы следующие вариации:
Числовой литерал может быть заменён другим числовым литералом тогда и только тогда, когда они имеют одно и то же значение.
Простое имя может быть заменено расширенным именем, в котором это простое имя является постфиксом тогда и только тогда, когда смысл простого имени в обоих случаях определяется одним и тем же описанием.
Строковый литерал в качестве знака операции может быть заменён на другой строковый литерал тогда и только тогда, когда они представляют одну и ту же операцию (см. 8.5).
Две спецификации подпрограммы называются согласованными, если за исключением комментариев и приведённых выше вариаций, обе спецификации образованы одной и той же последовательностью лексем и соответствующие лексемы имеют одинаковый смысл с точки зрения правил видимости и совмещения.
Аналогичное согласование определяется для разделов формальных параметров, разделов дискриминантов и обозначений типов
(для субконстант и фактических параметров, которые имеют форму преобразования типа (см. 6.4.1)).
Простое имя может быть заменено на расширенное имя, даже если простое имя само является префиксом именуемой компоненты.
Например, Q.R может быть заменено на P.Q.R, если Q описано непосредственно в Р.
Следующие спецификации не согласуются, так как они сформированы различными последовательностями лексем:
Прагма INLINE используется для указания того факта, что для каждого вызова каждого указанного в прагме имени подпрограммы желательна подстановка тела соответствующей подпрограммы.
Форма этой прагмы следующая:
Каждое имя — это либо имя подпрограммы, либо имя настраиваемой подпрограммы.
Прагма INLINE допустима только на месте элемента описания в разделе описаний или спецификации пакета либо после библиотечного модуля в компиляции, но до любого следующего компилируемого модуля.
Если прагма стоит на месте элемента описания, то каждое имя должно обозначать подпрограмму или настраиваемую подпрограмму, описанную раньше в виде элемента описания этого же раздела описаний или этой же спецификации пакета.
Если несколько совмещённых подпрограмм удовлетворяют этому требованию, то прагма применяется ко всем.
Если эта прагма стоит после данного библиотечного модуля, то в качестве её аргумента допустимо только имя этого модуля.
Если в прагме упомянуто имя настраиваемой подпрограммы, это указывает, что подстановка желательна для вызовов всех подпрограмм, являющихся конкретизацией именованного настраиваемого модуля.
Смысл подпрограммы не изменяется прагмой INLINE.
Для каждого вызова заданных в прагме подпрограмм реализация может выполнять или игнорировать рекомендации прагмы.
(Заметим, в частности, что подстановка не может быть выполнена для рекурсивных подпрограмм.)
Вызов подпрограммы — это либо оператор вызова процедуры, либо вызов функции;
он вызывает выполнение соответствующего тела подпрограммы.
Вызов определяет связь фактических параметров, если они есть, с формальными параметрами подпрограммы.
Каждое сопоставление параметров связывает фактический параметр с соответствующим формальным параметром.
Сопоставление параметров называется именованным, если формальный параметр указан явно, в противном случае оно называется позиционным.
Для позиционного сопоставления фактический параметр соответствует формальному параметру в той же позиции раздела формальных параметров.
Именованные сопоставления могут быть даны в любом порядке, но если в одном и том же вызове использованы позиционные и именованные сопоставления, то позиционные сопоставления должны стоять первыми, на своих местах.
Следовательно, после именованного сопоставления все остальные должны быть только именованными сопоставлениями.
Для каждого формального параметра подпрограммы вызов подпрограммы должен задавать точно один соответствующий фактический параметр.
Этот фактический параметр определяется либо явно сопоставлением параметра, либо в отсутствие такого сопоставления выражением по умолчанию (см. 6.4.2).
Сопоставления параметров вызова подпрограммы вычисляются в некотором порядке, не определённом в языке.
Аналогично правила языка не определяют, в каком порядке значения параметров вида in out или out копируются обратно в соответствующих фактических параметрах (если это делается).
Примеры вызовов процедур:
Примеры вызовов функций:
Тип каждого фактического параметра должен совпадать с типом соответствующего формального параметра.
Фактический параметр, сопоставляемый с формальным параметром вида in, должен быть выражением;
оно вычисляется до вызова.
Фактический параметр, сопоставляемый с формальным параметром вида in out или out, должен быть либо именем переменной, либо иметь форму преобразования типа с аргументом, являющимся именем переменной.
В любом случае для параметра вида in out переменная не должна быть формальным параметром вида out или подкомпонентой такого параметра.
Для фактического параметра, который имеет форму преобразования типа, обозначение типа должно быть согласовано (см. 6.3.1) с обозначением типа формального параметра;
допустимый операнд и целевой тип такие же, как и для преобразования типа (см. 4.6).
Данное для фактического параметра вида in out или out имя переменной вычисляется до вызова.
Если фактический параметр имеет форму преобразования типа, то перед вызовом для параметра вида in out переменная преобразуется к заданному типу;
после (нормального) окончания тела подпрограммы формальные параметры вида in out или out преобразуются обратно в тип переменной.
(Тип преобразования должен быть тем же, что и у формального параметра.)
Для параметров скалярного и ссылочного типов проверяются следующие ограничения:
Перед вызовом для параметра вида in или in out проверяется принадлежность фактического параметра подтипу формального параметра.
После (нормального) окончания тела подпрограммы для параметра вида in out или out проверяется принадлежность значения формального параметра подтипу фактического параметра.
В случае преобразования типа значение формального параметра преобразуется обратно и проверяется результат преобразования.
В каждом из вышеуказанных случаев выполнение программы ошибочно, если проверяемое значение неопределено.
Для параметров других типов всех видов проверка осуществляется до вызова, как для скалярных и ссылочных типов;
после возврата никаких проверок не делается.
Если результат хотя бы одной проверки отрицателен, то при вызове подпрограммы возбуждается исключение CONSTRAINT_ERROR.
Если обозначение типа формального параметра задаёт ограниченный подтип, то для индексируемых типов и типов с дискриминантами достаточно проверки перед вызовом (проверка после возврата была бы избыточной), так как ни границы массива, ни дискриминанты не могут быть изменены.
Если это обозначение типа задаёт неограниченный индексируемый тип, то формальный параметр ограничен границами соответствующего фактического параметра и никакой проверки не требуется (ни до вызова, ни после возврата, см. 3.6.1).
Аналогично не требуется никакой проверки, если обозначение типа обозначает неограниченный тип с дискриминантами, так как формальный параметр ограничен точно так же, как соответствующий фактический параметр (см. 3.7.1).
Если спецификация параметра включает выражение по умолчанию для параметра вида in, то соответствующие вызовы подпрограммы не обязательно содержат сопоставления для такого параметра.
Если в вызове сопоставление для таких параметров опускается, то оставшаяся часть вызова, следующая за начальными позиционными сопоставлениями, должна использовать только именованные сопоставления.
Для любого опущенного сопоставления параметров выражение по умолчанию вычисляется до вызова, а значение результата используется как неявный фактический параметр.
Примеры процедур со значениями по умолчанию:
Примеры их вызовов:
Если выражение по умолчанию используется для двух или более параметров в групповой спецификации параметров, то это выражение по умолчанию вычисляется один раз для каждого опущенного параметра.
Поэтому в примере два вызова процедуры PAIR эквивалентны.
Функция — это подпрограмма, которая возвращает значение (результат вызова функции).
Спецификация функции начинается с зарезервированного слова function, а параметры, если они есть, должны иметь вид in
(указанный явно или неявно).
Операторы тела функции (исключая операторы программных модулей, вложенных в тело функции) должны содержать один или несколько операторов возврата, -определяющих возвращаемое значение.
Исключение PROGRAM - ERROR возбуждается, если выход из тела функции осуществляется не через оператор возврата.
Это исключение не возбуждается, если выполнение функции прекращается в результате исключения.
Два раздела формальных параметров называются имеющими одинаковый профиль типа параметров тогда и только тогда, когда они имеют одинаковое число параметров, а в каждой позиции соответствующие параметры имеют один и тот же базовый тип.
Подпрограмма или вход имеет одинаковый профиль типа параметров и результата с другой подпрограммой или входом тогда и только тогда, когда оба имеют одинаковый профиль типа параметров, и либо оба являются функциями с одним и тем же базовым типом результата, либо оба функциями не являются.
Один и тот же идентификатор подпрограммы или знак операции может быть использован для нескольких спецификаций подпрограмм.
В этом случае идентификатор или знак операции называется совмещённым;
подпрограммы, которые имеют этот идентификатор или знак операции, тоже называются совмещёнными и, следовательно, могут совмещаться друг с другом.
Как поясняется в разд.
8.3, если две подпрограммы совмещаются друг с другом, то одна из них может скрыть другую, только если обе подпрограммы имеют одинаковый профиль типа параметров и результата
(см. 8.3, где описаны другие требования, необходимые для скрытия).
Вызов совмещённой подпрограммы неоднозначен (и поэтому неправилен), если её имя, число сопоставлений параметров, типы и порядок фактических параметров, имена формальных параметров (при использовании именованных сопоставлений параметров) и тип результата (для функций) не позволяют идентифицировать единственную (совмещённую) спецификацию подпрограммы.
Примеры совмещённых подпрограмм:
Примеры вызовов:
Понятие профиля типа параметров и результата не учитывает имён параметров, их видов и подтипов, а также присутствия или отсутствия выражений по умолчанию.
Неоднозначности могут (но не обязательно) также возникнуть, когда фактические параметры вызова совмещённой подпрограммы сами являются вызовами совмещённой функции, совмещёнными литералами или агрегатами.
Неоднозначности могут (но не обязательно) также возникнуть, когда видимы несколько совмещённых подпрограмм, принадлежащих различным пакетам.
Этих неоднозначностей можно избежать несколькими способами: использовать квалифицированные выражения для некоторых или для всех фактических параметров и результата, если он есть;
имя такой подпрограммы можно задавать более точно расширенным именем;
наконец, такая подпрограмма может быть переименована.
Описание функции, обозначение которой является знаком операции, используется для совмещения операций.
Последовательность символов в знаке операции должна быть обозначением операции: логической, отношения, бинарной аддитивной, унарной аддитивной, мультипликативной или высшего приоритета (см. 4.5).
В качестве обозначения функции не допускаются никакие проверки вхождения, ни формы управления с промежуточной проверкой.
Спецификация подпрограммы унарной операции должна иметь один-единственный параметр.
Спецификация подпрограммы бинарной операции должна иметь два параметра;
при каждом использовании этой операции левый операнд берётся в качестве первого фактического параметра, правый операнд — в качестве второго параметра.
Аналогично, конкретизация настройки функции, которая обозначена знаком операции, допускается, только если спецификация настраиваемой функции имеет соответствующее число параметров.
Выражения по умолчанию для параметров операции недопустимы
(описана ли операция явно спецификацией подпрограммы или конкретизацией настройки).
Операции + и - допускают как унарную, так и бинарную совмещённую операцию.
Явное описание функции, которая совмещает операцию =, отличное от описания переименования, допустимо, только если оба параметра являются параметрами одного и того же лимитируемого типа.
Совмещение равенства должно давать результат предопределённого типа BOOLEAN;
операция неравенства /=, дающая результат, дополнительный к результату операции равенства, совмещается неявно при задании операции равенства.
Явное совмещение операции неравенства недопустимо.
Описание переименования, обозначение которого — операция равенства, допустимо только для переименования другой операции равенства.
(Например, такое описание переименования может быть использовано, когда равенство видимо по имени, но не непосредственно.)
Совмещение операций отношения не нарушает соотношений, таких как проверка вхождения в диапазон или выборы в операторе выбора.
Пакеты — это одна из четырёх форм программных модулей, из которых составляются программы.
Другие формы — это подпрограммы, задачные модули и настраиваемые модули.
Пакеты допускают спецификацию групп логически связанных понятий.
Простейшие формы пакета специфицируют совокупность общих объектов и описаний типов.
Вообще пакеты могут использоваться для спецификации групп взаимосвязанных понятий, включающих также подпрограммы, которые могут быть вызваны извне пакета, тогда как действие внутри пакета остаётся скрытым и защищённым от внешних пользователей.
Пакет обычно представлен двумя частями: спецификацией пакета и телом пакета.
Спецификация имеется у каждого пакета, а тело имеют не все пакеты.
Простое имя в начале тела пакета должно совпадать с идентификатором этого пакета.
Аналогично если простое имя помещено в конце спецификации или тела пакета, то оно должно совпадать с идентификатором этого пакета.
Если описание подпрограммы, описание пакета, описание задачи или описание настройки являются элементами описания в спецификации пакета, то тело (если оно существует) программного модуля, описанного этим элементом описания, само должно быть элементом описания в разделе описаний тела того же самого пакета.
Для простой формы пакета, специфицирующей совокупность объектов и типов, тело не обязательно.
Одной из возможностей использования последовательности операторов тела пакета является инициализация таких объектов.
Для каждого описания подпрограммы должно существовать соответствующее тело
(за исключением подпрограмм, написанных на другом языке, см. 13.9).
Если тело программного модуля является следом тела, то для этого программного модуля требуется раздельно компилируемый субмодуль, содержащий соответствующее тело (см. 10.2).
Тело не является основным элементом описания и, таким образом, не может присутствовать в спецификации пакета.
Описание пакета — это либо библиотечный пакет (см. 10.2), либо элемент описания внутри другого программного модуля.
Первый список элементов описания в спецификации пакета называется видимым разделом пакета.
Необязательный список элементов описания после зарезервированного слова private называется личным разделом пакета.
Понятие, описанное в личном разделе пакета, невидимо вне з^ого пакета
(имя, обозначающее такое понятие, доступно только в пакете).
В противоположность этому расширенные имена, обозначающие описанные в видимом разделе понятия, могут быть использованы даже вне этого пакета;
прямую видимость этих понятий можно получить также с помощью спецификатора использования (см. 4.1.3 и 8.4).
Предвыполнение описания пакета состоит в предвыполнении его основных элементов описания в порядке их следования.
Видимый раздел пакета содержит всю информацию, доступную для другого программного модуля.
Пакет, состоящий только из спецификации пакета (т.е. без тела пакета), может быть использован для представления группы общих констант или переменных или общей совокупности объектов и типов, как показано ниже в примерах.
Пример пакета, описывающего группу общих переменных:
Пример пакета, описывающего общую совокупность объектов и типов:
В отличие от понятий, описанных в видимом разделе спецификации пакета, понятия, описанные в теле пакета, видимы только внутри самого тела пакета.
Поэтому пакет с телом пакета может быть использован для создания группы взаимосвязанных подпрограмм (пакет прикладных программ в обычном смысле), в которой доступные пользователям операции явно изолированы от внутренних понятий.
При предвыполнении тела пакета сначала предвыполняется его раздел описаний, а затем выполняется его последовательность операторов (если она имеется).
Необязательно присутствующие в конце тела пакета обработчики исключений обслуживают исключения, возбуждаемые при выполнении последовательности операторов тела пакета.
Переменная, описанная в теле пакета, видима только внутри этого тела, и, следовательно, её значение может быть изменено только внутри этого тела пакета.
В отсутствие локальных задач значение такой переменной сохраняется неизменным между вызовами извне пакета подпрограмм, описанных в его видимом разделе.
Свойства такой переменной аналогичны свойствам «собственной» переменной в языке Алгол-60.
Предвыполнение тела подпрограммы, описанной в видимом разделе пакета, осуществляется при предвыполнении тела пакета.
Следовательно, при вызове такой подпрограммы извне программного модуля возбуждается исключение PROGRAM_ERROR, если вызов производится до предвыполнения тела пакета (см. 3.9).
Пример пакета:
Описание типа в качестве личного (приватного) в видимом разделе пакета служит для отделения характеристик, которые могут быть использованы непосредственно внешними программными модулями (логические свойства), от других характеристик, непосредственное использование которых возможно только внутри пакета (детали определения самого типа).
Описания субконстант задают константы личных типов.
Описание личного типа допустимо только в качестве элемента описания в видимом разделе пакета или в качестве описания параметра настройки для типа в разделе формальных параметров настройки.
Обозначение типа в описании субконстанты должно обозначать личный тип или подтип личного типа.
Описание субконстанты и описание соответствующего личного типа должны быть оба элементами описаний в видимом разделе одного и того же пакета.
Описание субконстант с несколькими идентификаторами эквивалентно последовательности описаний субконстант с одним идентификатором, как объяснено в разд.
3.2.
Примеры описаний личного типа:
Пример описания субконстанты:
Если описание личного типа даётся в видимом разделе пакета, то соответствующее описание типа с тем же самым идентификатором должно присутствовать в качестве элемента описания в личном разделе пакета.
Соответствующее описание должно быть либо полным описанием типа, либо описанием задачного типа.
В оставшейся части этого раздела объяснения даются для полных описаний типов.
Те же правила применяются к описаниям задачных типов.
Описание личного типа и соответствующее полное описание типа определяют один тип.
Описание личного типа вместе с видимым разделом определяет операции, которые могут использовать внешние программные модули (см. 7.4.2).
С другой стороны, полное описание типа определяет другие операции, непосредственное использование которых возможно только внутри самого пакета.
Если описание личного типа включает раздел дискриминантов, то полное описание типа должно включать раздел дискриминантов по правилам согласования (см. 6.3.1) и определением типа должно быть определение именуемого типа.
И наоборот, если описание личного типа не включает раздела дискриминантов, то тип, описанный с помощью полного описания типа (полный тип), не должен быть неограниченным типом с дискриминантами.
Полный тип не должен быть неограниченным индексируемым типом.
Лимитируемый тип (в частности, задачный тип) допускается в качестве полного типа, только если в описании личного типа присутствует зарезервированное слово limited (см. 7.4.4).
Внутри спецификации пакета, в которой описан личный тип, и до конца соответствующего полного описания типа ограничено использование имени этого личного типа или его подтипа, а также использование имени любого типа или подтипа с подкомпонентой данного личного типа.
Использование такого имени допускается только в описании субконстанты, описании типа или подтипа, спецификации подпрограммы или описания входа;
более того, не допускается использование этого имени в определениях производного типа или в простых выражениях.
При предвыполнении описания личного типа создаётся личный тип.
Если описание личного типа имеет раздел дискриминантов, то он также предвыполняется.
Предвыполнение полного описания типа заключается в предвыполнении определения типа;
если имеется раздел дискриминантов, то он не предвыполняется
(так как уже предвыполнен согласованный раздел дискриминантов в описании личного типа).
Из перечисленных правил следует, что ни описание переменной личного типа, ни создание объекта личного типа с помощью генератора недопустимо до полного описания типа.
Точно также до полного описания нельзя использовать имя личного типа в конкретизации настройки или в спецификаторе представления.
Операции, которые неявно описаны введением описания личного типа, включают базовые операции.
Это такие операции, как присваивание (кроме лимитируемого типа), проверка принадлежности, именование компоненты для какого-либо дискриминанта, квалификация и явное преобразование типа.
Для личного типа Т в базовые операции также входят атрибуты Т'BASE (см. 3.3.3) и T'SIZE (см. 13.7.2).
Для объекта А личного типа в базовые операции включается атрибут A'CONSTRAINED, если личный тип содержит дискриминант (см. 3.7.4), и во всех случаях — атрибуты A'SIZE и A'ADDRESS (см. 13.7.2).
Наконец, операции, неявно описанные описанием личного типа, включают предопределённые отношения равенства и неравенства (кроме личных типов, в описании которых присутствует зарезервированное слово limited).
Рассмотренные выше операции вместе с подпрограммами, которые имеют параметр или результат личного типа и описаны в видимом разделе пакета, являются единственными операциями над личным типом, используемыми вне пакета.
Внутри пакета, содержащего описание личного типа, дополнительные операции вводятся неявно полным описанием типа.
При этом переопределение этих операций допустимо внутри той же самой зоны описаний, а именно между описанием личного типа и соответствующим полным описанием.
Явно описанная подпрограмма скрывает неявно описанную операцию, которая имеет тот же самый профиль типа параметров и результата
(это возможно, только если неявно описанной операцией является производная подпрограмма или предопределённая операция).
Если составной тип имеет подкомпоненту личного типа и описан вне пакета, содержащего описание личного типа, то неявно описанные при описании составного типа операции включают все операции, зависящие только от характеристик, вытекающих из одного описания личного типа.
(Например, операция < не включается в набор операций для одномерного индексируемого типа.)
Если составной тип сам описан внутри пакета, содержащего описание личного типа (включая внутренний пакет или настраиваемый пакет), то неявно описываются дополнительные операции, которые зависят от характеристик полного типа, как этого требуют правила использования составного типа
(например, операция < описана для одномерного индексируемого типа, если полный тип является дискретным).
Эти дополнительные операции считаются неявно описанными в самом начале непосредственной области действия составного типа, их использование разрешено только после полного описания типа.
Те же правила относятся к неявно описанным для ссылочного типа операциям, чьё обозначение типа есть личный тип или тип, описанный посредством неполного описания типа.
Для каждого личного типа или подтипа Т определён следующий атрибут:
Вырабатывает значение FALSE, если Т обозначает неограниченный неформальный личный тип с дискриминантами, не являющийся формальным параметром настройки;
вырабатывает также значения FALSE, если Т обозначает личный тип, являющийся формальным параметром настройки, а соответствующий подтип фактического параметра является либо неограниченным типом с дискриминантом, либо неограниченным индексируемым типом;
в остальных случаях вырабатывает значение TRUE.
Значение атрибута имеет предопределённый тип BOOLEAN.
Описание личного типа и соответствующее полное описание типа определяют два разных аспекта одного и того же типа.
Вне пакета тип обладает теми характеристиками которые определены в видимой части.
Для внешних программных модулей тип является именно личным типом, и любое правило языка, которое применяется только к другому классу типов к этому типу неприменимо.
Тот факт, что полное описание может реализовать личный тип в виде типа конкретного класса (например, в виде индексируемого типа), можно использовать только внутри пакета.
Последствия такой фактической реализации сказываются тем не менее везде.
Например, производится некоторая инициализация компонент по умолчанию;
атрибут SIZE вырабатывает размер полного типа;
правила зависимости задач распространяются также на компоненты — объекты задачного типа.
Примечание к примеру:
Операциями, применимыми к объектам типа KEY вне пакета KEY MANAGER являются: присваивание, сравнение на равенство и неравенство, процедура GET_KEY и операция "<";
сюда не включаются другие операции отношения, например >= или арифметические операции.
Явно описанная операция " <" скрывает предопределённую операцию < , неявно описанную полным описанием типа.
В теле функции необходимо явное преобразование Х и Y к типу INTEGER для явного вызова операции "<" над этим типом.
С другой стороны результат функции мог бы быть записан в виде not(X > = Y), так как операция " > = не переопределена.
Значение переменной LAST_KEY, описанной в теле пакета, не меняется между вызовами процедуры GET_KEY.
(см. также примечание к разд.
7.3).
Если описание субконстанты даётся в видимом разделе пакета, то описание константы (т.е. описание объекта, задающее константу с явной инициализацией) с тем же самым идентификатором должно быть элементом описания личного раздела этого пакета.
Такое описание объекта называется полным описанием субконстанты.
Заданное в полном описании обозначение типа должно быть согласовано с обозначением типа, заданным в описании субконстанты (см. 6.3.1).
Допускаются групповые и единичные полные описания и описания субконстант при условии, что эквивалентные единичные описания согласованы.
В спецификации пакета, содержащей описание субконстанты, и до конца соответствующего полного описания имя субконстанты допускается использовать только в выражении по умолчанию для именуемой компоненты или формального параметра (но не формального параметра настройки).
Предвыполнение описания субконстанты не даёт другого эффекта.
Выполнение программы ошибочно, если оно пытается использовать значение субконстанты до предвыполнения соответствующего полного описания.
Полное описание субконстанты заданного личного типа не должно встречаться до соответствующего полного описания типа.
Это является следствием правил, определяющих допустимые использования имени, обозначающего личный тип (см. 7.4.1).
Лимитируемый тип — это тип, для которого неявным описанием не вводится ни присваивание, ни сравнение на равенство и неравенство.
Описание личного типа с зарезервированным словом limited описывает лимитируемый тип.
Задачный тип является лимитируемым типом.
Производный тип от лимитируемого типа сам является лимитируемым типом.
Наконец, составной тип является лимитируемым, если тип одной из его компонент является лимитируемым.
Над личным лимитируемым типом определены операции, которые даны в разд.
7.4.2, за исключением присваивания и предопределённого сравнения на равенство и неравенство.
Вид out допустим для формального параметра лимитируемого типа, описанного явно, только в том случае, если этот тип является личным лимитируемым типом, а описание подпрограммы находится в видимом разделе пакета, где описан и личный тип.
То же самое относится к формальным параметрам описаний входов и описаний настраиваемых процедур.
Соответствующий полный тип не должен быть лимитируемым, если любой такой формальный параметр имеет вид out.
В противном случае в качестве соответствующего полного типа допускается (но не требуется) лимитируемый тип
(в частности, допустим задачный тип).
Если полный тип, соответствующий лимитируемому личному типу, сам не является лимитируемым, то для этого типа в пакете (но не вне его) допустимо присваивание.
Из правил для лимитируемых типов вытекает следующее:
Если тип объекта является лимитируемым, то в описании этого объекта явная инициализация недопустима.
Если тип именуемой компоненты является лимитируемым, то выражение по умолчанию в описании компоненты недопустимо.
Если тип объекта, указанного ссылочным типом, является лимитируемым, то в генераторе явная инициализация недопустима.
Формальный параметр настройки вида in не должен быть лимитируемого типа.
Описанные выше правила не исключают выражение по умолчанию для формального параметра лимитируемого типа;
они не исключают также субконстанту лимитируемого типа, если полный тип не является лимитируемым.
Для лимитируемого типа допускается явное описание операции равенства (см. 6.7).
Для лимитируемого составного типа не разрешаются агрегаты (см. 3.6.2 и 3.7.4).
Для лимитируемого индексируемого типа не разрешается катенация (см. 3.6.2).
Примечание к примеру.
В приведённом примере для внешних подпрограмм, использующих I_О_PACKAGE, имя файла можно получить в результате вызова процедуры OPEN, а затем использовать его в вызовах процедур READ и WRITE.
Следовательно, вне пакета имя файла, полученное после вызова процедуры OPEN, выполняет функцию пароля;
его внутренние свойства (например, содержать числовое значение) неизвестны, и никакие другие операции (такие как сложение или сравнение внутренних имён) над этим именем не могут выполняться.
Этот пример характерен для тех случаев, когда желателен полный контроль над операциями.
Такие пакеты служат двум целям.
Они препятствуют пользователю в использовании внутренней структуры типа.
Также реализуют понятие упрятывания (скрытия) типов данных, для которых определены только заданные в спецификации пакета операции.
Следующий пример иллюстрирует использование пакетов для организации простого взаимодействия пользователя с довольно сложными процедурами.
Необходимо создать пакет для работы с таблицами по внесению и извлечению их элементов.
Элементы включаются в таблицу по мере их поступления.
Каждый поступивший элемент имеет порядковый номер.
Элементы выбираются в соответствии с их порядковыми номерами, причём первым выбирается элемент с наименьшим порядковым номером.
С точки зрения пользователя, пакет чрезвычайно прост.
Существует тип с именем ITEM — тип элемента таблицы, есть процедура INSERT для включения элементов в таблицу и процедура RETRIEVE для извлечения элемента с наименьшим порядковым номером.
Если таблица пуста, то возвращается специальный элемент NULL_ITEM, а если таблица заполнена, то при вызове процедуры INSERT возбуждается исключение TABLE_FULL.
Ниже приведена схема такого пакета.
Пользователю известна только спецификация пакета.
Детали реализации таких пакетов могут быть достаточно сложными;
в данном случае используются двусвязные списки внутренних элементов.
Локальная вспомогательная процедура EXCHANGE используется для перемещения внутренних элементов из списка занятых в список свободных.
Начальные связи таблицы устанавливаются в разделе инициализации.
Нет необходимости показывать пользователям тело пакета.
Этот пример иллюстрирует простой пакет обработки текстов.
Пользователи имеют доступ только к видимому разделу;
реализация от них скрыта в личном разделе и теле пакета (тело не показано).
С точки зрения пользователя, TEXT является строкой переменной длины.
Каждый текстовый объект имеет максимальную длину, которая должна задаваться при описании этого объекта, и текущую длину, которая равна длине в диапазоне от нуля до максимального.
Максимальная возможная длина текстового объекта является константой, определяемой реализацией.
Сначала в пакете определяются необходимые типы, затем функции, возвращающие некоторые характеристики объектов типа, затем функции преобразования текстов и предопределённых типов CHARACTER и STRING и, наконец, некоторые стандартные операции над переменными строками.
Большинство операций над строками, символами, а также над типом TEXT совмещены для минимизации числа явных преобразований, которые должен написать пользователь.
Пример использования пакета обработки текста:
Программа открывает файл вывода, имя которого даётся строкой NAME.
Эта строка имеет вид
Для устройства, имени файла и расширения существуют стандартные значения по умолчанию.
Названное пользователем имя передаётся через параметр функции EXPAND_FILE_NAME, её результатом является расширенная версия с необходимыми добавлениями по умолчанию.
В этой главе описаны правила, определяющие область действия описания, и правила, определяющие видимость идентификаторов в различных точках текста программы.
Формулировка правил видимости использует понятие зоны описания.
Зона описания является частью текста программы.
Единичная зона описания — это:
Описание подпрограммы, описание пакета, описание задачи или описание настройки с соответствующим телом (если оно есть).
Если это тело — след тела, то зона описания включает также соответствующий субмодуль.
Если программный модуль содержит субмодули, то они также включаются в зону описания.
Описание входа с соответствующими операторами принятия.
Описание именуемого типа с соответствующими описанием личного типа или неполным описанием типа (если они есть) и спецификатором представления записи (если он есть).
Описание переименования, содержащее раздел формальных параметров, или описание параметров настройки, включающее либо раздел формальных параметров, либо раздел дискриминантов.
Оператор блока или оператор цикла.
В каждом из перечисленных выше случаев говорят, что зона описания связана с соответствующим описанием или оператором.
Описание находится непосредственно в зоне описания, если она является самой вложенной охватывающей данное описание без учёта зоны описания (если она есть), связанной с самим описанием.
Описание, которое находится непосредственно в зоне описания, является локальным в этой зоне.
Говорят, что описания во внешних (охватывающих) зонах являются глобальным по отношению к внутренней (охватываемой) зоне описания.
Локальные понятия — это те, которые описаны непосредственно локальными описаниями;
глобальные понятия — это те, которые описаны посредством глобальных описаний.
Некоторые из упомянутых выше форм зон описания включают несколько разъединённых разделов
(например, между описанием пакета и его телом могут быть помещены другие элементы описания).
Тем не менее каждая зона описания рассматривается как непрерывная часть текста программы (логически).
Следовательно, если какое-либо правило определяет часть текста, расположенного от некоторой выделенной точки зоны описания до конца зоны, то эта часть является соответствующим подмножеством данной зоны описания
(в неё не включаются, например, промежуточные элементы описания, расположенные между двумя разделами пакета).
Как определено в разд.
3.1, в термин описание включаются основные описания, неявные описания и описания, являющиеся разделом основных описаний, например спецификации дискриминантов и параметров.
Из определения зоны описания следует, что спецификация дискриминанта находится непосредственно в зоне, связанной с охватывающим описанием именуемого типа.
Аналогично спецификация параметра находится непосредственно в зоне, связанной с телом охватывающей подпрограммы или с оператором принятия.
Пакет STANDARD образует зону описания, которая охватывает все библиотечные модули; предполагается, что неявное описание каждого библиотечного модуля находится непосредственно в этом пакете (см. разд.
8.6 и 10.1.1).
Зоны описания могут быть вложены в другие зоны описания.
Например, подпрограммы, пакеты, задачные модули, настраиваемые модули и операторы блока могут быть вложены друг в друга и содержать описания именуемого типа, оператор цикла, а также операторы принятия.
Для каждой формы описания правила языка определяют конкретную часть текста программы, называемую областью действия описания.
Область действия описания также является областью действия описанных в нем понятий.
Более того, если описание сопоставляет некоторое обозначение с описанным понятием, то эта часть текста также называется областью действия этого обозначения
(либо идентификатора, либо символьного литерала, либо знака операции, либо обозначения базовой операции).
В области действия понятия, и только в ней, есть места, в которых будет правильным использовать сопоставленное обозначение для ссылки на описанное понятие.
Эти места определены правилами видимости и совмещения.
Область действия описания, находящегося непосредственно в зоне описания, распространяется от начала описания до конца зоны описания;
этот раздел области действия описания называется непосредственной областью действия.
Более того, для любого из описаний, перечисленных ниже, область действия описания распространяется за пределы непосредственной области действия:
описание, которое находится непосредственно в видимом разделе описания пакета;
описание входа;
описание компоненты;
спецификация дискриминанта;
спецификация параметра;
описание параметра настройки.
В каждом из этих случаев данное описание находится непосредственно в некотором охватывающем описании, а область действия данного описания распространяется до конца области действия охватывающего описания.
При отсутствии описания подпрограммы спецификация подпрограммы, заданная в теле подпрограммы или в следе тела, действует как описание, и в этом случае применимо правило д).
Приведённые правила, определяющие область действия, применяются для всех форм описаний, определённых в разд.
3.1;
они применяются, в частности, и к неявным описаниям.
Правило а) применяется к описанию пакета и тем самым неприменимо к спецификации пакета в описании настройки.
Для вложенных описаний правила от а) до е) применяются на каждом уровне.
Например, если задачный модуль описан в видимом разделе пакета, то область действия входа задачного модуля распространяется до конца области действия этого задачного модуля, т.е. до конца области действия охватывающего пакета.
Область действия спецификатора использования определена в разд.
8.4.
Правила видимости, а в случае совмещённых операций и правила совмещения, трактуют вхождение идентификатора в данной точке текста программы.
Под идентификатором в данной главе подразумевают любой идентификатор, кроме зарезервированных слов, обозначений атрибутов, идентификаторов прагм и аргументов прагм.
Под точкой текста программы в этой главе понимают место вхождения лексемы (например, идентификатора).
Под совмещёнными описаниями — описания подпрограмм, литералов перечисления, одиночных входов.
Для каждого идентификатора и в каждой точке текста программы правила видимости определяют набор описаний (с этим идентификатором), т.е. варианты трактовки идентификатора.
Говорят, что описание видимо в данной точке текста, когда, согласно правилам видимости, оно определяет возможные трактовки его вхождения.
Возникают два случая:
Правила видимости определяют не более одной трактовки идентификатора.
В таком случае правил видимости достаточно для выявления описания, определяющего трактовку вхождения идентификатора, или при отсутствии такого описания для выявления того, что это вхождение в данной точке незаконно, не является правильным.
Правила видимости определяют более чем одну трактовку.
В таком случае вхождение идентификатора является правильным в данной точке, если и только если точно одно видимое описание выбирается правилами совмещения в соответствии с данным контекстом
(см. разд.
6.6 для правил совмещения и разд.
8.7 для контекста, используемого при разрешении совмещения).
Описание видимо только в определённой части своей области действия;
эта часть начинается в конце описания, а в спецификации пакета эта часть начинается с зарезервированного слова is, следующего за идентификатором пакета.
(Это правило применяется, в частности, для неявных описаний.)
Видимость может быть прямой или видимостью по имени.
Описание видимо по имени в точках программы для:
описания, находящегося в видимом разделе описания пакета — на месте постфикса после точки в расширенном имени, префикс которого обозначает пакет;
описания входа конкретного задачного типа — на месте постфикса после точки в именованной компоненте, префикс которой соответствует задачному типу;
описания компоненты конкретного описания именуемого типа — на месте постфикса после точки в именованной компоненте, префикс которой соответствует этому типу, а также на месте простого имени компоненты (перед составным ограничителем =>) в именованном сопоставлении компонент агрегата этого типа;
спецификации дискриминанта конкретного описания типа — в местах, предназначенных для описания компоненты и простого имени дискриминанта (перед составным ограничителем =>) в именованном сопоставлении дискриминанта в ограничении дискриминанта для этого типа;
спецификации параметра данной спецификации подпрограммы или описания входа — на месте формального параметра (перед составным ограничителем =>) в именованном сопоставлении параметра соответствующей подпрограммы или вызова входа;
описания параметра настройки данного настраиваемого модуля — на месте формального параметра настройки (перед составным ограничителем =>) в именованном сопоставлении соответствующей конкретизации настройки.
Наконец, в зоне описания, связанной с конструкцией, не являющейся описанием именуемого типа, любое описание видимо по имени на месте постфикса после точки в расширенном имени, префикс которого обозначает эту конструкцию.
Там, где нет видимости по имени, говорят, что описание видимо непосредственно.
Описание видимо непосредственно в определённом разделе его непосредственной области действия;
этот раздел распространяется до конца непосредственной области действия описания, за исключением тех мест, где это описание скрыто, как поясняется ниже.
Кроме того, описание, находящееся непосредственно в видимом разделе пакета, может быть сделано непосредственно видимым с помощью спецификатора использования по правилам, описанным в разд.
8.4.
(см. также разд.
8.6 о видимости библиотечных модулей).
Описание скрыто во внутренней зоне описания, если она содержит омоним этого описания;
внешнее описание является тогда скрытым в непосредственной области действия этого внутреннего омонима.
Каждое из двух описаний является омонимом другого, если оба описания имеют один и тот же идентификатор и не более чем для одного из них допустимо совмещение.
Если совмещение допустимо для обоих описаний, то каждое из двух является омонимом другого в случае, если они имеют одинаковый идентификатор, символ операции или символьный литерал, а также одинаковый профиль типа параметров и результата (см. 6.6).
В спецификации подпрограммы скрыто каждое описание с таким же обозначением, как у подпрограммы; данное положение справедливо для конкретизации настройки, которая описывает подпрограмму, и в описании входа или в разделе формальных параметров оператора принятия.
В этих случаях описание не является видимым ни по имени, ни непосредственно.
Два описания, которые находятся непосредственно в одной и той же зоне описания, не должны быть омонимами, за исключением тех случаев, когда выполнены одно или оба следующих требования:
а) точно одно из них является неявным описанием предопределённой операции;
б) точно одно из них является неявным описанием производной подпрограммы.
В таких случаях предопределённая операция всегда скрыта другим омонимом;
производная подпрограмма скрывает предопределённую операцию, но скрыта сама любым другим омонимом.
Там, где скрытие осуществляется таким образом, неявное описание скрыто во всей области действия другого описания
(независимо от того, какое описание стоит первым);
неявное описание не видимо ни по имени, ни непосредственно.
Всегда, когда описание с определённым идентификатором видимо в данной точке, говорят, что идентификатор и описанное понятие (если оно есть) видимы в этой точке.
Непосредственная видимость и видимость по имени для символьных литералов и символов операций определяются аналогично.
Операция, обозначенная знаком, непосредственно видима тогда и только тогда, когда описание соответствующей операции непосредственно видимо.
Наконец, обозначения, связанные с базовой операцией, непосредственно видимы во всей области действия этой операции.
Примечание о видимости библиотечных модулей.
Видимость библиотечных модулей определена спецификаторами совместности (см. 10.1.1) и тем фактом, что библиотечные модули неявно описаны в пакете STANDARD (см. 8.6).
Примечание об омонимах.
Один и тот же идентификатор может находиться в различных описаниях и, таким образом, соответствовать различным понятиям, даже если области действия описаний перекрываются.
Перекрытие областей действия описаний с одним и тем же идентификатором может получиться из-за совмещения подпрограмм и литералов перечисления.
Такое перекрытие может произойти для понятий, описанных в видимых разделах пакета, а также входов, компонент записей и параметров, где имеется перекрытие областей действия охватывающих описаний пакета, описаний задачи, описаний именуемого типа, описаний подпрограмм, описаний переименований и описаний настройки.
Наконец, перекрытие областей действия может быть результатом вложенности.
Примечание к непосредственной области действия, скрытию и видимости.
Правила, определяющие непосредственную область действия, скрытия и видимости, предусматривают, что ссылка на идентификатор в его собственном описании является неправильной
(исключая случаи пакетов и настраиваемых пакетов).
Идентификатор скрывает внешние омонимы в собственной непосредственной области действия, т.е. от начала описаний;
с другой стороны, идентификатор является видимым только после конца описания.
По этой причине (кроме последнего) все следующие описания являются неправильными.
Спецификатор использования обеспечивает непосредственную видимость описаний, которые находятся в видимых разделах пакетов с именами, упомянутых в спецификаторе использования.
Для каждого спецификатора использования существует определённая зона текста, называемая областью действия спецификатора использования.
Эта зона начинается непосредственно после спецификатора использования.
Если спецификатор использования является элементом описания некоторой зоны описания, то область действия спецификатора использования распространяется до конца этой зоны описания.
Если спецификатор использования находится в спецификаторе контекста компилируемого модуля, то область действия спецификатора использования распространяется до конца зоны описания, связанной с данным компилируемым модулем.
Чтобы определить, какие описания становятся прямо видимыми в данном месте с помощью спецификатора использования, рассмотрим пакеты, упомянутые в спецификаторах использования, области действия которых охватывают это место.
Описанием, которое может быть сделано прямо видимым с помощью спецификатора использования (потенциально видимое описание), является такое описание, которое находится непосредственно в видимом разделе одного из этих пакетов.
Потенциально видимое описание становится фактически прямо видимым, за исключением двух случаев:
Потенциально видимое описание не становится прямо видимым, если рассматриваемое место программы находится непосредственно в области действия описания омонима.
Потенциально видимые описания с одинаковыми идентификаторами не становятся прямо видимыми, если только каждое из них не является спецификацией литерала перечисления или описанием подпрограммы
(представляющим собой описание подпрограммы, описание переименования, конкретизацию настройки или неявное описание).
Предвыполнение спецификатора использования не имеет другого эффекта.
Приведённые выше правила гарантируют, что описание, которое стало прямо видимым с помощью спецификатора использования, не может скрывать другое прямо видимое описание.
Эти правила сформулированы в терминах набора пакетов, упомянутых в спецификаторах использования.
Следовательно, приведённые ниже строчки текста дают один и тот же эффект (в предположении существования единственного пакета Р).
Пример противоречия имён в двух пакетах:
Пример идентификации имени со спецификатором использования:
Описание переименования задаёт другое имя для понятия.
Предвыполнение описания переименования вычисляет имя, которое следует после зарезервированного слова renames, и таким образом определяет понятие, обозначенное этим именем (переименованное понятие).
В любой точке, где описание переименования видимо, идентификатор или знак операции, заданный в этом описании, обозначает переименованное понятие.
Первая форма описания переименования используется для переименования объектов.
Переименованное понятие должно быть объектом базового типа обозначения типа.
Описание переименования не изменяет свойств переименованного объекта.
В частности, описание переименования не оказывает влияния на значение объекта и на то, является ли он константой или нет;
аналогично переименования не затрагивают ограничения, накладываемые на объект
(любое ограничение, которое следует из обозначения типа, входящего в описание переименования, игнорируется).
Описание переименования правильно только в том случае, если точно один объект имеет этот тип и может быть обозначен этим именем объекта.
Существуют следующие ограничения, связанные с переименованием подкомпоненты переменной, которая зависит от дискриминантов.
Переименование недопустимо, если подтип переменной, как это определено в соответствующем описании объекта, описании компоненты или указании подтипа компоненты, является неограниченным типом или если переменная — это формальный объект настройки (вида in out).
Также если переменная — формальный параметр, то переименование недопустимо, если заданное в спецификации параметра обозначение типа обозначает неограниченный тип, чьи дискриминанты имеют выражения по умолчанию.
Вторая форма описания переименования используется для переименования исключений;
третья форма — для переименования пакетов.
Последняя форма описания переименования используется для переименования подпрограмм и входов.
Переименованная подпрограмма или вход и спецификация подпрограммы, заданная в описании переименования, должны иметь один и тот же профиль типа параметров и результата (см. 6.6).
Описание переименования правильно только в том случае, если точно одна видимая подпрограмма или вход удовлетворяют упомянутым выше требованиям и могут быть обозначены конкретным именем подпрограммы или входа.
Кроме того, виды параметров должны совпадать с видами соответствующих по позиции формальных параметров.
Переименование не оказывает влияния на подтипы параметров и результата (если он есть) переименованной подпрограммы или входа.
Эти подтипы заданы в первоначальном описании подпрограммы, конкретизации настройки или описании входа (но не в описании переименования), а также для вызовов, которые используют новое имя.
С другой стороны, описание переименования может вводить имена параметров и выражения по умолчанию, которые отличаются от заданных для переименованной подпрограммы;
именованные сопоставления в вызовах с новым именем подпрограммы должны использовать новое имя параметра;
вызовы со старым именем подпрограммы должны использовать старые имена параметров.
Процедура может быть переименована только как процедура.
Функция либо операция могут быть переименованы как функция либо как операция;
при переименовании функции или операции операцией спецификация подпрограммы, заданная в описании переименования, подчиняется правилам разд.
6.7 для описаний операции.
Литералы перечисления могут быть переименованы как функции;
аналогично атрибуты, определённые как функции (такие, как SUCC или PRED), могут быть переименованы как функции.
Вход может быть переименован только как процедура;
новое имя допускается только в контексте, допускающем имя процедуры.
Вход из семейства может быть переименован, но семейство входов не может быть переименовано целиком.
Примеры описания переименования с новыми именами параметров:
Пример описания переименования с новым выражением по умолчанию:
Переименование может быть использовано для разрешения конфликта имён и введения сокращений.
Переименование другим идентификатором или символом операции не скрывает старое имя;
новое и старое имена (символ операции) не обязательно видимы в одних и тех же точках.
Атрибуты POS и VAL не могут быть переименованы, так как не могут быть написаны соответствующие спецификации;
это положение справедливо для предопределённых мультипликативных операций с результатом универсального фиксированного типа.
Вызовы переименованного входа с новым именем являются операторами вызова процедуры и недопустимы в местах, где синтаксис требует оператора вызова входа в условном и временном вызовах входа;
аналогично атрибут COUNT нельзя применить к новому имени.
Объект задачного типа, описанный посредством описания объекта, может быть переименован как объект.
Однако одиночная задача не может быть переименована, так как соответствующий задачный тип является анонимным.
По тем же причинам не может быть переименован объект анонимного индексируемого типа.
Не существует синтаксической формы для переименования настраиваемого модуля.
Для достижения эффекта переименования типа (включая задачный тип) может быть использован подтип, например:
Предопределённые типы (например, BOOLEAN, CHARACTER и INTEGER) описаны в предопределённом пакете, называемом STANDARD;
этот пакет включает также описания предопределённых для них операций.
Пакет STANDARD описан в приложении С.
Спецификация пакета STANDARD, за исключением предопределённых числовых типов, должна быть одинаковой для всех реализации языка.
Пакет STANDARD образует зону описания, которая охватывает каждый библиотечный модуль и, следовательно, главную программу;
предполагается, что описание каждого библиотечного модуля находится непосредственно в этом пакете.
Предполагается также, что неявные описания библиотечных модулей упорядочены таким образом, что область действия данного библиотечного модуля включает в себя любой компилируемый модуль, который упоминает в спецификаторе совместности этот библиотечный модуль.
Однако видимыми в данном компилируемом модуле являются библиотечные модули, упомянутые в каких-либо спецификаторах совместности при данном модуле, а если он является вторичным модулем некоторого библиотечного модуля, то и этот модуль является видимым для него.
Если все вложенные операторы блока программы поименованы, то имя каждого программного модуля, вложенного в блок, всегда может быть записано как расширенное имя, начинающееся с идентификатора STANDARD
(в случае когда этот пакет не является скрытым).
Если тип описан в видимом разделе библиотечного пакета, то из правил видимости следует, что базовая операция (например, присваивание) над этим типом непосредственно видима в точке, где сам тип невидим (либо по имени, либо непосредственно).
Однако эта операция может быть применена только к тем операндам, которые являются видимыми, и описание этих операндов требует видимости либо типа, либо одного из его подтипов.
Совмещение определено для программ, литералов перечисления, символов операций и одиночных входов, а также для тех операций, которые присущи обычным базовым операциям, например присваивание, проверка принадлежности, генератор, литерал null, агрегаты и строковые литералы.
Для совмещённых понятий разрешение совмещения определяет фактический смысл, который имеет вхождение идентификатора, когда в соответствии с правилами видимости выясняется, что в месте этого вхождения приемлема более чем одна трактовка идентификатора;
аналогичным образом разрешение совмещения определяет фактическую трактовку вхождения операции или некоторой базовой операции.
В таком месте рассматриваются все видимые описания.
Вхождение правильно только тогда, когда есть точно одна интерпретация самого вложенного полного контекста.
Полный контекст — это описание, оператор, спецификатор представления.
При рассмотрении возможных интерпретаций полного контекста учитываются только те правила, которые касаются синтаксиса, области действия и видимости, а также те, которые даны ниже.
любое правило, которое требует, чтобы имя или выражение имели определённый тип или такой же тип, как другое имя или выражение;
любое правило, которое требует, чтобы тип имени или выражения был типом определённого класса; аналогично любое правило, которое требует, чтобы определённый тип был дискретным, целым, вещественным, универсальным, символьным, логическим или нелимитируемым типом;
любое правило, которое требует, чтобы префикс соответствовал определённому типу;
любое правило, которое задаёт определённый тип в качестве типа результата базовой операции, и любое правило, которое устанавливает, что это тип определённого класса;
правила, которые требуют, чтобы тип агрегата или строкового литерала был определён исключительно охватывающим полным контекстом (см. 4.3 и 4.2).
Аналогично правила, которые требуют, чтобы тип префикса атрибута, тип выражения оператора выбора или тип операнда преобразования типа были определены независимо от контекста (см. 4.1.4, 4.6, 5.4 и 6.4.1);
правила, данные в разд.
6.6 по разрешению вызовов совмещённых подпрограмм, в разд.
4.6 по неявным преобразованиям универсальных выражений, в разд.
3.6.1 по интерпретации дискретных диапазонов с границами, имеющими универсальный тип, в разд.
4.1.3 по интерпретации расширенного имени, чей префикс обозначает подпрограмму или оператор принятия.
Имена подпрограмм, используемые в качестве аргументов прагмы, следуют другому правилу: прагма может применяться для нескольких совмещённых подпрограмм, как пояснено в разд.
6.3.2 для прагмы INLINE, в разд.
11.7 для прагмы SUPPRESS и в разд.
13.9 для прагмы INTERFACE.
Подобно данные в спецификаторах контекста (см. 10.1.1) и спецификаторах адреса простые имена следуют другим правилам.
Если существует только одна возможная интерпретация, то идентификатор обозначает соответствующее понятие.
Однако данное утверждение не означает, что это вхождение обязательно правильно, так как существуют другие требования, которые не учитываются при разрешении совмещения: например, является ли выражение статическим, каковы виды параметров, является ли объект константой, выполняются ли правила согласования, является ли вхождение в спецификатор представления предписывающим, каков порядок предвыполнения и т.п.
Аналогично при разрешении совмещения не учитываются подтипы.
(Нарушение ограничения не делает программу неправильной, но возбуждает исключение во время выполнения программы.)
Спецификация параметра цикла есть описание и, следовательно, полный контекст.
Правила, которые требуют, чтобы определённые конструкции имели один и тот же профиль параметров и типа результата, подпадают под категорию а);
то же справедливо для правил, которые требуют согласования двух конструкций, так как это согласование требует в свою очередь, чтобы соответствующие имена имели одинаковый смысл, определённый правилами видимости и совмещения.
Правила формы (а): выбор 3.7.3, 4.3.2, 5.4, выражение по умолчанию 3.7, 3.7.1, 6.1, 12.1.1, выражение результата 5.8, дискретный диапазон 3.6.1, 5.5, 9.5, индексное выражение 4.1.1, 4.1.2, 9.5, квалифицированное выражение 4.7, начальное значение 3.2.1, ограничение диапазона 3.5, ограничение дискриминанта 3.7.2, ограничение индекса 3.6.1, оператор задержки 9.6, переименование объекта 8.5, правила согласования 9.5, присваивание 5.2, проверка принадлежности 4.5.2, профиль параметров и типа результата 8.5, 12.3.6, сопоставление компонент 4.3.1, 4.3.2, сопоставление параметров настройки 12.3, сопоставление параметров 6.4.1, спецификатор адреса 13.5, спецификатор представления перечислимых 13.3.
Правила формы (б): атрибут VAL 3.5.5, выражение выбора 6.4, дискретный диапазон 3.6.1, 5.5, 9.5, именуемая компонента 4.1.3, оператор прекращения 9.10, описание плавающего типа 3.5.7, описание фиксированного типа 3.5.9, описание целого типа 3.5.4, описание числа 3.2.2, присваивание 5.2, проверка принадлежности 4.4, спецификатор длины 13.2, спецификатор представления записи 13.4, условие 5.3, 5.5, 5.7, 9.7.1, форма управления промежуточной проверкой 4.4.
Правила формы (в): именуемая компонента 4.1.3, индексируемая компонента 4.1.1, отрезок 4.1.2.
Правила формы (г): агрегат 4.3, генератор 4.8, литерал null 4.2, проверка принадлежности 4.4, строковый литерал 4.2, форма управления с промежуточной проверкой 4.4, числовой литерал 2.4.
Выполнение программы без задач определено в терминах последовательного выполнения её действий в соответствии с правилами, сформулированными в других главах данного руководства.
Можно предположить, что эти действия выполняет один логический процессор.
Под параллельным выполнением задач понимают следующее.
Предполагается, что каждую задачу выполняет отдельный логический процессор.
Различные задачи (на различных логических процессорах) выполняются независимо, за исключением точек их синхронизации.
Некоторые задачи могут иметь входы.
Вход задачи может быть вызван другими задачами.
Задача принимает вызов одного из своих входов выполнением оператора принятия этого входа.
Синхронизация достигается посредством рандеву между задачей, вызывающей вход, и задачей, принимающей вызов.
Некоторые входы имеют параметры;
вызовы и операторы принятия таких входов, имеющих параметры, являются основным средством обмена значениями между задачами.
Свойства каждой задачи определяются соответствующим задачным модулем, который состоит из спецификации задачи и тела задачи.
Задачные модули представляют собой одну из четырёх форм программных модулей, из которых может состоять программа.
Другие три формы — это подпрограммы, пакеты и настраиваемые модули.
В данной главе описываются свойства задачных модулей, задач и входов и операторы, влияющие на взаимодействие задач (т.е. операторы вызова входов, принятия, задержки, отбора и прекращения).
Параллельные задачи (параллельные логические процессоры) могут быть реализованы на многомашинных комплексах, многопроцессорных ЭВМ или чередующимся выполнением на одном физическом процессоре.
С другой стороны, если реализация способна определить, что тот же результат получается при параллельном выполнении частей одной задачи на различных физических процессорах, то можно принять и такой способ выполнения;
в этом случае несколько физических процессоров реализуют один логический процессор.
Задачный модуль состоит из спецификации задачи и тела задачи.
Спецификация задачи, которая начинается зарезервированными словами task type, описывает задачный тип.
Значение объекта задачного типа указывает задачу co входами, (если они есть), которые описаны в спецификации задачи;
эти входы также называются входами объекта.
Выполнение задачи определяется соответствующим телом задачи.
Спецификация задачи без зарезервированного слова type определяет одну задачу.
Описание такой задачи эквивалентно описанию анонимного задачного типа одновременно с описанием объекта этого задачного типа, а идентификатор задачного модуля именует объект.
В остальной части данной главы пояснения даются в терминах описаний задачного типа;
соответствующие пояснения для одной задачи следуют из упомянутого отношения эквивалентности.
Простое имя в начале тела задачи должно совпадать с идентификатором задачного модуля.
Аналогично если в конце спецификации или тела задачи появляется простое имя, то оно должно совпадать с идентификатором задачного модуля.
Внутри тела задачи имя соответствующего задачного модуля может быть также использовано для ссылки на объект задачу (указывать на задачу), тело которой выполняется в данный момент;
кроме того, не допускается использование этого имени в качестве обозначения типа внутри собственного задачного модуля.
При предвыполнении спецификации задачи описания входов и спецификаторы представления (если они есть) предвыполняются в том порядке, в котором они даны.
Спецификаторы представления применяются только к входам, описанным в спецификации задачи (см. 13.5).
Предвыполнение тела задачи не имеет никакого другого результата, кроме установления, что тело с этих пор может быть использовано для выполнения задач, указанных объектами соответствующего задачного типа.
Выполнение тела задачи вызывается активизацией задачного объекта соответствующего типа (см. 9.3).
Возможные в конце тела задачи обработчики исключений обрабатывают исключения, возбуждаемые в ходе выполнения последовательности операторов тела задачи (см. 11.4).
Примеры спецификации задачных типов:
Примеры спецификации одной задачи:
Пример спецификации задачи и соответствующего тела:
Спецификация задачи задаёт интерфейс задачам данного типа с другими задачами тех же или различных типов, а также с главной программой.
Задачный тип является лимитируемым типом (см. 7.4.4).
Следовательно, для объектов задачного типа не определены ни присваивание, ни предопределённое сравнение на равенство и неравенство;
более того, вид out недопустим для формального параметра задачного типа.
Задачный объект — это объект задачного типа.
Значение задачного объекта указывает задачу с входами соответствующего задачного типа, а её выполнение определено соответствующим телом задачи.
Если задачный объект является объектом или подкомпонентой объекта, заданными описанием объекта, то его значение определяется предвыполнением описания объекта.
Если задачный объект является объектом или подкомпонентой объекта, созданными при выполнении генератора, то его значение определяется выполнением генератора.
Для всех видов параметров, если фактический параметр указывает задачу, сопоставляемый формальный параметр указывает ту же задачу;
это же относится к подкомпоненте фактического параметра и к соответствующей подкомпоненте сопоставляемого формального параметра;
наконец, то же справедливо и для параметров настройки.
Пример ссылочного типа, указывающего задачный объект:
Поскольку задачный тип является лимитируемым, он может появиться как определение лимитируемого личного типа в личном разделе и как фактический параметр настройки, сопоставляемый формальному параметру лимитируемого типа.
С другой стороны, тип формального параметра настройки вида in не должен быть лимитируемым и, следовательно, не может быть задачным типом.
Задачные объекты ведут себя как константы (задачный объект всегда указывает одну и ту же задачу), поскольку их значения неявно определены при описании либо при генерации, либо при сопоставлении параметров, и никакие присваивания недопустимы.
Однако зарезервированное слово constant недопустимо в описании задачного объекта, так как его наличие требует явной инициализации.
Задачный объект, который является формальным параметром вида in, есть константа (как и любой формальный параметр вида in).
Если алгоритм требует запоминания и переименования задачи, то это можно сделать определением ссылочного типа, указывающего на соответствующие задачные объекты, и использованием ссылочных значений для целей идентификации (см. предыдущий пример).
Присваивание для такого ссылочного типа возможно, как и для любого другого ссылочного типа.
Для задачных типов допустимы описания подтипов, как и для других типов, но никакие ограничения к задачному типу неприменимы.
Тело задачи определяет выполнение всякой задачи, которая указывается задачным объектом соответствующего задачного типа.
Начальный этап этого выполнения называется активизацией задачного объекта и указанной им задачи;
активизация состоит из предвыполнения раздела описаний (если он есть) тела задачи.
Выполнение различных задач, в частности, их активизация, производится параллельно.
Если задачный объект описан непосредственно в разделе описаний, то активизация задачного объекта начинается после предвыполнения раздела описаний
(т.е. после грамматического разбора зарезервированного слова begin, следующего за разделом описаний);
аналогично если такое описание помещено непосредственно в спецификацию пакета, то активизация начинается после предвыполнения раздела описаний тела пакета.
То же относится и к активизации задачного объекта, являющегося подкомпонентой объекта, описанной непосредственно в разделе описаний или спецификации пакета.
Первый оператор, следующий за разделом описаний, выполняется только после окончания активизации задачных объектов.
Если при активизации одной из таких задач возбуждается исключение, то эта задача становится законченной (см. 9.4);
на других задачах это прямо не отражается.
Если во время активизации одна из этих задач становится законченной, то после завершения активизации (успешного или нет) всех задач возбуждается исключение TASKING_ERROR;
исключение возбуждается непосредственно за разделом описаний перед выполнением первого оператора
(непосредственно после зарезервированного слова begin).
Исключение TASKING_ERROR возбуждается лишь однажды, даже если во время активизации сразу несколько задач становятся законченными таким способом.
Если исключение возбуждается при предвыполнении раздела описаний или спецификации пакета, то любая созданная (прямо или косвенно) этим предвыполнением задача, которая ещё не активизирована, становится завершённой и, таким образом, она никогда не активизируется
(см. разд.
9.4 с определением завершённой задачи).
Приведённые выше правила предполагают, что в теле пакета без операторов присутствует пустой оператор.
Для пакета без тела подразумевается тело пакета с единственным пустым оператором.
Если пакет без тела описывается непосредственно в некотором программном модуле или в операторе блока, то его тело подразумевается в конце раздела описаний программного модуля или оператора блока;
при наличии нескольких пакетов без тела порядок следования подразумеваемых тел пакетов не определён.
Задачный, объект, являющийся объектом или подкомпонентой объекта, созданного выполнением генератора, активизируется этим выполнением.
Активизация начинается после инициализации объекта, созданного генератором;
если несколько подкомпонент являются задачными объектами, они активизируются параллельно.
Ссылочное значение, указывающее этот объект, возвращается генератором только после проведения этих активизации.
Если исключение возбуждается при активизации одной из таких задач, то она становится законченной задачей;
на другие задачи этот факт не оказывает прямого воздействия.
Если во время своей активизации одна из задач становится законченной, то после проведения активизации (успешной или нет) всех этих задач возбуждается исключение TASKING_ERROR;
исключение возбуждается в той точке текста программы, где выполняется генератор.
Исключение TASKING_ERROR возбуждается лишь однажды, даже если во время активизации сразу несколько задач становятся законченными таким образом.
Если исключение возбуждается во время инициализации объекта, созданного генератором (следовательно, до начала активизации), то любая задача, указанная подкомпонентой этого объекта, становится завершённой, и, таким образом, она никогда не активизируется.
Вход задачи может быть вызван до активизации задачи.
Если несколько задач активизируются параллельно, выполнение любой из них не предполагает ожидания конца активизации других задач.
Задача может стать законченной во время её активизации как из-за исключения, так и из-за прекращения (см. 9.10).
Каждая задача зависит по крайней мере от одного родителя.
Родитель — это конструкция, являющаяся либо задачей, либо в данный момент выполняемым оператором блока или подпрограммой, либо библиотечным пакетом
(но не описанным в другом программном модуле).
Зависимость от родителя является непосредственной зависимостью в следующих двух случаях:
Задача, указанная задачным объектом, который является объектом или подкомпонентой объекта, созданными при выполнении генератора, зависит от родителя, предвыполняющего соответствующее описание ссылочного типа.
Задача, указанная другим задачным объектом, зависит от родителя, выполнение которого создаёт задачный объект.
Более того, если задача зависит от данного родителя, являющегося оператором блока, выполняемым другим родителем, то задача также косвенно зависит и от этого родителя;
тоже справедливо, если данный родитель является подпрограммой, вызванной другим родителем, а также если данный родитель — задача (прямо или косвенно), зависящая от другого родителя.
Зависимости существуют и для объектов личного типа, полное описание которого задано в терминах задачного типа.
Говорят, что задача закончила своё выполнение, когда осуществилось выполнение последовательности операторов, помещённых в её теле за зарезервированным словом begin.
Аналогично говорят, что блок или подпрограмма закончили своё выполнение, когда осуществилось выполнение соответствующей последовательности операторов.
В случае оператора блока также говорят, что выполнение его закончилось при достижении операторов выхода, возврата или перехода, передающих управление из блока.
В случае процедуры также говорят, что её выполнение закончилось при достижении соответствующего оператора возврата.
В случае функции также говорят, что её выполнение закончилось после вычисления результирующего выражения в операторе возврата.
Наконец, выполнение задачи, оператора блока или подпрограммы закончено, если при выполнении содержащихся в них соответствующих последовательностей операторов возбуждено исключение и нет соответствующего ему обработчика, а при его наличии — по окончании выполнения соответствующего обработчика.
Если у задачи нет зависимых задач и закончено её выполнение, имеет место её завершение.
После завершения задачи говорят, что она завершена.
Если задача имеет зависимые задачи, то её завершение имеет место после окончания выполнения задачи и завершения всех зависимых задач.
Из оператора блока или тела подпрограммы, чьё выполнение закончено, нельзя выйти до завершения всех зависимых задач.
С другой стороны, завершение задачи имеет место тогда и только тогда, когда её выполнение достигло открытой альтернативы завершения в операторе отбора (см. 9.7.1) и удовлетворены следующие условия:
Задача зависит от некоторого родителя, выполнение которого закончено (следовательно, не от библиотечного пакета).
Каждая задача, зависящая от рассмотренного родителя, либо уже завершена, либо также ожидает открытой альтернативы завершения в операторе отбора.
Когда оба условия удовлетворены, задача становится завершённой вместе со всеми задачами, зависящими от этого же родителя.
Правила завершения подразумевают, что все задачи, зависящие (прямо или косвенно) от заданного родителя и ещё не завершённые, могут завершиться (коллективно) тогда и только тогда, когда каждая из них ожидает открытой альтернативы завершения в операторе отбора и выполнение данного родителя закончено.
Те же правила справедливы и для главной программы.
Следовательно, для завершения главной программы необходимо завершение всех зависимых задач, даже если соответствующий задачный тип описан в библиотечном пакете.
С другой стороны, завершение главной программы не зависит от завершения задач, в свою очередь зависящих от библиотечных пакетов;
в языке не определено, требуется ли завершение таких задач.
Для ссылочного типа, являющегося производным другого ссылочного типа, соответствующее определение ссылочного типа является определением родительского типа;
зависимость в данном случае является зависимостью от родителя, который предвыполняет основные определения родительского ссылочного типа.
Описание переименования вводит новое имя для уже существующего понятия и, следовательно, не порождает дальнейшей зависимости.
Вызовы входов и операторы принятия являются основными средствами синхронизации задач и передачи значений между задачами.
Описание входа подобно описанию подпрограммы и допустимо только в спецификации задачи.
Действия, которые следует выполнить после вызова входа, задаются соответствующими операторами принятия.
Описание входа, включающее дискретный диапазон (см. 3.6.1), описывает семейство различных входов с одним и тем же формальным разделом (если он есть), а именно по одному входу для каждого значения дискретного диапазона.
Термин одиночный вход используется при определении правил, применимых к любому входу, отличному от члена семейства.
Задача, указанная объектом задачного типа, имеет вход (входы), который (которые) описан (описаны) в спецификации этого задачного типа.
В теле задачи каждый из её одиночных входов или семейства входов может быть именован соответствующим простым именем.
Имя входа семейства записывается в форме индексируемой компоненты: за простым именем семейства в круглых скобках следует индекс;
тип этого индекса должен быть тем же, что и тип дискретного диапазона в соответствующем описании семейства входов.
Вне тела задачи имя входа записывается в форме именованной компоненты, префикс которой обозначает задачный объект, а постфикс является простым именем одного из одиночных входов или семейства входов.
Одиночный вход совмещается с подпрограммой, литералом перечисления или другим одиночным входом, если у них одинаковые идентификаторы.
Совмещение для семейства входов не определено.
Одиночный вход или вход семейства могут быть переименованы в процедуру, как поясняется в разд.
8.5.
Виды параметров, определённые для параметров формального раздела описания входа, такие же, как в описании подпрограммы, и имеют тот же смысл (см. 6.2).
Синтаксически оператор вызова входа подобен оператору вызова процедуры; правила сопоставления параметров остаются теми же, что и для вызовов подпрограмм (см. 6.4.1 и 6.4.2).
Оператор принятия задаёт действия, которые выполняются при вызове упомянутого в этом операторе входа
(им может быть и вход семейства).
Раздел формальных параметров оператора принятия должен быть согласован с разделом формальных параметров, заданным в описании одиночного входа или семейства входов, упомянутых в операторе принятия
(см. разд.
6.3.1 о согласовании).
Если в конце оператора принятия используется простое имя, оно должно повторять простое имя, заданное в начале этого оператора.
Оператор принятия входа данной задачи допускается только в соответствующем теле задачи, исключая тело программного модуля, вложенного в тело задачи, и оператор принятия этого же одиночного входа или входа того же семейства.
(Из этих правил следует, что задача может выполнять операторы принятия только своих входов.)
Тело задачи может содержать несколько операторов принятия одного и того же входа.
При предвыполнении описания входа вначале вычисляется дискретный диапазон (если он есть), затем так же, как в описании подпрограммы, предвыполняется раздел формальных параметров (если он есть).
Выполнение оператора принятия начинается с вычисления индекса входа (в случае входа семейства).
Выполнение оператора вызова входа начинается с вычисления имени входа, затем следуют вычисления, требуемые для фактических параметров, как и при вызове подпрограммы (см. 6.4).
Дальнейшее выполнение оператора принятия и соответствующего оператора вызова входа синхронизовано.
Если данный вход вызывается только одной задачей, то предоставляются две возможности:
Если вызывающая задача перешла к оператору вызова входа раньше, чем имеющая этот вход задача достигла оператора принятия, то выполнение вызывающей задачи приостанавливается.
Если задача достигла оператора принятия раньше любого вызова этого входа, то выполнение задачи приостанавливается до получения такого вызова.
Если вход был вызван и соответствующий оператор принятия достигнут, то его последовательность операторов
(если она есть) выполняется вызванной задачей (вызывающая задача остаётся приостановленной).
Это взаимодействие задач называется рандеву.
После рандеву вызывающая задача и задача, содержащая вход, продолжают выполняться параллельно.
Если несколько задач вызывают один и тот же вход до того, как достигнут оператор принятия, то эти вызовы становятся в очередь;
с каждым входом связывается одна очередь.
Каждое выполнение оператора принятия удаляет из очереди один вызов.
Вызовы обрабатываются в порядке поступления.
При попытке вызвать вход задачи, закончившей своё выполнение, в точке вызова вызывающей задачи возбуждается исключение TASKING_ERROR;
это же исключение возбуждается в точке вызова, если вызванная задача заканчивает своё выполнение до принятия входа
(см. также разд.
9,10 для случая, когда вызванная задача становится аварийной).
Исключение CONSTRAINT_ERROR возбуждается, если индекс входа семейства не принадлежит заданному дискретному диапазону.
Примеры описаний входов:
Примеры вызовов входов:
Примеры операторов принятия:
Заданный в операторе принятия раздел формальных параметров не предвыполняется;
он используется только для идентификации соответствующего входа.
Оператор принятия может вызывать подпрограммы, производящие вызовы входов.
Оператор принятия может не содержать последовательности операторов, даже если соответствующий вход имеет параметры.
Точно так же он может содержать последовательность операторов, даже если соответствующий вход не имеет параметров.
Последовательность операторов в операторе принятия может включать операторы возврата.
Задача может вызывать и свои собственные входы, однако это, конечно, может привести к тупиковой ситуации.
Языком разрешены условные и временные вызовы входов (см. 9.7.2 и 9.7.3).
Правилами языка задаче в данной момент времени разрешается находиться только в одной очереди.
Если границы дискретного диапазона семейства входов являются литералами целого типа, то индекс (в имени входа или в операторе принятия) должен быть предопределённого типа INTEGER (см. 3.6.1).
Выполнение оператора задержки вычисляет простое выражение и приостанавливает дальнейшее выполнение задачи, содержащей данный оператор задержки, по крайней мере на длительность, заданную вычисленным значением.
Простое выражение должно быть предопределённого фиксированного типа DURATION (ДЛИТЕЛЬНОСТЬ);
его значение выражается в секундах;
оператор задержки с отрицательным значением эквивалентен оператору задержки с нулевым значением.
Все реализации типа DURATION должны допускать представление длительности (положительные и отрицательные) по крайней мере до 86 400 с (одни сутки);
минимальная представимая длительность, DURATION'SMALL, должна быть не больше 20 мс
(по возможности значение не превышает 50 мкс).
Заметим, что DURATION'SMALL не обязано соответствовать основному циклу таймера, именованному числу SYSTEM.TICK (см. 13.7).
Определение типа TIME приведено в предопределённом пакете CALENDAR.
Функция CLOCK возвращает текущее значение типа TIME.
Функции YEAR, MONTH, DAY и SECONDS возвращают соответствующие наименованиям значения для заданного значения аргумента типа TIME, а процедура SPLIT возвращает одновременно все четыре соответствующих значения.
Наоборот, функция TIME_OF упаковывает номера года, месяца, числа дня и значение длительности в значение типа TIME.
В операции " + " и " -" для сложения и вычитания значений времени и длительности, а также в операции соотношения для значений времени вкладывают традиционный смысл.
Исключение TIME_ERROR возбуждается в функции TIME_OF, если значения фактических параметров не формируют правильную дату.
Это исключение возбуждается также операциями "+" и "-", если для заданных операндов они не могут возвратить дату с номером года из диапазона соответствующего подтипа или если операция " -" не может возвратить значение из диапазона типа DURATION.
Во втором примере цикл повторяется в среднем один раз каждые INTERVAL секунд.
Этот интервал между двумя последовательными итерациями только приблизителен.
Однако здесь не произойдёт ошибки по длительности, поскольку длительность каждой итерации (существенно) меньше значения INTERVAL.
Существует три формы операторов отбора.
Одна форма обеспечивает отбор с ожиданием одной или нескольких альтернатив.
Две другие обеспечивают условный и временной вызовы входа.
Эта форма оператора отбора допускает объединение ожидания и отбор с ожиданием одной или нескольких альтернатив.
Отбор может зависеть от условий, связанных с каждой альтернативой отбора с ожиданием.
Оператор отбора с ожиданием должен содержать по крайней мере одну альтернативу принятия.
В дополнение к этому оператор отбора с ожиданием может содержать либо альтернативу завершения (только одну), либо одну или несколько альтернатив задержки, либо раздел else;
эти три возможности являются взаимоисключающими.
Альтернатива отбора называется открытой, если она, не начинается с зарезервированного слова when или если значение условия — TRUE.
В противном случае альтернатива называется закрытой.
При выполнении оператора отбора с ожиданием в произвольном, не определённом в языке порядке вычисляются все условия, заданные после зарезервированного слова when;
определяются открытые альтернативы.
Для открытой альтернативы задержки вычисляется выражение длительности задержки.
Для открытой альтернативы принятия входа семейства вычисляется индекс входа.
Выполнение отбора с ожиданием заканчивается отбором и вычислением либо одной из открытых альтернатив, либо раздела else;
правила такого отбора описываются ниже.
Первыми рассматриваются открытые альтернативы.
Отбор одной из таких альтернатив производится немедленно, если возможно соответствующее рандеву, т.е. если другая задача произвела вызов соответствующего входа и ожидает его принятия.
Если таким образом могут быть отобраны несколько альтернатив, то одна из них выбирается произвольно
(которая именно, в языке не определено).
После отбора такой альтернативы выполняются соответствующий оператор принятия и следующая за ним последовательность операторов (если она есть).
Если никакое рандеву не может произойти немедленно и отсутствует раздел else, то задача ждёт, пока можно будет выбрать открытую альтернативу отбора с ожиданием.
Отбор других форм альтернатив или раздела else осуществляется следующим образом.
Отбирается открытая альтернатива задержки, если никакая другая альтернатива принятия не может быть выбрана до истечения указанной задержки ожидания
(немедленно, если длительность отрицательная или нулевая и при отсутствии очереди вызовов входа);
затем выполняются возможные последующие операторы этой альтернативы.
Если возможен отбор нескольких альтернатив задержки (т.е. если задержки у них одинаковы), то одна из них выбирается произвольно.
Отбирается раздел else и выполняется последовательность операторов этого раздела, если нельзя немедленно отобрать альтернативу принятия, в частности если все альтернативы закрыты.
Отбирается открытая альтернатива завершения, если перечисленные в разд.
9.4 условия удовлетворены.
Из других правил следует, что нельзя отобрать альтернативу завершения, пока существует очередь вызовов 'любого входа задачи.
Исключение PROGRAM_ERROR возбуждается, если все альтернативы закрыты и раздел else отсутствует.
Пример оператора отбора:
Пример тела задачи с оператором отбора:
В отборе с ожиданием допускаются несколько открытых альтернатив задержки.
В отборе с ожиданием допускаются несколько открытых альтернатив принятия одного и того же входа.
Условный вызов входа производит вызов входа, который отменяется, если рандеву нельзя осуществить немедленно.
При выполнении условного вызова входа вначале вычисляется имя входа.
Затем выполняются требуемые вычисления фактических параметров, как при вызове подпрограммы (см. 6.4).
Вызов входа отменяется, если выполнение вызванной задачи не достигло точки, в которой она готова к принятию входа
(т.е. не достигнуты оператор принятия соответствующего входа или оператор отбора с открытой альтернативой принятия этого входа),
или существует очередь ранее сделанных вызовов этого входа.
Если вызванная задача достигла оператора отбора, но альтернатива принятия этого входа не отобрана, то вызов входа отменяется.
Если вызов входа отменен, то выполняются операторы раздела иначе.
В противном случае происходит рандеву и выполняется последовательность операторов после вызова входа (если она есть).
Выполнение условного вызова входа возбуждает исключение TASKING_ERROR, если вызванная задача уже закончила своё выполнение
(см. разд.
9.10 для случая, когда вызванная задача становится аварийной).
Временной вызов входа производит вызов входа, который отменяется, если рандеву не началось на протяжении заданной задержки.
При выполнении временного вызова входа вначале вычисляется имя входа.
Затем выполняются требуемые вычисления фактических параметров, как при вызове подпрограммы (см. 6.4).
После этого вычисляется выражение, задающее задержку, и, наконец, производится вызов входа.
Если рандеву может начаться в течение указанной длительности
(или немедленно, как для условного вызова входа, если задержка отрицательная или нулевая),
то оно происходит, и затем выполняется необязательная последовательность операторов после вызова входа.
Иначе, по истечению указанной длительности, вызов входа отменяется и выполняется возможная последовательность операторов альтернативы задержки.
Выполнение временного вызова входа возбуждает исключение TASKING_ERROR, если вызванная задача закончила своё выполнение до принятия вызова
(см. также разд.
9.10 для случая, когда вызванная задача становится аварийной).
Каждая задача может (но не обязательно) иметь приоритет со значением подтипа PRIORITY (типа INTEGER), описанного в предопределённом библиотечном пакете SYSTEM (см. 13.7).
Меньшее значение приоритета указывает на меньшую степень важности;
диапазон приоритетов определяется реализацией.
Приоритет связывается с задачей, если в спецификации соответствующей задачи присутствует прагма:
Приоритет задаётся значением выражения.
Если такая прагма присутствует в самом внешнем разделе описаний главной программы, то приоритет связывается с главной программой.
В спецификации данной задачи или при подпрограмме — библиотечном модуле может употребляться не более одной такой прагмы, и это единственные места, допустимые для этой прагмы.
Прагма PRIORITY игнорируется при её появлении в подпрограмме, не являющейся главной программой.
Спецификация приоритета является указанием, помогающим реализации в распределении ресурсов между параллельными задачами, когда число выполняемых задач превышает возможности их одновременной обработки имеющимися ресурсами.
Влияние приоритетов на порядок очерёдности выполнения задач определяется следующим правилом.
Если две задачи с разными приоритетами готовы к выполнению и могут практически выполняться, используя одни и те же физические процессоры и одни и те же ресурсы обработки, то нельзя чтобы выполнялась задача с более низким приоритетом, а не выполнялась задача с более высоким приоритетом.
Для задач с одинаковыми приоритетами порядок выполнения не определён.
Для задач, приоритеты которых не заданы, правила очерёдности не определены, исключая случай, когда между задачами происходит рандеву.
Если приоритеты обеих задач определены, то рандеву выполняется с той задачей, чей приоритет является наибольшим.
Если приоритет определён только для одной задачи, то рандеву выполняется как минимум с приоритетом этой задачи.
Если приоритеты задач не заданы, то приоритет рандеву также не определён.
Приоритет задачи является статическим и поэтому фиксирован.
Однако приоритет во время рандеву может и не быть статическим, поскольку он также зависит от приоритета задачи, вызывающей вход.
Приоритеты следует использовать только для указания относительной степени важности;
их не следует использовать для синхронизации задач.
Для задачного объекта или значения Т определены следующие атрибуты:
Вырабатывает значение FALSE, если выполнение указанной задачи Т либо закончено, либо завершено либо задача аварийная.
В остальных случаях вырабатывает значение TRUE.
Значение этого атрибута имеет предопределённый тип BOOLEAN.
Вырабатывает значение TRUE, если указанная Т задача завершена.
В остальных случаях вырабатывает значение FALSE.
Значение этого атрибута имеет предопределённый тип BOOLEAN.
В дополнение к приведённым для задачного объекта Т или задачного типа Т определены атрибуты представления STORAGE_SIZE, SIZE и ADDRESS (см. 13.7.2).
Атрибут COUNT определён для входа Е задачного модуля Т.
Вход может быть либо одиночным входом, либо входом семейства
(в любом случае имя одиночного входа или семейства входов может быть либо простым, либо расширенным).
Этот атрибут допустим только в теле Т, но не во вложенном в тело Т программном модуле.
Вырабатывает число вызовов входа, присутствующих в очереди входа Е в данный момент
(если атрибут вычисляется при выполнении оператора принятия входа Е, то в это число не включается вызывающая задача).
Значение атрибута имеет тип универсальный целый.
Алгоритмы, соответствующие программы которых используют атрибут E'COUNT, обязаны учитывать возможность увеличения значения атрибута с появлением новых вызовов и уменьшения этого значения, например, при временных вызовах входа.
Оператор прекращения переводит одну или несколько задач в аварийное состояние, предотвращая любые дальнейшие рандеву с такими задачами.
При определении типа имени каждой задачи используется тот факт, что это задачный тип.
При выполнении оператора прекращения заданные имена задач вычисляются в порядке, который в языке не определён.
Затем каждая упомянутая задача становится аварийной, если она ещё не завершена;
аналогично любая зависящая от упомянутой задача становится также аварийной, если она ещё не завершена.
Любая аварийная задача, выполнение которой приостановлено операторами принятия, отбора или задержки, становится законченной.
Любая аварийная задача, выполнение которой приостановлено при вызове входа, а соответствующее рандеву шее не началось, становится законченной и удаляется из очереди к входу.
Любая аварийная задача, которая не начала свою активизацию, становится законченной (и, следовательно, завершённой).
Этим заканчивается выполнение оператора прекращения.
Окончание любой другой аварийной задачи не производится до окончания выполнения оператора прекращения.
Оно должно произойти не позднее достижения аварийной задачей точки синхронизации, которой может быть конец её активизации, начало активизации другой задачи, вызов входа, начало или конец выполнения оператора принятия, оператор отбора, оператор задержки, обработчик исключения или оператор прекращения.
Если задача, вызвавшая вход, становится аварийной в ходе рандеву, то её завершение не производится до окончания рандеву (см. 11.5).
Вызов входа аварийной задачи возбуждает в месте вызова исключение TASKING_ERROR.
Аналогично исключение TASKING_ERROR возбуждается в любой задаче, вызвавшей вход аварийной задачи, если вызов входа все ещё находится в очереди либо рандеву не окончено
(вызовом входа может быть либо оператор вызова входа, либо операторы условного или временного вызова входа);
исключение возбуждается не позже окончания аварийной задачи.
Для любой аварийной (или законченной) задачи значение атрибута CALLABLE есть FALSE.
Если аварийное окончание задачи произошло во время изменения в задаче некоторой переменной, то значение этой переменной не определено.
Оператор прекращения следует использовать только в крайних случаях, требующих безусловного завершения.
Допускается, что задача может прекратить любую задачу, включая себя самое.
Обычными средствами передачи данных между задачами являются операторы вызова и принятия входов.
Если две задачи считывают или изменяют разделяемую переменную (доступную обеим задачам), то ни одна из них ничего не может знать о порядке выполнения операций над переменной в другой задаче, исключая точки их синхронизации.
Две задачи синхронизуются в начале и в конце их рандеву.
В начале и в конце своей активизации задача синхронизуется с вызвавшей эту активизацию задачей.
Задача, которая закончила своё выполнение, синхронизуема с любой другой задачей.
О действиях, выполняемых программой, использующей разделяемые переменные, всегда могут быть сделаны следующие предположения:
Если в интервале времени между двумя точками синхронизации задача считывает разделяемую переменную скалярного или ссылочного типа, то эта переменная не изменяется никакой другой задачей в течение данного интервала времени.
Если в интервале времени между двумя точками синхронизации задача изменяет разделяемую переменную скалярного или ссылочного типа, то эта переменная не считывается и не изменяется никакой другой задачей в течение данного интервала времени.
Выполнение программы ошибочно, если какое-либо из этих предположений нарушено.
Если данная задача считывает значение разделяемой переменной, сделанные выше предположения допускают, чтобы реализация поддерживала локальные копии значения
(например, в регистрах или в некоторых других видах временной памяти);
и пока данная задача не достигла точки синхронизации или не изменила значение разделяемой переменной, следствием принятых допущений является то, что для данной задачи чтение локальной копии эквивалентно чтению собственно разделяемой переменной.
Аналогично если данная задача изменяет значение разделяемой переменной, сделанные предположения допускают, чтобы реализация поддерживала локальные копии значения и откладывала запоминание локальной копии в разделяемую переменную до точки синхронизации, заменяя каждые последующие считывание или изменения значений разделяемой переменной на считывание или изменение локальной копии.
С Другой стороны, не допускается, чтобы реализация вводила такую память, которая не будет обрабатываться в каноническом порядке (см. 11.6).
Для задания того, что каждое считывание или изменение значения разделяемой переменной является для этой переменной точкой синхронизации, может быть использована прагма SHARED, т.е. для данной переменной (но не обязательно для остальных) сделанных выше предположения справедливы.
Форма этой прагмы следующая:
Прагма допустима только для переменной, объявленной описанием объекта скалярного или ссылочного типа;
описание переменной и прагма должны помещаться (в таком порядке) непосредственно в одном и том же разделе описаний или в спецификации пакета;
прагма должна появиться до любого вхождения имени переменной, отличного от вхождения в спецификаторе адреса.
Реализация должна ограничивать объекты, для которых допустима прагма SHARED, объектами, для которых каждое прямое считывание или прямое изменение реализуется неделимыми операциями.
В следующем примере определена задача буферизации для сглаживания различий между скоростью ввода производящей задачи и скоростью ввода некоторой потребляющей задачи.
Например, производящая задача может содержать операторы:
потребляющая задача — операторы:
Задача буферизации содержит внутренний пул для символов, обрабатываемых циклически.
Пул имеет два индекса: IN_INDEX, указывающий место следующего вводимого символа, и OUT_INDEX, указывающий место следующего выводимого символа.
В этой главе описываются общая структура программы и средства раздельной компиляции.
Программа представляет собой набор из одного или нескольких компилируемых модулей, подаваемых на вход компилятора в виде одной или нескольких компиляций.
Каждый компилируемый модуль определяет раздельную компиляцию некоторой конструкции, которой может быть описание или тело подпрограммы, описание или тело пакета, описание или тело настраиваемого модуля или же конкретизация настройки.
Кроме того, компилируемый модуль может быть субмодулем, т.е. телом подпрограммы, пакета, задачи, или настраиваемым модулем, описанным внутри другого компилируемого модуля.
Текст программы может подаваться на вход компилятора в виде одной или нескольких компиляций.
Каждая компиляция представляет собой последовательность компилируемых модулей.
Говорят, что компилируемые модули программы принадлежат программной библиотеке.
Компилируемый модуль определяет библиотечный модуль или вторичный модуль.
Вторичный модуль — это раздельно компилируемое соответствующее тело библиотечного модуля или субмодуль другого компилируемого модуля.
Обозначением раздельно компилируемой подпрограммы (библиотечного модуля или субмодуля) должен быть идентификатор.
В программной библиотеке простые имена всех библиотечных модулей должны быть различными идентификаторами.
Результат компилирования библиотечного модуля состоит в том, чтобы определить (или переопределить) его как модуль программной библиотеки.
По правилам видимости каждый библиотечный модуль рассматривается как описание, приведённое непосредственно внутри пакета STANDARD.
Результат компилирования вторичного модуля состоит в том, чтобы определить тело библиотечного модуля или в случае субмодуля соответствующее тело программного модуля, описанного внутри другого компилируемого модуля.
Тело подпрограммы в качестве компилируемого модуля рассматривается как вторичный модуль в том случае, если программная библиотека уже содержит библиотечный модуль, который является подпрограммой с тем же именем.
В противном случае оно рассматривается одновременно и как библиотечный модуль, и как соответствующее этому библиотечному модулю тело (т.е. как вторичный модуль).
Компилируемые модули одной компиляции транслируются в заданном порядке.
Относящаяся ко всей компиляции прагма должна помещаться перед первым компилируемым модулем компиляции.
Подпрограмма, являющаяся библиотечным модулем, может использоваться в качестве главной программы в традиционном смысле.
Главная программа выполняется так, как будто она вызвана некоторой внешней задачей, средства инициализации этого выполнения языком не предписаны.
Реализация может предъявить определённые требования к параметрам и результату (если он есть) главной программы
(эти требования должны быть приведены в приложении F).
Каждая реализация должна разрешать задание в качестве главной программы процедуры без параметров, а любая главная программа должна быть подпрограммой — библиотечным модулем.
Простая программа может состоять из одного компилируемого модуля.
Компиляция может не содержать ни одного компилируемого модуля, например её текст может состоять из одних прагм.
Обозначение библиотечной функции не может быть знаком операции, но для переименования библиотечной функции в операцию допускается использование описания переименования.
Две библиотечные подпрограммы должны иметь различные простые имена и потому не могут быть совмещены друг с другом.
Однако описания переименования могут определить совмещённые имена для таких подпрограмм; кроме того, с библиотечной подпрограммой можно совмещать локально описанную подпрограмму.
Так как библиотечные модули рассматриваются как описания, приведённые непосредственно в пакете STANDARD, то для библиотечного модуля L может быть использовано расширенное имя STANDARD.L (если только имя STANDARD не скрыто).
Для указания библиотечных модулей, имена которых используются в' компилируемом модуле, служит спецификатор контекста.
Имена в спецификаторе контекста должны быть простыми именами библиотечных модулей.
В спецификаторе совместности допустимы простые имена любых библиотечных модулей.
В спецификаторе использования допустимы простые имена только тех библиотечных пакетов, которые указаны в предшествующих спецификаторах совместности данного спецификатора контекста.
В спецификаторе контекста недопустимы простые имена, введённые описанием переименования.
Спецификаторы совместности и использования в спецификаторе контекста библиотечного модуля применяются к этому библиотечному модулю и ко вторичному модулю, который определяет соответствующее тело
(независимо от того, повторен ли такой спецификатор для вторичного модуля или нет).
Аналогично для компилируемого модуля спецификаторы совместности и использования в спецификаторе контекста применяются к этому модулю и к его субмодулям (если они есть).
Библиотечный модуль, упомянутый в спецификаторе совместности, применённом к компилируемому модулю, видим непосредственно внутри этого компилируемого модуля, исключая случаи его скрытия;
этот библиотечный модуль видим как описанный непосредственно в пакете STANDARD (см. 8.6).
Спецификаторы совместности задают зависимости между компилируемыми модулями, т.е. компилируемый модуль зависит от других библиотечных модулей, упомянутых в спецификаторе контекста.
Зависимости между модулями учитываются при определении допустимого порядка компиляции (и перекомпиляции) компилируемых модулей (см. разд.
10.3), а также при определении допустимого порядка предвыполнения компилируемых модулей (см. разд.
10.5).
Внутри компилируемого модуля видимы библиотечные модули, упомянутые в спецификаторе совместности (исключая случаи их скрытия), следовательно, они могут использоваться как соответствующие программные модули.
Так, в компилируемом модуле имя библиотечного пакета может быть дано в спецификаторе использования и служит для формирования расширенных имён;
библиотечные подпрограммы можно вызывать;
можно описать конкретизации библиотечного настраиваемого модуля.
Правила для спецификаторов совместности дают одинаковый результат как при упоминании имени библиотечного модуля один или несколько раз, в различных спецификаторах совместности, так и внутри заданного спецификатора совместности.
Пример 1.
Главная, программа.
Ниже приведён пример главной программы, состоящей из одного компилируемого модуля — процедуры печати вещественных корней квадратного уравнения.
Предполагается, что в программной библиотеке уже содержится предопределённый пакет TEXT_I0 и заданный пользователем пакет REAL_OPERATIONS (содержащий определения типа REAL и пакетов REAL_I0 и REAL_FUNCTIONS).
Такие пакеты могут быть использованы и другими главными программами.
Примечание к примеру.
В спецификаторах совместности компилируемого модуля надо упоминать имена только тех библиотечных подпрограмм или пакетов, видимость которых действительно необходима внутри модуля.
Нет необходимости (и не следует) упоминать имена других библиотечных модулей, используемых внутри модулей, перечисленных в этих спецификаторах совместности, кроме тех, которые используются непосредственно в данном компилируемом модуле.
Например, в теле пакета REAL_OPERATIONS могут потребоваться некоторые элементарные операции, определённые в других пакетах.
Но эти пакеты не надо упоминать в спецификаторе совместности процедуры QUADRATIC_EQUATION, так как в её теле элементарные операции не вызываются непосредственно.
Компилируемый модуль может быть расчленён на несколько компилируемых модулей.
Например, рассмотрим следующую программу:
Приведённые ниже три компилируемых модуля определяют программу с результатом, эквивалентным результату предыдущего примера
(пунктирные линии между модулями напоминают, что они не обязаны составлять единый текст).
Пример 2.
Несколько компилируемых модулей.
Заметим, что в последней версии примера в пакете STOCK невидимы внешние идентификаторы, отличные от предопределённых (в пакете STANDARD).
В частности, в нем не используются идентификаторы SMALL и TOTAL, описанные в процедуре PROCESSOR;
в противном случае пакет STOCK нельзя выделить из процедуры PROCESSOR, как это сделано выше.
С другой стороны, процедура PROCESSOR зависит от пакета STOCK и упоминает его в спецификаторе совместности.
Поэтому пакет STOCK можно использовать в расширенном имени и спецификаторе использования.
Эти три компилируемых модуля могут быть организованы как одна или несколько компиляций.
Например, возможно объединение в одной компиляции спецификации и тела пакета в указанном порядке.
Субмодули используются для раздельной компиляции соответствующего тела программного модуля, описанного в другом компилируемом модуле.
Этот метод разделения программы позволяет разрабатывать программу иерархически.
Использование следа тела в качестве тела программного модуля (подпрограммы, пакета, задачного модуля или настраиваемого модуля) допускается, только если след тела помещён непосредственно в теле библиотечного пакета или в разделе описаний некоторого компилируемого модуля.
В случае задания тела программного модуля следом тела требуется, чтобы субмодуль, содержащий соответствующее тело, был откомпилирован раздельно.
В случае подпрограммы спецификации подпрограммы, данные в соответствующем теле и в следе тела, должны быть согласованы (см. 6.3.1).
Для каждого субмодуля задаётся имя родительского модуля, т.е. компилируемого модуля, содержащего соответствующий след тела.
Если родительский модуль — библиотечный модуль, то он называется предком.
Если родительский модуль сам является субмодулем, то его имя должно быть представлено расширенным именем, начинающимся простым именем библиотечного модуля-предка.
Простые имена всех субмодулей, которые имеют одинакового предка, должны задаваться различными идентификаторами.
Видимость в соответствующем теле субмодуля — это видимость, которая была бы получена в месте задания следа тела (в родительском модуле), если бы спецификаторы совместности и использования субмодуля были добавлены к спецификатору контекста родительского модуля.
Если родительский модуль сам является субмодулем, то это же правило используется для определения видимости в соответствующем теле родительского модуля.
Результатом предвыполнения следа тела является предвыполнение соответствующего тела субмодуля.
Два субмодуля различных библиотечных модулей в одной и той же программной библиотеке могут иметь совпадающие идентификаторы.
В этом случае их расширенные имена различны, так как различны простые имена библиотечных модулей и простые имена всех субмодулей одного предка данного библиотечного модуля.
Средствами описаний переименования могут быть введены для (различных) субмодулей совмещённые имена подпрограмм.
Библиотечный модуль, упомянутый в спецификаторе совместности субмодуля, может быть скрыт описанием (с тем же идентификатором), данным в соответствующем теле субмодуля.
Более того, такой библиотечный модуль может быть скрыт описанием, данным в родительском модуле, так как библиотечный модуль рассматривается как описанный в пакете STANDARD;
это, однако, не влияет на интерпретацию спецификаторов совместности, ибо в них могут быть упомянуты имена только библиотечных модулей.
Сначала процедура ТОР оформлена в виде компилируемого модуля без субмодулей.
Тело пакета FACILITY и процедуру TRANSFORM можно представить в виде раздельно компилируемых субмодулей модуля ТОР.
Тело процедуры G также может быть представлено как субмодуль модуля FACILITY.
Пример 3:
В этом примере TRANSFORM и FACILITY являются субмодулями процедуры TOP, а G -субмодулем пакета FACILITY.
Видимость в этом пакете такая же, как и в предыдущем, с одним отличием : TEXT_IO используется только в G, по этому соответствующий спецификатор совместности написан для G, а не для процедуры TOP.
В остальном видимость идентификаторов в соответствующих телах программ обеих версий одинакова.
Например, в соответствующем теле субмодуля G (непосредственно) видимы процедура TOP, тип REAL, переменные R и S, пакет FACILITY и содержащиеся в нем именованное число PI и подпрограммы F и G.
Правила, определяющие порядок компилирования модулей, являются непосредственным следствием правил видимости и, в частности, того факта, что любой библиотечный модуль, упомянутый в спецификаторе контекста компилируемого модуля, видим в нем.
Компилируемый модуль должен компилироваться после всех библиотечных модулей, указанных в его спецификаторе контекста.
Вторичный модуль, являющийся телом подпрограммы или пакета, должен компилироваться после соответствующего библиотечного модуля.
Любой субмодуль родительского компилируемого модуля должен компилироваться после него.
Компилирование, при котором в компилируемом модуле обнаружена ошибка, считается неудавшимся и никак не влияет на программную библиотеку;
то же самое относится и к перекомпиляции
(никакой компилируемый модуль не может стать устаревшим вследствие такой перекомпиляции).
Порядок компилирования компилируемых модулей программы должен отвечать частичной упорядоченности, определённой приведёнными выше правилами.
Аналогичные правила применяются при перекомпиляции.
На компилируемый модуль потенциально влияет изменение любого библиотечного модуля, упомянутого в его спецификаторе контекста.
На вторичный модуль потенциально влияет изменение соответствующего библиотечного модуля.
На субмодуль потенциально влияет изменение родительского компилируемого модуля.
В результате успешной перекомпиляции компилируемого модуля все компилируемые модули, на которые потенциально влияет данный, считаются устаревшими и должны перекомпилироваться, кроме тех, которые больше не нужны.
Реализация может уменьшить стоимость перекомпиляции, если установит, что данные изменения не повлияли на модули, которые находились под потенциальным влиянием данного.
Перекомпилирование субмодулей некоторого модуля на сам этот модуль никакого влияния не оказывает.
Изменения в теле подпрограммы или пакета не влияют на другие компилируемые модули (кроме субмодулей этого тела), так как эти компилируемые модули имеют доступ только к спецификации подпрограммы или пакета.
В реализации допустимы описанные ниже отступления от этого правила, связанные с открытыми подстановками, некоторыми оптимизациями, осуществляемыми компилятором, и некоторыми аспектами реализации настраиваемых программных модулей.
Если прагма INLINE применяется к описанию подпрограммы в спецификации пакета, то открытая подстановка возможна, только если тело пакета откомпилировано раньше модулей, вызывающих эту подпрограмму.
В таком случае открытая подстановка создаёт зависимость вызывающего модуля от тела пакета; компилятор должен распознавать такую зависимость при определении необходимости перекомпиляции.
Если вызывающий модуль компилируется раньше, чем тело пакета, то для таких вызовов прагма INLINE может игнорироваться компилятором
(при этом может быть выдано предупреждение о невозможности открытой подстановки).
То же относится и к раздельно компилируемой подпрограмме, к которой применяется прагма INLINE.
С целью оптимизации реализация может компилировать несколько модулей данной компиляции, создавая при этом дальнейшие зависимости между этими компилируемыми модулями.
Эти зависимости должны учитываться компилятором для определения необходимых перекомпиляций.
Реализация может требовать, чтобы описание настройки и соответствующее тело были частями одной и той же компиляции независимо от того, раздельно ли компилируется настраиваемый модуль или он локален в другом компилируемом модуле.
Реализация может также требовать, чтобы субмодули настраиваемого модуля были частью одной и той же компиляции.
Примеры порядка компиляции:
В примере 1 (см. 10.1.1) процедура QUADRATIC_EQUATION должна компилироваться после библиотечных пакетов TEXT_IO и REAL_OPERATIONS, так как они упомянуты в спецификаторе совместности процедуры.
В примере 2 (см. 10.1.2) тело пакета STOCK должно компилироваться после соответствующей спецификации пакета.
В примере 2 (см. 10.1.2) спецификация пакета STOCK должна компилироваться до процедуры PROCESSOR.
С другой стороны, процедура PROCESSOR может компилироваться как до, так и после тела пакета STOCK.
В примере 3 (см. 10.2.1) процедура G должна компилироваться после пакета TEXT-10, так как этот пакет упомянут в спецификаторе совместности процедуры G.
В то же время пакет TEXT-10 может компилироваться как до, так и после процедуры ТОР.
В примере 3 (см. 10.2.1) субмодули TRANSFORM и FACILITY должны компилироваться после главной программы ТОР.
Субмодуль G должен компилироваться после его родительского модуля FACILITY.
Для библиотечных пакетов из правил перекомпиляции следует, что тело пакета становится устаревшим после перекомпиляции соответствующей спецификации.
Если новая спецификация пакета не требует задания тела
(т.е. она не содержит описаний программных модулей),
то перекомпиляции тела такого пакета не требуется.
В любом случае устаревшее тело пакета не должно использоваться и поэтому может быть удалено из программной библиотеки.
Правила языка требуют, чтобы компилятор одинаковым образом обрабатывал программу, состоящую из нескольких компилируемых модулей (и субмодулей) или из одного компилируемого модуля.
Должен быть предусмотрен библиотечный файл, содержащий информацию о компилируемых модулях программной библиотеки, целостность которого обеспечивается компилятором или компилирующей средой.
Данная информация может содержать символьные таблицы и другу информацию, относящаяся к предыдущим компиляциям.
Обычно входными данными для компилятора являются компилируемые модули (или модуль) и библиотечный файл.
Последний используется для проверок и корректируется после успешного компилирования каждого из этих модулей.
Для компилируемых модулей компиляции создаётся одна программная библиотека.
Возможно существование различных программных библиотек;
в языке не определены правила их именования — это обеспечивается окружением системы программирования.
Для создания программной библиотеки данной программы или данного семейства программ следует ввести команды.
Эти команды могут разрешать использование модулей из других программных библиотек.
Наконец, для запроса состояний модулей в программной библиотеке также следует ввести команды.
Форма этих команд не задана в определении языка.
Перед выполнением главной программы все библиотечные модули, необходимые для главной программы, и тела этих модулей (если они есть) предвыполняются.
Такими библиотечными модулями являются модули, упомянутые в спецификаторах совместности для главной программы, её тела и субмодулей, а также модули, упомянутые в спецификаторах совместности для этих библиотечных модулей, их тел и субмодулей, и т. д. вплоть до получения транзитивного замыкания.
Предвыполнение таких библиотечных модулей и их тел производится в соответствии с частичной упорядоченностью, определяемой спецификаторами совместности (см. 10.3).
Кроме того, библиотечный модуль, упомянутый в спецификаторе контекста для субмодуля, должен быть предвыполнен до тела библиотечного модуля-предка этого субмодуля.
Порядок предвыполнения, отвечающий такому отношению упорядоченности, не всегда обеспечивает выполнение следующего требования: тело любого библиотечного модуля предвыполняется прежде любого другого компилируемого модуля, при предвыполнении которого необходимо предвыполнение тела этого библиотечного модуля.
Для указания необходимости более раннего предвыполнения тел библиотечных модулей используется прагма ELABORATE.
Эта прагма записывается в виде
Такие прагмы допустимы только непосредственно после спецификатора контекста компилируемого модуля
(до следующего за ним библиотечного или вторичного модуля).
Аргументы этой прагмы должны быть простыми именами библиотечных модулей, упомянутых в спецификаторе контекста, и каждый такой библиотечный модуль должен иметь соответствующее тело.
Эта прагма указывает, что тело библиотечного модуля должно предвыполняться до данного компилируемого модуля.
Если данный компилируемый модуль — субмодуль, то тело библиотечного модуля должно предвыполняться до тела библиотечного модуля-предка (субмодуля).
Программа неправильна, если не может быть найден необходимый порядок предвыполнения
(т.е. если существуют циклические зависимости).
Предвыполнение компилируемых модулей программы в остальных случаях осуществляется в некотором порядке, который не определён в языке.
Компиляторы могут осуществлять оптимизацию предвыполнения описаний и выполнения операторов.
В частности, компилятор может оптимизировать программу, вычисляя определённые выражения помимо статических.
Если какое-либо из таких выражений, статических или нет, при вычислении приводит к возбуждению исключения, то код этой части программы может быть заменён кодом возбуждения того же исключения;
это справедливо для исключений, возбуждаемых при вычислении имён и простых выражений (см. также разд.
11.6).
Компилятор может определить, что некоторые операторы или подпрограммы никогда не будут выполняться, например, если их выполнение зависит от условия, имеющего значение FALSE.
В таком случае соответствующие части объектного машинного кода могут быть опущены.
Такое правило позволяет на уровне языка производить условную компиляцию.
Выражение, вычисление которого может привести к возбуждению исключения, не обязательно представляет ошибку, если выражение находится в операторе или подпрограмме, которые никогда не выполняются.
Компилятор может предупреждать программиста о потенциальной ошибке.
В этой главе определяются средства обработки ошибок или других исключительных ситуаций, которые возникают при выполнении программы.
Такая ситуация называется исключением.
Возбуждение исключения следует понимать как прекращение нормального выполнения программы для обработки соответствующей ситуации.
Ответное действие на возбуждение исключения называется обработкой исключения.
В описании исключения задаётся имя исключения.
Исключение может быть возбуждено либо оператором возбуждения, либо каким-либо другим оператором или операцией, распространяющими исключение.
При возбуждении исключения управление может быть передано обработчику исключения, написанному пользователем либо в конце оператора блока, либо в конце тела подпрограммы, пакета или задачного модуля.
В описании исключения задаётся его имя.
Это имя можно употреблять только в операторах возбуждения, обработчиках исключений и описаниях переименования.
Описание исключения с несколькими идентификаторами эквивалентно последовательности единичных описаний с одним идентификатором (см. 3.2).
Каждое единичное описание исключения задаёт имя отличного от других исключения.
В частности, если настраиваемый модуль содержит описание исключения, то такие описания, неявно сгенерированные различными конкретизациями настройки, ссылаются на разные исключения
(но все они имеют один и тот же идентификатор).
Конкретное исключение, обозначенное именем, определяется во время компиляции и является одним и тем же независимо от числа предвыполнений его описания.
Следовательно, если описание исключения находится в рекурсивной подпрограмме, то имя исключения обозначает одно и то же исключение для всех вызовов рекурсивной подпрограммы.
В языке предопределены следующие исключения.
Они возбуждаются при обнаружении описанных ниже ситуаций.
Это исключение возбуждается в любой из следующих ситуаций: при попытке нарушить ограничение диапазона, ограничение индекса или ограничение дискриминанта;
при попытке использовать компоненту записи, не существующую для текущих значений дискриминанта;
при попытке использовать именуемую компоненту, индексируемую компоненту, отрезок или атрибут объекта, обозначенного ссылочным значением, если этот объект не существует, поскольку ссылочное значение пустое.
Это исключение возбуждается при выполнении предопределённой числовой операции, которая не может выработать верный результат
(для вещественных типов в пределах предписанной точности).
Сюда относится также случай использования реализацией предопределённых числовых операций для выполнения, вычисления или предвыполнения некоторой конструкции.
Данные в разд.
4.5.7 правила определяют случаи, для которых от реализации не требуется возбуждения исключения в случае возникновения ошибочной ситуации (см. также 11.6).
Это исключение возбуждается при попытке вызвать подпрограмму, активизировать задачу или предвыполнить конкретизацию настройки, если тело соответствующего модуля ещё не предвыполнено.
Оно также возбуждается, если выполнение функции завершается через end (см. 6.5), при выполнении оператора отбора с ожиданием, когда отсутствует раздел else, а все альтернативы закрыты (см. 9.7.1).
Наконец, в зависимости от реализации исключение может возбуждаться при попытке выполнить ошибочное действие и при некорректной зависимости от порядка (см. 1.6).
Это исключение возбуждается в одной из следующих ситуаций: при вычислении генератора; когда не хватает динамической памяти, выделенной для задачи; когда исчерпана память для набора генерируемых объектов; при предвыполнений элемента описания или при вызове подпрограммы, если памяти недостаточно.
Это исключение возбуждается при возбуждении исключений во время взаимодействия задач (см. 9 и 11.5).
Описанные выше ситуации могут возникать, не возбуждая соответствующих исключений, если была использована прагма SUPPRESS подавления проверок (см. 11.7).
Примеры описанных пользователем исключений:
Контекст исключения CONSTRAINT_ERROR: агрегат 4.3.1, 4.3.2, атрибут дискретного типа 3.5.5, генератор 4.8, именованная компонента 4.1.3, индекс входа 9.5, индексированная компонента 4.1.1, квалифицированное выражение 4.7, логическая операция 4.5.1, ограничение 3.3.2, ограничение диапазона 3.5, ограничение дискриминанта 3.7.2, ограничение индекса 3.6.1, оператор присваивания 5.2, 5.2.1, операция возведения в степень 4.5.6, описание объекта 3.2.1, отрезок 4.1.2, преобразование типа 4.6, предвыполнение формального параметра настройки 12.3, пустое ссылочное значение 3.8, сопоставление параметров 6.4.1, указание подтипа 3.3.2.
Контекст исключения NUMERIC_ERROR: атрибут дискретного типа 3.5.5, неявное преобразование 3.5.4, 3.5.6, 4.6, операция над числовым типом 4.5, 4.5.7, числовая операция 3.5.5, 3.5.8, 3.5.10.
Контекст исключения PROGRAM_ERROR: выход из функции 6.5, контроль предвыполнения 3.9, 7.3, 9.3, 12.2, набор 3.8, некорректная зависимость от порядка 1.6, отбор с ожиданием 9.7.1, ошибочный 1.6, предвыполнение 3.9.
Контекст исключения STORAGE_ERROR: генератор 4.8.
Контекст исключения TASKING_ERROR: активизация задачи 9.3, вызов входа 9.5, 9.7.2, 9.7.3, исключения при взаимодействии задач 11.5, оператор прекращения 9.10.
Ответная реакция на одно или несколько исключений определяется обработчиком исключения.
Обработчик исключения помещается в оператор блока, в тело подпрограммы, пакет, задачный модуль или настраиваемый модуль.
Каждая из указанных в этой главе конструкций называется окружением.
В любом случае окружение обработчиков исключений синтаксически включает следующий раздел:
Имена исключений, перечисленные во всех выборах данного окружения, должны быть все различны.
Выбор исключения others допустим только в последнем обработчике исключения данного окружения как единственный выбор;
он задаёт все исключения, не перечисленные в предыдущих обработчиках окружения, включая исключения, имена которых на месте данного обработчика исключения невидимы.
Обработчики исключений в окружении обрабатывают исключения, возбуждаемые при выполнении последовательности операторов этого окружения.
Исключения обрабатываются тем обработчиком, в выборах которого заданы имена этих исключений.
В каждом обработчике исключений и в последовательностях операторов окружения допустимы одни и те же виды операторов.
Например, оператор возврата допустим в обработчике, если окружение является телом функции.
Оператор возбуждения возбуждает исключение.
При выполнении оператора возбуждения с именем исключения возбуждается заданное исключение.
Оператор возбуждения без имени исключения допустим только внутри обработчика исключения
(но не в последовательности операторов подпрограммы, пакета, задачного модуля или настраиваемого модуля, вложенных в данный обработчик);
он снова возбуждает то же исключение, которое вызвало переход на обработчик, содержащий данный оператор возбуждения.
После возбуждения исключения нормальное выполнение программы прекращается и управление, передаётся обработчику исключения.
Выбор обработчика зависит от места возбуждения: при выполнении операторов или при предвыполнении описаний.
Обработка исключения, возбуждаемого при выполнении последовательности операторов, зависит от того, вложена ли она в самое внутреннее окружение или в оператор принятия.
Случай вложенности в оператор принятия описан в разд.
11.5.
Здесь рассмотрен первый случай.
Предпринимаемые действия зависят от того, содержит ли данное окружение обработчик этого исключения и возбуждено ли исключение в последовательности операторов окружения или обработчика исключения.
Если некоторое исключение возбуждено в последовательности операторов окружения, содержащего нужный обработчик, то выполнение этой последовательности операторов прекращается и управление передаётся обработчику данного исключения.
Выполнение последовательности операторов обработчика заканчивает выполнение окружения
(или предвыполнение, если окружение — тело пакета).
Если исключение возбуждено в последовательности операторов окружения, не содержащего обработчик этого исключения, то выполнение последовательности операторов прекращается.
Дальнейшие действия зависят от природы окружения:
Для тела подпрограммы — то же исключение повторно возбуждается в точке вызова этой подпрограммы, кроме случаев, когда она является главной программой.
Тогда выполнение главной программы прекращается.
Для оператора блока — то же исключение повторно возбуждается непосредственно после оператора блока
(т.е. в самом вложенном объемлющем окружении или в операторе принятия, содержащем этот оператор блока).
Для тела пакета, являющегося дополнительным элементом описания, — то же исключение повторно возбуждается непосредственно после этого элемента описания (в объемлющем разделе описаний).
Если тело этого пакета описано как субмодуль, то исключение повторно возбуждается на месте соответствующего следа тела.
Если пакет является библиотечным модулем, то выполнение главной программы прекращается.
Для тела задачи — задача становится законченной.
Говорят, что повторно возбуждённое исключение (как это рассмотрено в пунктах а), б) и в)) распространяется либо выполнением подпрограммы, либо выполнением оператора блока, либо предвыполнением тела пакета.
В случае тела задачи распространения не происходит.
Если окружение является подпрограммой или оператором блока и если оно содержит зависимые задачи, то распространение исключения происходит только после завершения зависимых задач.
Наконец, если исключение возбуждено в последовательности операторов обработчика исключения, то выполнение этой последовательности операторов прекращается.
Последующие действия (включая возможное распространение) зависят от природы окружения и выполняются в соответствии с пунктах а) - г).
Если при умножении возбуждается исключение NUMERIC_ERROR, то значение FLOAT'SAFE- LARGE возвращается обработчиком исключения.
Это значение будет вызывать возбуждение исключения NUMERIC_ERROR при вычислении выражения в каждом из оставшихся обращений к этой функции.
Таким образом, для больших значений N эта функция всегда будет возвращать значение FLOAT'SAFE-LARGE.
Могут возникнуть следующие случаи:
Если исключение ERROR возбуждено при выполнении последовательности операторов внешней процедуры P, то выполнение процедуры Р заканчивает обработчик Е1, расположенный внутри Р.
Если исключение ERROR возбуждено при выполнении последовательности операторов процедуры Q, то обработчик Е2, расположенный внутри Q, закончит её выполнение.
По окончании выполнения этого обработчика управление будет возвращено в точку вызова процедуры Q.
Если исключение ERROR возбуждено в теле процедуры R, вызываемой из процедуры Q, то выполнение процедуры R прекращается и то же самое исключение возбуждается в теле Q.
Затем обработчик Е2 заканчивает выполнение процедуры Q, как и в случае 2.
Заметим, что в случае 3 возбуждение исключения в R приводит (косвенно) к передаче управления обработчику, являющемуся частью Q и, следовательно, не вложенному в R.
Заметим также, что если бы внутри R был задан обработчик с выбором others, то в случае 3 вместо непосредственного завершения R выполнился бы этот обработчик.
Наконец, если бы исключение ERROR было описано в R, а не в Р, то обработчики Е1 и Е2 не могли бы обеспечивать обработку исключения ERROR, так как этот идентификатор не был бы видимым внутри тел Р и Q.
В случае 3, однако, это исключение могло бы быть обработано в Q с помощью обработчика с выбором исключения others.
В языке не определено, что происходит после прекращения выполнения главной программы в результате необработанного исключения.
Предопределённые исключения — это исключения, которые могут распространяться базовыми и предопределёнными операциями.
Случай, когда окружением является настраиваемый модуль, уже был учтён в правилах для тел подпрограмм и пакетов, так как последовательность операторов такого окружения не выполняется, а служит шаблоном для конкретизации настройки соответствующей последовательности операторов подпрограммы или пакета.
Если исключение возбуждено при предвыполнении раздела описаний данного окружения, то это предвыполнение прекращается.
Дальнейшее действие зависит от природы окружения.
Для тела подпрограммы — то же исключение повторно возбуждается в точке вызова подпрограммы, кроме случая, когда эта подпрограмма является главной программой, — тогда её выполнение прекращается.
Для оператора блока — то же исключение повторно возбуждается непосредственно после оператора блока.
Для тела пакета, являющегося дополнительным элементом описания, — то же исключение повторно возбуждается непосредственно после этого элемента описания в объемлющем разделе описаний.
Если тело пакета является субмодулем, то исключение повторно возбуждается на месте соответствующего следа тела.
Если пакет является библиотечным модулем, то выполнение главной программы прекращается.
Для тела задачи — задача становится законченной, а в точке активизации задачи возбуждается исключение TASKING_ERROR; как пояснено в разд.
9.3.
Если исключение возбуждается во время предвыполнения либо описания пакета, либо описания задачи, то это предвыполнение прекращается;
дальнейшее действие зависит от природы описания.
Для описания пакета или задачи, являющегося элементом описания, — то же исключение повторно возбуждается непосредственно после этого элемента описания в объемлющем разделе описаний или в спецификации пакета.
Для описания библиотечного пакета — выполнение главной программы прекращается.
Говорят, что повторно возбуждаемое исключение (как рассмотрено выше в пунктах а) — г)) распространено либо выполнением подпрограммы или оператора блока, либо предвыполнением описания пакета, описания задачи или тела пакета.
Пример исключения в разделе описания оператора блока (случай б}):
Исключение может распространяться на взаимодействие задач или на попытку начать взаимодействие одной задачи с другой.
Исключение может также распространяться на вызывающую задачу, если оно было возбуждено в процессе рандеву.
Когда задача вызывает вход другой задачи, то в точке этого вызова в вызывающей задаче возбуждается исключение TASKING_ERROR, если вызванная задача закончена до принятия вызова входа или к времени этого вызова.
Рандеву может иметь аварийное окончание в двух случаях:
если исключение возбуждено в операторе принятия и не обработано во внутреннем окружении.
В этом случае выполнение оператора принятия прекращается, и то же исключение повторно возбуждается непосредственно после оператора принятия в вызванной задаче;
исключение также распространяется на вызывающую задачу в точку вызова входа,
если задача, содержащая оператор принятия, закончена аварийно в результате выполнения оператора прекращения.
В этом случае исключение TASKING - ERROR возбуждается в вызывающей задаче в точке вызова входа.
С другой стороны, если задача, вызывающая вход, аварийно прекращает своё выполнение (в результате выполнения оператора прекращения), то в вызванной задаче исключение не возбуждается.
Если рандеву ещё не началось, то вызов входа аннулируется.
Если же рандеву началось, то оно заканчивается нормально, и это никак не влияет на вызванную задачу.
В данном разделе описаны условия, при которых в реализации можно выполнять те или иные действия раньше или позже, чем это определено правилами языка.
В целом, если правила языка задают порядок некоторых действий [канонический порядок}, реализация может использовать альтернативный порядок при гарантии, что такое переупорядочивание не скажется на результате выполнения программы.
В частности, если при выполнении программы в каноническом порядке не возбуждается никакое исключение, то также никакие исключения не должны возбуждаться при выполнении переупорядоченной программы.
С другой стороны, если порядок некоторых действий не определён языком, то реализация может использовать любой порядок.
(Например, аргументы предопределённой операции могут вычисляться в любом порядке, так как правила из разд.
4.5 не требуют определённого порядка выполнения.)
Реализации предоставляется дополнительная свобода для переупорядочивания действий, включающих предопределённые или базовые операции, за исключением присваивания.
Эта свобода предоставляется даже в том случае, если при выполнении предопределённых операций может распространяться (предопределённое) исключение с учётом следующих правил:
С целью установления, одинаков ли результат выполнения некоторых действий в каноническом или альтернативном порядке, можно предположить, что ни одна из вызванных этими действиями предопределённых операций не распространяет (предопределённые) исключения, и при этом выполняются два следующих требования к реализации альтернативного порядка: во-первых, операция не должна вызываться в альтернативном порядке, если она не вызывается в каноническом порядке;
во-вторых, самое внутреннее объемлющее окружение или оператор принятия для каждой операции должны быть одинаковы для канонического и альтернативного порядков с теми же самыми обработчиками исключений.
Связь знака операций с операндами в выражении определена синтаксисом.
Однако для последовательности предопределённых операций с одним и тем же приоритетом (при отсутствии скобок, вводящих особые связи) эти связи могут быть изменены (и это допускается) при выполнении следующего требования: результат целого типа должен быть эквивалентен результату вычислений в каноническом порядке слева направо;
результат вещественного типа должен принадлежать модельному интервалу результата, полученного после выполнения в каноническом порядке слева направо (см. 4.5.7).
Такое переупорядочивание допустимо даже тогда, когда может быть устранено некоторое исключение или вставлено предопределённое исключение.
Также дополнительная свобода предоставляется реализации при вычислении простых числовых выражений.
При выполнении предопределённых операций в реализации допускается использование операций над типами, которые имеют более широкий диапазон результата, чем базовый тип операндов, при условии, что это приводит к точному результату (или результату с заданной точностью для вещественного типа), даже если промежуточные результаты выходят за границы базового типа.
В таком случае нет необходимости возбуждать исключение NUMERIC_ERROR.
В частности, если числовое выражение является операндом предопределённой операции отношения и может быть получен правильный результат типа BOOLEAN, то в процессе вычисления можно не возбуждать исключение NUMERIC_ERROR.
Нет необходимости в выполнении предопределённой операции, если её единственным возможным результатом является распространение предопределённого исключения.
Аналогично, нет необходимости в выполнении предопределённой операции, если изменение последовательности операций по описанным выше правилам приводит к её безрезультатному выполнению.
Правило б) применимо к предопределённым операциям, но неприменимо к формам управления с промежуточной проверкой.
Выражение SPEED < 300_000.0 может быть заменено на TRUE, если значение 300-000.0 находится вне границ базового типа для SPEED, даже если неявное преобразование этого числового литерала может возбудить исключение NUMERIC_ERROR.
Вычисление А(К) может быть выполнено до цикла и, возможно, непосредственно перед оператором присваивания (1), даже если в нем может возбуждаться исключение.
Следовательно, внутри обработчика исключения значение N будет либо неопределённым, либо результатом последнего присваивания.
С другой стороны, вычисление А(К) не может быть выполнено до begin, поскольку в этом случае исключение будет обрабатываться другим обработчиком.
По этой причине инициализация N в описании будет исключать возможность наличия неопределённого начального значения N в обработчике.
Присутствие прагмы SUPPRESS позволяет реализации опускать некоторые проверки во время выполнения программы.
Эта прагма имеет следующий вид:
Проверка, указанная идентификатором, может быть опущена.
Имя (если оно присутствует) должно быть простым или расширенным и обозначать объект, тип или подтип, задачный модуль или настраиваемый модуль;
оно также может быть именем подпрограммы, в этом случае имя обозначает все видимые совмещённые подпрограммы.
Прагма SUPPRESS допустима непосредственно в разделе описаний или непосредственно в спецификации пакета.
Во втором случае допустимо представление прагмы только с именем, которое обозначает понятие (или несколько совмещённых подпрограмм), описанное непосредственно в спецификации пакета.
Действие прагмы распространяется от местоположения прагмы до конца зоны описания, связанной с самым внутренним объемлющим оператором блока или программным модулем.
Если прагма задана в спецификации пакета, то её действие распространяется до конца области действия именованного понятия.
Если в прагму включено имя, то возможность подавления проверки в дальнейшем ограничена: прагма действует только для операций над объектом с этим именем или над всеми объектами базового типа для указанного в прагме имени типа или подтипа, для вызовов подпрограмм с этим именем, для активизации задач указанного именем задачного типа и для конкретизации указанного настраиваемого модуля.
Следующие проверки соответствуют ситуациям, в которых может быть возбуждено исключение CONSTRAINT_ERROR.
В этих проверках имя (если оно указано) должно обозначать объект или тип
Проверяется именуемая компонента, индексируемая компонента, отрезок или атрибут объекта, указанный ссылочным значением на неравенство значению null этого ссылочного значения.
Проверяется, что дискриминант составного значения удовлетворяет ограничению дискриминанта.
Также при ссылке на компоненты записи проверяется их существование для текущих значений дискриминанта.
Проверяется, что границы значений индексов массива равны соответствующим границам ограничения индекса.
Также при ссылке на компоненту массива по каждой размерности проверяется, что данное значение индекса находится в диапазоне, определённом границами индекса массива.
При ссылке на отрезок массива проверяется, что заданный дискретный диапазон совместим с диапазоном, определённым границами индексов массива.
Проверяется, что каждой компоненте массива соответствует подходящая компонента при выполнении присваивания массиву, преобразовании типа и выполнении логических операций над массивами логических компонент.
Проверяется, что некоторое значение удовлетворяет ограничению диапазона.
Также при предвыполнении указания подтипа проверяется совместимость ограничения (если оно имеется) с обозначением типа.
Для агрегата проверяется принадлежность индекса или дискриминанта соответствующему подтипу.
Наконец, осуществляются проверки любых ограничений, создаваемых при конкретизации настройки.
Следующие проверки соответствуют ситуациям, в которых возбуждается исключение NUMERIC_ERROR.
Допустимыми именами в соответствующих прагмах являются имена числовых типов.
Проверяется, что второй операнд операций /, rem и mod не равен нулю.
Проверяется, что в результате выполнения числовой операции не возникает переполнения.
Следующие проверки соответствуют ситуациям, в которых возбуждается исключение PROGRAM - ERROR.
Допустимыми именами в соответствующих прагмах являются имена задачных модулей, настраиваемых модулей или подпрограмм.
Когда вызывается подпрограмма, выполняется активизация задачи или предвыполняется конкретизация настройки, то проверяется, что тело соответствующего программного модуля уже предвыполнено.
Следующие проверки соответствуют ситуациям, в которых возбуждается исключение STORAGE_ERROR.
Допустимыми именами в соответствующих прагмах являются имена, обозначающие ссылочные типы, задачные модули или подпрограммы.
Проверяется, что выполнение генератора не потребует объёма памяти, большего, чем необходимо для потребления.
Проверяется, что требуемый под задачу или для подпрограммы объем памяти не превышает ограничений.
Если возникает ошибочная ситуация в отсутствие проверок во время выполнения программы, то программа считается ошибочной
(результаты выполнения не определяются в языке).
Для некоторых реализации может оказаться невозможным или слишком дорогим подавление некоторых проверок.
Тогда соответствующая прагма SUPPRESS может быть проигнорирована.
Следовательно, наличие такой прагмы внутри данного модуля не гарантирует, что соответствующее исключение не будет возбуждено;
эти исключения также могут распространяться вызванными модулями.
Настраиваемый модуль — это программный модуль, являющийся настраиваемой подпрограммой или настраиваемым пакетом.
Настраиваемый модуль — это шаблон с параметрами или без них, по которому могут быть получены соответствующие (ненастраиваемые) подпрограммы или пакеты.
Итоговые программные модули называются экземплярами исходного настраиваемого модуля.
Настраиваемый модуль задаётся описанием настройки.
Эта форма описаний имеет раздел формальных параметров настройки, описывающий эти параметры.
Конкретный экземпляр настраиваемого модуля получается в результате конкретизации настройки путём сопоставления формальным параметрам фактических.
Экземпляр настраиваемой подпрограммы — это подпрограмма.
Экземпляр настраиваемого пакета — пакет.
Настраиваемые модули — это шаблоны.
Как шаблоны они не обладают свойствами, характерными для их ненастраиваемых аналогов.
Например, настраиваемая подпрограмма может быть конкретизирована, но не может быть вызвана.
В отличие от неё экземпляр настраиваемой подпрограммы может быть вызван, но не может использоваться для изготовления других экземпляров.
Описание настройки задаёт настраиваемый модуль — настраиваемую подпрограмму или настраиваемый пакет.
Описание настройки включает раздел формальных параметров настройки, в котором описываются её формальные параметры.
Формальный параметр настройки может быть объектом;
кроме того (в отличие от параметра подпрограммы), он может быть типом или подпрограммой.
Для ссылки на соответствующие формальные параметры настройки используются такие термины: формальный объект настройки (или, короче, формальный объект}, формальный тип настройки (или, короче, формальный тип) и формальная подпрограмма настройки (или, короче, формальная подпрограмма}.
В разделе формальных параметров настройки указание подтипа допустимо только в виде обозначения типа
(т.е. такое указание подтипа не должно содержать явного ограничения).
Обозначение настраиваемой подпрограммы должно быть задано идентификатором.
Имя программного модуля, являющегося настраиваемым модулем, вне его спецификации и тела обозначает этот настраиваемый модуль.
В отличие от этого в зоне описания, связанной с настраиваемой подпрограммой, имя такого программного модуля обозначает подпрограмму, полученную при текущей конкретизации настраиваемого модуля.
Аналогично в зоне описания, связанной с настраиваемым пакетом, имя программного модуля обозначает пакет, полученный при текущей конкретизации.
Предвыполнение описания настройки не имеет другого эффекта.
Примеры разделов формальных параметров:
Примеры описаний настройки с настраиваемыми подпрограммами:
Пример описания настройки с настраиваемым пакетом:
Внутри тела настраиваемой подпрограммы её имя рассматривается как имя подпрограммы.
Следовательно, это имя может быть совмещено, а также может появиться в рекурсивном вызове текущей конкретизации.
По этой же причине его нельзя использовать после зарезервированного слова new в (рекурсивной) конкретизации настройки.
Выражение, которое находится в разделе формальных параметров настройки, — это выражение по умолчанию для формального параметра вида in, либо составная часть имени входа, заданного как имя по умолчанию для формальной подпрограммы, либо выражение по умолчанию для параметра формальной подпрограммы.
В первых двух случаях значение этого выражения вычисляется только в тех конкретизациях, в которых используется соответствующее умолчание.
В третьем случае значение выражения вычисляется только в вызовах формальных подпрограмм, использующих такое умолчание.
(К любому имени, используемому в выражении по умолчанию, применяются обычные правила видимости: обозначенные этим именем понятия должны быть видимы в том месте, где стоит выражение.)
Ни формальные параметры настройки, ни их атрибуты в качестве частей статических выражений недопустимы (см. 4.9).
Первая форма описания формального параметра настройки задаёт формальные объекты настройки.
Тип формального объекта настройки — это базовый тип обозначения типа, данного в описании формального параметра настройки.
Описание формального параметра настройки с несколькими идентификаторами эквивалентно последовательности единичных описаний, как поясняется в разд.
3.2.
Формальный объект настройки имеет вид in или in out.
При отсутствии в описании формального параметра настройки явного указания вида подразумевается вид in.
Если описание формального параметра настройки задано выражением, то оно является выражением по умолчанию для этого формального параметра.
Выражение по умолчанию допустимо только для параметров вида in
(указанного либо явно, либо неявно).
Тип выражения по умолчанию должен быть таким же, как и у соответствующего формального параметра настройки.
Формальный объект настройки вида in — это константа, значение которой является копией значения сопоставленного ему фактического параметра конкретизации настройки, как описано в разд.
12.3.
Тип формального объекта настройки вида in не должен быть лимитируемым типом;
подтип 'такого формального объекта настройки — это подтип в обозначении типа, данного в описании параметра настройки.
Формальный объект настройки вида in out — это переменная, обозначающая объект, задаваемый в конкретизации настройки фактическим параметром настройки, как описано в разд.
12.3.
Ограничения, применяемые к формальному объекту настройки, те же, что и для соответствующего фактического параметра.
Ограничения, применяемые к формальному объекту настройки вида in out, те же, что и для соответствующего фактического параметра
(а не те, которые связаны с обозначением типа из описания параметра настройки).
Во избежание путаницы рекомендуется, когда это возможно, использовать в описании такого формального объекта имя базового типа.
Если, однако, базовый тип анонимный, то рекомендуется использовать имя подтипа, определённого в описании базового типа.
Описание параметра настройки, включающее определение настраиваемого типа или описание личного типа, задаёт формальный тип настройки.
Формальный тип настройки обозначает подтип, заданный соответствующим фактическим параметром в конкретизации настройки, как описано в пункте г) разд.
12.3.
В настраиваемом модуле формальный тип настройки рассматривается как некоторый уникальный тип, отличный от всех остальных (формальных или нет) типов.
Форма ограничения, применимого к формальному типу в указании подтипа, зависит от класса типа, как и для типов, не являющихся формальными.
В описании формального (ограниченного) индексируемого типа настройки в качестве формы дискретного диапазона допустимо только обозначение типа.
Раздел дискриминантов формального личного типа настройки не должен включать выражение по умолчанию для дискриминанта.
(Следовательно, переменная, заданная описанием объекта, должна быть ограничена, если её тип — это формальный тип настройки с дискриминантами.)
В описании и теле настраиваемого модуля операции, которые можно выполнять над значениями формального типа настройки (кроме дополнительных операций, заданных формальными подпрограммами настройки), определяются описанием параметра настройки для этого формального типа.
Для описания личного типа разрешены операции, определённые в разд.
7.4.2
(в частности, для личного, но нелимитируемого типа — присваивание, равенство и неравенство).
Для определения индексируемого типа разрешены операции, определённые в разд.
3.6.2
(например, они включают формирование индексируемых компонент и отрезков).
Для определения ссылочного типа разрешены операции, определённые в разд.
3.8.2
(например, могут быть использованы генераторы).
Четыре формы определения настраиваемого типа, в которых содержится бокс (т.е. составной ограничитель о), соответствуют следующим основным формам скалярного типа:
Для дискретного типа: (<>)
Разрешённые операции — общие для перечисленных и целых типов;
они определены в разд.
3.5.5.
Для целого типа: range <>
Разрешённые операции над целыми типами определены в разд.
3.5.5.
Для плавающего типа: digits <>
Разрешённые операции определены в разд.
3.5.8.
Для фиксированных типов; delta <>
Разрешённые операции определены в разд.
3.5.10.
Во всех случаях, пунтках а) — е), каждая операция, неявно связанная с формальным типом (т.е. отличная от операции, заданной формальной подпрограммой), считается неявно описанной в месте описания формального типа.
Это же относится и к формальному фиксированному типу, исключая мультипликативные операции, которые возвращают результат универсального фиксированного типа (см. 4.5.5), так как эти специальные операции описаны в пакете STANDARD.
При конкретизации настройки каждая из этих операций — соответствующая базовая операция или предопределённая операция для сопоставленного фактического типа.
Для операции это правило сохраняется даже в случае переопределения её для фактического типа или некоторого его родительского типа.
Примеры формальных типов настройки:
Пример раздела формальных параметров настройки с описанием формального целого типа:
Описание параметра настройки, включающее спецификацию подпрограммы, описывает формальную подпрограмму настройки.
В описании формальной подпрограммы настройки могут встречаться две формы умолчания.
В них после спецификации подпрограммы следует зарезервированное слово is и либо бокс, либо имя подпрограммы или входа.
Правила сопоставления для таких умолчаний описаны в разд.
12.3,6.
Формальная подпрограмма настройки обозначает подпрограмму, литерал перечисления или вход, заданный соответствующим фактическим параметром настройки в конкретизации настройки, как описано в разд.
12.3.6.
Примеры формальных подпрограмм настройки:
Ограничения на параметр формальной подпрограммы те же, что у соответствующего параметра в спецификации сопоставленной фактической подпрограммы
(а не те, которые вводятся соответствующим обозначением типа в спецификации формальной подпрограммы).
Это же относится и к результату функции.
Во избежании путаницы рекомендуется везде, где можно, в описании формальной подпрограммы использовать имя базового типа, а не имя подтипа.
Если, однако, базовый тип — анонимный, то рекомендуется использовать имя подтипа, определённое в описании типа.
Тип, заданный для формального параметра формальной подпрограммы настройки, может быть любым видимым типом, включая формальный тип настройки из того же раздела формальных параметров настройки.
Тело настраиваемой подпрограммы или настраиваемого пакета (настраиваемое тело) является шаблоном для тел соответствующих подпрограмм или пакетов, получаемых конкретизацией настройки.
Синтаксис настраиваемого тела идентичен обычному телу.
Для каждого описания настраиваемой подпрограммы должно быть соответствующее тело.
Предвыполнение настраиваемого тела не имеет другого эффекта, кроме установления того, что тело начиная с этого момента может быть использовано в качестве шаблона для получения соответствующих экземпляров.
Пример настраиваемого тела процедуры:
Пример тела настраиваемой функции:
Пример тела настраиваемого пакета:
Экземпляр настраиваемого модуля описывается конкретизацией настройки.
Для каждого формального параметра настройки должен быть задан явный фактический параметр настройки, кроме случая, когда соответствующим описанием параметра настройки задана форма умолчания.
Сопоставление параметров настройки может быть либо позиционным, либо именованным (как в вызове подпрограммы (см. 6.4)).
Если две или несколько формальных подпрограмм имеют одно и то же обозначение, то для соответствующих параметров настройки именованные сопоставления недопустимы.
Каждый фактический параметр настройки должен быть сопоставлен с соответствующим формальным параметром.
Выражение может быть сопоставлено с формальным объектом вида in;
имя переменной может быть сопоставлено с формальным объектом вида in out;
имя подпрограммы или имя входа может сопоставляться с формальной подпрограммой;
обозначение типа может сопоставляться с формальным типом.
Детальные правила, определяющие единственные допустимые сопоставления, даны в разд.
12.3.1 — 12.3.6.
Экземпляр — это копия настраиваемого модуля без его раздела формальных параметров настройки;
таким образом, экземпляр настраиваемого пакета — пакет, настраиваемой процедуры — процедура, настраиваемой функции — функция.
Для каждого вхождения обозначающего данное понятие имени в настраиваемый модуль следующий список определяет, какое понятие соответствует этому имени в экземпляре.
Имя обозначает настраиваемый модуль: соответствующее вхождение обозначает экземпляр.
Имя обозначает формальный объект настройки вида in: соответствующее в экземпляре имя обозначает константу, значение которой — копия значения сопоставленного фактического параметра настройки.
Имя обозначает формальный объект настройки вида in out: соответствующее в экземпляре имя обозначает переменную, указанную сопоставленным фактическим параметром настройки.
Имя обозначает формальный тип настройки: соответствующее в экземпляре имя обозначает подтип, указанный сопоставленным фактическим параметром настройки (фактическим подтипом).
Имя обозначает дискриминант формального типа настройки: соответствующее в экземпляре имя обозначает соответствующий дискриминант (он должен быть один) фактического типа, сопоставленного формальному типу настройки.
Имя обозначает формальную подпрограмму настройки: соответствующее в экземпляре имя обозначает подпрограмму, литерал перечисления или вход, указанный сопоставленным фактическим параметром настройки (фактической подпрограммой).
Имя обозначает формальный параметр формальной подпрограммы настройки: соответствующее в экземпляре имя обозначает соответствующий формальный параметр фактической подпрограммы, соответствующей формальной подпрограмме.
Имя обозначает локальное понятие, описанное в настраиваемом модуле: соответствующее в экземпляре имя обозначает понятие, описанное соответствующим локальным описанием в экземпляре.
Имя обозначает глобальное понятие, описанное вне настраиваемого модуля: соответствующее в экземпляре имя обозначает это же глобальное понятие.
Те же правила справедливы для знаков операций и базовых операций; в частности, для формальных операций верно правило е), для локальных операций — правило з) и для операций над глобальными типами — правило и).
Кроме того, если в настраиваемом модуле используется предопределённая операция или базовая операция над формальным типом, то в экземпляре используется предопределённая операция, соответствующая фактическому типу, сопоставленному формальному.
Эти же правила применяются к обозначению типа и выражению (по умолчанию) из раздела формальных параметров настройки настраиваемого модуля.
При предвыполнении конкретизации настройки, сначала вычисляется каждое выражение, заданное в качестве явного фактического параметра настройки, и каждое выражение, входящее как составная часть в имя переменной или входа, заданное в качестве явного фактического параметра настройки;
в языке не определён порядок вычисления этих выражений.
Затем вычисляются выражения или имена по умолчанию для тех параметров, для которых опущены сопоставления параметров (если они есть) настройки;
эти вычисления производятся в порядке следования описаний формальных параметров настройки.
Наконец, предвыполняется неявно сгенерированный экземпляр.
Предвыполнение конкретизации настройки может также вызывать проверки некоторых ограничений, как описано ниже.
Рекурсивная конкретизация настройки недопустима в следующем смысле: если данный настраиваемый модуль включает конкретизацию другого настраиваемого модуля, то экземпляр, сгенерированный этой конкретизацией, не должен включать экземпляр первого настраиваемого модуля
(независимо от того, генерируется ли этот экземпляр непосредственно или косвенно через промежуточную конкретизацию).
Примеры конкретизации настройки (см. 12.1):
Примеры использования конкретизированных модулей:
Опускать параметр настройки допускается только тогда, когда для него существует умолчание.
Если использованы выражение по умолчанию или (отличные от простых) имена по умолчанию, то они вычисляются в том порядке, в котором описаны соответствующие формальные параметры настройки.
Если две совмещённые подпрограммы описаны в спецификации настраиваемого пакета и различаются только (формальным) типом параметров и результата, то существуют правильные конкретизации, для которых все вызовы этих подпрограмм вне экземпляра будут неоднозначными.
Например:
Формальному параметру настройки вида in данного типа сопоставляется выражение этого же типа.
Если настраиваемый модуль имеет формальный объект настройки вида in, то проверяется принадлежность значения выражения подтипу, заданному обозначением типа, как и для явного описания константы (см. 3.2.1).
При отрицательном результате проверки возбуждается исключение CONSTRAINT_ERROR.
Формальному параметру настройки вида in out данного типа сопоставляется имя переменной этого же типа.
Переменная не должна быть формальным параметром вида out или его подкомпонентой.
Имя должно обозначать такую переменную, для которой допустимо переименование (см. 8.5).
Тип фактического параметра настройки вида in не должен быть лимитируемым типом.
Ограничения формального параметра настройки вида in out являются ограничениями соответствующего фактического параметра настройки (см. 12.2.1).
Формальный личный тип настройки сопоставляется с типом или подтипом (фактическим подтипом), удовлетворяющим следующим условиям:
Если формальный тип не является лимитируемым, то фактический тип не должен быть лимитируемым.
(С другой стороны, если формальный тип является лимитируемым, то соответствующий фактический тип может быть лимитируемым и нелимитируемым.)
Если формальный тип имеет раздел дискриминантов, то фактический тип должен быть типом с таким же числом дискриминантов;
тип дискриминанта в данной позиции в разделе дискриминантов фактического типа должен совпадать с типом дискриминанта в той же позиции раздела дискриминантов формального типа;
фактический подтип должен быть неограниченным.
(С другой стороны, если формальный тип не имеет дискриминантов, для фактического типа дискриминанты допустимы.)
Ниже рассматривается вхождение имени формального типа в том месте, где оно использовано как указание неограниченного подтипа.
Фактический подтип не должен быть неограниченным индексируемым типом или неограниченным типом с дискриминантами, если любое вхождение находится на месте, где для индексируемого типа или типа с дискриминантами требуется либо ограничение, либо выражения по умолчанию для дискриминантов (см. 3.6.1 и 3.7.2).
Такое же требование предъявляется ко всем вхождениям имени подтипа формального типа, а также к вхождениям имени любого типа или подтипа, производного (непосредственно или косвенно) для этого формального типа.
Если настраиваемый модуль имеет формальный личный тип с дискриминантами, то при предвыполнении соответствующей конкретизации настройки проверяется совпадение подтипа каждого дискриминанта фактического типа и подтипа соответствующего дискриминанта формального типа.
При несовпадении таких подтипов возбуждается исключение CONSTRAINT_ERROR.
Формальному типу настройки, определённому символами (<>), сопоставляется любой дискретный подтип (т.е. любой перечислимый или целый подтип).
Формальному типу настройки, определённому символами range <>, сопоставляется любой целый подтип.
Формальному типу настройки, определённому символами digits <>, сопоставляется любой плавающий подтип.
Формальному типу настройки, определённому символами delta <>, сопоставляется любой фиксированный подтип.
Никакие другие сопоставления для этих формальных типов настройки невозможны.
Формальному индексируемому типу сопоставляется фактический индексируемый подтип, удовлетворяющий следующим условиям:
Формальный и фактический индексируемые типы должны иметь одинаковые размерности;
формальный тип и фактический подтип должны быть либо оба ограниченными, либо оба неограниченными.
Для каждой позиции индекса тип индекса фактического индексируемого типа должен совпадать с типом индекса формального индексируемого типа.
Типы компонент фактического и формального индексируемых типов должны быть одинаковыми.
Если тип компоненты отличен от скалярного, то подтипы компонент фактического и формального индексируемых типов должны быть либо оба ограниченными, либо оба неограниченными.
Если настраиваемый модуль имеет формальный индексируемый тип, то при предвыполнении соответствующей конкретизации проверяются совпадения ограничений (если они есть) на тип компоненты фактического индексируемого типа с ограничениями для формального индексируемого типа; для любой данной позиции индекса индексируемых подтипов или дискретных диапазонов проверяется совпадение границ.
При несовпадениях возбуждается исключение CONSTRAINT_ERROR.
Если тип любого индекса или тип компоненты формального индексируемого типа сам является формальным типом, то по приведённым правилам в экземпляре его имя обозначает соответствующий фактический подтип (см. 12.3 г)).
Формальному ссылочному типу сопоставляется фактический ссылочный подтип, если тип указываемых объектов для формального и фактического типов один и тот же.
Если указываемый тип отличен от скалярного, то указываемые подтипы должны быть либо оба ограниченными, либо оба неограниченными.
Если настраиваемый модуль имеет формальный ссылочный тип, то при предвыполнении соответствующей конкретизации проверяется совпадение любых ограничений на указанные объекты фактического и формального ссылочных типов.
При несовпадении возбуждается исключение CONSTRAINT_ERROR.
Если указанный тип сам является формальным, то в соответствии с описанными выше правилами в экземпляре его имя обозначает соответствующий фактический подтип (см. 12.3 г)).
Формальной подпрограмме сопоставляется фактическая подпрограмма, литерал перечисления или вход, если в первом и последнем случаях профиль типов параметров и результата один и тот же (см. 6.6) и виды формальных и фактических параметров в одинаковых позициях должны быть одинаковыми.
Если настраиваемый модуль имеет формальную подпрограмму, заданную именем, то это имя должно обозначать подпрограмму, литерал перечисления или вход, сопоставленные формальной подпрограмме (в указанном выше смысле).
Вычисление имени по умолчанию производится во время предвыполнения каждой конкретизации, в которой используется это умолчание, как определено в разд.
12.3.
Если настраиваемый модуль имеет подпрограмму по умолчанию, специфицированную как бокс, то соответствующий фактический параметр может быть опущен, если подпрограмма, литерал перечисления или вход, сопоставляемые формальной подпрограмме, имеют то же обозначение, что и формальная подпрограмма, и непосредственно на месте конкретизации должна быть видима единственная такая подпрограмма, или литерал перечисления, или вход.
Правила сопоставления для формальных подпрограмм устанавливают требования, которые подобны требованиям, применяемым к описаниям переименования подпрограмм (см. 8.5).
В частности, не требуется совпадения имён соответствующих параметров формальной и фактической подпрограмм;
аналогично для таких параметров не обязательно соответствие выражений по умолчанию.
Формальной подпрограмме сопоставляется атрибут типа, если этот атрибут — функция с сопоставимой спецификацией.
Литерал перечисления данного типа сопоставляется с формальной функцией без параметров и результатом данного типа.
В следующем примере использован настраиваемый пакет для одной из возможных организаций стеков.
Размер каждого стека и тип его элементов являются параметрами настройки.
Экземпляры настраиваемого пакета могут быть получены так:
После этого могут быть вызваны процедуры конкретизированных пакетов:
Возможна другая организация стека (тело пакета опущено):
При использовании такого пакета сначала должна быть осуществлена конкретизация, после чего можно описать стеки с элементами соответствующего типа:
В этой главе описываются спецификаторы представления, зависящие от реализации особенности, а также некоторые возможности, используемые в системном программировании.
Спецификаторы представления задают способ представления типов в объектной машине.
Они могут быть использованы для более эффективного представления или для интерфейса с внеязыковой сферой (например, с периферийным оборудованием).
Спецификатор представления типа применяется либо к типу, либо к первому именованному подтипу
(т.е. подтипу, идентифицированному описанием типа, базовый тип которого является анонимным).
Такой спецификатор представления применяется ко всем объектам данного типа или данного первого именованного подтипа.
Для конкретного типа допустимо не более одного спецификатора представления перечисления или записи; спецификатор представления перечисления допустим только для перечислимого типа; спецификатор представления записи — только для именуемого типа.
(С Другой стороны, для конкретного типа может быть задано более одного спецификатора длины;
более того, могут быть одновременно заданы спецификатор длины и спецификатор представления записи или перечисления.)
Спецификатор длины — это единственный из спецификаторов представления, допустимый для производного от родительского типа, имеющего (определённые пользователем) наследуемые подпрограммы.
Спецификатор адреса применяется либо к объекту, либо к подпрограмме, пакету или задачному модулю, либо к входу.
Для любого из этих понятий допустимо не более одного спецификатора адреса.
Спецификатор представления и описание понятия, к которому применяется спецификатор, должны оба находиться непосредственно в одном и том же разделе описаний, спецификации пакета или спецификации задачи;
описание должно помещаться до спецификатора.
В отсутствие спецификатора представления для данного описания реализация определяет представление по умолчанию.
Место нахождения такого подразумеваемого определения представления по умолчанию — не позже конца непосредственно объемлющего раздела описаний, спецификаций пакета или задачи.
Для описания из раздела описаний место нахождения подразумеваемого определения по умолчанию — до любого вложенного тела.
В случае типа некоторые вхождения его имени неявно предполагают, что представление типа уже должно быть определено.
Следовательно, такие вхождения требуют определения по умолчанию любого способа представления, ещё не определённого предшествующим спецификатором представления типа.
Аналогичные вхождения имени подтипа этого типа или имени любого типа или подтипа с подкомпонентами данного типа также требуют определения по умолчанию.
Требуемое вхождение — это любое вхождение, отличное от вхождения в описание типа или подтипа, спецификацию подпрограммы, описание входа, описание субконстанты, прагму или спецификатор представления для самого типа.
В любом случае вхождение в выражение является всегда требуемым.
Спецификатор представления для данного понятия не должен помещаться после вхождения имени понятия, если вхождение требует определения представления этого понятия по умолчанию.
Аналогичные ограничения существуют для спецификатора адреса.
Любое вхождение имени объекта (после описания объекта) требует определения представления.
Для подпрограммы, пакета, задачного модуля или входа любое вхождение атрибута представления таких понятий является требуемым вхождением.
Результат предвыполнения спецификатора аспектов представления — определение соответствующих представления.
Интерпретация некоторых выражений, помещённых в спецификаторах представления, зависит от реализации, например, выражений, задающих адреса.
Реализация может ограничивать использование спецификаторов представления лишь теми, которые можно просто обрабатывать на имеющемся оборудовании.
Для учитываемых реализации спецификаторов представления компилятор должен гарантировать независимость конечного результата работы программы от наличия или отсутствия таких спецификаторов представления, исключая спецификатор адреса и те разделы программы, где используются атрибуты представления.
Если программа содержит спецификатор представления, который не учитывается реализацией, она неправильна.
Для каждой реализации в приложении даются правила составления руководства по языку, в котором должны быть описаны допустимые ею спецификаторы представления и соглашения для выражений, зависящих от реализации.
Если спецификатор представления используется для того, чтобы предписывать некоторые характеристики отображения понятия в объектной машине, то для выбора такого отображения реализация может использовать прагмы.
Прагма PACK указывает, что минимизация размера памяти является главным критерием при выборе представления именуемого или индексируемого типа.
Её форма такова:
Упаковка означает, что промежутки между областями памяти, выделенные под последовательные компоненты, следует минимизировать.
Однако, упаковка не влияет на отображение в памяти каждой компоненты.
На отображение компонент можно повлиять прагмой (или спецификатором представления) для компоненты или типа компоненты.
Место прагмы PACK в программе и ограничения на именованный тип подчинены тем же правилам, что и для спецификатора представления;
в частности, прагма должна помещаться до любого использования атрибута представления упакованного понятия.
Прагма PACK — единственная определённая в языке прагма, связанная с представлением.
Реализация может вводить дополнительные прагмы;
они должны быть перечислены в приложении F.
(В отличие от спецификаторов представления прагма, которая не принята в реализации, игнорируется.)
Для формального типа настройки недопустим спецификатор представления.
Спецификатор длины задаёт объем памяти:
Выражение должно быть некоторого числового типа; оно вычисляется, при пред выполнении спецификатора длины
(кроме случая, когда оно является статическим).
Префикс атрибута должен обозначать либо тип, либо первый именованный подтип.
Далее этот префикс обозначается буквой Т.
В спецификаторе длины в качестве обозначений атрибутов допустимы только SIZE, STORAGE_SIZE и SMALL.
Результат применения спецификатора длины зависит от обозначения атрибута.
Спецификация размера: Т'SIZE
Выражение должно быть статическим некоторого целого типа.
Его значение определяет максимальное число битов, используемых для размещения в памяти объектов типа или первого именованного подтипа Т.
Спецификация размера должна задавать объем памяти, достаточный для размещения любого допустимого значения таких объектов.
Спецификация размера для составного типа может повлиять на размер промежутков между областями памяти, отводимыми под последовательные компоненты.
С другой стороны, нет необходимости влиять на размер области памяти, отводимой для каждой компоненты.
Спецификация размера допустима, только если ограничения на Т и его компоненты (если они есть) являются статическими.
Для неограниченного индексируемого типа статическими должны быть также подтипы индексов.
Спецификация размера набора: T'STORAGE_SIZE
Префикс Т должен обозначать ссылочный тип.
Выражение должно быть некоторого целого типа (но не обязательно статическим);
его значение определяет число квантов памяти, выделяемых для набора, т.е. объем памяти, необходимый для размещения всех объектов, указанных значениями ссылочного типа и значениями других типов, непосредственно или косвенно производных от ссылочного типа.
Эта форма спецификатора длины недопустима для типа, производного от ссылочного типа.
Спецификация объёма памяти для активизации задачи: T'STORAGE_SIZE
Префикс Т должен обозначать задачный тип.
Выражение должно быть некоторого целого типа (но не обязательно статическим);
его значение определяет число квантов памяти, выделяемых для активизации (но не для кода) задачи данного типа.
Спецификация наименьшего для фиксированных типов: Т'SMALL
Префикс Т должен обозначать первый именованный подтип фиксированного типа.
Выражение должно быть статическим некоторого вещественного типа;
его значение должно быть не больше, чем дельта этого первого поименованного подтипа.
Результат применения спецификатора длины — использование этого наименьшего значения для представления значений фиксированного базового типа.
(Спецификатор длины, таким образом, также влияет на выделенный для объектов этого типа объем памяти.)
Спецификация размера допустима для ссылочного, задачного или фиксированного типов независимо от того, задана или нет для такого типа какая-либо другая форма спецификатора длины.
От реализации зависит, что понимается под резервированием части памяти для набора или активизации задачи.
Поэтому управление с помощью спецификаторов длины зависит от соглашений в реализации.
Например, в языке не определено, включается ли в память, выделяемую для активизации задачи память, необходимая для размещения набора, сопоставленного ссылочному типу и описанному в теле задачи.
Метод распределения памяти под объекты, обозначенные значениями ссылочного типа, также не определяется.
Например, место может выделяться в стеке;
можно использовать схему настраиваемого динамического распределения памяти, или память может быть зафиксирована.
Размещённые объекты набора не обязаны занимать одинаковые размеры памяти, если указанный тип — это неограниченный индексируемый тип или неограниченный тип с дискриминантами.
Заметим также, что сам генератор может требовать некоторый объем памяти для размещения внутренних таблиц и связей.
Следовательно, спецификатор длины для набора ссылочного типа не всегда позволяет точно управлять максимальным числом генерируемых объектов.
Примечание к примерам.
В спецификаторе длины для SHORT минимально необходимы пятнадцать разрядов, так как определение типа требует SHORT'SMALL = 2.0**(-7) и SHORT'MANTISSA = 14.
Спецификатор длины для DEGREE вводит модельные числа, которые занимают в точности весь диапазон типа.
Спецификатор представления перечисления задаёт внутренние коды для литералов перечислимого типа, указанного в спецификаторе.
Используемый в спецификаторе агрегат записывается как одномерный агрегат, в кото ром подтип индекса — перечислимый тип, а тип компоненты — универсальный целый тип.
Для всех литералов перечислимого типа должны быть заданы различные целые коды, и все выборы и значения всех компонент в агрегате должны быть статическими.
Целые коды, заданные для перечислимого типа, должны удовлетворять предопределённому отношению упорядоченности типа.
Атрибуты SUCC, PRED и PCS определены даже для перечислимых типов с разрывным представлением;
их определение соответствует (логическому) описанию типа, и на них не влияет спецификатор представления перечисления.
В примере из-за того, что значения даны с пропуском, эти функции реализуются менее эффективно, чем это могло быть в отсутствие спецификатора представления.
Это же справедливо и при использовании таких типов для индексации.
Спецификатор представления записи задаёт представление записи в памяти, т.е. порядок, позицию и размер компонент записи (включая дискриминанты, если они есть).
Простое выражение, заданное в спецификаторе выравнивания после зарезервированных слов at mod или в спецификаторе компоненты после зарезервированного слова at, должно быть статическим некоторого целого типа.
Если в спецификаторе компоненты границы диапазона спецификатора компоненты определяются простыми выражениями, то каждая граница должна быть определена как статическое выражение любого целого типа; не обязательно, чтобы обе границы были одного и того же целого типа.
Спецификатор выравнивания требует, чтобы каждая запись данного типа была размещена начиная с адреса памяти, кратного значению данного выражения
(т.е. адрес по модулю выражения должен быть равен нулю).
Реализация может наложить ограничения на допускаемые выравнивания.
Спецификатор компоненты специфицирует для компоненты место в памяти относительно начала записи.
Значение целого типа, определённое статическим выражением в спецификаторе компоненты, — это относительный адрес, выраженный в квантах памяти.
Диапазон определяет позиции разрядов места памяти относительно этого кванта памяти.
Первый квант памяти для записи имеет нулевой номер.
Первый разряд кванта памяти тоже имеет нулевой номер.
Порядок разрядов в кванте памяти машинно-зависим, а их нумерация может переходить на соседние кванты.
(Для конкретной машины размер кванта памяти в разрядах задан с помощью зависящего от конфигурации именованного числа SYSTEM.STORAGE_UNIT.)
Допускается размещение одной компоненты записи в соседних квантах памяти, это размещение определяется реализацией.
Для каждой компоненты именуемого типа, включая каждый дискриминант, допустимо не более одного спецификатора компоненты.
Спецификаторы компонент могут быть даны для нескольких, всех или ни для одной из компонент.
Если для компоненты не задан спецификатор компоненты, то выбор места в памяти для компоненты определяется компилятором.
Если спецификаторы компонент даны для всех компонент, то спецификатор представления записи полностью задаёт представление именуемого типа и компилятор должен в точности следовать спецификатору.
Места в памяти для компонент в пределах одного варианта не должны перекрываться, но допускается перекрытие для различных вариантов.
Каждый спецификатор компоненты должен допускать достаточный размер памяти для размещения допустимого значения компоненты.
Спецификатор компоненты допустим только для такой компоненты, для которой любое ограничение, наложенное на него или на его подкомпоненты, является статическим.
Реализация может генерировать имена, обозначающие зависящие от реализации компоненты (например, компоненту, содержащую смещение другой компоненты).
Такие имена могут быть использованы в спецификаторах представления записей
(эти имена могут не быть простыми именами, например они могут быть зависящими от реализации атрибутами).
Примечание к примеру.
Спецификатор представления записи определяет размещение полей записи.
Спецификатор длины гарантирует, что при этом будет использовано точно восемь квантов памяти.
Спецификатор адреса задаёт адрес в памяти для понятия.
Выражение после зарезервированного слова at должно быть типа ADDRESS, определённого в пакете SYSTEM (см. 13.7).
Этот пакет должен быть именован в спецификаторе совместности компилируемого модуля, в котором помещается спецификатор адреса.
Условия, определяющие интерпретацию значения типа ADDRESS как адреса, уровня прерывания или чего-либо другого, зависят от реализации.
Ниже перечислены допустимые толкования простого имени и смысл соответствующего адреса:
имя объекта: требуемый адрес — адрес объекта (переменной или константы);
имя подпрограммы, пакета или задачного модуля: требуемый адрес — адрес машинного кода, связанного с телом программного модуля;
имя одиночного входа: адрес задаёт аппаратное прерывание, связанное с этим входом.
Если простое имя — это имя одиночной задачи, то спецификатор адреса относится к задачному модулю, а не к задачному объекту.
Во всех случаях спецификатор адреса является правильным только тогда, когда точно одно описание с этим идентификатором помещено раньше непосредственно в том же разделе описаний, спецификации пакета или спецификации задачи.
В качестве простого имени недопустимо имя, введённое описанием переименования.
Спецификаторы адреса не могут быть использованы для задания перекрытия объектов или перекрытия программных модулей.
Данное прерывание может быть связано не более чем с одним входом.
Любая программа, использующая такой спецификатор адреса, ошибочна.
Из приведённых правил следует, что если в данной точке программы видимы две совмещённые подпрограммы, то спецификатор адреса для каждой из этих подпрограмм является неправильным в данной точке.
Аналогично если в спецификации задачи описаны совмещённые друг с другом входы, то они не могут быть входами прерываний.
Для библиотечного модуля синтаксис не допускает спецификатора адреса.
Реализацией могут быть определены прагмы для обеспечения оверлейных перекрытий программ.
Спецификатор адреса для входа сопоставляет вход с некоторым устройством, которое может вызвать прерывание;
такой вход в этом разделе называется входом по прерыванию.
Если прерывание сопровождается управляющей информацией, то она передаётся соответствующему входу по прерыванию как один или несколько параметров входа вида in;
допустимы параметры только такого вида.
Прерывание действует как вызов входа некоторой связанной с оборудованием задачи, приоритет которой выше приоритета главной программы и любых определённых пользователем задач
(т.е. любой задачи, тип которой описан с помощью задачного модуля в программе).
Вызов входа может быть обычным, временным или условным вызовом входа в зависимости от вида прерывания и от реализации.
Если оператор отбора содержит как альтернативу завершения, так и альтернативу принятия входа по прерыванию, то реализация может наложить некоторые дополнительные требования на отбор альтернативы завершения в дополнение к требованиям, сформулированным в разд.
9.4.
Вызовы входа по прерыванию имеют только описанную выше семантику;
они могут быть реализованы с помощью аппаратуры, непосредственно выполняющей соответствующие операторы принятия.
Выстраиваемые в очередь прерывания соответствуют обычным вызовам входа.
Прерывания, которые теряются или немедленно не обрабатываются, соответствуют условным вызовам входов.
Из правил приоритетов следует, что оператор принятия, выполняемый в ответ на прерывание, имеет более высокий приоритет, чем определённые пользователями обычные задачи, и может быть выполнен без задачи, выполняющей планировку.
Одним из возможных результатов указания спецификатора адреса для входа по прерыванию является спецификация (непосредственно или косвенно) приоритета прерывания.
Допустимы прямые вызовы входов по прерыванию.
Для данного типа и данного аспекта его представления допустимо не более одного спецификатора представления.
Поэтому если желательно другое представление, то необходимо описать второй тип, производный от первого, и для него специфицировать другое представление.
Изменение представления может быть теперь достигнуто присваиванием с явным преобразованием типа:
Для каждой реализации имеется предопределённый библиотечный пакет SYSTEM, который включает определения некоторых характеристик, зависящих от конфигурации.
Спецификация пакета зависит от реализации и должна быть приведена в приложении F.
Видимый раздел этого пакета должен содержать по крайней мере следующие описания:
Тип ADDRESS — это тип адресов, задаваемых спецификаторами адреса;
к этому же типу принадлежат значения, вырабатываемые атрибутом ADDRESS.
Значения перечислимого типа NAME — это имена альтернативных машинных конфигураций, обрабатываемых реализацией;
одно из них — константа SYSTEM_NAME.
Именованное число STORAGE_UNIT равно числу разрядов в кванте памяти, а именованное число MEMORY_SIZE — числу квантов памяти, доступных в конфигурации; эти именованные числа имеют универсальный целый тип.
Альтернативная форма пакета SYSTEM с другими значениями SYSTEM_NAME, STORAGE_UNIT и MEMORY_SIZE может быть получена использованием соответствующих прагм.
Эти прагмы допустимы только в начале компиляции до первого компилируемого модуля (если он есть) компиляции.
В результате выполнения этой прагмы заданный идентификатором литерал перечисления будет использован для определения константы SYSTEM_NAME.
Эта прагма допустима, только если этот идентификатор соответствует одному из литералов типа NAME.
В результате выполнения этой прагмы заданное числовым литералом значение будет использовано для определения именованного числа STORAGE_UNIT.
В результате выполнения этой прагмы заданное числовым литералом значение будет использовано для определения именованного числа MEMORY_SIZE.
Компиляция любой из этих прагм вызовет неявную перекомпиляцию пакета SYSTEM.
Следовательно, любой компилируемый модуль, в спецификаторе контекста которого упоминается пакет SYSTEM, становится устаревшим.
Реализация может ввести дополнительные ограничения на использование этих прагм.
Например, реализация может допустить их только в начале первой компиляции, когда создаётся новая программная библиотека.
Согласно правилам видимости, описание из пакета SYSTEM видимо в компилируемом модуле только в том случае, если этот пакет упомянут в спецификаторе совместности, применённом (непосредственно или косвенно) к данному компилируемому модулю.
Перечисленные ниже именованные числа описаны в пакете SYSTEM.
Числа FINE_DELTA и TICK принадлежат универсальному вещественному типу, остальные — универсальному целому типу.
Наименьшее (наибольшее по модулю отрицательное) значение из всех определённых целых типов.
Наибольшее (положительное) значение из всех предопределённых целых типов.
Наибольшее допустимое значение числа значащих десятичных цифр в ограничении для плавающего типа.
Наибольшее возможное число двоичных цифр в мантиссе модельных чисел фиксированного подтипа.
Наименьшая дельта, допустимая в ограничении для фиксированного типа, которое имеет ограничение диапазона -1.0..1.0.
Базовый период времени, выраженный в секундах.
Значения некоторых зависящих от реализации характеристик могут быть определены с помощью соответствующих атрибутов представления.
Эти атрибуты описаны ниже.
Для любого объекта, программного модуля, метки или входа X:
Вырабатывает адрес первого кванта памяти, отведённой под X.
Для подпрограммы, пакета, задачного модуля или метки это значение ссылается на машинный код, связанный с соответствующим телом или оператором.
Для входа, для которого задан спецификатор адреса, это значение ссылается на соответствующее аппаратное прерывание.
Значение этого атрибута принадлежит типу ADDRESS, определённому в пакете SYSTEM.
Для любого типа или подтипа Х или для любого объекта X:
Применённый к объекту вырабатывает число битов, отводимых в памяти для размещения объекта.
Применённый к типу или подтипу вырабатывает минимальное число битов, необходимое реализации для размещения любого возможного объекта этого типа или подтипа.
Значение этого атрибута имеет тип универсальный целый.
Если префиксом атрибута является функция, то атрибут понимается как атрибут функции (а не как результат вызова функции).
Если тип префикса — ссылочный тип, то атрибут понимается как атрибут префикса
(а не указанного объекта: атрибуты этого объекта могут быть записаны с префиксом, оканчивающимся зарезервированным словом all).
Для любого компонента С записи R:
Вырабатывает величину смещения первого кванта памяти, занятого полем С, относительно первого кванта памяти, занятого записью R.
Величина смещения измеряется числом квантов.
Значение этого атрибута принадлежит универсальному целому типу.
Вырабатывает величину смещения первого бита, занятого полем С, относительно первого кванта памяти.
Величина смещения измеряется числом битов.
Значение этого атрибута имеет универсальный целый тип.
Вырабатывает величину смещения последнего бита, занятого полем С, относительно первого кванта памяти, занятого С.
Величина смещения измеряется числом битов.
Значение этого атрибута имеет универсальный целый тип.
Для любого ссылочного типа или подтипа Т:
Вырабатывает общее число квантов памяти, выделенных для набора, связанного с базовым типом Т.
Значение атрибута имеет универсальный целый тип.
Для любого задачного типа или объекта задачного типа Т:
Вырабатывает число квантов памяти, выделенных для каждой активизации задачи типа Т или активизации объекта Т задачного типа.
Значение этого атрибута имеет универсальный целый тип.
Для объекта Х задачного типа атрибут X'SIZE вырабатывает число разрядов, используемых для размещения объекта X; атрибут X'STORAGE_SIZE вырабатывает число квантов памяти, выделенных для активизации задачи, указанной X.
Для формального параметра Х в случае передачи параметра копированием Х'ADDRESS вырабатывает адрес локальной копии;
в случае передачи параметра ссылкой Х'ADDRESS вырабатывает адрес фактического параметра.
Для каждого вещественного типа или подтипа Т определены нижеследующие машинно-зависимые атрибуты, не связанные с модельными числами.
Использующие эти атрибуты программы могут получить некоторую дополнительную информацию о характеристиках числового типа
(см. разд.
4.5.7 о правилах определения точности операций с вещественными операндами).
Для обеспечения переносимости программ должна быть обеспечена известная осторожность в использовании таких машинно-зависимых атрибутов.
Атрибуты, применимые к плавающим и фиксированным типам:
Вырабатывает значение TRUE, если каждая предопределённая арифметическая операция над значениями базового типа Т либо возвращает точный результат, либо осуществляет округление.
В противном случае вырабатывает значение FALSE.
Значение этого атрибута имеет предопределённый тип BOOLEAN.
Вырабатывает значение TRUE, если каждая предопределённая операция над значениями базового типа Т либо возвращает точный результат, либо возбуждает исключение NUMERIC_ERROR при перевыполнении (см. 4.5.7);
в противном случае вырабатывает значение FALSE.
Значение этого атрибута имеет предопределённый тип BOOLEAN.
Следующие атрибуты дают характеристики машинного представления значений плавающего типа в терминах канонической формы, определённой в разд.
3.5.7:
Вырабатывает значение основания системы счисления, используемого в машинном представлении базового типа Т.
Значение этого атрибута имеет универсальный целый тип.
Вырабатывает наибольшее значение порядка в машинном представлении базового типа Т.
Значение этого атрибута имеет универсальный целый тип.
Вырабатывает наименьшее (наибольшее по модулю отрицательное) значение порядка в машинном представлении базового типа Т.
Значение этого атрибута имеет универсальный целый тип.
В большинстве машин наибольшее представимое в машине число типа Т равно X а наименьшее положительное представимое число в машине равно Y.
Машинные коды могут быть включены в программу с помощью вызова процедуры, последовательность операторов которой состоит из операторов кода.
Оператор кода допустим только в последовательности операторов тела процедуры.
Если в теле процедуры содержатся операторы кода, то в нем недопустимы никакие формы операторов, кроме операторов кода (помеченных или нет); из описаний допустимы только спецификаторы использования; недопустимы обработчики исключения
(комментарии и прагмы допустимы как обычно).
Каждая машинная команда записывается как агрегат именуемого типа, агрегат определяет эту команду.
Базовый тип обозначения типа в операторе кода должен быть описан в предопределённом пакете MACHINE_CODE;
этот пакет должен быть упомянут в спецификаторе контекста, помещаемом для компилируемого модуля, в который входит оператор кода.
Реализация не обязана обеспечивать такой пакет.
В реализации допустимо наложение дополнительных ограничений на допустимые в операторах кода агрегаты записи.
Например, можно требовать, чтобы выражения в агрегатах были статическими.
Реализация может определить машинно-зависимые прагмы, специфицирующие соглашения об использовании регистров и вызовов.
Такие прагмы должны быть описаны в приложении F.
Из программы, написанной на языке Ада, может быть вызвана подпрограмма, написанная на другом языке; все связи с этими подпрограммами обеспечиваются через параметры и результаты функций.
Для каждой такой подпрограммы должна быть задана следующая прагма:
Допустимо использование совмещённых имён подпрограмм.
Эта прагма допустима на месте элемента описания и должна применяться к подпрограмме, описанной ранее в этом же разделе описаний или спецификации пакета.
Прагма также допустима и для библиотечного модуля;
в этом случае прагма должна помещаться после описания подпрограммы, но до любого следующего компилируемого модуля.
Прагма задаёт другой язык (и тем самым соглашения о вызовах) и сообщает компилятору, что для такой подпрограммы будет задан объектный модуль.
Для таких подпрограмм недопустимо задание тела (даже в форме следа тела), так как его команды написаны на другом языке.
Эту возможность не обязательно обеспечивают все реализации.
Реализация может наложить ограничения на допускаемые формы и места параметров и вызовов.
Соглашения, использованные в других языковых процессорах, которые вызывают Ада-программы, не являются частью определения языка Ада.
Эти соглашения должны быть определены в описании других языковых процессоров.
Прагма INTERFACE не определена для настраиваемых подпрограмм.
Для неконтролируемого освобождения памяти и неконтролируемого преобразования типов используются предопределённые настраиваемые библиотечные подпрограммы: UNCHECKED_DEALLOCATION и UNCHECKED_CONVERSION.
В результате вызова процедуры, полученной конкретизацией настраиваемой процедуры UNCHECKED_DEALLOCATION, производится неконтролируемое освобождение памяти, занимаемой объектом, указанным значением ссылочного типа.
Например:
Такая процедура FREE даёт следующий результат:
после выполнения FREE(X) значением Х является null
если Х уже равно null, то FREE(X) не имеет другого результата
если Х не равно null, то FREE(X) обозначает, что указанный значением Х объект не требуется, и поэтому занимаемая им память может использоваться для других целей.
Если Х и Y указывают на один и тот же объект, то после вызова FREE(X) доступ к этому объекту (или попытка доступа к нему) через Y ошибочен;
язык не определяет, что происходит в результате такого доступа.
Согласно правилам видимости, настраиваемая процедура UNCHECKED_DEALLOCATION невидима в компилируемом модуле, если только её имя не указано в спецификаторе совместности этого компилируемого модуля.
Если Х указывает на объект задачного типа, то вызов FREE(X) никак не влияет на задачу, указанную значением этого объекта.
Это же относится и к любой подкомпоненте задачного типа объекта X.
Неконтролируемое преобразование типа можно осуществить вызовом функции, полученной конкретизацией настраиваемой функции UNCHECKED_CONVERSION.
Неконтролируемое преобразование типа состоит в возврате значения параметра в качестве значения целевого типа, т.е. поразрядное изображение, определяющее исходное значение, возвращается неизменным, как поразрядное изображение значения целевого типа.
Реализация может наложить ограничения на неконтролируемое преобразование типа, например ограничения, зависящие от предполагаемых размеров объектов исходного и целевого типов.
Такие ограничения должны быть отражены в приложении F.
При использовании неконтролируемых преобразований типов сам программист несёт ответственность за сохранность свойств, гарантируемых языком для объектов целевого типа.
Программы, нарушающие их свойства при неконтролируемых преобразованиях, являются ошибочными.
Согласно правилам видимости, настраиваемая функция UNCHECKED_CONVERSION невидима в компилируемом модуле, если она не упомянута в спецификаторе совместности этого компилируемого модуля.
Ввод-вывод в языке обеспечивается предопределёнными пакетами.
Настраиваемые пакеты SEQUENTIAL_IO и DIRECT_IO определяют операции ввода-вывода, которые применимы для файлов с элементами данного типа.
В пакете TEXT_IO даны дополнительные операции ввода-вывода текстов.
В пакете IO_EXCEPTIONS определены исключения, необходимые при работе трёх указанных пакетов.
Наконец, пакет LOW_LEVEL_IO позволяет осуществлять непосредственное управление периферийными устройствами.
Значения, вводимые из внешнего для программы окружения или выводимые в это окружение, размещаются во внешних файлах.
Внешним файлом может быть нечто внешнее по отношению к программе, которая может произвести читаемое значение или получить записываемое.
Внешний файл идентифицируется строкой {именем).
Вторая строка (форма) задаёт дополнительные системно-зависимые характеристики, которые могут быть сопоставлены с файлом, например физическая организация или права доступа.
Соглашения об интерпретации таких строк должны быть приведены в приложении F.
Операции ввода и вывода выражены операциями над объектами некоторого файлового типа, а не непосредственно в терминах внешних файлов.
Далее в этой главе термин файл будет всегда использоваться для ссылки на объект файлового типа;
в остальных случаях будет использоваться термин внешний файл.
Значения, передаваемые данному файлу, должны быть все одного и того же типа.
Ввод и вывод для последовательных файлов из элементов некоторого типа определены настраиваемым пакетом SEQUENTIAL_IO.
Общая структура этого пакета дана ниже.
Для определения последовательного ввода-вывода элементов данного типа должна быть описана конкретизация этого настраиваемого модуля с фактическим параметром данного типа.
Конкретизация настройки содержит описание файлового типа (названного FILE_TYPE) для файлов таких элементов, а также операции над этими файлами — например, процедуры OPEN, READ и WRITE.
Ввод-вывод для файлов прямого доступа определён аналогичным способом в настраиваемом пакете DIRECT_IO.
Ввод-вывод в текстовой форме определён в (ненастраиваемом) пакете TEXT_IO.
До выполнения ввода или вывода как операции над файлом должна быть установлена связь файла с внешним файлом.
Когда такая связь установлена, файл называется открытым, в противном случае — закрытым.