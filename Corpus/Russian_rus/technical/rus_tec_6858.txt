# language_name_wals:	Russian
# language_name_glotto:	Russian
# iso639_3:	rus
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Cyrl
# special_characters:	NA
# short_description:	KDE4
# source:	https://object.pouta.csc.fi/OPUS-KDE4/v2/raw/ru.zip
# copyright_short:	http://opus.nlpl.eu/KDE4.php
# copyright_long:	http://opus.nlpl.eu/KDE4.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

Андрей Балагута uj2@ mail. ru Перевод на русский Алексей Опарин opaleksej@ yandex. ru Перевод на русский
Подсветка синтаксиса
Обзор
Синтаксическая подсветка позволяет отображать текст в редакторе разными цветами и стилями, таким образом отделяя одни синтаксические понятия от других. Например, в исходном тексте программы можно ключевые слова выделить полужирным шрифтом, а типы данных и комментарии отображать разными цветами, выделяя их из основного текста. Это улучшает читаемость документа и повышает продуктивность работы автора.
Функция Perl, отображенная с использованием синтаксической подсветки.
Функция Perl, отображенная с использованием синтаксической подсветки.
Та же самая функция, но без подсветки.
Та же самая функция, но без подсветки.
Какой из примеров легче читать?
& kate; имеет гибкую, легко настраиваемую систему синтаксической подсветки, в стандартную поставку редактора входят правила подсветки синтаксиса для большого числа языков программирования, разметки и других текстовых форматов. Все определения хранятся в простых текстовых файлах в формате & XML;, поэтому вы можете свободно создавать собственные правила.
При открытии файла & kate; автоматически подбирает правила подсветки, основываясь на & MIME; - типе (который, в свою очередь, определяется расширением файла) или содержании файла, если расширения нет. Если & kate; неправильно определил тип файла, выберите нужный режим подсветки вручную в меню Документ Режим подсветки.
Вы можете настроить стили и цвета доступных синтаксических определений на вкладке Подсветка синтаксиса отдельных форматов диалога Настройка & kate;, а соответствующие им & MIME; - типы — на вкладке Типы файлов.
Синтаксическая подсветка улучшает читаемость корректно оформленного текста, но не факт, что текст некорректен, если он неправильно отображается системой подсветки. Синтаксическая разметка текста — достаточно сложный процесс, сложность которого зависит от формата файла, поэтому авторы синтаксических определений считают удачей, если 98% текста отображается корректно, но не стоит забывать об оставшихся 2%.
На сайте & kate; вы можете загрузить обновлённые или дополнительные правила синтаксической подсветки. Для этого нужно щёлкнуть на кнопке Скачать файлы подсветки синтаксиса... на вкладке Типы файлов диалога Настройка & kate;.
Система синтаксической подсветки & kate;
В этом разделе подробно рассматривается механизм синтаксической подсветки & kate;. Прочитав его, вы сможете изменять существующие или создавать свои синтаксические определения.
Механизм работы
Когда вы открываете файл, первое, что делает & kate; - определяет, какое синтаксическое определение использовать для него. При чтении и наборе система подсветки анализирует текст в редакторе, используя правила, указанные в синтаксическом определении, и помечает границы контекстов и стилей.
При вводе система динамически анализирует текст, поэтому, если вы удалите символ, который был помечен как начало или конец контекста, стиль окружающего текста автоматически изменится.
Синтаксические определения & kate; хранятся в & XML; - файлах. Они содержат:
Правила определения роли текста, организованного в контекстные блоки
Списки ключевых слов
Определения стилей
Система подсветки анализирует текст последовательно от начала до конца. Указатель анализатора перемещается от символа к символу, проверяя текст на соответствие правилам и помечая границы контекстов. Правила применяются к текущей строке в порядке их объявления, и при соответствии к ней применяется контекст, указанный в правиле. После этого указатель смещается на конец области соответствия и начинается новый цикл проверки правил, принадлежащих установленному контексту.
Правила
Правила - это сердце системы подсветки. Правило может быть строкой, символом или регулярным выражением, с которым сравнивается текст документа. Оно содержит информацию о стиле, который будет применен к тексту, если последний соответствует правилу. Оно может переключить текущий контекст системы на явно указанный или предыдущий контекст.
Правила организованы в контекстные группы. Контекстная группа используется для определения главных понятий в формате, например, строка, заключенная в двойные кавычки, или блок комментария в исходном тексте программы. Такая организация правил позволяет предотвратить проверку правил, неприменимых к текущему контексту (правил из других контекстов). Эта структура делает систему подсветки более гибкой, позволяя определять одинаковые правила в разных контекстах, что делает возможным одинаковые последовательности символов отображать разными стилями в зависимости от контекста, в котором они находятся.
Контексты могут образовываться динамически, чтобы сделать возможным использование правил, справедливых для данного момента.
Стили контекстов и ключевые слова
В некоторых языках программирования целые и вещественные числа трактуются компилятором по- разному (компилятор - это программа, которая преобразует исходный текст программы в двоичный исполняемый файл). Синтаксис языка может определять символы, имеющие специальное значение, если они находятся в строке, заключенной в кавычки. В этих случаях есть смысл выделять их в тексте для более удобного чтения. Иногда бывает полезно выделять символы, не имеющие специального значения - это тоже под силу системе синтаксической подсветки & kate;.
Синтаксическое определение может содержать столько стилей, сколько нужно для данного формата.
Во многих форматах существуют списки слов, имеющих специальное значение. Например, в языках программирования такими словами будут являться управляющие операторы, названия типов данных и встроенные функции. Это концептуальные слова, поскольку они определяют саму суть синтаксиса. Система синтаксической подсветки & kate; использует списки подобных слов, чтобы подчеркнуть концептуальные элементы формата.
Стили по умолчанию
Если вы откроете файл исходного кода на C++, на & Java; или документ HTML, то увидите, что разные форматы отображаются в одних и тех же цветах. Дело в том, что & kate; содержит предустановленный набор стандартных стилей. Синтаксические определения по возможности используют этот набор.
Это позволяет подобным образом отображать похожие концепции в различных форматах. Например, комментарии есть почти во всех языках программирования, разметки и скриптах.
Каждый стиль в синтаксическом определении основывается на одном из стандартных стилей. Поэтому, если вы часто используете какой- то формат с большим количеством стилей, следует проверить его конфигурацию на предмет их совпадения. Приведём небольшой пример. В & kate; определен всего один стандартный стиль для отображения строковых констант, но в языке программирования Perl существует два вида строк. Согласитесь, было бы гораздо лучше отображать их по разному - вы заходите в диалоговое окно настройки & kate; и изменяете соответствующие стили. Все доступные стандартные стили будут рассмотрены позже.
& XML; - формат определения синтаксической подсветки
В этом разделе вы познакомитесь с & XML; - форматом определения синтаксической подсветки. Вначале, на небольшом примере, будут кратко объяснены главные компоненты и их значение, затем мы более подробно остановимся на правилах подсветки.
Формальное определение (DTD) находится в файле language. dtd, в каталоге $KDEDIR / share/ apps/ katepart/ syntax.
Основные разделы файла определения синтаксической подсветки & kate;
В заголовке файла подсветки указаны версия XML и тип документа:
& lt;? xml version=quot; 1. 0quot; encoding=quot; UTF- 8quot;? gt; & lt;! DOCTYPE language SYSTEM & quot; language. dtdquot; gt;
Главная часть файла определений - элемент language. Доступные атрибуты:
Необходимые атрибуты:
name определяет название языка. Впоследствии оно появляется во всех меню и диалогах.
section указывает категорию.
extensions определяет расширения файлов, вроде & quot; *. cpp; *. hquot;
Дополнительные атрибуты:
mimetype связывает файл с определенным типом & MIME;.
version указывает текущую версию файла определений.
kateversion указывает новейшую из поддерживаемых версий & kate;.
casesensitive определяет чувствительность ключевых слов к регистру.
priority определяет приоритет в случае использования разных правил подсветки. Действует правило с высшим приоритетом.
author содержит имя и email- адрес автора.
license содержит лицензию, обычно LGPL, Artistic, GPL и т. п.
hidden определяет, будет ли отображаться название в меню & kate;.
Итак, следующая строка может быть примерно такой:
& lt; language name=quot; C++quot; version=quot; 1. 00quot; kateversion=quot; 2. 4quot; section=quot; Sourcesquot; extensions=quot; *. cpp; *. hquot; / gt;
Следующий элемент - highlighting, состоящий из необязательного list и обязательных - contexts и itemDatas.
Элемент list содержит список ключевых слов. В нашем случае это class и const. Списков можете добавить, сколько хотите.
Элемент contexts содержит все контексты. По умолчанию, подсветка начинается с первого контекста. В контексте Normal Text есть два правила, одно из которых проверяет наличие в тексте слов, соответствующих списку ключевых слов, другое определяет наличие кавычек и переключает контекст к строковому типу. Подробнее правила описаны в следующей главе.
Элемент itemDatas содержит сведения о цветах и стилях, применяющихся в контекстах и правилах. В нашем примере itemData использует контексты Normal Text, String и Keyword.
& lt; highlightinggt; & lt; list name=quot; somenamequot; gt; & lt; itemgt; class & lt; / itemgt; & lt; itemgt; const & lt; / itemgt; & lt; / listgt; & lt; contextsgt; & lt; context attribute=quot; Normal Textquot; lineEndContext=quot; # popquot; name=quot; Normal Textquot; & gt; & lt; keyword attribute=quot; Keywordquot; context=quot; # stayquot; String=quot; somenamequot; / gt; & lt; DetectChar attribute=quot; Stringquot; context=quot; stringquot; char=quot; amp; quot; quot; / gt; & lt; / contextgt; & lt; context attribute=quot; Stringquot; lineEndContext=quot; # stayquot; name=quot; stringquot; & gt; & lt; DetectChar attribute=quot; Stringquot; context=quot; # popquot; char=quot; amp; quot; quot; / gt; & lt; / contextgt; & lt; / contextsgt; & lt; itemDatasgt; & lt; itemData name=quot; Normal Textquot; defStyleNum=quot; dsNormalquot; / gt; & lt; itemData name=quot; Keywordquot; defStyleNum=quot; dsKeywordquot; / gt; & lt; itemData name=quot; Stringquot; defStyleNum=quot; dsStringquot; / gt; & lt; / itemDatasgt; & lt; / highlightinggt;
Последня часть файла определения синтаксической подсветки - необязательный раздел general. Здесь могут содержаться сведения о ключевых словах, сворачивании блоков кода, комментариях и отступах.
Раздел comment определяет, какой строкой вводится однострочный комментарий. Можно пользоваться также многострочными комментариями, используя multiLine с дополнительным атрибутом end. Это используется тогда, когда пользователь нажимает комбинацию клавиш, назначенную для действия закомментировать/ раскомментировать.
Секция keywords определяет чувствительность ключевых слов к регистру. Остальные атрибуты рассмотрим позднее.
& lt; generalgt; & lt; commentsgt; & lt; comment name=" singleLine "start=" # "/ gt; & lt; / commentsgt; & lt; keywords casesensitive=" 1" / gt; & lt; / generalgt; & lt; / languagegt;
Более подробно о разделах
В этой части указаны все возможные атрибуты для контекстов, itemDatas, ключевых слов, комментариев, сворачивания кодов и отступов.
Элемент context относится к группе contexts. Контекстом определяются некоторые особые правила (например, что происходит при достижении подсвеченной структурой конца строки). Доступные атрибуты:
name - название контекста. Правила используют это название для переключения на указанный контекст.
lineEndContext определяет, на какой контекст подсвеченная структура переключается при достижении конца строки. Это может быть название другого контекста, # stay, если контекст не меняется (т. е. не делать ничего) или # pop для выхода из контекста. Например, набор # pop# pop# pop приведет к троекратному выходу из контекста.
lineBeginContext определяет контекст при достижении начала строки. По умолчанию: # stay.
fallthrough определяет поведение в случае переключения подсвеченной структуры на контекст, указанный в fallthroughContext, если не найдено соответствующее правило. По умолчанию: false.
fallthroughContext указывает следующий контекст, если не найдено соответствующее правило.
Если dynamic имеет значение true, то контекст запоминает строки/ метки- заполнители, сохранённые в динамических правилах. Это необходимо, например, для текущих документов. По умолчанию: false.
Элемент itemData принадлежит группе itemDatas. Он определяет стиль и цвет шрифта, их можно устанавливать самому в тех случаях, когда это необходимо. И все же, рекомендуется придерживаться стандартных стилей, чтобы помочь пользователю свободно ориентироваться в любом языке. Название атрибута (name) и defStyleNum обязательны, остальные нет. Доступные атрибуты:
name даёт название itemData. Контексты и правила будут использовать это название при обращении к itemData в своих атрибутах attribute.
defStyleNum определяет стиль, используемый по умолчанию. Доступные стандартные стили будут детально описаны ниже.
color определяет цвет. Правильные форматы '# rrggbb' или '# rgb'.
selColor определяет цвет выделенного текста.
Если italic имеет значение true, шрифт будет курсивным.
Если bold имеет значение true, шрифт будет полужирным.
Если underline имеет значение true, текст будет подчёркнут.
Если strikeout имеет значение true, текст будет зачёркнут.
Элемент keywords в группе general определяет свойства ключевых слов. Доступные атрибуты:
casesensitive может быть true или false. Если true, все ключевые слова будут проверяться на соответствие с учетом регистра
weakDeliminator - это группа знаков, которые не могут разделять слова. Например, точка '.' - разделитель слов. Если ключевое слово в list содержит точку, оно будет использовано по назначению только, если точка будет определена как "нетвердый разделитель" (weak delimiter).
additionalDeliminator определяют дополнительные разделители.
wordWrapDeliminator определяют символы, после которых может происходить перевод строки.
По умолчанию разделителями слов и строк являются символы. ():! +, - lt; =gt;% amp; * /;? [] ^{ |} ~\\, пробел ('') и табуляция ('\\ t').
Элемент comment в группе comments определяет свойства комментариев, которые используются в меню Сервис Закомментировать и Сервис Раскомментировать. Доступные атрибуты:
name может быть singleLine или multiLine. Если выбрать multiLine, то потребуются атрибуты end и region.
start указывает строку начала комментария. В C++ это может быть & quot; / * quot;.
end указывает строку окончания комментария. В C++ это может быть & quot; * / quot;.
region должно быть названием сворачиваемого многострочного комментария. Допустим, если в ваших правилах указано beginRegion=" Comment "... endRegion=" Comment", вы должны использовать region=" Comment ". В этом случае раскомментирование будет действовать, даже если не будет выделен весь текст многострочного комментария. Достаточно будет просто поместить курсор в его пределы.
Элемент folding в группе general определяет свойства сворачивания кода. Доступные атрибуты:
Если indentationsensitive имеет значение true, то маркёры сворачивания кода будут располагаться с учетом отступов, как в языке сценариев Python. Чаще всего в этом нет необходимости, поэтому по умолчанию этот параметр определен как false.
Элемент indentation в группе general определяет формат отступов, однако мы настоятельно рекомендуем не менять этот элемент, так как отступы обычно определяются типом файла или добавлением режимной строки в текстовый файл. Если вы всё- таки укажете способ отступа, он может оказаться навязанным пользователю, которому совсем не нужен. Доступные атрибуты:
mode - название формата отступов. Доступные форматы: normal, cstyle, csands, xml, python и varindent.
Стандартные стили
Стандартные стили уже были кратко описаны: Стандартные стили предопределяют настройки цветов и шрифтов.
Здесь приведен только список доступных стандартных стилей:
dsNormal, для нормального текста.
dsKeyword, для ключевых слов.
dsDataType, для типов данных.
dsDecVal, для десятичных значений.
dsBaseN, для значений с основанием, отличным от10.
dsFloat, для значений с плавающей точкой.
dsChar, для символов.
dsString, для строк.
dsComment, для комментариев.
dsOthers, для всего остального.
dsAlert, для вывода предупреждений.
dsFunction, для вызова функций.
dsRegionMarker, для маркёров участков.
dsError, для подсветки ошибок и неверного синтаксиса.
Синтаксические правила
В этом разделе описываются синтаксические правила.
При анализе строки каждое правило может запросить на проверку любое количество символов (даже ноль). Если правило подходит, к соответствующим символам применяется стиль или атрибут, определённый в правиле. Применяемое правило также может запросить переключение текущего контекста.
Правило выглядит примерно так:
& lt; RuleName attribute=quot; (identifier) quot; context=quot; (identifier) quot; [rule specific attributes] / gt;
Параметр attribute указывает, какой стиль применить к символам, соответствующим правилу. Параметр context определяет контекст, который будет установлен в случае применения правила.
Параметр context может принимать следующие значения:
Идентификатор, т. е. название контекста.
order предписывает системе подсветки не менять текущий контекст (# stay) или вернуться к предыдущему контексту (# pop).
Чтобы вернуться назад на несколько контекстов, повторите нужное количество раз ключевое слово # pop: # pop# pop# pop
Некоторые правила могут иметь дочерние правила, которые проверяются только в том случае, если текст соответствует родительскому правилу. Всей совпавшей строке будут присвоены атрибуты, определенные в родительском правиле. Вот пример правила с дочерними правилами:
& lt; RuleName (attributes) gt; & lt; ChildRuleName (attributes) / gt;... & lt; / RuleNamegt;
Параметры конкретных видов правил описаны в следующих разделах.
Общие атрибуты
У любого правила есть следующие атрибуты, (common attributes), доступные всегда. attribute и context обязательны, остальные - нет.
attribute: Атрибут, описывающий определённые itemData.
context: Определяет контекст, на который происходит переключение в случае соответствия правилу.
beginRegion: Начало сворачиваемого блока кода. По умолчанию: не установлен (unset).
endRegion: Окончание сворачиваемого блока кода. По умолчанию: не установлен (unset).
Если lookAhead имеет значение true, то система подсветки больше не будет обрабатывать соответствия. По умолчанию: false.
firstNonSpace: Соответствие, только если строка начинается не с пробела. По умолчанию: false.
column: Соответствие, только если соответствует номер столбца. По умолчанию: не установлено (unset).
Динамические правила
У некоторых правил есть необязательный атрибут dynamic, имеющий логическое значение (по умолчанию false). Если dynamic установить true, то правило может использовать метки- заполнители, заменяющие текст, соответствующий правилу регулярного выражения, переключенного к текущему контексту по своим атрибутам string или char. В атрибуте string метка- заполнитель% N (где N - цифра) будет заменена номером N найденного регулярного выражения. В атрибуте char метка- заполнитель должна быть цифрой N, и будет заменена первым символом N найденного регулярного выражения. Чтобы правило могло использовать эти атрибуты, оно должно содержать параметр (dynamic).
dynamic: логический атрибут (true|false).
Более подробно о правилах
DetectChar
Проверка на совпадение с одним определенным символом. Используется, например, для определения завершающего символа строки, заключённой в кавычки.
& lt; DetectChar char=quot; (character) quot; (common attributes) (dynamic) / gt;
Параметр char определяет символ.
Detect2Chars
Проверка на совпадение с двумя символами в заданном порядке.
& lt; Detect2Chars char=quot; (character) quot; char1=quot; (character) quot; (common attributes) (dynamic) / gt;
Параметр char определяет первый символ для проверки, char1 - второй.
AnyChar
Проверка на совпадение с любым символом из заданного набора.
& lt; AnyChar String=quot; (string) quot; (common attributes) / gt;
Параметр String содержит набор допустимых символов.
StringDetect
Проверка на совпадение со строкой.
& lt; StringDetect String=quot; (string) quot; [insensitive=quot; true|falsequot;] (common attributes) (dynamic) / gt;
Параметр String должен содержать строку, которую нужно проверить на соответствие. Атрибут insensitive по умолчанию имеет значение false, он влияет на сравнение строк. Если этот параметр установлен true, функция сравнения не будет учитывать регистр символов.
RegExpr
Проверка на совпадение с регулярным выражением.
& lt; RegExpr String=quot; (string) quot; [insensitive=quot; true|falsequot;] [minimal=quot; true|falsequot;] (common attributes) (dynamic) / gt;
Параметр String определяет регулярное выражение.
insensitive имеет то же значение, что и в предыдущем правиле; по умолчанию установлен false.
Параметр minimal по умолчанию имеет значение false и передаётся функции обработки регулярных выражений.
Символ перевода каретки (^) в начале регулярного выражения говорит о том, что данное правило будет применяться только к тем цепочкам символов, которые начинаются с новой строки.
Более подробно регулярные выражения рассматриваются в разделе Регулярные выражения.
keyword
Проверка на ключевое слово из указанного списка.
& lt; keyword String=quot; (list name) quot; (common attributes) / gt;
В параметре String нужно указать название списка ключевых слов. Этот список должен существовать.
Int
Проверка на целое число.
& lt; Int (common attributes) (dynamic) / gt;
Это правило не имеет своих параметров. Дочерние правила обычно используются для определения комбинаций символов L и U после числа, которые конкретизируют тип целой константы в коде программы. Вообще, все правила могут быть использованы в качестве дочерних, хотя DTD разрешает использовать в качестве дочернего только правило StringDetect.
Пример проверки на целые числа, следующие за символом 'L'.
& lt; Int attribute=" Decimal "context=" # stay "& gt; & lt; StringDetect attribute=" Decimal" context= "# stay" String=" L "insensitive=" true" / gt; & lt; / Intgt;
Float
Проверка на число с плавающей точкой.
& lt; Float (common attributes) / gt;
У этого правила нет особых атрибутов. AnyChar можно использовать как дочернее, обычно оно используется для проверки комбинаций. Для примера смотрите правило Int.
HlCOct
Проверка на восьмеричное число (должно начинаться с нуля).
& lt; HlCOct (common attributes) / gt;
У этого правила нет особых атрибутов.
HlCHex
Проверка на шестнадцатеричное число (должно начинаться с символов 0x).
& lt; HlCHex (common attributes) / gt;
HlCStringChar
Проверка на управляющий символ.
& lt; HlCStringChar (common attributes) / gt;
Проверка на специальное представление символов, которое используется в языках программирования, например,\ (переход на новую строку) или\\ t (символ табуляции).
Следующие символы соответствуют правилу, если они вводятся после обратной черты (\\): abefnrtvquot; '?\\. Также будут соответствовать шестнадцатеричные и восьмеричные числа, предварённые обратной чертой (например,\\ xff и\\ 033).
HlCChar
Проверка на символ C.
& lt; HlCChar (common attributes) / gt;
Правило находит символы C, заключенные в одинарные кавычки (например, 'c'). Внутри одинарных кавычек может быть как одиночный символ, так и управляющая последовательность, более подробно ознакомиться с которыми можно в описании правила HlCStringChar.
RangeDetect
Проверка на строку, имеющую заданные начальный и конечный символы.
& lt; RangeDetect char=quot; (character) quot; char1=quot; (character) quot; (common attributes) / gt;
char определяет символ, с которого начинается строка, а char1 - которым она заканчивается.
Это правило может быть использовано для поиска небольших строк, заключённых в кавычки, но, поскольку при проверке правила система подсветки работает с одной строкой, данное правило не сможет определить строку, разбитую символами перевода.
LineContinue
Проверка на символ перевода строки.
& lt; LineContinue (common attributes) / gt;
Это правило может быть удобно для переключения контекста в конце строки, если последним знаком будет обратная черта ('\\'). Это необходимо, например, в языках C/ C++ для продолжения макросов и строк.
IncludeRules
Включение правил из другого контекста или языка/ файла.
& lt; IncludeRules context=quot; contextlinkquot; [includeAttrib=quot; true|falsequot;] / gt;
Атрибут context определяет контекст, из которого берётся правило.
Если это простая строка, то включаются все правила из другого контекста, например:
& lt; IncludeRules context=quot; anotherContextquot; / gt;
Если строка начинается с ##, то система подсветки найдёт описание для другого языка с указанным названием, например:
& lt; IncludeRules context=quot; ## C++quot; / gt;
Если includeAttrib выставить true, атрибут назначения должен быть таким же, как атрибут источника. Это необходимо, например, при вводе комментариев, если текст, соответствующий включаемому контексту, имеет иную подсветку, чем основной контекст.
DetectSpaces
Поиск пробелов.
& lt; DetectSpaces (common attributes) / gt;
Используйте это правило, если вы уверены, что в тексте есть несколько пробелов подряд, например в начале строк с отступом. Это правило поможет пропустить все пробелы разом, вместо проверки каждого из них по нескольким параметрам.
DetectIdentifier
Поиск строк идентификаторов (таких как регулярные выражения: [a- zA- Z _] [a- zA- Z0- 9 _] *).
& lt; DetectIdentifier (common attributes) / gt;
Используйте это правило, чтобы пропустить все буквенные символы разом, вместо проверки каждого из них по нескольким параметрам.
Подсказки & Советы
Усвоив принцип действия переключения контекста, вы без труда сможете написать своё определение подсветки. Подумайте о том, в какой ситуации какое правило следует применить. Регулярные выражения - мощное средство, но, по сравнению с другими правилами, очень медленное. Поэтому стоит воспользоваться следующими советами.
Проверяя на соответствие только пару символов, воспользуйтесь Detect2Chars вместо StringDetect. То же относится к DetectChar.
Регулярные выражения несложны в использовании, но очень часто можно найти более быстрый способ. Допустим, вы ищете символ '#', это первый символ строки. Решение с регулярным выражением будет выглядеть примерно так: lt; RegExpr attribute=quot; Macroquot; context=quot; macroquot; String=quot; ^\\ s * # quot; / gt;. Этой же цели можно достичь значительно быстрее: lt; DetectChar attribute=quot; Macroquot; context=quot; macroquot; char=quot; # quot; firstNonSpace=quot; truequot; / gt;. Для поиска регулярного выражения '^ #' можно применить DetectChar с атрибутом column=quot; 0quot;. Отсчет для атрибута column идет посимвольно, поэтому знак табуляции для него - всего один символ.
Можно переключать контексты без специальных символов. Допустим, вы хотите переключить контекст при достижении строки * /, но в новом контексте хотите продолжить обработку этой строки. Можно воспользоваться нижеследующим правилом, а атрибут lookAhead заставит систему подсветки сохранить найденную строку для нового контекста.
& lt; Detect2Chars attribute=quot; Commentquot; context=quot; # popquot; char=quot; * quot; char1=quot; / quot; lookAhead=quot; truequot; / gt;
Если известно, что в тексте много пробелов, воспользуйтесь DetectSpaces.
Пользуйтесь DetectIdentifier вместо регулярного выражения '[a- zA- Z _]\\ w *'.
Старайтесь использовать стандартные стили, это удобно для пользователя.
Заглянув в другие XML- файлы, вы узнаете много нового о работе с правилами.
Проверить правильность XML- файла можно командой xmllint -- dtdvalid language. dtd mySyntax. xml.
Если сложное регулярное выражение встречается часто, воспользуйтесь ENTITIES. Пример:
& lt;? xml version=" 1. 0 "encoding=" UTF- 8"? gt; & lt;! DOCTYPE language SYSTEM "language. dtd" [& lt;! ENTITY myref "[A- Za- z _:] [\\ w.: _ -] *" gt;] gt;
Теперь вместо регулярного выражения можно использовать amp; myref;.