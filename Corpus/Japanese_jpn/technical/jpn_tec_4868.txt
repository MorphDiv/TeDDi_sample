# language_name_wals:	Japanese
# language_name_glotto:	Japanese
# ISO_6393:	jpn
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Jpan
# special_characters:	NA
# short_description:	PHP
# source:	https://object.pouta.csc.fi/OPUS-PHP/v1/raw/ja.zip
# copyright_short:	http://opus.nlpl.eu/PHP.php
# copyright_long:	http://opus.nlpl.eu/PHP.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

PCRE ライブラリは、(以下に示す)僅かな違いを除き Perl 5 と同じ構文と 意味を使用した正規表現パターンマッチングを実装した関数群です。 現在の実装は、Perl 5.005 に対応しています。
ここで説明するのは、Perl 5.005 に関連するものです。
デフォルトでは空白文字は C ライブラリ関数 isspace() が認識する 全ての文字ですが、別の文字型テーブルを用いてPCREをコンパイルす ることも可能です。通常、isspace() は空白、フォームフィード、改 行、複改、水平タブ、垂直タブにマッチします。Perl 5 ではもう空白 文字の中に垂直タブを含んでいません。かなり前から Perl ドキュメ ントにあった \v エスケープは、実際は認識されていませんでした。 しかし、その文字自体は少なくとも 5.002 までは空白文字として処理 されています。5.004 および 5.005 では、この文字は \s にマッチし ません。
PCREでは、先読み言明(assertion)時に繰り返し数の指定を使用できま せん。Perlはこれを許可しますが、意図した通りに動作することを意 味するわけではありません。例えば、(?!a){3} は、次の3文字が "a" でないことを言明するわけではありません。この指定は、次の文字が "a" ではないことを3回言明するだけです。
否定の先読み言明の中で生じるサブパターンを取得する回数は計算さ れますが、オフセットベクトルの中の対応するエントリは設定されま せん。Perlでは、言明のマッチングに失敗する前にマッチしたパター ンからその変数を設定しますが、それが行われるのは、否定の先読み 言明の枝が1つだけの場合のみです。
ヌル文字文字は、検索対象文字列でサポートされますが、パターン文 字列ではサポートされません。これは、パターン文字列は、0を終端と する通常のC文字列として渡されるためです。エスケープシーケンス "\0"は、ヌル文字を表すパターンとして使用することが可能です。
次のPerlエスケープシーケンスは、サポートされません。: \l, \u, \L, \U, \E, \Q 実際、Perlでは、これらはパターンマッチングエン ジンの部分ではなく、通常の文字列処理の部分に実証されています。
Perlの\G言明は、一回のパターンマッチに関するものではないため、 サポートされません。
明確に述べると、PCREは(?{code})構造をサポートしません。
Perl 5.005_02では、書きこみ時にパターンの一部を繰り返す際に取得 した文字列の設定に関連する奇妙な動作が見うけられます。例えば、 "aba"をパターン/^(a(b)?)+$/にマッチングする場合、$2には、値"b" が設定されますが、"aabbaa"を/^(aa(bb)?)+$/にマッチさせた場合、 $2は設定されません。しかし、パターンを/^(aa(b(b))?)+$/に変える と、$2 (および $3)が設定されます。Perl 5.004では、$2 はどちらの ケースでも設定されま、PCREでも TRUE に設定されます。将来的に Perlが別の矛盾のない状態に変更された場合、PCREも追従する可能性 があります。
他の未解決の矛盾は、Perl 5.005_02 では、パターン /^(a)?(?(1)a|b)+$/ は文字列 "a" にマッチしますが、PCRE ではマッ チしないということです。しかし、Perl と PCRE は共に /^(a)?a/ で "a" をマッチした場合に $1 が未定義のままとなります。
PCREは、Perl正規表現の機能にいくつかの拡張機能を提供します。
先読み言明は、固定長の文字列にマッチする必要がありますが、先 読み言明の別の各枝は、異なった長さの文字列にマッチすることが できます。Perl 5.005 では全て同じ長さである必要があります。
PCRE_DOLLAR_ENDONLY が 設定されており、 PCRE_MULTILINE が設定 されていない場合、メタ文字$は、文字列の終端にのみマッチします。
PCRE_EXTRA が設 定されている場合、バックスラッシュの後に文字があって特に意味 がないものは、エラーとなります。
PCRE_UNGREEDY が 設定されている場合、デフォルトでは貪欲でない繰り返し指定子の 貪欲さは反転しますが、疑問符が後ろにつく場合は、貪欲になります。
PCREによりサポートされる正規表現の構文を以下に示します。 正規表現は、Perlのドキュメントや他の多くの書籍において 豊富な例と共に説明されています。 Jeffrey Friedl が書いた O'Reilly 発刊の "Mastering Regular Expressions" には、詳細が示されています。 ここでの説明はリファレンスドキュメントとして使用することを 意図しています。 正規表現はパターンであり、検索対象文字列に対して左から右にマッチングが 行われます。 パターンの中の多くの文字はそれ自体を表し、検索対象の対応する文字に マッチします。簡単な例をあげると、パターン The quick brown fox は、検索対象文字列のそれ自体と同じ部分にマッチします。
正規表現の強力さは、パターン中に複数の選択肢や繰り返しを含む能力 によるものです。これらは、 メタ - 文 字 を使用したパターンによりエンコードされます。 メタ文字はそれ自体を表しませんが、代わりに特有の解釈が行われます。
2種類のメタ文字が存在します。片方は、ブラケットの中以外にあるパターン で使用可能なもので、もう片方は、ブラケットの中で使用可能なものです。 ブラケットの外で使用されるメタ文字には次のようなものがあります。
一般的なエスケープ文字
検索対象(複数行モードでは行)の始まりを言明
検索対象(複数行モードでは行)の終わりを言明
(デフォルトでは)改行を除く全ての文字にマッチ
文字クラス開始を定義
文字クラスの終了
選択枝の開始
サブパターンの開始
サブパターンの終了
(の意味を拡張するまたは、0 または1 回の繰り返しまたは、繰り 返しを最小化する
0以上の繰り返し
1以上の繰り返し
最小/最大繰り返しの開始
最小/最大繰り返しの終了
一般的なエスケープ文字
最初の文字に用いた場合のみ、クラスを否定
文字の範囲を示す
文字クラスを終了する
バックスラッシュには、いくつかの使用法があります。まず、 英字でない文字が後に続く場合、そて?字が有する 特別な意味は失われます。このバックスラッシュの使い方は、 文字クラスの内側と外側の両方で使用可能です。
例えば、"*" 文字にマッチさせたい場合、パターンに "\*" を書きます。 これにより、次の文字がメタ文字として解釈されようとされまいと、 "\" を伴った英字でない文字が、その文字自体を表すことを保証します。 特に、バックスラッシュにマッチさせたい場合は、"\\" と書きます。
パターンが、 PCRE_EXTENDED オプションを付けてコンパイルされている 場合、(文字クラスの中でない)パターン内の空白文字および "#" と次の改行文字の間の文字は無視されます。 空白文字または "#" をパターンの一部として含める際には、 バックスラッシュによりエスケープすることができます。
バックスラッシュの2番目の使用法は、出力されない文字を パターン内に目に見える形でエンコードする手法を提供するものです。 パターンを終了させるヌル文字を除き、出力されない文字の見え方に は何の制約もありませんが、パターンをテキスト編集する際には、通常 次のエスケープシーケンスを用いる方が、元のバイナリ文字よりも より簡単でしょう。

アラーム、ベル文字 (16進 07)
"control-x", ただし x はあらゆる文字
エスケープ (16進 1B)
改ページ (16進 0C)
改行 (16進 0A)
復帰 (16進 0D)
タブ (16進 09)
16進数で hh の文字
8進数で ddd の文字または後方参照
"\cx" の正確な効果は、次のようになります。"x" が小文字の場合、 大文字に変換されます。続いて、文字の6ビット目(16進数 40)が 反転されます。つまり、"\cz" は16進数の 1A になりますが、"\c{" は16進数の 3B になり、"\c;" は 16進数の 7B になります。
"\x" の後では、2桁の16進数が読まれます。(表す文字は、大文字でも 小文字でも可です)"\0"では2桁までの8進数が読みこまれます。 両方のケースとも、2桁より少ない場合、表している文字自体が 使用されます。つまり、"\0\x\07" は2つのヌル文字の後にベル文字 が続いたものを表します。8進数を表す文字については、最初のゼロ の後に2桁の数字を指定するように注意して下さい。
バックスラッシュの後に0以外の数字が続く場合の処理は、複雑です。 文字クラスの外では、PCRE は続く桁を10進数として読みこみます。 数字が10よりも小さい場合、または、式の中に値を取得した左括弧が この数以上あった場合、全体のシーケンスは、 後方 参照 として解釈されます。この動作に関する説明 は、括弧付きのサブパターンの説明の後に行います。
文字クラスの中または10進数が9より大きく、取得を行ったサブパターン がこの数に満たない場合、PCRE はバックスラッシュの後から最大3文字の8進数 を再度読みこみ、その値の最下位 8ビットから1バイトを生成します。 続く桁はそれ自体を表します。例えば、

は空白の別の表記法です。
は、同じ意味です。ただし、値を取得済みのサブパターンが40個未 満の場合。
は常に後方参照です。
は後方参照またはタブの別の表記法です。
は常にタブです。
はタブの後に文字 "3" が続いたものです。
(99 を超える後方参照はないので) 8進数 113 を表す文字。
は1ビットの並びで構成される1バイトです。
は後方参照または、ヌル文字の後に2つの文字 "8" および "1" が 続いたものです。
3桁を超えて8進数は読みこまれないため、値が100以上の8進数には ゼロを前につけるべきではないことに注意してください。
1バイトの値を定義するあらゆるシーケンスは、文字クラスの内部 および外部で使用可能です。加えて、文字クラスの内部ではシーケンス "\b" はバックスペース(16進 0x)として解釈されます。 文字クラスの外では、別の意味を有します。(以下を参照下さい)
バックスラッシュの第3の使用法は、包括的な文字型を指定する用途 です。

10進数字
10進数字でない全ての文字
空白文字
空白文字以外の文字
単語構成文字
単語構成文字以外
エスケープシーケンスの各組は、全文字の集合を2つの集合に 分割します。全ての文字は、各組のうち、片方だ?kマッチします。
単語構成文字とは英字または数字またはアンダースコア文字であり、 Perl の "単語" と成り得る文字のことです。 文字および数字の定義は、PCRE の文字テーブルにより制御され、 ロケールを指定したマッチを行った場合には変わる可能性があります。 ("ロケールのサポート"を参照下さい) 例えば、"fr" (フランス語)ロケールの場合、いくつかの128を超える 文字コードの文字は、アクセント付きの文字に使用されており、 これらは \w にマッチします。
これらの文字型シーケンスは、文字クラスの内外によらず使用可能 です。これらは、適当な型の1文字にマッチします。現在マッチング を行っている位置が検索対象文字列の終端である場合、マッチできる 文字はないので全てのマッチングは失敗します。
バックスラッシュの第4の使用法は、単純な言明です。 言明は、検索対象文字列から文字を全く抜き出さずに マッチが特定の位置で生じるという拘束条件を指定します。 より複雑な言明に関するサブパターンの使用法を以下に説明します。 バックスラッシュ付きの言明は次のものがあります。

単語の境界
単語の境界でない
検索対象の始まり (複数行モードとは独立)
検索対象の終わりまたは終端の改行 (複数行モードとは独立)
検索対象の終わり (複数行モードとは独立)
これらの言明は、文字クラスには使用できません。(しかし、文字クラスの 中では、" \b "には別の意味、つまり、バックスペー ス文字という意味があることに注意してください)
単語の境界は、検索対象文字列において、現在の文字および前の文字が 両方は \w または \W にマッチし ない(すなわち、片方は \w にマッチして、もう片方 は \W にマッチする)か、または、最初のまたは最後 の文字が \w にマッチするならば、それぞれ、文字 列の始めまたは終わりの位置です。
言明 \A, \Z, \z は、(以下に説明する)どんなオプションを設定 しても文字列の始端および終端にのみマッチするハット記号およびドル 記号とは異なっています。 これらの言明は、 PCRE_NOTBOL または PCRE_NOTEOL オプションの 影響を受けません。 \Z 及び \z の違いは、 \Z は、文字列の終端と同時に文字列の 最後の文字が改行の場合に前の文字にマッチするのに対し、 \z は終端にのみマッチします。
文字クラスの外側の場合、デフォルトのマッチモードでは、ハット記号は 現在マッチングを行っている位置が対象文字列の始端である場合にのみ TRUE となる言明です。 文字クラスの内部では、ハット記号は全く別の意味となります。 (以下を参照) 複数の選択肢がある場合、 ハット記号はパターンの最初の文字である必要はありません。 しかし、パターンがその枝にマッチしない場合、 各選択肢の先頭に置く必要があります。 全ての選択肢がハット記号で始まる場合、パターンは対象の最初にのみ マッチするように拘束されてㄣ?場合であり、"アンカー付き" パターンと 呼ばれます。 (他の文字もパターンをアンカー付きにすることが可能です) ドル記号は、(デフォルトでは)現在のマッチング点が対象文字列の 終端にあるか、文字列の最後の文字が改行文字である場合に その直前にある場合のみ TRUE となる言明です。 ドル記号は、複数の選択肢がある場合、パターンの最後の文字であ る必要はありませんが、使用さ??枝の最後のアイテムである必要 があります。ドル記号は、文字クラスの中では特別な意味を有しま せん。 ドル記号の意味は、コンパイル時またはマッチング時の PCRE_DOLLAR_ENDONLY オプションの設定により文字列の終端にのみマッチするように変更する ことが可能です。この設定は、\Z 言明には影響を与えません。 ハット記号とドル記号の意味は、 PCRE_MULTILINE オプション を設定した場合に変化します。これを設定した場合、対象文字列の始端 及び終端にマッチするのに加えて、文字列内部の "\n" 文字の直前 及び直後にそれぞれマッチします。例えば、パターン /^abc$/ は 複数行モードでは対象文字列 "def\nabc" にマッチしますが、 そうでない場合はマッチしません。結果として、 全ての枝が "^" で始まるため、単一行モードでアンカー付きのパタ ーンは、複数行モードではアンカー無しとなります。 PCRE_DOLLAR_ENDONLY オプションは、 PCRE_MULTILINE が設定され ている場合は無視されます。 両方のモードで対象の始端および終端にマッチさせるために シーケンス \A, \Z, \z を使用出来ることに注意してください。 パターンの枝が \A を付けて始まる場合、 PCRE_MULTILINE の設 定によらず、常にアンカー付きとなります。
文字クラスの外側では、パターンの中のドットは非出力文字を含む (デフォルトでは)改行以外の対象の全ての1文字にマッチします。 PCRE_DOTALL オプショ ンを設定した場合、ドットは改行にもマッチします。ドットの処理は、 ハット記号およびドル記号とは完全に独立しています。共通な点は共に 改行文字を含むことだけです。 ドットは、文字クラスの中では特別な意味を持ちません。
左ブラケットは文字クラスの開始を表し、右ブラケットにより終了 します。右ブラケットは、それ自体特別なものではありません。 右ブラケットがクラスのメンバーとして必要な場合、(もしあるな らば、最初にハット記号を持ってきた後で)クラスの最初の文字データ があるか、バックスラッシュでエスケープする必要があります。 文字クラスは、対象の1文字にマッチします。その文字はクラスにより 定義される文字集合の中にある必要があります。ただし、 クラスの最初の文字がハット記号の場合は、対象文字は暮らすにより 定義される集合のん課兄あってはなりません。 ハット記号がクラスのメンバーとして必要な場合は、必ず、最初の 文字としないか、バックスラッシュでエスケープするようにして下 さい。 例えば、文字クラス [aeiou] は小文字の母音にマッチしますが、 [^aeiou] は小文字の母音以外の文字にマッチします。 ハット記号は、存在しないものを列挙することによりクラスにある 文字を指定する便利な表記です。 ハット記号は、言明ではありません。対象文字列から文字を消費し、 現在のポインタが文字列の終端にある場合には失敗します。 大文字小文字を区別しないマッチが行われた場合、クラスの文字は 大文字・小文字の両方を表します。これは、例えば、大文字小文字 を区別しない場合のマッチ [aeiou] は "a" と同様に "A" にマッチ し、文字小文字を区別しない場合のマッチ [^aeiou] は "A" にマッ チしません。一方、大文字小文字を区別する場合はマッチします。 PCRE_DOTALL または PCRE_MULTILINE オプ ションをどのように設定しようとも改行文字は、文字クラスにおいて特 別な方法で処理されません。[^a] のようなクラスは常に改行にマッチ します。 マイナス (ハイフン)文字は文字クラスの中で文字の範囲を指定する ために使用されます。例えば、[d-m] は d と m の間のあらゆる 文字にマッチします。間にナス文字がクラスの中に必要な場合は、 バックスラッシュでエスケープするか、クラスの最初または最後の ような範囲を示すとは解釈されない場所に使用して下さい。 文字リテラル "]" を範囲の最後の文字として使用することはできま せん。[W-]46] のようなパターンは、2つ文字のクラス("W" および "-")の後にリテラル文字列 "46]" が続いているクラスとして解釈 され、"W46]"または "-46]" にマッチします。しかし、範囲の終端 として解釈される "]" をバックスラッシュでエスケープした場合、 [W-\]46] は範囲の後に2つの文字が続く一つのクラスとして解釈さ れます。"]" の8進あるいは16進表現も範囲の終端として使用可能 です。 範囲指定では、ASCII 照合処理を行います。範囲では、[\000-\037] のように数値的に指定した文字も使用可能です。文字を含む範囲が 大文字小文字を区別しないマッチが設定されているときに使用された 場合、大文字小文字の両方にマッチします。例えば、[W-c] は、 [][\^_`wxyzabc] に等価であり、大文字小文字に関係なくマッチし ます。文字テーブルで "fr" ロケールを使用している場合、 [\xc8-\xcb] は、大文字小文字の区別無くアクセント付きの E に マッチします。 文字型 \d, \D, \s, \S, \w, \W は文字クラスの中でも指定可能 であり、クラスにマッチする文字を追加します。例えば、[\dABCDEF] は、16進数にマッチします。ハット記号は大文字と組み合わせて 小文字にマッチング??より範囲の狭い文字集合を簡便に指定する ことができます。 例えば、クラス [^\W_] は文字または数字にマッチしますが、アンダ ースコアにはマッチしません。\, -, (始端の)^ 以外の全ての英数字でない文字および終端の] は、 文字クラスにおいて特別でない文字ですが、エスケープした場合でも 悪影響はありません。
垂直バー文字は、選択肢を指定するパターンで使用されます。例えば、パターン gilbert|sullivan は、"gilbert" または "sullivan" にマッチします。選択肢の数に 制限はありません。また、選択肢を空とすることが可能です (空の文字列にマッチします)。マッチの過程は、各選択肢を左から 右に逆に行い、最初に成功したものが使用されます。選択肢が(以下 で説明する)サブパターンの中にある場合、"成功した"ということは サブパターンの選択肢と同様にメインパターンの残りの部分もマッチ したということを意?Wます。
PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, PCRE_EXTENDED の 設定は、"(?" および ")" で括った Perl オプション文字により パターン内部で変更可能です。 i PCRE_CASELESS を指定 m PCRE_MULTILINE を指定 s PCRE_DOTALL を指定 x PCRE_EXTENDED を指定 例えば、(?im) は大文字小文字を区別しない、複数行マッチングを 指定します。ハイフン文字を前につけることによりそのオプション を解除することも可能です。(?im-sx) のように設定と解除を組み合 わせることも可能です。この場合は、 PCRE_CASELESS および PCRE_MULTILINE が設定され、 PCRE_DOTALL および PCRE_EXTENDED が解除されます。ある文字がハイフンの前にも後にも指定された 場合、そのオプションは解除されます。 オプション変更の適用範囲は設定が行われたパターンの場所に依存 します。サブパターンの外側で設定された場合、その効果は、オプ ションの設定あるいは解除がマッチングの最初で行われたのと同じ となります。次のパターンは、全て全く同様に動作します。 (?i)abc a(?i)bc ab(?i)c abc(?i) はコンパイル後のパターンとしては、パターン abc に PCRE_CASELESS を設定したものとなり同じになります。言いかえると、このような "最上位の"設定は、(サブパターン内部で他の変更を行わない限り) パターン全体に適用されます。最上位と同じ設定が複数回行われて いる場合、最も右側の設定が使用されます。 サブパターンの内部でオプションの変更が行われた場合、効果は 異なります。この動作の変更は、Perl 5.005 で行われました。 サブパターン内のオプション変更は、それを指定したサブパター ンのその部分にのみ影響します。そのため、 (a(?i)b)c は、abc および aBc にマッチし、( PCRE_CASELESS が使用され ていないと仮定した場合、)他の文字列にはマッチしません。 このように、オプションは、パターンの各場所に異なった設定を行う ことが可能です。ある選択肢に御こなれた変更は全て、同じサブパ ターン内の後に続く枝に波及します。例えば、 (a(?i)b|c) は、"C" にマッチする際に最初の枝がオプション設定前に破棄 されているにもかかわらず、"ab", "aB", "c", "C" にマッチします。 これは、オプション設定の効果がコンパイル時に生じることにより ます。そうでないと、非常に奇妙なことが生じることになります。 PCRE 特有のオプション、 PCRE_UNGREEDY および PCRE_EXTRA はそれぞれ文字 U および X を使用することにより、Perl 互換のオプションと同様に変 更することが可能です。 (?X) フラグの設定は特別で、最上位の場合でも、常にパターン 内で他の設定をオンにする前に指定する必要があります。 このフラグは、最初に指定するのが最善です。
サブパターンは括弧(丸括弧)で区分され、ネストが可能です。 パターンの一部をサブパターンとして指定するためには、2つのこ とを行います。 1. 選択肢の集合をローカル化します。例えば、パターン cat(aract|erpillar|) は、単語 "cat", "cataract", "caterpillar" にマッチします。 括弧をつけないと、このパターンは、"cataract", "erpillar" または空の文字列にマッチしてしまいます。 2. 括弧は、サブパターンを(以下で定義する)値を取得するサブパターン として設定します。パターン全体がマッチしたサブパターンにマッチ した対象文字列の一部は、 pcre_exec() の ovector 引数によりコールした側に返されます。値を取得するサブパターンの 番号を得るために括弧の始まりは(1から始まって)左から右に数えられます。 例えば、文字列 "the red king" を次のパターンにマッチさせた場合、 the ((red|white) (king|queen)) 取得される部分文字列は、 "red king", "red", "king" であり、 それぞれ 1, 2, 3 番となります。 括弧が2つの機能を有しているという事実が常に良い方に働くわけで はありません。値を取得する必要はないが、サブパターンを複数用 いることが必要である場合も少なくありません。左括弧の後に "?:" を付けた場合、そのサブパターンは値の取得を行わず、値を取得する サブパターンの番号を計算する際にも加算されません。例えば、文字列 "the white queen" は次のパターンをマッチさせてみましょう。 the ((?:red|white) (king|queen)) 取得される部分文字列は、"white queen" と "queen" であり、 1番と 2番になります。部分文字列の最大数は99であり、値の取得を 行うものと行わないものを合わせて全サブパターンの最大数は 200です。 便利な略記として、オプションの設定を値を取得しないサブパターンの 先頭で指定する必要がある場合、オプションの文字を "?" と ":" の 間に入れることができます。つまり、次の2つのパターン、 (?i:saturday|sunday) (?:(?i)saturday|sunday) は全く同じ文字列集合にマッチします。選択肢は左から右に試行さ れ、オプションはサブパターンの終端に達するまでリセットされな いので、ある枝にあるオプション設定は後に続く枝にも作用します。 このため、上のパターンは、"Saturday" と同様に"SUNDAY" にも マッチします。
繰り返しは、反復指定子により指定します。次の要素の後に付ける ことが出来ます。 文字またはエスケープされた文字 メタ文字. 文字クラス 後方参照 (次の節を参照下さい) 括弧で括ったサブパターン(言明を除く - 以下を参照下さい) 通常の反復指定子は、大括弧の中に2つの数をカンマで区切って指定 することにより、マッチ可能な最小の数と最大の数を指定します。 指定する数は、65536 未満であり、最初の数は2番目の数以下である 必要があります。例えば、 z{2,4} は、"zz", "zzz", "zzzz" にマッチします。右括弧はそれ自体特別な 文字ではありません。2番目の数字が省略されたが、カンマがある場合、 上限は設定されません。2番目の数字とカンマの両方が省略された場合、 反復指定子は、必要なマッチの数そのものを指定します。つまり、 [aeiou]{3,} は3回以上母音が続くものにマッチしますが、もっと多い場合にも マッチします。一方、 \d{8} は8桁の数字にのみマッチします。左大括弧は反復指定子を置けない 場所または反復指定子の構文にマッチしない場所に置いた場合、文字 リテラルとして解釈されます。例えば、{,6} は反復挥Κ子ではなく、 4つの文字の文字リテラルとなります。 反復指定子として {0} を指定することができ、前の項目および反復 指定子が存在しないという式を指定したことになります。 簡単のため、最も使用される3つの反復指定子には、次のような1文字 の省略型があります。 * は、{0,} と等価です。 + は、{1,} と等価です。? は、{0,1} と等価です。 反復を設定せず、どの文字にもマッチしない次のようなサブパターンに より無限ループを作成することが可能です。 (a?)* 以前のバージョンの Perl および PCRE はこのようなパターンに関 してコンパイル時にエラーを発生していました。しかし、便利な場 合があるので、このようなパターンは現在は許可されています。 しかし、他のサブパターンの繰り返しがどの文字にもマッチしない 場合、ループは強制的に中断されます。 デフォルトでは、反復指定子は "貪欲"、つまり、残りのパターンを 失敗させることなく(許可された回数の最大数まで)出来るだけ多く のものにマッチします。 この動作が問題を生じる古典的な例としては、 C プログラムのコメントにマッチさせようとする場合があります。 コメントは、/* と */ の間にありますが、その中に、独立した文字 * と / が現れる可能性があります。C のコメントにマッチさせる ために、次のパターンを使用してみましょう。 /\*.*\*/ を文字列 /* first command */ not comment /* second comment */ に使用した場合、失敗します。これは、.* の貪欲さのせいで指定した パターンが文字列全体にマッチしてしまうためです。 しかし、反復指定子の後に疑問符を続けた場合、貪欲さは消え、 代わりに最小のマッチを行います。このため、パターン、 /\*.*?\*/ はCコメントに正しくマッチします。様々な反復指定子の意味は、 他には変化せず、好ましいマッチの数だけが変更されます。 この疑問符の使用法を反復指定子がその右にある場合の使用法と混乱し ないで下さい。このように2種類の使用法があるため、時々、次のように 2重に使用されることがあります。 \d??\d 選択により1桁の数字にマッチしますが、パターンの残りがマッチ する唯一の方法である場合には、2桁の数値にマッチすることが可能です。 PCRE_UNGREEDY オプショ ンが設定された場合(Perl ではこのオプションは使用できません)、反復 指定子はデフォルトでは貪欲ではありません。 しかし、この反復指定子は、後ろに疑問符をつけることにより貪欲 にすることが可能です。言いかえると、疑問符は、デフォルトの動作 を逆転します。 括弧で括られたサブパターンが1より多い最小の反復数または最大数 で指定されている場合、コンパイル済みのパターンのために、最大 または最小の大きさに応じてより多くの保存領域が必要となります。 パターンが、.* または .(0,) で始まり、(Perl で等価なものは /s) PCRE_DOTALL オプショ ンが設定されている場合、. は改行にマッチできるようになり、暗黙の うちにアンカー付きとなります。 これは、後ろに続くものによらず、対象文字列の各文字の位置に 対して試行されるためです。このため、最初にマッチした後で どこかの位置で全体のマッチを再び行うことはできません。 PCRE はこのようなパターンを \A が前にあるものとして処理します。 対象文字列が改行を含まないことが既知の場合、 パターンが .* で始まる場合の最適化のためにもしくは ^ を用いて アンカーを陽に示すために PCRE_DOTALL を設定する価値 があります。 値を取得するサブパターンが繰り返される時、取得される値は、 最後の繰り返しでマッチした部分文字列です。例えば、 (tweedle[dume]{3}\s*)+ "tweedledum tweedledee" をマッチさせた場合、取得される部分文 字列の値は、"tweedledee" です。しかし、ネストされた値を取得 するサブパターンがある場合、対応する取得値は前の繰り返しで指 定されたものになる可能性があります。例えば、 /(a|(b))+/ を "aba" にマッチさせると、2番目に取得される部分文字列は、 "b" になります。
文字クラスの外で、バックスラッシュの後に 0 より大きい数字を 付けたものはパターンで以前に(すなわち左にある)値を取得した サブパターンに対する後方参照であり、前にある値の取得を行う 左括弧の数まで使用可能です。 しかし、バックスラッシュの後に続く10進数が10未満の場合は常に 後方参照として解釈され、パターン全体の値を取得する左括弧の数 に満たない場合にのみエラーとなります。 言いかえると、参照される括弧は10未満の数については参照する側 の左にある必要がないということです。 バックスラッシュの後に数字が続く場合の処理の詳細については、 上記の "バックスラッシュ"という題の節を参照下さい。 後方参照は、サブパターン自体がマッチするものよりむしろ、 現在の対象文字列における値を取得するパターンが実際にマッチし たものにマッチします。このため、パターン (sens|respons)e and \1ibility は、"sense and sensibility" および "response and responsi- bility" にマッチしますが、"sense and responsibility" には マッチしません。後方参照の時点で、大文字小文字を区別したマッチ が有効の場合、文字の大文字小文字が関係します。例えば、 ((?i)rah)\s+\1 は、"rah rah" および "RAH RAH" にマッチしますが、 元の取得したサブパターンは大文字小文字を区別せずマッチしてい るにもかかわらず、"RAH rah" にはマッチしません。 同じサブパターンに複数回の後方参照を行Fことができます。ある サブパターンが特定のマッチで実際には使用されていない場合、 後方参照は常に失敗します。例えば、パターン (a|(bc))\2 は、"bc" ではなく "a" に最初にマッチする場合に常に失敗します。 最大 99 個の後方参照を使用できるため、バックスラッシュの後に 数字が続くものは全て後方参照番号の可能性がある集合として解釈 されます。 パターンの後に数字が続く場合、後方参照を終了するために なんらかの区切り文字を置く必要があります。 PCRE_EXTENDED オプ ションを設定している場合、空白を区切り文字とすることができます。 その他の場合は空のコメントを使用できます。 参照する括弧の中にある後方参照は、サブパターンを最初に使用し た際に失敗します。このため、(a\1) は何にもマッチしません。 しかし、このような参照は、複数回使用するサブパターンの内部で 有用です。例えば、次のパターン (a|b\1)+ は、"a" の並び、および "aba"、"ababaa" 等にもマッチします。 サブパターンの各反復において、後方参照は、前の繰り返しに対応 する文字列にマッチします。これを動作させるために、最初の反復 時に後方参照にマッチする必要がないようなパターンである必要が あります。これは上の例のように選択を使用するか、ゼロを最小と する反復指定子により行うことができます。
言明は、現在マッチを行っている位置の後に続くか前にある文字に 対するテストであり、実際には文字への作用を行いません。 \b, \B, \A, \Z, \z, ^, $のような簡単な言明コードを以下で説 明します。より複雑な言明は、サブパターンとしてコード化されま す。2種類の言明があります。対象文字列において現在位置の前を 見るものと、後ろを見るものです。 言明サブパターンは、現在マッチを行っている位置を変更ししない ことを除き、通常と同じようにマッチされます。前方への言明は、 肯定言明の場合 (?= で、否定言明の場合 (?! で始まります。例えば、 \w+(?=;) は、セミコロンが後に続く単語にマッチしますが、マッチするもの には、セミコロンを含ません。そして、 foo(?!bar) は、"bar" が後ろに続かない "foo" にマッチします。 見かけは似ているパターンに注意して下さい。 (?!foo)bar は、"foo" 以外のものが前にある "bar" の存在を見つけられません。 次の3文字が "bar" である場合に、(?!foo) は常に TRUE となるため に、このパターンは、"bar" の存在を見つけることができないのです。 この動作を実現するためには、後方言明が必要です。 後方言明は、肯定言明の場合 (? = で、否定言明の場合 (?! で始まります。例えば、 (? !foo)bar は、"foo" が前にない "bar" の存在を見つけます。後方言明の内容 は、マッチする文字列全体が固定長である必要があることに制限さ れています。しかし、複数の選択肢がある場合、全ての同じ固定長 である必要はありません。つまり、 (? =bullock|donkey) は使用可能ですが、 (? !dogs?|cats?) はコンパイル時にエラーを生じます。異なった長さの文字列にマッ チする枝は、後方言明の最上位でのみ使用可能です。この機能は、 全ての枝の同じ長さの文字列にマッチする必要がある Perl 5.005 に対して拡張されています。次のような言明 (? =ab(c|de)) は、最上位の枝が2つの異なった長さにマッチし得るため、使用でき ません。しかし、最上位の枝を2つ使用するように書き換えた場合は、 使用可能です。 (? =abc|abde) 後方言明の実装においては、選択肢毎に一時的に固定の幅だけ現在の 位置を後退し、マッチを試みます。現在位置の前に十分な文字がない 場合は、マッチは失敗とみなされます。1度しか使用されないサブパ ターンと組み合わせた後方言明は、文字列の終端でのマッチングに 特に有用です。節の最後に1度だけ使用するサブパターンの例を示し ます。 (あらゆる種類の)複数の言明を連続して指定することも可能です。 例えば、 (? =\d{3})(? !999)foo は前に "999" でない3桁の数字がある "foo" にマッチします。 各言明は対象文字列の同じ場所に独立して適用されることに注意して下 さい。まず、前の3文字が全て数字であることがチェックされ、続いて、 同じ3文字が"999"でないことが確認されます。このパターンは、"foo"の 前に6個の文字があり、その猜疑ょが数字で最後の3文字が"999"でないパ ターンにはマッチしません。例えば、"123abcfoo"にはマッチしません。 これを行うパターンは次のようになります。 (? =\d{3}...)(? !999)foo この時、最初の言明は、先行する6つの文字を探し、最初の3文字が数字 であることを確認します。続いて、2番目の言明は、先行する3文字が "999"でないことを確認します。 言明は、自由に組み合わせてネストさせることが可能です。例えば、 (? =(? !foo)bar)baz は、"bar" が前にあり、逆に "foo" が前にない "baz" にマッチします。 一方、 (? =\d{3}(?!999)...)foo は、3桁の数が先行し、中の3文字が"999"でない"foo"にマッチする別の パターンです。 言明のサブパターンは値を取得するサブパターンではなく、繰り 返されないかもしれません。それは、同じことを複数回言明するの は意味がないからです。ある言明が値を取得するサブパターンを 中に含んでいる場合、パターン全体の中で値を取得するサブパター ンを数えるために常に数え上げられます。 取得した部分文字列は、肯定言明では使用されますが、否定言明 では意味を持ちません。 言明の括弧で括られたサブパターンの数は、最大 200 です。
反復を最大化および最小化する場合は共に、後に続くものへのマッ チが失敗した場合、反復数を変えた場合にパターンの残りにマッチ することができるかどうかを調べるために反復する項目が再評価さ れます。 時々、こうした動作を行わない方が便利なことがります。 それは、パターンの作者が続けていく価値がないとわかった時に マッチの特性を変更するか、他のことがおきるよりも前に失敗させ る場合です。 例えば、パターン \d+foo を次の対象に適用した場合を考えてみま しょう。 123456bar 6桁の数字にマッチした後、"foo" にマッチするのに失敗します。 マッチ処理の通常の動作では、5桁の数字のみが \d+ にマッチする としてで再度試行を行い、続いて 4 桁といったように完全に失敗 するまで試行を行います。使い捨てのサブパターンは、 パターンの一部が一回マッチしたら、再評価されないことを指定す るものです。このため、最初に "foo" へのマッチに失敗した時点 で、ただちにマッチがとりやめられます。 表記には、次の例のように (? で始まる別の特別な括弧を用い ます。 (? \d+)bar この種類の括弧は、一回マッチが行われたパターンの一部に鍵をか け、そのパターンへの再マッチは失敗します。 しかし、マッチに成功する前の再マッチは、通常と同様に動作しま す。 この型のサブパターンは、対象文字列の現在の点にアンカーがある 場合、同じ孤立したパターンがマッチする文字列にマッチするとい うようにも説明できます。 使い捨てのサブパターンは、サブパターンの値を取得しません。 上の例のように簡単な場合は、できるだけ多くのものを呑み込む よう反復を最大化すると考えられます。 このため、\d+ および \d+? が数字の数を調整しつつ残りのパターン がマッチするようマッチを繰り返すのに対して、(? \d+) は 数字の並び全体にのみマッチが可能です。 この構造は、任意の複雑なサブパターンを含むことができ、ネスト することが可能です。 使い捨てのサブパターンは、文字列の終端に対するマッチを効率的 に指定するために後方言明を組み合わせて使用できます。次の簡単 なパターンを見てましょう。 abcd$ マッチしない長い文字列に適用した場合を考えます。 マッチは左から右に行われるため、PCRE は対象の "a" を探し、 後にあるものがパターンの残りにマッチするかどう??調べます。 パターンが次のように指定された場合、 ^.*abcd$ 最初の .* はまず文字列全体にマッチしますが、これに失敗した場 合、最後の文字以外の全てのものにマッチするよう再度マッチを 行い、続いて最後の2文字以外という風に動作します。 "a" の検索を文字列全体に対して左から右に再度行うため、 効率は良くありません。しかし、パターンを次のように書いた場合、 ^(? .*)(? =abcd) この場合は、.* に関する再検索は行われず、文字列全体にのみマッ チします。続く後方言明は、最後の4文字に対する試行を1回だけ行 います。これが失敗した場合、マッチはただちに失敗します。長い 文字列の場合、この方法による実行時間にはかなりの差が生じます。 パターンの無制限の繰り返しをサブパターン内に有しており、そのサブ パターン自体の無制限の反復が可能な場合、一度限りのサブパターンの 使用がマッチに非常に長い時間かかり失敗することを回避するための唯 一の手段です。 パターン (\D+| \d+ )*[!?] は、無制限の数の副文字列にマッチします。その副文字列は非数値から なるか で括られた数値のどちらかで、後に! または? が続くもので す。マッチした場合、実行は高速です。しかし、以下の文字列に適用し た場合、 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa エラーを出力するまでに長い時間を要します。これは、二つの反復に文 字列を分割する選択肢が多く、全て試みる必要があるためです。(この例 では、終端に単一の文字ではなく[!?]を使用しています。これは、PCRE とPerlは共に単一の文字を使用した場合により早く失敗と判定するよう に最適化するためです。マッチに必要な最後の一文字をこれらは記憶し ており、文字列にこれがない場合に早期に失敗と判定します。) このパターンを次のように変更した場合、 ((? \D+)| \d+ )*[!?] 数字以外の並びにより不備を生じることがなくなり、失敗は早期に生じ ます。
言明の結果または前の値を取得するサブパターンがマッチしたかど うかにより、サブパターンのマッチ処理を行ったり、サブパターンの 2つの選択肢を選択したりすることが可能です。条件付きサブパター ンには2つの形式があります。 (?(condition)yes-pattern) (?(condition)yes-pattern|no-pattern) 条件が満たされた場合、yes-pattern が使用されます。そうでない 場合は、(指定された場合は) no-pattern が使用されます。サブパ ターンに2つ以上の選択肢がある場合、コンパイル時にエラーになり ます。 2種類の条件があります。括弧の間のテキストが数字の並びからなる 場合、条件は、その番号の値を取得したサブパターンが前にマッチ している場合に満たされます。次のパターンを見てみましょう。 可読性を高めるために意味のない空白を挿入し(PCRE_EXTENDED オプションが指定されたと仮定します)、説明を簡単にするため 3つの部分に分割しています。 (\()? [^()]+ (?(1)\)) 最初の部分は、オプションの左括弧にマッチし、その文字がある場 合に、最初の部分文字列として設定します。第2の部分は、括弧以外 の一つ以上の文字にマッチします。第3の部分は、最初の括弧にマッ チしたかどうかを調べる条件付きサブパターンです。マッチしている 場合、つまり、対象が左括弧で始まっている場合、条件は TRUE と なり、yes-pattern が実行され、右括弧が必要となります。 そうでない場合、no-pattern が存在しないため、サブパターンは 何にもマッチしません。言いかえると、このパターンは、括弧なし の並びにマッチし、オプションで括弧で囲まれた並びにマッチします。 条件が数字の並びの場合、言明となります。肯定あるいは否定の 前方または後方言明となります。次のパターンを見てみましょう。 このパターンにも意味のないパターンを挿入し、2つの選択肢を2行 目に置いています。 (?(?=[^a-z]*[a-z]) \d{2}-[a-z]{3}-\d{2} | \d{2}-\d{2}-\d{2}) 条件は、肯定後方言明であり、英字以外の文字の並びかその後に 英字が続くものにマッチします。言いかえると、対象文字列に少な くとも文字が一つあるかどうかを調べます。文字がみつかると、 検索対象は最初の選択肢に対してマッチします。みつからない場合 は、2番目にマッチします。このパターンは、2つの形式 dd-aaa-dd または dd-dd-dd のどちらかの文字列にマッチします。ただし、 aaa は英字、dd は数字です。
(?# という並びは、開始を指定します。コメントは、次の右括弧まで 続きます。括弧のネストは許可されません。コメント中の文字は、 パターンマッチングには全く関係しません。 PCRE_EXTENDED オプションが設定されている場合、文字クラスの外 にあるエスケープされていない # 文字は、コメントを指定します。 コメントは、パターン中の次の改行文字まで続きます。
無制限のネストを許容する括弧を含む文字列にマッチを行う問題を考え てみましょう。再帰を使用しない場合、実現可能な最良の方法は、何ら かの固定した深さのネストまでマッチを行うパターンを使用することで す。これでは、任意の深さのネストを処理することはできません。Perl 5.6では、(他の機能と共に)正規表現で再帰を行うことを可能にする実験 的な機能がサポートされています。専用のシーケンス (?R)が再帰を指定 するためにサポートされています。このPCREパターンによりこの括弧の 問題は次のように解決されます。(空白を無視するために PCRE_EXTENDED オプション が設定されていると仮定します) \( ((? [^()]+) | (?R) )*\) まず、このパターンは開き括弧にマッチします。続いて、括弧以外の並 びまたはパターン自体に再帰的にマッチする部分文字列に何回でもマッ チします。最後に閉じ括弧にマッチします。 このパターン例には、ネストした無制限の反復が含まれており、このた め、マッチしない文字列のパターンを適用する際に括弧以外の文字列に 一回だけマッチするサブパターンを使用することが重要です。例えば、 このパターンを次の文字列に適用した場合、 (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa() "マッチしない"という判定が速やかに行われます。しかし、一回限りの サブパターンを使用しない場合、対象文字列を分割可能な + と * の反 復の種類が非常に多く、失敗を出力する前に全てを確認する必要がある ため、マッチに非常に時間がかかります。 値を取得するサブパターンに設定される値は、サブパターンの値が設定 される最も外側の再帰のレベルからのものです。上記のパターンを以下 にマッチさせる場合、 (ab(cd)ef) 値を取得する括弧の値は"ef"であり、最上位レベルの最後の値です。 次のように括弧を追加すると、 \( (((? [^()]+) | (?R) )*)\) 取得される文字列は、"ab(cd)ef" と なり、最上位レベルの括弧の中身となります。一つのパターン内に 15以上の取得用括弧がある場合、PCREは再帰の間のデータ保存用に 追加のメモリを取得する必要があります。これは、pcre_malloc に より確保され、後で pcre_free により開放されます。メモリが取 得できない場合、メモリ不足エラーを再帰の内側から出力する手段 はないため、最初の15個の取得用括弧についてのみデータが保存さ れます。
パターンの幾つかの要素は、他の要素よりもより効率的です。 (a|e|i|o|u) のような選択肢の集合よりも [aeiou] のような文字ク ラスの方がより効率的です。一般に、構成が最も簡単なものが たいてい最も効率が良いです。Jeffrey Friedl の本には、 性能向上のために正規表現の最適化に関する多くの議論が 記述されています。 パターンが .* で始まり、 PCRE_DOTALL オプションが設 定されている場合、対象文字列の始端でしかまっちできないため、パター ンはPCREにより暗黙のうちにアンカー付きとなります。 しかし、 PCRE_DOTALL が設定されていない場合、メタ文字. が改行にマッチしないので、PCRE はこの最適化を行えません。 対象文字列が改行を含む場合、パターンは文字列の始端からではなく 各改行の直後の文字からマッチする可能性があります。例えば、 パターン (.*) second は、対象文字列 "first\nand second" (ただし、\n は改行文字を 意味します) にマッチします。 最初に値を取得される部分文字列は、"and" になります。これを動 作させるには、PCRE は対象文字列の各改行の後からマッチを再度 開始する必要があります。 このようなパターンを改行を含まない対象文字列に使用した場合、 PCRE_DOTALL を設定す るか、アンカー付きであることを陽に示すためにパターンを ^.* で開始 することにより最高の性能が得られます。 これにより、PCRE が対象文字列の改行を探し、そこで再スタート することを防止します。 ネストした未確定の反復を有するパターンには注意を要します。 このパターンをマッチしない文字列に適用した場合には、実行に長い時 間を要します。次のパターンを考えてみましょう。 (a+)* これは、33通りの異なった方法で、"aaaa"にマッチします。この数は、 文字列が長くなるにつれて急激に増大します。(* 反復は、0、1、2、3、 4回マッチし、0以外の各々のケースで、+反復は異なった回数分マッチし ます) パターンの残りにマッチ全体が失敗するようなパターンである場 合、PCREは基本的に全ての可能性がある選択肢を調べるため、非常に長 い時間がかかります。 次のように文字リテラルが後にあるようなより簡単な場合には最適化が 可能です。 (a+)*b 標準のマッチ手順に着手する前に、PCREは対象文字列の後の方に"b"があ るかどうかを調べます。これがない場合には、直ちにマッチは失敗しま す。しかし、リテラルが後にない場合には、この最適化を使用すること はできません。以下のパターンと上のパターンの動作の差異を比較して みましょう。 (a+)*\d 前者は、全体が "a" 文字である行に適用された場合にほぼ瞬間的に失敗 と判定します。一方、後者では、およそ20文字より長い文字列ではかな りの時間がかかります。