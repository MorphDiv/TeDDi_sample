# language_name_wals:	Japanese
# language_name_glotto:	Japanese
# ISO_6393:	jpn
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Jpan
# special_characters:	NA
# short_description:	PHP
# source:	https://object.pouta.csc.fi/OPUS-PHP/v1/raw/ja.zip
# copyright_short:	http://opus.nlpl.eu/PHP.php
# copyright_long:	http://opus.nlpl.eu/PHP.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

変数のスコープは、その変数が定義されたコンテキストです。ほとんどの PHP 変数は、スコープを1つだけ有しています。このスコープの範囲は、 includeやrequireにより読みこまれたファイルも含みます。例えば、
この例で、変数 $a はインクルードされた b.inc スクリプトの中でも利用可能です。しかし、 ユーザー定義の関数の中では変数の有効範囲はローカル関数の中となりま す。関数の中で使用された変数はデフォルトで有効範囲が関数内部に制限 されます。例えば、
このスクリプトは、出力を全く行いません。これは、echo 命令がローカ ル版の $a 変数を参照しているにもかかわらず、こ のスコープでは値が代入されていないからです。この動作は、特にローカ ルな定義で上書きしない限りグローバル変数が自動的に関数で使用可能で ある C 言語と少々異なっていると気がつかれるかもしれません。C言語の ような場合、グローバル変数を不注意で変更してしまうという問題を生じ る可能性があります。PHP では、グローバル変数は、関数の内部で使用す る場合、関数の内部でグローバルとして宣言する必要があります。例を以 下に示します。
上のスクリプトは、"3" を出力します。関数の内部で $a 、 $b をグローバル宣言を行うことにより、両変数への参照は、グローバル変数 の方を参照することになります。ある関数により操作できるグローバル変 数の数は無制限です。
グローバルスコープから変数をアクセスする2番目の方法は、PHPが定義す る配列 $GLOBALS を使用することです。先の例は、次 のように書き換えることができます。
配列 $GLOBALS は連想配列であり、グローバル変数の 名前がキー、その変数の内容が配列要素の値となっています。 $GLOBALS は スーパーグローバル であるため、 $GLOBALS は全てのスコープに存在します。 以下にスーパーグローバルの効果を示す例を示します。

変数のスコープに関する別の重要な機能は、 静的 (static) 変数です。静的変数はローカル関数スコープのみに 存在しますが、プログラム実行がこのスコープの外で行われるようになっ てもその値を失わないません。次の例を見てください。
この関数は、コールされる度に $a を 0 にセットし、"0" を出力するのでほとん ど役にたちません。変数を1増やす $a++ は、関数から外に出ると変数 $a が消えてしまうために目的を達成しません。現在 のカウントの追跡ができるようにカウント関数を使用できるようにするた めには、変数 $a をstaticとして宣言します。
こうすると、Test() 関数がコールされる度に $a の値 を出力し、その値を増加させます。
static変数は、再帰関数を実現する1つの手段としても使用されます。再帰 関数は、自分自身をコールする関数です。再帰関数を書くときには、無限 に再帰を行う可能性があるため、注意する必要があります。適当な方法に より再帰を確実に終了させる必要があります。次の簡単な関数は、中止す るタイミングを知るためにstatic変数 $count を用いて、 10 回まで再帰を行います。
PHP4 を駆動するZend Engine 1では、 リファレンス変数の修正子 static および global を実装しています。 例えば、関数スコープ内に global 命令により実際にインポートされた真のグローバル変数は、 実際にグローバル変数へのリファレンスを作成します。 これにより、以下の例が示すように予測できない動作を引き起こす可能性 があります。
この例を実行すると以下の出力が結果として表示されます。
類似の動作が static 命令にも適用されます。 リファレンスは静的に保存することができません。
この例を実行すると以下の出力となります。
この例は、static変数にリファレンスを代入した時に get_instance_ref() 関数を2回目に コールした際に保持されていないことを示しています。