# language_name_wals:	Japanese
# language_name_glotto:	Japanese
# iso639_3:	jpn
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Jpan
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/ja.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

common
common
common
ウェブ用の画像の作成
ウェブ
ウェブ用の画像

画像の容量最適化と品質
画像をウェブでも使いやすくするとき肝心なのは、 どんな画像形態とファイル形式にするかということです。 写真は大抵がたくさんの色を持ちとても緻密なので
まずは、 いつも通り画像を開いてください。 ここには例として我らがウィルバー君の画像をとりあげます。

この画像は
写真画像にアルファチャンネルがつくことはめったにありませんので、 画像は
もしも画像に半透明な部分があり、 全く透明な部分へ徐々に変化する透過効果がついているなら、 アルファチャンネルを外してはなりません。 [インデックス化も避けるべきです。] この部分に用いられているなだらかな色変化の情報がファイルに保存されなくなるからです。 透明部分がある画像でも、 徐々に変化する部分を含まないのであれば、 (
画像を統合したあとは、 ウェブサイト用に
画像を
さらにファイル容量を削減
画像のファイル容量をもっと小さくしたいときは、 画像をインデックス化モードに変換することになるでしょう。 つまり全色数を 256 色に減らすのです。 徐々に色が変化する画像やグラデーション効果があるものはインデックス化モードに変換してはいけません。 なぜなら徐々に変化していた色が数色の縞に変えられてしまうからです。 とくにインデックス化モードは写真に使うと粗末な仕上りになるためおすすめできません。
インデックス化した画像
インデックス化した画像はややギザギザになってしまう。 左上の画像が元の大きさのウィルバー君、 右の大きい画像が 300 パーセントにズームしたもの。

画像をインデックス化モードに変換したら、 こんどは
透過画像の保存
透過効果
透過画像の保存
画像の透明部分をサポートするのに使える画像ファイル形式は 2 つあります。 単純二値化透過とアルファ透過です。 単純二値化透過は

透明部分のある画像の作成 (アルファ透過)
まずは
アルファ透過つきの画像で保存するにはアルファチャンネルが必要です。 画像のアルファチャンネルの有無は、

画像が仕上がったら、
透過効果つきのウィルバー像

localized
common
common
common
common
ブラシのサイズ変更
ブラシ

ブラシの高さの変更方法
ブラシの大きさを変更する方法が 3 通りあります。
ブラシを利用するツールオプションの
拡大・縮小スライダー
マウスホイールを使うようプログラムする方法
画像ウィンドウのメニューより
現れた


すると
下側の対応表内の
表の下の中央にある


左側の
すると
同じ手順で、
ウィンドウを閉じます。
最後に、
説明が少々長くなりましたが、 もうマウスホイールでブラシの大きさを調節できるようになっているはずです。 試しに
キーボードの
その手順はマウスホイールにするのと似ていますが、 次の点が異なります。


そして、 マウスホイールと同じ結果がふたつのキー (
ブラシの手早い作成
ブラシを簡単に作る方法を 2 通りご紹介します。
最初は
選択範囲が取り込まれてブラシになる
ふたつめの方法は最初のよりも手が込んでいます。

この新しい画像を拡大ズーム表示して、
その絵を
ブラシダイアログウィンドウの
そのあとは貴方の手になる鳥肌が立ちそうなブラシが、 ちゃんと他のブラシと一緒に並んで表示されます。 今直ぐにこのブラシは使えます。
ブラシの作成手順
絵を描いたら ブラシとして保存
ブラシの更新
ブラシを使う
localized
テキストツールボックス
テキスト
ツールボックス
このテキスト用ツールボックスはテキストツールで画像をクリックするとただちに画像上に出現します。 これで文字編集が直に画像上で行なえます。
従来の書体系統や字体や大きさを選択するテキスト整形機能ではなく、 ここでは基線からのオフセット値やカーニング値による数値制御を行なうしくみになっており、 さらに選択した文字の色が変更できるようなっています。
ツールチップ表示が充分な説明をしてくれます。
基線からのオフセット値やカーニング値を変更する方法には
これらの機能は選択してある文字にのみ作用します。 何も文字を選択しないでこの機能を使うと変な効果が出ます。
テキスト用ツールボックスの脈絡メニュー
common
common
common
common
common
common
単純なものの描画
直線
直線を引く
演習
矩形
矩形を描く
この節では
直線の引き方
直線を引くところから始めましょう。 直線を引く最も簡単な方法は、 お好きな
白紙の画像
このダイアログは背景を白く塗りつぶした新しい画像を示している。

直線の始点
このダイアログには直線の始点を示す点が現れている。 この点は描画色にしてあった黒で描かれている。

補助線
このスクリーンショットでは描かれる直線を予見できる補助線が示されている。
それでは
次のクリックで現れた直線

補助線が望み通りの方向と長さになったら
基本図形を描画
そういった用途のために

矩形の選択範囲を作成
このスクリーンショットは矩形選択の作り方を示している。 マウスの
矩形 (長方形) や楕円形などの基本図形は
描画色で塗りつぶされた矩形の選択範囲
このスクリーンショットは矩形の選択範囲が描画色で塗りつぶされた様子を表しています。
選択範囲ができあがったら、 描画色に指定した色で範囲内を塗りつぶしたり輪郭線をなぞったりできます。 どちらもまず
localized
メニューの各機能にショートカットを作成
ショートカット
誂物
メニューを通じて呼び出せる数多くの機能に初期段階からキーボードショートカットが付いています。 能く使うのにまだ付いていないコマンドに新たにショートカットを付けたり、 稀ですが既にあるショートカットを編集してみたいと思ったことはありませんか。 これには 2 通りの手続きがあります。
動的キーボードショートカットを使用する
第 1 の方法は、
このときさらに、 作成したショートカットが保存されるようにするため
キーボードショートカットを付けるには、 まずメニュー上でお目当てのコマンドにマウスポインターをかざしてください。 するとその行が強調表示されます。 マウスポインターが動かないように注意しながら関連づけたいキー、 もしくは修飾キーとの組み合わせを押したまま
自前で誂えるショートカットには

キーボードショートカット編集ダイアログを利用
このエディターダイアログは
ショートカットを作成したいコマンドを、 ご覧いただいているダイアログの左側、
このショートカットエディターはキーボードによる
誂えたキーボードショートカットは
タイルキャッシュの設定方法
タイルキャッシュ
データの処理や絵の操作をすすめるにつれ、
タイルキャッシュ値を低くすると
それではタイルキャッシュの大きさはどの位が適当でしょうか。 ちょうど良い値を見付けるためのコツやちょっとした技をここに紹介します。
一番楽なやり方は何も気にしないで、 既定値でうまくいくと信じることです。 コンピューターに搭載されている
メモリーをふんだんに搭載 (512 メガバイト以上) した最新のコンピューターなら、 タイルキャッシュの設定量がその
お使いのコンピューターが大勢で共有されているものならば、 管理者か誰かに設定を頼むのが良策です。 ただし
一定の間をとりながら少しずつその値を上昇させてゆくのなら、 システムがメモリー不足を訴えることもなくそのつど加速が見込めます。 ただしときには突然にメモリー不足が顕在化し、 一部のアプリケーションを資源確保のため強制終了するはめになるおそれがあります。
簡単な計算で済みますから実用的な値を弾き出しましょう。 遅かれ早かれ調整しなければならないことですし、 上に挙げた方法によることになるでしょう。 さあこれでタイルキャッシュの設定の違いでどんな結果がでるか判りましたし、 お使いのコンピューターから最大限の処理能力が引き出せるようになりました。
最後の提案にあったちょうど良い値が気になると思います。 これを得るには、 まずはじめにお使いのコンピューターについていくつかのデータを用意せねばなりません。 システムに搭載されている
つぎに、
あとはいよいよ決断ですがちょっとだけ簡単な計算が必要です。 決断で肝心な点は、 すべてのタイルキャッシュを

オペレーティングシステムのスワップ領域が置かれているのと同じディスク内に


もうお觧りになったと思いますが、 すべては記憶資源の残量の確認と、 いかに
もちろんタイルキャッシュの設定には他のきっかけもあります。 まず基本的なところではコンピューターの使用状況が変化するとか、 ハードウェア自体を変更したという場合です。 そういうときには[今までの]コンピューターの使い方や処理速度についての勘はもはやあてになりません。 やはり先に述べた決断への過程を通して適当な値を見極める必要があります。 その値は以前のものとほとんど変わらないかも知れませんし、 全然違う値が出てくるかもしれません。
タイルキャッシュの値を変えるもうひとつの理由はどうも

このほかには手持ちの一番速いディスクや、 普段使っているファイルを収めるディスクとは別のディスクにスワップ用フォルダーを置く技があります。 通常はオペレーティングシステムが管理するスワップ領域を複数のディスクに分散して置くのも良策といえます。 言わずもがなではありますが
画像を開いたらそれが消費するメモリー量も見てみてはどうでしょうか。 画像は大きいものほど、 また操作履歴が長くなればなるほど、 資源の消費量も増えていきます。 ここで得られる数値を参考にするのもひとつの方法ではあります。 ただし扱う画像の大きさがほとんど同じで、 消費される実際のメモリー量も変化しないことが条件です。 そのほかこの消費量を参考にすれば必要な
common
common
common
common
選択範囲の作成と利用
選択範囲
利用法
選択範囲の移動
選択範囲
移動
矩形選択や楕円選択の見えかたは 2 つのモードがあります。 初期設定では選択範囲に取っ手 (ハンドル) がつきますが、 選択範囲内をクリックするか
矩形選択と楕円選択の移動
選択範囲の取っ手をクリックしてドラッグすると、 選択範囲の境界線は移動しますが、 選択された矩形や楕円の内側の画像は移動しません。

選択範囲の輪郭を移動
大概のシステムでは
取っ手のない選択をドラッグして放った場合には、 新たな選択ができてしまいます。選択範囲の内容の移動のしかたは、 つぎの 2 通りがあります。

選択範囲とその内容の移動、 もとの位置に空白

もとの位置を空白とせずに、 選択範囲とその内容を移動
システムに拠っては
その他のツールでの選択範囲の移動
それ以外の選択方法 (自由選択、 ファジー選択、 色域選択) では選択範囲に取っ手がありません。 これらをそのままドラッグして放つことはできません。 これらの選択範囲を矩形や楕円の場合のように移動させるには、 それぞれ
クリックしてドラッグするかわりに
その他の方法
もっと遠回しな方法ならば、 他にも選択範囲を移動できます。 まず
選択範囲の加減
選択範囲の加減
置換が最もよく使われる選択のモードです。 置換モードでは既存の選択範囲が解消され新たに作った選択範囲で置き換わります。
追加モードは既存の選択範囲に新たに作成した選択範囲を足します。
除去モードは既存の選択範囲から新たに作成した選択範囲を引きます。
交差モードは既存の選択範囲と新たに作成した選択範囲の共通部分だけが残ります。
ツールには大抵その振る舞いを調節するためのツールオプションが付いています。 選択ツールなら選択のモードが選べます。 次の種類の選択モードがあります。
自由選択ツールを使用して矩形選択範囲を拡張
この図では矩形の選択範囲が既にできています。 自由選択 (なげなわ) ツールを起用します。
選択のはみだしを精密に修正するのなら、
localized
localized
common
Script-Fu 作成演習
Script-Fu
演習
この訓練過程は Script-Fu を扱う上で必須の Scheme 言語の基礎を身につけ、 例題で便利なスクリプトを書いて道具箱に収めるまでを修めていただきます。 例題のスクリプトはユーザーに語句の入力を促し、 そのテキストの大きさにぴったり合う画像を新たに作成します。 つづいてテキストまわりに余裕をもたせる空隙をつくれるようにスクリプトを改造します。 少しずつ Script-Fu の知識が身につくよう、 ここでとりあげる議題は最小限にとどめることにしました。
この節は
Scheme に精通
Scheme をはじめよう
最もはじめに学んでほしいことは、
Scheme 言語ではどんな構文も丸括弧 () でくくられること
そのつぎに覚えてほしいことは、
関数名や演算子は常に括弧内の先頭に置かれ、 つづくパラメーターがその関数や演算子に渡されること
です。 もちろん括弧でくくられるのは関数だけにとどまりません。 リストと呼ばれる一連の項目の羅列も括弧でくくります。 これについてはあとで触れます。 Scheme は前置記法の規則にしたがい関数が式の最初に来ます。 後置記法に馴染みのある方や
3 つ目にご理解いただきたいことは、
算数で使われている演算子も関数の一種とみなされており、 数式を書くときその最初に置かなくてはならないこと
です。 こちらの規則は前置記法の考え方がわかればすんなり理解できると思います。
前置記法と中置記法と後置記法のそれぞれの例
この例は
前置記法では
中置記法では
後置記法では
Scheme の練習
では早速学んだことを練習してみましょう。 まだ
Script-Fu コンソールのウィンドウ
ウィンドウの下部にある一行記入欄はかつて
(+ 3 5)
このように記入したら
Script-Fu コンソールを使う
ではもっとたくさんの数値を合算させたいときはどうすればよいのでしょう。
(+ 3 5 6)
この式も期待通りの答えとなる 14 を返します。
ここまではよろしいですか。 Scheme 構文を
余計な括弧に注意しよう
複雑な数式を書くときも読むときもその構成をはっきりさせる目的で部分ごとに括弧をつけることを私などはよくやりますが、 そういう人はどこでも好きなところに括弧をつけ足す習慣がついています。 ところが Scheme ではそういった余分な括弧を書かないよう気をつけねばなりません。 たとえばもし 5 たす 6 の結果に 3 [や 7] を足そうとしたら普通はこんな風に書くでしょう。
3 + (5 + 6) + 7 = ?
前置記法は
(+ 3 (5 6) 7)
でもこれは間違いです。 Scheme の構文はいずれも丸括弧ではじまり丸括弧で終わることを思い出してください。 Scheme のインタープリターは 2 つめの括弧に出会ったときに括弧内の数値を足すのではなく先頭の
正しい記法はつぎのようにします。
(+ 3 (+ 5 6) 7)
空白も適切に入れるよう気をつけよう
C/C++ や Perl や Java のような他のプログラミング言語に慣れ親しんだ人なら演算子の周囲に空白をどう置くか注意しなくても数式は適切に書けると思っているはずです。
3+5, 3 +5, 3+ 5
C/C++ と Perl と Java のコンパイラーは上の数式のいずれも受け入れます。 ところが同じ規則が Scheme には通用しません。 Scheme では数式記号や関数名や演算子のあとに空白を置かなければ Scheme インタープリターに正しく解釈してもらえません。
Script-Fu コンソールを使ってもうすこしの間簡単な数式で練習を積み、 以上の基本的な構えにすっかり慣れるようにしてください。
変数と関数
さて今、 どんな Scheme 構文も丸括弧でくくられること、 関数名や演算子はその先頭に置かれることが觧りましたが、 つぎは変数の作り方と使い方や、 関数の作り方と使い方を知っておかなければなりません。 まずは変数から始めましょうか。
変数の定義
変数の定義のしかたには 2 通りの方法があるのですが、
(let*
 (
 (a 1)
 (b 2)
 )
 (+ a b)
 )
のように書きます。 これはつぎのように 1 行でも書けます。
(let* ( (a 1) (b 2) ) (+ a b) )
コンソールウィンドウでは 1 行にまとめて記入しなければなりません。 でも普通はスクリプトが見易くなるように字下げを適宜行ないたいですよね。 この節で空白文字についてもう少し掘り下げて説明します。
このコードは a と b の 2 つの変数を定義して初期化し、 両局所変数の合算を表示して終わります。
局所変数とは何でしょう
計算式
その理由はスクリプト内に書かれた


(let* (
となります。
空白文字
先程、 スクリプトは字下げをして明確でまとまりのある書き方ができると申し上げました。 やってみたいと思われたことでしょう。 身に付けると良い習慣ですし、 Scheme 言語に問題を起こすことはありません。 空白文字はいくら増やしても Scheme インタープリターが無視しますので、 自由に使ってスクリプトを解り易くまとめるのに役立てられます。 ただし Script-Fu コンソール上でだけは式全体を 1 行に書く必要があります。 つまり式の最初の括弧
新しい値を変数に代入
一度変数を初期化して使用したあとで、 スクリプト内で別の値を入れて使う必要が生じるかもしれません。 そんなときは
(let* ( (いろは 10) ) (set! いろは (+ いろは いろは)) )
この構文がどんなことをしているかあててみてください。 そうしたら Script-Fu コンソールに実際に書き込んで試してみましょう。
例題に
関数
さて変数のコツを掴んだところでこんどは関数の扱い方に取り組みましょう。 関数はつぎの構文規則で定義します。
(define
 (
ここで
(define (AddXY inX inY) (+ inX inY) )
の関数定義では
C/C++ や Java や Pascal のような他の命令型言語のプログラミングを経験された方はそういった言語と比べて見るとこの関数定義に 2 つのことがらが抜け落ちていることに気付かれたことでしょう。
ひとつめはどのパラメーターにも
ふたつめは関数が得た結果の値を
(AddXY (AddXY 5 6) 4)
リストにリストもそのまたリスト
変数と関数の鍛錬をしたばかりですが、 ここからは Scheme のリストの霧靄立ち籠める湿地に足を踏み入れます。
リストの定義法
リストについてあれこれ話す前にアトム値とリストの何が違うのか知っていただく必要があります。
アトム値についてはこれまでの講義で変数を初期化するときにご覧に入れました。 アトム値とは単独値のことです。 ですからたとえばつぎの構文で変数
(let* ( (x 8) ) x)
この例では最後にもう一度
変数は単なる値のみならず一連の他の値をまとめたリストを指すこともできます。 値 1、 3、 5 からなるリストを変数
(let* ( (x '(1 3 5))) x)
先の構文とこの構文をおのおの Script-Fu コンソールに打ち込んでどんな結果が返されるか試してみましょう。 先の構文を打ち込んだ場合はこのような簡単な答えになります。
8
ところがもう一方の構文を打ち込んだ場合にはつぎのような結果を返します。
(1 3 5)
返された値が 8 の例は変数
リストを定義する構文は、
'(a b c)
のように書く規則になっており、
空のリストもつぎのようにすれば定義できます。
'()
もしくは単純に、
()
と書いてもよろしい。 リストにはアトム値だけでなく他のリストも入れられます。
(let*
 (
 (x
 '("GIMP" (1 2 3) ("is" ("great" () ) ) )
 )
 )
 x
)
ちなみに最初にアポストロフィをつけてしまえば、 その内部でさらにリストをつくるときにアポストロフィを省略できます。 それでは直ちに Script-Fu コンソールに上記のリストを写してどんな結果がでるか見てみましょう。
返される値が単なるアトム値のリストではないことに注意してください。 ここではリテラル
リストの考え方
リストを
連結でリストを作成 (Cons 関数)
今後使うことになる関数のなかでも
(cons 1 '(2 3 4) )
結果的にリストは
同様にして要素がひとつだけのリストも作れます。
(cons 1 () )
先に定義してあった変数が、 あらゆるリテラルの代わりに思い通りに使えます。

リテラルとあらかじめ定義しておいた変数を組み合わせて、
(list 5 4 3 a b c)
この式は変数
(let* (
 (a 1)
 (b 2)
 (c 3)
 )

 (list 5 4 3 a b c)
 )
この式はリスト
リスト内の値を引き出す
リストの中にある値を取り出すときは


(car '("first" 2 "third"))
すなわちこれはつぎの値と同じです。
"first"


(cdr '("first" 2 "third"))
この式が返すのはつぎのとおりです。
(2 "third")
また、
(cdr '("たったひとつ"))
リストの他の位置の要素を引き出す
はい、 もう十分です。 リストから先頭の要素も後続の要素たちも取り出せるようになりました。 それではリストの 2 番目や 3 番目などほかの要素はどんなふうにしたら取り出せるのでしょう。 ここで使える
根本的に命名規則は簡単です。 a や d がそれぞれリストの先頭や後続を表しているのです。 ですから
(car (cdr (car x) ) )
という式はつぎのように書き直せます。
(cadar x)
リスト用引き出し関数の練習のためつぎのスクリプトを書いてみましょう。 コンソール上で試すときは 1 行につづけて書きます。 そうしたら
(let* (
 (x '( (1 2 (3 4 5) 6) 7 8 (9 10) )
 )
 )
 ; この行以降にご自分なりの式を car や cdr を駆使して書きます
 )
両関数だけをいろいろ組み合わせて、 リストから数字の 3 を引き出す式を書きましょう。 これができるならあなたは Script-Fu の達人になりつつあるのです。
Scheme 言語ではセミコロン
はじめての Script-Fu スクリプト
ひと息ついて休みをとる必要はないですか。 大丈夫ですね。 よろしい、 ではいよいよはじめての Script-Fu スクリプトを書く第 4 段階に進みましょう。
テキストボックススクリプトを作成

Script-Fu の達人も入門者のみなさんも Script-Fu を使ったら簡単かつ自動的にこの問題を解決できるとすぐ気付くはずです。
したがってテキストボックスという名前でスクリプトを書いて、 これに画像を作らせ、 テキストを与えたらちょうどぴったり囲む頃合いの寸法になるようなスクリプトにしましょう。 それから好みのフォントやフォントサイズや文字色が選べるようにしましょう。
スクリプトを書いて保存
ここまで私たちは
自作のスクリプトをどこに置くかは好みの設定の問題でもあります。 もし
ホームディレクトリー内に
肝心要
どんな Script-Fu スクリプトもそのメイン関数として少なくとも 1 つの関数を定義します。 この作業にとりかかりましょう。
またどんな Script-Fu もプロシージャーデータベースに登録して
ではメイン関数をまず定義しましょう。
(define (script-fu-text-box inText inFont inFontSize inTextColor))
この式で
命名規則
Scheme の変数や関数の名前は小文字の英字を適宜ハイフンでつないだ表現が好まれているようです。 それで私も同じ規則でこの関数の名前をつけました。 ただしパラメーターについてはその規則から外れた方法をとることにします。 私は変数やパラメーターにはもっと説明的な書き方をするのが好きなので、 パラメーターの頭に

関数を登録
ではこの関数を
関数を登録している様子をつぎに示します。 パラメーターに関してはまもなく説明します。
以上の関数をテキストファイルにして
この新しいスクリプトは実行しても何も起こりません。 もちろんメニューを辿れば説明文が表示されますし、 呼び出せばウィンドウも現れます。 スクリプトの登録が反映されたからなのですが、 何が起きたかの情報についてはあとで詳しく説明します。
最後にプロシージャーブラウザーを画像ウィンドウのメニューより
スクリプトを登録するための工程

必須のパラメーター
関数の
バージョン 2.6 よりも前はツールボックスを表す
スクリプトを挿入するメニュー内での
既存の画像を加工しないスクリプトを書いた場合 (このテキストボックスのような画像を新たに作成するスクリプトもこの分類に含まれる)、
マイクテリー氏の原文はツールボックスメニュー内の
それとは反対に画像を編集・加工する目的のスクリプトを書いた場合は画像ウィンドウのメニューの
もうお気付きだとは思いますが
スクリプトの


スクリプトの
スクリプトが作動できる画像の
メニューにこのスクリプトが現れた様子
スクリプトのパラメーターを登録
必須のパラメーターを列挙したので、 ここでスクリプトが使うパラメーターについて一覧表にまとめておきます。 これらの媒介変数を紹介するにあたりその型式がわかるようにしました。 これはスクリプトが呼ばれると現れるダイアログを構成するために使います。 また変数には初期設定値を与えておきます。
この節で行なわれる登録処理にはつぎの型式が関わります。
パラメーターの型
説明
例
SF-IMAGE
既に開いてある画像を操作するためのスクリプトを作るときは、 必須のパラメーターの直後にこのパラメーターを置かねばなりません。
3
SF-DRAWABLE
既に開いてある画像を操作するためのスクリプトを作るときは、
17
SF-VALUE
数値と文字列の両方を受け入れる型です。 初期設定のテキストを渡すとき引用符をエスケープ処理しなければならなくなるので、 文字列には
42
SF-STRING
文字列を収める変数です。
"Some text"
SF-COLOR
このパラメーターが要求する色の情報を示します。
'(0 102 255)
SF-TOGGLE
真理 2 値をとるチェックボックスを表示します。
有効なら TRUE、 無効なら FALSE
スクリプトを肉付け
さあ訓練を続けましょう。 こんどはスクリプトに機能を加えます。
新しい画像を生成
先の講義では中身のない関数を作成し
変数の設定や関数の定義、 リストの要素を引き出す方法についてはもう学びましたので、 あとは坂を滑り下りるだけです。 これからなすべきことは
新しい画像を作成するところから始めます。
プロシージャーデータベースのブラウザーによると、
(define (script-fu-text-box inText inFont inFontSize inTextColor)
 (let*
 (
 ; define our local variables 
 ; create a new image: (新しい画像を作る局所変数を定義する)
 (theImageWidth 10)
 (theImageHeight 10)
 (theImage (car
 (gimp-image-new
 theImageWidth
 theImageHeight
 RGB
 )
 )
 )
 (theText) ;a declaration for the text (テキストの定義)
 ;we create later (あとで作成するつもり)

関数を呼び出した結果の値から先頭の要素を引き出しているところにご注目ください。 これは奇妙な感じがします。 というのもデータベースにははっきりとこの関数が返す値はたったひとつ新しい画像の ID 番号だけだと記されているからです。 実は
画像に新しいレイヤーを追加
画像ができたのでこんどはレイヤーを追加する必要があります。
;create a new layer for the image: (新しい画像を作る局所変数を定義する)
 (theLayer
 (car
 (gimp-layer-new
 theImage
 theImageWidth
 theImageHeight
 RGB-IMAGE
 "layer 1"
 100
 NORMAL
 )
 )
 )
 ) ;end of our local variables (局所変数の終わり)
新しいレイヤーができたので画像に加えなくてはなりません。
(gimp-image-add-layer theImage theLayer 0)
さてここまでにスクリプトが実らせた果実の熟れ具合を見て楽しむために、 つぎの行を追加して新しい空の画像を表示させましょう。
(gimp-display-new theImage)
以上の工作を保存します。 そのあと画像ウィンドウのメニューより
テキストを追加
先に進みたいので先程画像を表示させるために追加した行を削除してください。 (もしくはその行の最初にセミコロン
画像にテキストを加える前に、 画像の背景色と描画色を設定してテキストが読み取れる色づかいに設定しなくてはなりません。 これには
(gimp-context-set-background '(255 255 255) )
 (gimp-context-set-foreground inTextColor)
色がうまく設定できたら、 描画対象を塗りつぶす方法で画像に溢れているゴミを一掃しましょう。
(gimp-drawable-fill theLayer BACKGROUND-FILL)
画像が清められたらつぎはテキストの追加にとりかかります。
(set! theText
 (car
 (gimp-text-fontname
 theImage theLayer
 0 0
 inText
 0
 TRUE
 inFontSize PIXELS
 "Sans")
 )
 )
長い関数呼び出しになっていますが、 プロシージャーデータベースのブラウザーでそれぞれのパラメーターについて見てみればどの項目もありきたりなものばかりです。 要するにここでは新しいテキストレイヤーを作成して変数
さてテキストができましたので、 つぎはその幅と高さをつかめば画像とそのレイヤーの寸法をテキストの大きさに合わせられます。
(set! theImageWidth (car (gimp-drawable-width theText) ) )
 (set! theImageHeight (car (gimp-drawable-height theText) ) )

 (gimp-image-resize theImage theImageWidth theImageHeight 0 0)

 (gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
私もそうでしたが、 描画対象というのはレイヤーとどんな関係にあたるものなのか疑問に思われたことでしょう。 両者の違いについては、 レイヤーやチャンネルやレイヤーマスクや選択範囲などなどあらゆる描画可能なものを描画対象と呼ぶということで説明できます。 レイヤーは特定の描画対象だといえます。 ほとんどの場合その区別は重要ではありません。
画像の準備ができましたので、 また途中経過の表示の行を追加してもよいでしょう。
(gimp-display-new theImage)
以上の工作を保存したらデータベースを読み込み直し、 できたばかりの

でき上がった画像をファイルに保存せずに閉じようとすると、
この目的のためには
(gimp-image-clean-all theImage)
この処理は手付きの回数を 0 にするので結果的に画像が
このような行を挿し挟むか否かは個人的な好みに委ねられます。 私なら新たな画像を作成するスクリプトの、 今回のようにありきたりの結果が出る場合に限ります。 しかしスクリプトがとても複雑だったり、 既存の画像を加工するものならば、 おそらくこういった機能を使いたい理由がありません。
テキストボックススクリプトを拡張
取り消し機能の正しい取扱い
スクリプトを作成すると、 取り消し機能をつけて失敗から戻れるようにしたくなります。 これは簡単で、 画像を操作するコードを
新しい画像を丸ごと生成するスクリプトならこの機能を使う意味がありません。 なぜなら既存の画像を変更しているわけではないからです。 しかし反対に既存の画像を変更するスクリプトならこの機能を使いたいのは当然です。
この両関数を使う限りスクリプトの動作の取り消しはほとんど完全無欠に行なえます。
もう少しスクリプトを拡張
今やテキストボックスを作るとっても素敵便利な
現在はテキストの周りをぴったり囲む大きさに画像が調節されます。 ドロップシャドウみたいな特殊効果がつけば他のスクリプトなら自動的に寸法を必要なだけ増やせるのに、 余地も調節機能も全くありません。そこでテキストまわりに余裕をもたせて、 しかもその幅をユーザーがテキストの結果的な大きさに対する比率で指定できるようにします。
このスクリプトはテキストを扱う他のスクリプトから簡単に利用されるようにもできます。 スクリプトが生成した画像やレイヤーを返すよう関数を改造し、 他のスクリプトがこのスクリプトを呼び出して生成させた画像やレイヤーを利用できるように拡張しましょう。
パラメーターと登録関数の変更
テキスト周りの余裕を設定できるよう、 メイン関数にパラメーターを追加して登録関数を変更します。
(define (script-fu-text-box inTest inFont inFontSize inTextColor inBufferAmount)
 (let*
 (
 ; define our local variables
 ; create a new image: (新しい画像を作る局所変数を定義する)
 (theImageWidth 10)
 (theImageHeight 10)
 (theImage (car
 (gimp-image-new
 theImageWidth
 theImageHeight
 RGB
 )
 )
 )
 (theText) ;a declaration for the text (テキストの定義)
 ;we create later (あとで作成するつもり)

 (theBuffer) ;
新しいコードの追加
画像の寸法を変更する前と、 スクリプトの最後の 2 箇所にコードを追加してゆきます。 後者はできたばかりの新しい画像とそのレイヤーとテキストを返すためのコードです。
テキストの高さと幅が判ったら、 ユーザーが指定したテキスト周りの余裕の量 (
(set! theBuffer (* theImageHeight (/ inBufferAmount 100) ) )

 (set! theImageHeight (+ theImageHeight theBuffer theBuffer) )
 (set! theImageWidth (+ theImageWidth theBuffer theBuffer) )
このコードが行なっているのはテキストの高さに基づいて余裕の量を算出し、 新たにできた画像の高さや幅にそれぞれ 2 度ずつ加えていることだけです。 縦にも横にも 2 度ずつ加算している理由は、 余裕の幅をテキストの両側に加える必要があるからです。
画像の寸法が変更できて余裕の幅がとれるようになったので、 つぎは画像の中央にテキストを配置しなくてはなりません。 これは (x, y) 座標で表すと (
(gimp-layer-set-offsets theText theBuffer theBuffer)
ここまでできたらスクリプトを保存して、 データベースを読み込み直してから試してみましょう。
もう残された課題は画像とレイヤーとテキストレイヤーの情報を返す処理だけです。
(list theImage theLayer theText)
これが関数の最後に置かれる行です。 これで他のスクリプトから利用できるようになります。
他のスクリプトからテキストボックススクリプトを使う場合はつぎのようなコードを書くことになります。
(set! theResult (script-fu-text-box
 "Some text"
 "Charter" "30"
 '(0 0 0)
 "35"
 )
 )
 (gimp-image-flatten (car theResult))
おめでとう。 あなたは Script-Fu の黒帯への道を進んでいますよ。
スクリプト作品とその稼動の様子
書いた成果
スクリプトの完全版はつぎのとおりです。
得られるもの
画面にはこんな成果が現れます。
この節は原文の演習には含まれていません。
Script-Fu パラメーター
上記のパラメーター型に加え、 操作盤ダイアログ上に使えるさらに多くの相互対話モード用ウィジェットの型があります。
SF-ADJUSTMENT
ダイアログ上に値を調節するためのウィジェットを作成します。

ウィジェット変数表
要素
"
ウィジェットの前に貼られる語句

当初の数値 デフォルト

最低値と最高値 (選べる値の範囲)

最小変動値、 公差



小数点以下の桁数 (十進数)

スライダーは
ダイアログにカラーボタンを作成します。

もしくは

'(
赤・緑・青の 3 つの成分
"

SF-FONT
ダイアログにフォント選択ウィジェットを作成します。 フォント名を文字列変数形式で返します。

<!--no use-->
いずれも

"
初期状態でのフォント名
SF-BRUSH
ダイアログにブラシ選択ウィジェットを作成します。 このウィジェットは縮小見本表示があります。 ここはクリックしたまま待つと大きく表示されます。 さらに


たとえば
SF-PATTERN
ダイアログにパターン選択ウィジェットを作成します。 このウィジェットは縮小見本表示があります。 ここはクリックしたまま待つと大きく表示されます。 さらに


SF-GRADIENT
ダイアログにグラデーション選択ウィジェットを作成します。 グラデーションボタンが設置され現在選ばれているグラデーションが表示されます。
このボタンはクリックするとグラデーション変更ダイアログが開かれ他のグラデーションも選べるしくみになっています。


SF-PALETTE
ダイアログにパレット選択ウィジェットを作成します。 このウィジェットは縮小見本とパレット名を表示します。 縮小見本はボタンになっておりクリックするとパレット選択ダイアログが開かれ他のパレットも選べるしくみになっています。


スクリプトが呼び出されたときに返される値はパレットの名前をもつ文字列変数です。 たとえば
SF-FILENAME
ダイアログにファイル選択ウィジェットを作成します。 ファイル名が記されたボタンが設置されます。 このボタンをクリックするとファイルブラウザーが開かれ、 ファイルを探してひとつ選ぶ操作ができるしくみになっています。


スクリプトが呼び出されたときに返される値はファイルの名前と保管場所を記した文字列変数です。
SF-DIRNAME
対話式操作でのみ有益です。 ファイルではなくディレクトリーを選択するウィジェットであることのほかは


SF-OPTION
ダイアログに数々の選択肢からひとつを選ぶコンボボックスウィジェットを作成します。
選択肢はまとめてリストにして渡し、 ウィジェットは最初の項目を初期値として表示します。


SF-ENUM
ダイアログに列挙型リストの選択ウィジェットを作成します。 指定された列挙型の項目を並べたコンボボックスが設けられます。 使える列挙型は登録済のものに限られ、 その名前から冒頭の


クイックマスクのモードを利用
マスク
クイックマスク
クイックマスクを利用
画像を開くか新たな創作を始めます。
画像ウィンドウの左下のボタンを押してクイックマスクのモードにします。 既に選択ができていたならマスクはその形で初期化されます。
描画ツールならば何でもよいですが、 クイックマスクを黒く塗ればそこは選択から外され、 白く塗れば選択に加えられます。 灰色では不完全選択ができます。
選択ツールで範囲を決めて塗りつぶしツールやブレンドツールで一括して塗ることもできます。 クイックマスク自体の選択が放棄されることはありません。
画像ウィンドウの左下のボタンを切り替えればクイックマスクから戻ります。 選択範囲は点滅破線となって表示されます。
common
ディジタルカメラ写真の処理
写真
はじめに

でき損なった写真を綺麗に直したいという要求をみていくと、 主なものは 4 つに分類できます。 すなわち構図の改良、 色補正、 ピントの補正、 画像から不要な被写体を除去することです。
構図の改良
画像を回転
写真を撮るときにちゃんと真っ直ぐ構えるのは難しいので、 被写体が斜めに傾いて写りやすいのですが、 あとで直すときは
実際問題としてはこの方法ではなかなかぴたりと合わせられません。 割とうまくできても完全には至らない、 そんな感じではないでしょうか。 少しづつ回転させれば良いかというと、 そうでもなくこの方法には欠点があります。 画像に回転をかける度に、 元の画像ほどには精密に画素を並べられないことが災いしてどうしようもなくだんだんと画像がぼけてきてしまうのです。 1 回だけの回転ならぼかしの程度はかなり低く抑えられますが、 これが 2 回になるとぼかしは 2 倍になりますから、 そこまでして回転をかけたくはないでしょう。 よりましなやり方としては回転と取り消しを交互に行ない、 最適な傾きを探る方法があります。
うれしいことに

画像を回転させた後には、 画像の隅に不愉快な三角形の
切り抜き
ディジタルカメラで写真を撮る際に構図に入れる対象に気を付けていたのに思ったとおりにはうまくできていないことがしばしばあります。 結果として画像を刈り込むことになります。 それ以上に、 画像の印象を改良する目的で重要な被写体が鍵となる位置につくように画像を刈り込むことは度々あることです。 鉄則ではありませんが覚えておくと便利な
画像を切り抜くにはツールボックスの
色補正
自動化ツール
高度な露出調整システム付きを謳っていながら、 ディジタルカメラで写真を撮ると露出不足や露出過多になったり、 明るさが不十分だったために色の出が悪くなる場合がしばしばみられます。 画像の色を修正できる

各機能を簡単に紹介すると、
平滑化
このツール (実体はプラグイン) は露出不足の画像に有効です。 画像の最も明るい部分が彩度の限界の右側に、 最も暗い部分が黒の側に寄るように画像全体を均等に調節します。 画像の明るさが最も明るい点と暗い点を参考に全体的に決められてしまう欠点があり、 一点でも真っ白や真っ黒の画素があると平滑化は効果を発揮しません。
正規化
これは色の範囲いっぱいまで画像の色の強度を均等に伸長させる非常に強力な補正を行います。 ときおり魅力的な効果を発揮して、 とても他の方法では真似ができないコントラストをもたらしますが、 いつもはほとんどの画像が超自然的に見えるようになります。 おっとそれから、 これだけはちょっと時間がかかります。
色強化
このコマンドはレイヤーの色の明るさや色相を変化させずに彩度の分布を広げます。 ですからグレースケール画像には効きません。
コントラスト伸長
これは
HSV 伸長
これは
ホワイトバランス
あまり使われていない色を削除して余った範囲いっぱいまで分布を広げますので、 貧弱な白か黒で画像が強調されます。
レベルの自動調整
これはレベルツールを起用 (画像ウィンドウのメニューより
画像を見てそこに真っ黒にすべき点と真っ白にすべき点があったら、 レベルツールの半自動調整を使えばだいたいいつも画像全体に色と明るさの両方をうまく直してくれます。 まずレベルツールを先述のとおりに呼び出します。 そうしたらダイアログの自動調整ボタンの隣りに点眼器の姿をした 3 つのボタンがありますね。 (見てのとおりスポイト機能です)。 試しに左のボタンにマウスポインターをかざすと、 その機能は
以上が自動化した色調整機能です。 何ひとつ役に立たないという場合は、 いよいよ相互対話型の色ツールを試すときです。 ひとつを除いていずれもメニューを辿って
露出の問題
最も簡素な
ちょっとばかり手間がかかりますが、 レベルツールを使うともっと洗練された方法で露出補正ができます。 このツールのダイアログは見た目に結構難しそうですが、 今回のような基本的な用途の場合はヒストグラムの下側にある
トーンカーブは露出の問題を非常に強力に修正するツールです。 このツールならば入力側の明るさレベルと出力側の明るさレベルの相関曲線 (カーブ) を描けますし、 これは線上のコントロールポイントをクリックしてドラッグするだけでできます。 トーンカーブツールは
卓越した
実際には利得調整に使えるモードは
レイヤーを複製します (新しいレイヤーを上に重ねます)。
新しい方のレイヤーを脱色します。
続けてそのレイヤーに、 ぼかし半径を 100 ピクセル以上に大きくとったガウスぼかしフィルターをかけます。
レイヤーダイアログでそのレイヤーのモードを除算に設定します。
補正はレイヤーダイアログで不透明度を調節するほか、 新しいレイヤーに対し
仕上りに満足できたら、

色相と彩度の調節
我々の経験では、 色の偏った (赤っぽかったり青っぽかったりする) 画像を直すにはレベルツールを使うのが、 赤・緑・青の各チャンネルごとにレベルを調整できることから、 最も簡単です。 これが役立たないのなら、
時折色の補正が適切にできているかどうか見分けるのが難しくなる場合があります。 こんなときに上手い客観的な技法があって、 その為には、 白くしたい位置や灰色だけの陰影にしたい位置を画像に見つけておきます。
画像が色褪せているとき (眩しいところで写真を撮るとよくこうなります)、
色褪せた画像でなくとも、 ほんのちょっと彩度を上げると大抵は見た目に強い印象を与えられます。 かつてのフィルム時代の先輩たちは、 この秘技を
明るさに乏しい状況で写真を撮ると、 場合によってはこの逆の彩度が高すぎる問題が起こります。 このときも
明瞭度の補正
鮮明化
カメラの焦点が正しく合っていなかったり、 ブレながらシャッターが切られると画像はぼけてしまいます。 あまり酷くぼけてしまうとどんな技術をもってしてもできることはほとんどありませんが、 大したことがなければ恐らく画像は修正できます。
一般にぼかしの入った画像をくっきりさせるために使うと有効なのが
画像のコントラストが強い部分でアンシャープマスクはときおり色を崩すことがあります。 そんなときはチャンネル分解を行なって色相-彩度-明度 (
メニューにはもう一つ、
場合によっては画像を部分的に際立たせるためにツールボックスの
ざらつきを減省
光量が乏しいところで撮った写真や露光時間が短すぎる写真は、 それぞれの画素に本来の色を正しく見積るだけの十分なデータが得られず、 したがってざらついた感じの画像になります。 画像にぼかしをかければざらつきは
淡柔化
反対に画像が元気良
画像から不要な物を除去
画像から除去したい物には 2 種類あります。 まずは、 レンズに付いたほこりや髪の毛のようなごみによる人工物、 つぎに、 現実に存在していた物ではあるけれどたとえば美しい山の風景の縁を横切って張られた電話線のような、 画像の美観を損ねる被写体です。
ノイズ除去
ほこりやレンズの汚れを除去するには
画像にまだ他にも人工物が写っている場合、 ノイズ除去はそれぞれ個別にかける必要があります。
がらくたの除去
画像に写った要らない

スタンプツールによく似ていてもっと洗練されたツールといえば
ひょっとすると画像から邪魔になる物体をまさに刳り貫いてしまって
赤目を修正
赤目現象
カメラに視線を向けている人にフラッシュを浴びせて写真を撮ると、 眼の虹彩がフラッシュの光を反射して目に明るい赤色が現れる

成果の保存
ファイル
作業の成果を保存するにはどのファイル形式にしたら良いでしょうか。 また、 大きさは変えないといけないでしょうか。 その答えは、 その画像を何に使うつもりなのかによって変わってきます。
まだその画像を
画像を紙に印刷しようという場合には、 切り抜き加工以外で画像を縮めてはいけません。 というのもディスプレイモニター画面に比べてプリンターは遥かに高い解像度を実現できるからです。 1 インチあたり 72～100 画素 (ピクセル) しかない画面と、 典型的なモデルで 1 インチあたり 600～1400 ドットは優にこなせるプリンターとは大違いです。 3000times;5000 ピクセルの画像は画面上では[メモリー上でも]巨大ですが、 紙に 600 dpi (ドット毎インチ) で印刷するとたった 5 インチ &times; 8 インチ [127 mm &times; 203 mm] です。 また普通は画像を
映写機やビデオプロジェクターを使って画像を映写幕に投影するつもりがあるなら、 最高の映写解像度に合わせ、 たとえば最も一般的なシステムなら 1600times;1200 ピクセルを目安にしてください。 それ以上画像が大きくても何の得にもなりません。 この使用目的には大抵通常は
画像をウェブページに貼ったり E メールで送るつもりなら、 ファイル容量をあらゆる手段を使ってできるだけ小さくしてあげましょう。 まず、 話題に関わる部分がはっきりわかる程度を保ちつつ画像を最小の大きさに縮尺します。 (他の人はモニターの大きさや解像度が違うかもしれないことを念頭に置いてください。) 次に、 画像を

写真を印刷
印刷
写真を印刷
ほとんどのソフトウェアと同じように
画像は画面上では
ICC-Profile
CMYK
Gamut
画面の解像度はだいたい 75dpi から 100dpi の範囲です。 プリンターの解像度はおよそその 10 倍かそれ以上あります。 印刷される画像の大きさは利用可能な画素数や解像度に依存します。 つまり実際の印刷物の大きさは画面上の見た目の大きさにもましてや紙の大きさにももとより同じにはなりえません。
したがって印刷をする前に
最後の忠告です。 センタリングもそうですがマージンの点検についても気を付けましょう。 マージンを大きくとり過ぎると画像の一部が切り取られる悲惨な結果になりますし、 センタリングが不適切だととりわけ特殊フォトペーパーを使っていたときの損害は甚大です。
Exifデータ
<!--Exchangeable Image File Format-->最近のディジタルカメラは、 撮影時のカメラの設定内容や状況についての情報をデータファイル内に追加します。 このデータは
&lt;!--Exif データの内容を見たい場合は Exif ブラウザープラグインをその登録サイト
common
common
common
localized
common
common
パス
画像
パスとは (ベジエ曲線で知られる) 曲線のことです。

パスは主に 2 つの目的があります。
閉じたパスが選択に転換できます。
開いたパスも閉じたパスも、 その
パス作成の例 4 つ

パスの作成
パスははじめのうちは大まかな線でかまいません。 後からでも変形ができます。 (その方法は
画像ウィンドウのメニューから
ツールボックスのツールアイコン
キーボードショートカット
パスツールを呼び出すとマウスポインターが矢印とうねった曲線からなる姿になります。 画像を左クリックしたところがパスの始点です。 次の点となる位置にマウスを移動してからまた左クリックすると、 第 2 の点ができて前の点と線で結ばれます。 クリックすればするほどいくつも点が打てますが、 パスの習得には始めの 2 点だけで十分です。 点を置くとき曲線の先ではポインターのそばに小さな十字
ポインターを線分に近づけてクリックしその線分をドラッグしてください。 すると 2 つの反応が起きます。
線分はつかんで引くにしたがって曲折します。
どの線分にも始点と終点があり、 しるしがついてはっきりわかるようになっています。 動かされた線分の各端点から
線分が曲線なら端点から伸びる
操作中のパスの様子
パスツールで操作中のパスの様子
図のパスには直線や曲線の入り交じった 2 本の成分があります。 黒い正方形はアンカーポイントを、 ひとつだけある白丸は選択されたアンカーを表していて、 2 つの白い正方形はそのアンカーから延びる 2 本の曲線のハンドルを表しています。
パスの性質
パスはレイヤーやチャンネルと同じく、 画像の一部です。 画像を

パスは非常に複雑になりやすいものです。 パスツールを用いて手書きでパスを描くならば、 こだわり過ぎなければアンカー点の数はせいぜい数十個程度、 普段はもっと少なく抑えられるでしょう。 ところが選択範囲をパスに変換するだとか、 テキストをパスに変換するといった操作があるとたちまち何千、 何万ものアンカー点ができてしまいます。
パスには数本の
パスの成分はそれぞれ
パスの線分は直線にも曲線にもなります。 線分が直線だけで構成されているパスは
パスの長所のひとつが[メモリー]資源の消費が極めて少ないことです。 画像そのものと比較すればその差は歴然です。
パスの作成や操作には
パスと選択範囲

選択範囲をパスに変換すると、 パスは点滅破線 (
パスの変形
回転、 拡大・縮小、 遠近法など、 どんな
パスを変形対象としたときの変形ツールは、 はじめ初期設定では一面のパスにのみ作用します。 これをパスダイアログでは
パスの境界線を描画
パスの境界線を描画
前掲のパス 4 例の境界線をそれぞれ異なる方法で描画
パスはその
いずれの方法も

パスの境界線の描画は重ね打ちすることでその効果を増したり、 線やブラシの太さを変えて重ねることもできます。 こんな風にすればおもしろい効果はほとんど無限にありそうです。
パスとテキスト
パスに転換されたテキスト
パスに転換され、 遠近法ツールで変形されたテキスト。
承前、 ぼかし入りブラシで描画、
テキストツールで作られたテキストは、 テキストレイヤーの脈絡メニューの
パスの境界線の描画機能を利用し、 テキスト装飾の可能性を広げること。
テキストの形状変形はさらに重要。 テキストをパスに転換、 続いてパスを変形、 最後はパスの境界線に描画したり、 パスを選択に転換して塗りつぶすこと。 テキストレイヤーの画素情報 (ピクセルデータ) を変形描画するよりも高品質に仕上りやすい。
パスと

幸いにもパスは



新しいレイヤーの作成
レイヤー
新しいレイヤーの作成
画像上に新たにレイヤーを作成する方法はいくつかあります。 最も重要なものを示します。
画像ウィンドウのメニューより
画像ウィンドウのメニューより
何かを
格子線を描写
画像に格子模様を描くにはどうすればよいでしょう。 これはグリッドを使用してもできません。 そもそもグリッドは補助が目的なので、 画面上かスクリーンショットでなければ見えないものなのです。 でもそのかわり

localized
localized
localized
localized
localized
固まったときの対処
GIMP
反応しなくなった!
了解しました。 おまかせください。 動かなくなったのですね。 画像にツールで何かの操作をしたら、 全然反応がなくなって、 しかも何をやっても変化しなくなったのでしょう。 あなたの手首は硬ばりだし、 額には脂汗が浮かんでhellip;。 もしやプログラムを強制終了しようかと思ってませんか？ それまでの成果は無駄になってしまうのに。 駄目じゃん。
まずは一回深呼吸です。 実は

フローティング選択範囲がある
フローティング (浮層) 選択範囲があることを示すレイヤーダイアログ


選択範囲が隠されている


これが問題になるそもそもの原因は、 ここを読んでいる時点まではいろいろ他の問題は思い付きはしても、 まさかここが関係するとはなかなか察知しづらいからではないでしょうか。 選択範囲を示す点滅破線はしばしば画像の重要な細部を見えづらくしてしまう難点があるため、

選択範囲の外で作業している

選択範囲を全域にするため

描画中の領域が不可視である
不可視レイヤーに対処
描画中のレイヤーが不可視になっていることを示すレイヤーダイアログ。


描画中の領域が透明になっている
レイヤーの不透明度に対処
作業中のレイヤーの不透明度がゼロであることを示すレイヤーダイアログ。


レイヤーの領域外で作業している


画像がインデックス化カラーのモードになっている


common
テキストの装飾
テキストの装飾
趣向を凝らしたテキスト
ロゴスクリプトによる趣向を凝らしたテキスト品目 4 例:
このようにテキストの色や書体を変化させるだけに留まらない多様な表現を可能にする様々な手段が用意されています。 テキストを選択範囲やパスに転換すれば、 塗りつぶすのも輪郭線を描画するのもよし、 変形するなど一般的なあらゆる
フォントの追加
フォント
追加


FreeType 2 はたいへん強力で柔軟なシステムです。 初期設定でも次のようなフォントファイル形式を扱えます。
TrueType フォント形式 (及びコレクション)
Type 1 フォント形式
CID-keyed Type 1 フォント形式
CFF フォント形式
OpenType フォント形式 (TrueType と CFF の発展形の両方)
SFNT系ビットマップフォント形式
X11 PCF フォント形式
Windows FNT フォント形式
BDF フォント形式 (アンチエイリアスつきを含む)
PFR フォント形式
Type42 フォント形式 (限定的)
これ以外のフォントファイル形式も、 その対応モジュールを追加すれば扱えるようになります。 より詳しい情報は FREETYPE 2 のサイト
Linux;
UNIX 風のシステムの場合、 通常の方法で Fontconfig ユーティリティを導入・設置しておれば、 新たにフォントを追加するには単にそのファイルを
Windows
フォントを導入する最も簡単な方法はそのファイルをフォント用ディレクトリーまでドラッグして放つことです。 すると自動的にシェル機能が拡張子を見て反応します。 何か特別な設定を加えていたのでなければ、 標準的なフォントの保管場所は
Mac OS X
システムにフォントをインストールする方法はいくつかあります。 そのひとつはフォントファイルをホームフォルダ内の
Type 1 形式のファイルをインストールするには


フォントの問題
問題点
フォントにまつわるバグ報告は 2.0 版の発表以降版を重ねるごとに減ってきてはいますが、 それでも
その他に、 文字配置情報 (

localized
localized
localized
localized
localized
localized

画像の保存方法とエクスポート方法
画像の保存方法とエクスポート方法
画像のエクスポート
これまでの版の
画像の加工が終了したら、 それを保存したくなります。 (現実的には、 作業にひとくぎりつくたびに保存するのが良策です。
ファイル形式
画像をファイルに
出来上がった画像を
画像のエクスポートで元の画像そのものが変更されるものではありませんので、 それが原因で何かを失なうおそれはありません。
画像を閉じたとき (あるいは
閉じるときの警告
何らかのファイル形式で画像を保存した時点で画像は必ず
GIF 形式に画像をエクスポート
GIF
.gif
形式


GIF オプション
インターレース

GIF コメント

動画 GIF オプション
アニメーション
動画 GIF オプション
無限ループ
このオプションを有効にすると、 停止させるまでアニメーションが繰り返されます。
指定しない場合のフレーム間の時間
フレーム間の待ち時間が設定されていなければここでミリ秒単位で指定します。 この場合、
指定しない場合のフレーム処理
このオプションはフレームの重ね方を指定するもので、 未定だった場合は以下の 3 つから選びます。



全フレームのディレイにこの値を使用
全フレームのフレーム処理にこの値を使用
JPEG 形式に画像をエクスポート
JPEG
.jpg
.jpeg



品質
画像を

画像ウィンドウでプレビュー
この項目を有効にすると、 品質 (やその他の
詳細設定
幾つかの詳細な設定情報
最適化
このオプションを有効にすると、 エントロピー符号化による最適化が行なわれます。 その結果は容量が小さくなるのが特徴ですが、 生成にはもっと時間がかかります。
プログレッシブ
このオプションが有効なときは、 ファイル内部で画像が分割され、 低速なネット回線でも画像が漸進的に表示できる順序に並べ替えられます。
Exif データの保存
Exif
ディジタルカメラの生成する
サムネイルの保存
このオプションは画像の本体のほかにサムネイル画像をもファイルに保存します。 この小さなサムネイル画像は他の多くのアプリケーションが素早いプレビュー機能のために利用します。
このオプションは
XMP データの保存

原画の品位設定を使用
所定の品位設定 (つまり
もし作成された画像が元の画像を僅かに加工しただけのものである場合、 この設定を再利用すれば元の画像とほぼ同じ品質かつほぼ同じファイル容量で保存できます。 この方法はまた量子化ステップに起因する損失を、 別の品位設定を用いて行なうよりも小さくする効果があります。
元の画像の品位設定よりもあなたの規定の品位設定のほうが優れている場合にも
スムージング

リスタートマーカー
このオプションを有効にすると画像ファイル内部に分割読み込みを可能にするマーカーを挿入できます。 ウェブページの画像を読み込んでいる最中に接続が中断しても、 あとで途中のマーカーを起点にして読み込みを再開できます。
サブサンプリング
人間の色覚は一様に可視光線全般に対して鈍感です。 このオプションはわずかに異なる色ならばごく近くほとんど同色であるとヒトの視覚が認識することを前提に圧縮します。 つぎの 3 つの形式から選択できます。




DCT 変換方法




コメント
この書き込み欄に記入した付記は画像とともにファイル内に保存されます。
PNG形式に画像をエクスポート
PNG

インターレース (Adam7)
背景色を保存
画像の透明度が大きく設定されている部分で、 透明度を 2 段階でしか認識できないインターネット用ブラウザーは透明化のかわりに背景色を表示します。 (背景色はツールボックスなどで指定できます。) ただし
ガンマ値を保存
ガンマ補正はコンピューターの表示装置によって起こる色の値の再現のずれを修正するしくみです。 このオプションを有効にすると
レイヤーオフセットを保存

解像度を保存
画像の解像度を ppi (ピクセル毎インチ) で記録します。
作成日時を保存
最終保存日時のことです。
コメントを保存
このコメントは
透明ピクセルの色の値を保存する
このオプションが入りのときは、 画素 (ピクセル) が完全に透明であっても色の値が保存されます。
圧縮レベル
この圧縮は可逆的なので、 圧縮レベルを 9 未満に落とす理由は単に低速なコンピューターでは圧縮に時間がかかるということ以外にありません。 しかも伸長には何の心配もありません。 どんな圧縮レベルでも一様に素早く伸長できます。
既定値として保存
このボタンを押すと、 ここで設定した内容は保存されます。 あとで

コンピューターの内部は

TIFF 形式に画像をエクスポート
TIFF

圧縮方法
このオプションで画像にふさわしい圧縮方法が選択できます。






この 2 つのオプションは、 画像が 2 色のみにインデックス化されている場合に有効です。
このオプションにより、 画素 (ピクセル) が完全透明でもその色の値が保存されます。
コメント
この書き込み欄には画像に関連する付記が書き込めます。
MNG 形式に画像をエクスポート
MNG


最大の問題は
自分流のスプラッシュスクリーン
スプラッシュスクリーン

もちろんこのスプラッシュスクリーンの画像も誂えられます。
画像 (複数可) をこの
画像が小さくなり過ぎないように注意しましょう。
localized
ブラシの追加
新規追加
ブラシを追加するには、 新たに作成したものであれダウンロードしてきたものであれ、
ファイル形式
GBR


GIH

VBR

追加したブラシを有効にするには
ブラシエディターで作成した媒介変数つきブラシは、 作成後に自動的に個人用
既にネット上では
localized
localized
localized
localized
common
common
common
localized
localized
localized
common
GIH ダイアログ
アニメーションブラシの作成
アニメーションするブラシができたなら、 それを画像ウィンドウで表示したうえで
アニメーションするブラシの構成を記述するダイアログ

このダイアログウィンドウのオプションはわかりにくそうですが、 これらはブラシをアニメーションさせるために必要な指定項目です。
間隔 (パーセント)

これはブラシにつける名前を記入するところで、 ブラシダイアログ上では
セルサイズ
これはブラシ画像のレイヤーから切り出すセル (小区画) の大きさを決めます。 初期値はセルの大きさがレイヤーと同じになり、 つまりレイヤーあたりのセル数は 1 つです。 ちなみにその場合はレイヤー 1 層にブラシ相が 1 つある設定になります。
たった 1 層の大きなレイヤーを細かくセルに分けて、 アニメーションするブラシの様々な相に割り当てることが可能です。
たとえば、 大きさが 100times;100 ピクセルで 8 つの相 (変化形) からなるブラシを作るとします。 この 8 相を 400times;200 ピクセルのレイヤーに振り分けてもよいですし、 300times;300 ピクセルのレイヤーを用意して 1 セル余らせる方法もあります。 前者は
セル数
これはレイヤー 1 層あたりのセル数を定めます。 1 つの相に 1 個のセルが必要です。 既定では 1 つの相に 1 層だけレイヤーがあるとみなすので初期値はレイヤーの数と同じになります。
表示方法
この表示はセルをレイヤーに配置する様子です。 たとえばもし 4 層のレイヤーを使ってそれぞれに高さセルを 2 つ置く割合にすると、 この表示は
次元; 並び; 及び選択モード
これらは結構複雑です。 まずはセルとレイヤーの関係とその配置について説明するところから始めましょう。

つぎに
コンピューター科学での 3 次元 (3D) では配列が myarray(x,y,z) のような形式になります。 2 次元を想像するのは簡単でしょう。 つまり紙の上の行と列の配列のことです。

各次元にそれぞれ桁数のように並びの数値を与えられるほかに、 これらには
Incremental
指定された次元から次元上での順序に従って位を選びます。
Random
与えられた次元から無作為に位を選択します。
Angular
与えられた次元から位を選ぶときにブラシが移動する方角を参考にします。
前の版の
最初の位は 0 度、 つまり上向き方向に結びつけます。 つづく他の位には桁数で 360 度を等分割した方角を時計回りの順に割り振ってゆきます。 たとえばこの次元に 4 つの位があればブラシの移動の方角はそれぞれ時計回りに 90 度ずつの区切りのどれかに拾われます。 つまり 2 番目の位は第 4 象限、 3 番目の位は第 3 象限、 4 番目の位は第 2 象限の各方向への動きに反応するようになるのです。
Velocity, Pressure, x tilt, y tilt
これらは高度なタブレット描画のためのオプションです。
例
1 次元のパイプブラシ
「おいおい！ そんなの何の役に立つの？」 答え: この例はこれからだんだんとグレードアップします。 次元も上げていきますから効果的なブラシもちゃんと作れます。
まずは 1 次元ブラシからはじめますが、 これでも選択モードのはたらきがわかるようになります。 下図のような配列を思い起こしてください。
大きさが 30times;30 ピクセルで塗りつぶし色を透明にした
画像は拡張子

数字の 1 と 2 と 3 と 4 が順番通りに並んでいる

数字が順不同に並ぶ
保存しておいた
並びの選択が
3 次元のパイプブラシ
さていよいよ 3 次元のアニメーションブラシをつくるところまで来ました。ブラシの方角によってブラシの刻印の向きを変えつつ左手と右手を交互に描き、 黒か青に無作為に色変りするブラシにします。
まずはじめにいくつの形象が必要になるかが問題になります。 第 1 次元 x はブラシの方角 (4方向) のためにとっておきます。 第 2 次元 y は左手と右手の交替に、 第 3 次元 z は色変化に割り当てます。 このようなブラシは 3 次元配列 myarray(4,2,2) として表せます。
第 1 次元 x の形象を作成
まあいいでしょう。 ここはちょっと安直に
塗りつぶし色に透明を指定した 30times;30 ピクセルの
レイヤーダイアログを開いて、 そのレイヤーの名前を
そのレイヤーを複製してください。 つぎに複製レイヤーだけを可視化し活性化してから、 90 度回転をかけます (画像ウィンドウのメニューより
同様にして
第 2 次元 y の形象を作成
この例題では第 2 次元に 2 つの位を置き、 1 つめに左手を、 2 つめには右手を割り当てます。 左手の位はもうできています。 水平方向の鏡像反転を利用して右手の形象をつくりましょう。

同様に左手のレイヤーから相応する右手のレイヤーを作ってください
時計回りの順にレイヤーを並び替え、 左手と右手が交互に現れるようにします。 つまり
第 3 次元 z の形象を作成



そうしたら移動ツールを起用してください。 ツールオプションの
つぎに
他のレイヤーに対しても同じ手順を繰り返してください。
レイヤーを順番通り並べます
ブラシを使ったときの動作に対して要求通りの形象を
もう一つの方法は配列を視覚的に表現してみることです。 先に示した見方との相関図を下に示します。

ほらね。 ブラシができました。 先に拡張子





第1次元: 4桁、 選択: Angular
第2次元: 2桁、 選択: Incremental
第3次元: 2桁、 選択: Random
個人用の
例題のブラシを用いて楕円選択の境界線を描画した結果を示す。
このブラシの左手と右手はかわるがわる入れ替わり、 無作為に黒と青の色変りが起こり、 ブラシの方向は 4 つの方角に従っている。
島本良太 (SimaMoto,RyōTa) <liangtai\.s16\@gmail\.com>, 2009-2013.