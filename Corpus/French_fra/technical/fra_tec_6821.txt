# language_name_wals:	French
# language_name_glotto:	French
# iso639_3:	fra
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/fr.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

@@image: 'figures/genius_window.png'; md5=726c4fc51539c5898333fa28720f94b3
@@image: 'figures/line_plot.png'; md5=0ce9e28d32f414d68a0958a1c38918fc
@@image: 'figures/line_plot_graph.png'; md5=284ee1a4302f7ce163b72b7d5ce7fb91
@@image: 'figures/parametric.png'; md5=d6be229108fb50a16e8bdbbfde822ba8
@@image: 'figures/parametric_graph.png'; md5=74cbbc455c4fd79de6d0e60d0b54aa4c
@@image: 'figures/surface_graph.png'; md5=45b10d405b4cd88ad07413452e5f68ac
Manuel de l'Outil de maths Genius.
Manuel de Genius
1997-2012
Jiří (George) Lebl
2004
Kai Willadsen
Permission vous est donnée de copier, distribuer et/ou modifier ce document selon les termes de la Licence GNU Free Documentation License, Version 1.1 ou ultérieure publiée par la Free Software Foundation sans section inaltérable, sans texte de première page de couverture ni texte de dernière page de couverture. Vous trouverez un exemplaire de cette licence en suivant ce
Ce manuel fait partie de la collection de manuels GNOME distribués selon les termes de la licence de documentation libre GNU. Si vous souhaitez distribuer ce manuel indépendamment de la collection, vous devez joindre un exemplaire de la licence au document, comme indiqué dans la section 6 de celle-ci.
La plupart des noms utilisés par les entreprises pour distinguer leurs produits et services sont des marques déposées. Lorsque ces noms apparaissent dans la documentation GNOME et que les membres du projet de Documentation GNOME sont informés de l'existence de ces marques déposées, soit ces noms entiers, soit leur première lettre est en majuscule.
LE PRÉSENT DOCUMENT EST FOURNI « TEL QUEL », SANS AUCUNE GARANTIE, EXPRESSE OU IMPLICITE, Y COMPRIS, ET SANS LIMITATION, LES GARANTIES DE MARCHANDABILITÉ, D'ADÉQUATION À UN OBJECTIF PARTICULIER OU DE NON INFRACTION DU DOCUMENT OU DE SA VERSION MODIFIÉE. L'UTILISATEUR ASSUME TOUT RISQUE RELATIF À LA QUALITÉ, À LA PERTINENCE ET À LA PERFORMANCE DU DOCUMENT OU DE SA VERSION DE MISE À JOUR. SI LE DOCUMENT OU SA VERSION MODIFIÉE S'AVÉRAIT DÉFECTUEUSE, L'UTILISATEUR (ET NON LE RÉDACTEUR INITIAL, L'AUTEUR, NI TOUT AUTRE PARTICIPANT) ENDOSSERA LES COÛTS DE TOUTE INTERVENTION, RÉPARATION OU CORRECTION NÉCESSAIRE. CETTE DÉNÉGATION DE RESPONSABILITÉ CONSTITUE UNE PARTIE ESSENTIELLE DE CETTE LICENCE. AUCUNE UTILISATION DE CE DOCUMENT OU DE SA VERSION MODIFIÉE N'EST AUTORISÉE AUX TERMES DU PRÉSENT ACCORD, EXCEPTÉ SOUS CETTE DÉNÉGATION DE RESPONSABILITÉ ;
EN AUCUNE CIRCONSTANCE ET SOUS AUCUNE INTERPRÉTATION DE LA LOI, QU'IL S'AGISSE D'UN DÉLIT CIVIL (Y COMPRIS LA NÉGLIGENCE), CONTRACTUEL OU AUTRE, L'AUTEUR, LE RÉDACTEUR INITIAL, TOUT PARTICIPANT OU TOUT DISTRIBUTEUR DE CE DOCUMENT OU DE SA VERSION MODIFIÉE, OU TOUT FOURNISSEUR DE L'UNE DE CES PARTIES NE POURRA ÊTRE TENU RESPONSABLE À L'ÉGARD DE QUICONQUE POUR TOUT DOMMAGE DIRECT, INDIRECT, PARTICULIER, OU ACCIDENTEL DE TOUT TYPE Y COMPRIS, SANS LIMITATION, LES DOMMAGES LIÉS À LA PERTE DE CLIENTÈLE, À UN ARRÊT DE TRAVAIL, À UNE DÉFAILLANCE OU UN MAUVAIS FONCTIONNEMENT INFORMATIQUE, OU À TOUT AUTRE DOMMAGE OU PERTE LIÉE À L'UTILISATION DU DOCUMENT ET DE SES VERSIONS MODIFIÉES, MÊME SI LADITE PARTIE A ÉTÉ INFORMÉE DE L'ÉVENTUALITÉ DE TELS DOMMAGES.
LE PRÉSENT DOCUMENT ET SES VERSIONS MODIFIÉES SONT FOURNIS SELON LES TERMES DE LA LICENCE DE DOCUMENTATION LIBRE GNU SACHANT QUE :
Jiří
Lebl
jirka@5z.com
Kai
Willadsen
Université de Queensland, Australie
kaiw@itee.uq.edu.au
0.2
Jiri (George) Lebl
Le présent manuel décrit la version 1.0.16 de Genius.
Votre avis
Pour signaler un problème ou faire une suggestion concernant l'application
Introduction
L'application
Il existe deux versions de l'
Ce manuel décrit principalement la version graphique du calculateur mais bien sûr le langage de programmation est le même. Il ne manque à la version en ligne de commande que les possibilités graphiques et toutes les autres fonctionnalités qui requièrent l'interface graphique.
Premiers pas
Lancement de l'
Vous pouvez démarrer l'
Menu
En fonction de votre système d'exploitation et de sa version, l'élément de menu pour l'
Boîte de dialogue
Il se peut que l'entrée de menu ne soit pas accessible pour votre système d'exploitation. Dans ce cas, vous pouvez ouvrir la boîte de dialogue
Ligne de commande
Pour démarrer la version GNOME de l'
Pour démarrer seulement la version en ligne de commande, exécutez la commande
Démarrage de Genius
Lorsque vous démarrez la version GNOME de l'
Fenêtre de l'
Outil de maths Genius
Fichier
Édition
Calculatrice
Paramètres
Aide
Affiche
La fenêtre de l'
Barre de menus
Les menus de la barre de menus contiennent toutes les commandes dont vous aurez besoin pour travailler avec les fichiers dans l'
Le menu
Les autres menus contiennent les mêmes fonctions classiques qui apparaissent dans d'autres applications.
Barre d'outils
La barre d'outils contient un sous-ensemble des commandes accessibles à partir de la barre de menus.
Zone de travail
La zone de travail est la principale méthode d'interaction avec l'application.
La zone de travail ne contient initialement que l'onglet
Vous pouvez également écrire des programmes plus longs qui peuvent apparaître dans des onglets séparés et peuvent être enregistrés dans des fichiers pour pouvoir les reprendre plus tard.
Utilisation de base
Utilisation de la zone de travail
Normalement, vous interagissez avec le calculateur dans l'onglet
Saisissez vos expressions dans la zone de travail
Pour obtenir une liste des fonctions et commandes, saisissez :
Supposons que vous ayez auparavant enregistré un programme contenant des commandes GEL dans un fichier et que vous vouliez maintenant les exécuter. Pour charger ce programme à partir du fichier
Création d'un programme
Pour commencer à écrire un nouveau programme, choisissez
Pour enregistrer le programme que vous venez d'écrire, choisissez
Ouverture et lancement d'un programme
Pour ouvrir un fichier, choisissez
Pour lancer un programme à partir d'un fichier, choisissez
Tracé de graphiques
Le tracé de graphiques n'est disponible que dans la version graphique GNOME. Tous les tracés accessibles à partir de l'interface graphique sont disponibles à partir de la fenêtre
Tracé de lignes
Pour tracer des fonctions réelles d'une variable, ouvrez la fenêtre
Une fois que vous avez cliqué sur le bouton
Fenêtre Création de graphiques
Affiche la fenêtre pour tracer des graphiques.
Dans les cases de texte, il suffit de saisir les expressions dans lesquelles
Fenêtre contenant une courbe
Le graphe produit.
À partir de là, vous pouvez imprimer le graphe, créer une version postscript encapsulé ou PNG du graphe ou modifier le zoom. Si l'axe dépendant n'a pas été configuré correctement, Genius peut l'avoir ajusté en cherchant les extrema des fonctions tracées.
Pour tracer à partir de la ligne de commande, consultez la documentation de la fonction
Courbes paramétriques
Dans la fenêtre Création de courbe, vous pouvez également sélectionner l'onglet
Onglet pour les courbes paramétriques
Création de graphiques
Onglet pour tracer paramétrique dans la fenêtre
Un exemple de tracé paramétrique est montré en
Courbe paramétrique
Courbe paramétrique produite
Champ de directions
Dans la fenêtre de création de graphiques, vous pouvez également sélectionner l'onglet
Quand un champ de directions est actif, un menu supplémentaire
Le solveur utilise la méthode standard de Runge-Kutta. Les graphiques restent sur l'écran jusqu'à ce qu'ils soient effacés. Le solveur s'arrête à chaque fois qu'il atteint les limites de la fenêtre du graphique. Le fait de zoomer ne modifie pas les limites ou paramètres des solutions, vous devez les effacer et les redessiner avec les paramètres appropriés. Vous pouvez utiliser la fonction
Champ de vecteurs
Dans la fenêtre de création de graphiques, vous pouvez également sélectionner l'onglet
Par défaut, la direction et l'amplitude du champ de vecteurs sont affichées. Pour n'afficher que la direction, cochez la case appropriée pour normaliser la longueur des flèches.
Quand un champ de vecteurs est actif, un menu supplémentaire
Le solveur utilise la méthode standard de Runge-Kutta. Les graphiques restent sur l'écran jusqu'à ce qu'ils soient effacés. Le fait de zoomer ne modifie pas les limites ou paramètres des solutions, vous devez effacer et les redessiner avec les paramètres appropriés. Vous pouvez utiliser la fonction
Tracé de surfaces
Genius peut aussi tracer des surfaces. Sélectionnez l'onglet
Graphique de surface
Module de la fonction cosinus complex.
Fondamentaux GEL
GEL signifie Genius Extension Language (langage d'extension de Genius). C'est le langage que vous devez utiliser pour écrire des programmes dans Genius. Un programme en GEL est simplement une expression qui renvoie un nombre. L'
Types de données
Les données GEL peuvent être des
Nombres
1234
0x123ABC
01234
23\\1234ABCD
Les entiers sont les premiers types de nombres GEL. Les entiers s'écrivent de façon habituelle.
3/4
1 3/10
Le deuxième type de nombres en GEL est celui des rationnels. Les rationnels sont simplement obtenus en divisant deux entiers. Il serait donc possible d'écrire :
1.315
7.887e77
7.887e-77
.3
0.3
77e5
Le type suivant est celui des nombres à virgule flottante. Ils sont saisis de la même manière qu'en C. Vous pouvez utiliser
1+2i
8.01i
77*e^(1.3i)
Le dernier type de nombres GEL est celui des nombres complexes. Vous pouvez saisir un nombre complexe sous sa forme cartésienne, ou sous sa forme exponentielle. La partie imaginaire se termine par un
Lorsque vous saisissez des nombres imaginaires, il doit y avoir un nombre devant le
Afin de pouvoir utiliser la notation en fraction mixte avec des nombres imaginaires, vous devez mettre la fraction mixte entre parenthèses (par exemple,
Booléens
Genius prend également en charge nativement les données booléennes. Les deux constantes booléennes sont
Là où une expression booléenne est attendue, vous pouvez utiliser une grandeur booléenne ou toute expression qui produit soit un nombre soit un booléen. Si Genius a besoin d'évaluer un nombre en tant que booléen, il interprète 0 comme
( (1 + true) - false ) * true
( (true or true) or not false ) and true
1 == true
Vous pouvez également faire des calculs avec des données booléennes. Par exemple :
Chaînes de caractères
a=2+3;"Le résultat est : "+a
Le résultat est : 5
"Barre oblique : \\\\ Guillemets : \\" Tabulations : \ 1\ 2\ 3"
Barre oblique : \\ Guillemets : " Tabulations : 1 2 3
Tout comme les nombres et les booléens, les chaînes en GEL peuvent être enregistrées dans des variables et transmises à des fonctions. Vous pouvez également concaténer une chaîne avec une autre en utilisant l'opérateur plus. Par exemple,
string(22)
"22"
Vous pouvez en plus utiliser la fonction
Null
Il existe une grandeur spéciale appelée
x=5;.
x=5;
Exemple :
Certaines fonctions renvoient
Utilisation des variables
NomDeVariable
Syntaxe :
Pour évaluer une variable elle-même, il suffit de saisir le nom de la variable. Cela renvoie la valeur de la variable. Vous pouvez utiliser une variable n'importe où, où vous utiliseriez normalement un nombre ou une chaîne. De plus, les variables sont indispensables pour définir des fonctions qui possèdent des arguments (consultez
Utilisation de la complétion à l'aide de la touche Tab
Vous pouvez utiliser la complétion à l'aide de la touche Tab pour que Genius complète les noms de variable pour vous. Essayez de saisir les premières lettres du nom et appuyez sur la touche
Noms de variable sensibles à la casse
Les noms de variable sont sensibles à la casse. Cela signifie que les variables appelées
Attribution de variables
x = 3
x := 3
Syntaxe :
a = b = 5
Pour attribuer une variable, utilisez les opérateurs
Les opérateurs
Pour les problèmes concernant le champ d'application des variables, consultez
Variables internes
GEL possède un certain nombre de « variables », telles que
Variable « Résultat précédent »
Ans+389
Les variables
Utilisation des fonctions
NomDeLaFonction(argument1, argument2, ...)
Factorial(5)
cos(2*pi)
gcd(921,317)
Syntaxe :
Il y a beaucoup de fonctions intégrées, telles que
Vous pouvez utiliser la fonction de complétion à l'aide de la touche Tab pour que Genius complète les noms de fonction pour vous. Essayez de saisir les quelques premières lettres du nom et appuyez sur
Noms de fonction sensibles à la casse
Les noms des fonctions sont sensibles à la casse. Cela signifie que les fonctions appelées
Définition de fonctions
Syntaxe :
function addup(a,b,c) = a+b+c
Une fonction prend zéro argument ou plus, séparés par des virgules et renvoie le résultat du corps de la fonction. Le fait de définir ses propres fonctions est une question de commodité ; un usage possible est d'avoir un ensemble de fonctions définies dans des fichiers GEL que Genius peut charger afin de les rendre accessibles. Exemple :
Liste d'arguments variable
function f(a,b...) = b
Si vous ajoutez
Une fonction comme argument d'une autre fonction
Dans Genius, il est possible de transmettre une fonction comme argument d'une autre fonction. Cela peut être fait en utilisant soit des « nœuds de fonction », soit des fonctions anonymes.
function f(a,b) = a(b)+1;
function b(x) = x*x;
f(b,2)
Si vous ne saisissez pas les parenthèses après un nom de fonction, la fonction est renvoyée sous la forme d'un « nœud de fonction », au lieu d'être évaluée. Le nœud de fonction peut ensuite être transmis à une autre fonction. Par exemple :
function f(a,b) = a(b)+1;
f(`(x) = x*x,2)
Pour transmettre des fonctions qui ne sont pas encore définies, vous pouvez utiliser une fonction anonyme (consultez
Opérations sur les fonctions
exp(sin*cos+4)
`(x) = exp(sin(x)*cos(x)+4)
f = exp(sin*cos+4)
LinePlot(sin^2)
Certaines fonctions permettent à des opérations arithmétiques et à certaines fonctions à un seul argument telles que
Toutes les fonctions ne peuvent pas être utilisées de cette façon. Par exemple, lorsque vous utilisez une opération binaire, les fonctions doivent prendre le même nombre d'arguments.
Valeur absolue / module
|a-b|
Vous pouvez prendre la valeur absolue de quelque chose en l'entourant de
Si l'expression est un nombre complexe, le résultat est le module (distance à partir de l'origine). Par exemple :
Séparateur
3 ; 5
En GEL, si vous voulez saisir plus d'une commande, vous devez utiliser l'opérateur
La présence de parenthèses peut parfois être nécessaire pour rendre l'expression non ambiguë, plus particulièrement si le
Commentaires
Évaluation modulaire
2^(5!) * 3^(6!) mod 5
Genius implémente l'arithmétique modulaire. Pour l'utiliser, vous avez juste à ajouter « mod &lt;entiergt; » après l'expression. Exemple :
10^-1 mod 101
1/10 mod 101
A = [1,2;3,4]
B = A^-1 mod 5
A*B mod 5
Vous pouvez calculer l'inverse de nombres modulo des entiers juste en utilisant des nombres rationnels (bien sûr, l'inverse doit exister). Exemples :
geniusgt; sqrt(4) mod 7
=
[2, 5]
geniusgt; 2*2 mod 7
= 4
Certaines fonctions telles que
Liste des opérateurs GEL
Dans le langage GEL, chaque chose est vraiment une expression. Les expressions sont reliées ensemble par différents opérateurs. Comme nous l'avons vu, même le séparateur est juste un opérateur binaire GEL. Voici une liste des opérateurs GEL.
a;b
C'est le séparateur, il évalue simplement à la fois
a=b
L'opérateur d'attribution. Il attribue
a:=b
L'opérateur d'attribution. Il attribue
|a|
Valeur absolue ou module (si
Consultez
a^b
Exposant, met
a.^b
Exposant élément par élément. Met chaque élément d'une matrice
a+b
Addition. Ajoute deux nombres, matrices, fonctions ou chaînes de caractères. Si vous ajoutez une chaîne à quelque chose, le résultat ne peut être qu'une chaîne.
a-b
Soustraction. Soustrait deux nombres, matrices ou fonctions.
a*b
Multiplication. C'est la multiplication matricielle normale.
a.*b
Multiplication élément par élément si
a/b
a./b
a\\b
Division arrière. C'est donc la même chose que
a.\\b
Division arrière élément par élément.
a%b
L'opérateur modulo. Cela n'active pas le mode d'
a.%b
L'opérateur modulo élément par élément. Renvoie le reste après la division entière élément par élément de
a mod b
Opérateur d'évaluation modulaire. L'expression
a!
Opérateur factoriel. Il s'agit de
a!!
Opérateur double factoriel. Il s'agit de
a==b
Opérateur inégalité, renvoie
a!=b
Opérateur inégalité, renvoie
alt;gt;b
Autre opérateur inégalité, renvoie
alt;=b
Opérateur inférieur ou égal, renvoie
agt;=b
Opérateur supérieur ou égal, renvoie
alt;b
Opérateur inférieur ou égal, renvoie
agt;b
Opérateur supérieur ou égal, renvoie
alt;=gt;b
Opérateur comparaison. Si
a and b
a or b
a xor b
not a
-a
&a
Déréférencement de variable (pour accéder à une variable référencée). Consultez
*a
Déréférencement de variable (pour accéder à une variable référencée). Consultez
a'
a.'
a@(b,c)
Renvoie l'élément ligne
a@(b,)
Renvoie une ligne de matrice (ou plusieurs lignes si
a@(b,:)
Comme ci-dessus.
a@(,c)
Renvoie une colonne de matrice (ou des colonnes si
a@(:,c)
a@(b)
Renvoie un élément d'une matrice en le traitant comme un vecteur. Cela parcourt la matrice dans le sens des lignes.
a:b
A@(2:4,)
 
Construit un vecteur allant de
a:b:c
geniusgt; 1:2:9
=
`[1, 3, 5, 7, 9]
Construit un vecteur allant de
(a)i
(a)*1i
 
Crée un nombre imaginaire (multiplie
`a
Apostropher un identifiant afin qu'il ne soit pas évalué. Ou apostropher une matrice afin qu'elle ne soit pas étendue.
a swapwith b
Échange la valeur de
increment a
Incrémente la variable
increment a by b
Incrémente la variable
L'opérateur @() rend l'opérateur : très utile. Grâce à lui, vous pouvez indiquer des régions d'une matrice. Ainsi a@(2:4,6) sont les lignes 2,3,4 de la colonne 6 ou a@(,1:2) vous renvoie les deux premières colonnes d'une matrice. Vous pouvez également attribuer un opérateur @() tant que la valeur de droite est une matrice qui correspond en taille à la région ou si c'est n'importe quel autre type de valeur.
Les opérateurs de comparaison (excepté l'opérateur &lt;=gt; qui se comporte normalement) ne sont pas des opérateurs strictement binaires, ils peuvent en fait être regroupés comme dans une expression mathématique normale, par ex. : (1lt;xlt;=ylt;5) est une expression booléenne correcte qui signifie bien ce qu'elle doit, c'est-à-dire (1lt;x et x≤y et ylt;5)
L'opérateur unitaire « moins » agit de manière différente en fonction de l'endroit où il apparaît. S'il apparaît devant un nombre, il est très prioritaire, s'il apparaît devant une expression, il est moins prioritaire que les opérateurs puissance et factoriel. Par exemple,
Programmation avec GEL
Tests
Syntaxe :
if a=5 then a=a-1
if a==5 then a:=a-1
Exemples :
Boucles
Boucles tant que (while) et jusqu'à (until)
Syntaxe :
Boucles pour (for)
for i = 1 to 20 by 2 do print(i)
Syntaxe :
for x = 0 to 1 by 0.1 do print(x)
for x = 0 to 1 by 1/10 do print(x)
Boucles pour chaque (foreach)
for n in [1,2:3,4] do print(n)
for n in RowsOf ([1,2:3,4]) do print(n)
Syntaxe :
Instructions « break » et « continue »
Vous pouvez aussi utiliser les instructions
Sommes et produits
Syntaxe :
Si aucun contenu (body) est exécuté (par exemple,
Opérateurs de comparaison
Les opérateurs de comparaison standard suivants sont pris en charge dans GEL et ont des significations évidentes :
if a=b then c
if a==b then c
Normalement
Tous les opérateurs de comparaison (sauf l'opérateur
Pour construire des expressions logiques, utilisez les mots
Variables globales et portée des variables
GEL est un
function f() = (a:=5; g());
function g() = print(a);
f();
Comme la plupart des langages de programmation, GEL possède différents types de variables. Normalement lorsqu'une variable est définie dans une fonction, elle est visible dans cette fonction et à partir de toutes les fonctions qui sont appelées (tous les contextes supérieurs). Par exemple, supposons qu'une fonction
function f() = (a:=5; g());
function g() = print(a);
a:=10;
f();
Si vous définissez une variable à l'intérieur d'une fonction, elle va supplanter toutes variables définies dans les fonctions appelantes. Par exemple, si nous modifions le code ci-dessus et écrivons :
Les arguments de fonction sont exactement comme les variables définies à l'intérieur de la fonction sauf qu'ils sont initialisés à la valeur qui a été transmise à la fonction. En dehors de ce point, ils sont traités exactement comme toutes les autres variables définies dans la fonction.
Les fonctions sont traitées exactement comme les variables. Par conséquent, vous pouvez redéfinir localement les fonctions. Normalement (au niveau supérieur) vous ne pouvez pas redéfinir des variables et fonctions protégées mais, vous pouvez le faire localement. Considérons la session suivante :
a=6;
function f() = (a:=5);
f();
set(`a,3)
set("a",3)
Les fonctions et variables définies au niveau supérieur sont considérées globales. Elles sont visibles de n'importe où. Comme nous l'avons déjà dit, la fonction
La fonction
Donc pour récapituler dans un langage plus technique : genius opère avec différents contextes numérotés. Le niveau supérieur est le contexte 0 (zéro). À chaque fois qu'une fonction est entrée, le contexte est augmenté et lorsqu'une fonction est quittée, le contexte est diminué. Une fonction ou une variable est toujours visible à partir de tous les contextes de numéro plus élevé. Si une variable a été définie dans un contexte de numéro plus bas alors attribuer une valeur à cette variable a pour effet de créer une nouvelle variable locale dans le numéro de contexte actuel et cette variable est maintenant visible de tous les contextes de numéro plus élevé.
Il existe également des variables vraiment locales, qui ne sont visibles de nulle part sauf du contexte actuel. Ainsi lorsque vous renvoyez des fonctions par valeur, il se peut que cela fasse référence à des variables non visibles à partir des contextes supérieurs et cela peut être un problème. Consultez
Variables paramètres
Comme dit précédemment, il existe des variables spéciales appelées paramètres qui existent dans toutes les portées. Pour déclarer un paramètre appelé
Si vous annulez la définition comme paramètre en utilisant la fonction
Certains paramètres sont internes à Genius et modifient son comportement.
Sortie de fonction
Normalement une fonction est une ou plusieurs expressions séparées par un point virgule et la valeur de la dernière expression est renvoyée. C'est suffisant pour les fonctions simples mais parfois vous ne voulez pas qu'une fonction renvoie la dernière chose calculée. Il se peut que vous vouliez, par exemple, quitter la fonction à partir du milieu de la fonction. Dans ce cas, vous pouvez utiliser le mot-clé
Références
Il peut être nécessaire pour certaines fonctions de renvoyer plus d'une seule valeur. C'est possible en renvoyant un vecteur de valeurs mais souvent il est pratique d'utiliser le passage d'une référence à une variable. Vous transmettez une référence vers une variable à une fonction et la fonction attribue des valeurs à la variable pour vous en utilisant un déréférencement. Ce n'est pas le seul usage que vous pouvez faire du passage par référence mais c'est son utilisation principale.
Lorsque vous utilisez des fonctions qui renvoient des valeurs à travers des références dans sa liste d'argument, il suffit de transmettre le nom de la variable précédée d'une esperluette. Par exemple, le code suivant calcule une valeur propre d'une matrice
Les détails concernant le fonctionnement des références et leur syntaxe sont similaires à ceux du langage C. L'opérateur
Les références s'expliquent mieux par un exemple :
Valeurs à gauche (lvalues)
a
Identifiant. Ici nous attribuons une valeur à la variable de nom
Déréférence un identifiant. Cela attribue une valeur à ce que vers quoi la variable
a@(lt;régiongt;)
Une région d'une matrice. Ici la région est indiquée normalement comme avec l'opérateur habituel @() et peut être une entrée unique ou une région entière de la matrice.
Une valeur à gauche est la partie à gauche d'une attribution. En d'autres mots, une valeur à gauche est la chose dans laquelle vous attribuez quelque chose. Des valeurs à gauche valides sont :
a:=4
*tmp := 89
a@(1,1) := 5
a@(4:8,3) := [1,2,3,4,5]'
Exemples :
Programmation avancée avec GEL
Gestion des erreurs
Si vous détectez une erreur dans votre fonction, vous pouvez la quitter rapidement (« to bail out of »). Pour les erreurs normales, telles que les mauvais types d'arguments, vous pouvez éviter de calculer la fonction en ajoutant l'instruction
function f(M) = (
 if not IsMatrix (M) then (
 error ("M n'est pas une matrice !");
 bailout
 );
 ...
)
Par exemple, si vous voulez vérifier les arguments de votre fonction. Vous pouvez utiliser le code suivant.
Syntaxe de haut-niveau
La syntaxe est légèrement différente si vous saisissez des instructions au niveau supérieur plutôt que lorsque vous êtes entre parenthèses ou à l'intérieur de fonctions. Au niveau supérieur, un retour à la ligne a le même effet qu'un appui sur la touche Entrée en ligne de commande. Par conséquent, considérez vos programmes comme une suite de lignes saisie en ligne de commande. En particulier, vous n'avez pas besoin de saisir le séparateur à la fin d'une ligne (à moins que cela ne soit une partie de plusieurs instructions à l'intérieur de parenthèses).
if QuelqueChose() then
 FaireQuelqueChose()
else
 FaireAutreChose()
Le code suivant provoque une erreur lorsqu'il est saisi au niveau supérieur d'un programme alors qu'il fonctionne très bien dans une fonction.
if QuelqueChose() then(
 FaireQuelqueChose()
) else (
 FaireAutreChose()
)
Le problème est que lorsque l'
Renvoi de fonction
function f() = (
 k = 5;
 `(x) = (x+k)
)
g = f();
g(5)
Il est possible de renvoyer des fonctions en tant que donnée. De cette manière, vous pouvez écrire une fonction qui construit des fonctions dans un but précis en fonction de certains paramètres. Le point délicat est de savoir quelles variables sont visibles par la fonction construite. La façon dont cela fonctionne dans GEL est que, lorsqu'une fonction renvoie une autre fonction, tous les identifiants qui étaient référencés dans le corps de la fonction mère, et qui deviendraient hors de portée, sont en fait ajoutés dans un dictionnaire privé de la fonction renvoyée. Ainsi la fonction voit toutes les variables qui étaient à sa portée au moment où elle a été définie. Par exemple, nous pouvons définir ainsi une fonction qui renvoie une fonction qui ajoute 5 à son argument :
function f() = (
 k := 5;
 function r(x) = (x+k);
 k := 10;
 r
)
Une chose à noter est que la valeur de
function f() = (
 k := 5;
 function r(x) [k] = (x+k);
 k := 10;
 r
)
Parfois il est préférable d'avoir un meilleur contrôle sur la façon dont les variables sont copiées dans le dictionnaire privé. Depuis la version 1.0.7, vous pouvez spécifier quelles variables sont copiées dans le dictionnaire privée en mettant des crochets carrés supplémentaires après les arguments contenant la liste des variables qui seront copiées, séparées par des virgules. Si vous faites cela alors les variables sont copiées dans le dictionnaire privé au moment de la définition de la fonction et le dictionnaire privé n'est pas modifié ensuite. Par exemple,
function f() = (
 k := 5;
 function r(x) [] = (x+k);
 r
);
k := 10;
g = f();
g(10)
Lorsque vous désirez que la fonction n'ait pas de dictionnaire privé alors mettez des crochets carrés vides après la liste d'arguments. Alors aucun dictionnaire privé n'est créé. Ce méchanisme est utile pour améliorer l'efficacité des fonctions qui n'ont pas besoin de dictionnaire privé, ou encore si vous voulez que la fonction utilise les variables dans leur état au moment où elle est appelée. Par exemple, supposons que vous vouliez que la fonction renvoyée par
Variables locales vraies
k := 10;
function r(x) = (x+k);
function f(g,x) = (
 k := 5;
 g(x)
);
f(r,1)
Lors de la transmission de fonctions dans d'autres fonctions, la portée normale des variables peut être indésirable. Par exemple :
function f(g,x) = (
 local g,x,k;
 k := 5;
 g(x)
);
Mais il y a une autre solution. Depuis la version 1.0.7 de Genius, il existe des variables vraiment locales. Ce sont des variables qui ne sont visibles qu'à partir du contexte actuel, et pas par les fonctions appelées. Nous pouvons définir
function f(g,x) = (
 local *;
 k := 5;
 g(x)
);
Si toutes les variables doivent être créées localement, vous pouvez utiliser un astérisque à la place d'une liste de variables. Dans ce cas, les variables ne sont pas initialisées tant qu'elles ne sont pas définies bien sûr. La définition suivante de
C'est une bonne pratique que toutes les fonctions qui prennent d'autres fonctions comme argument, utilisent des variables locales. De cette manière, la fonction transmise ne voit pas les détails de l'implémentation et n'est pas perturbée.
Procédure de démarrage de GEL
Dans un premier temps, le programme recherche dans le répertoire d'installation les fichiers de la bibliothèque installés (la version compilée
Si vous modifiez l'emplacement d'installation de la bibliothèque, vous devrez d'abord la compiler avec la commande
Chargement de programmes
load programme1.gel programme2.gel
load "Etrange nom de fichier avec des ESPACES.gel"
cd repertoire_contenant_des_programmes_gel
ls *.gel
Imaginons que vous ayiez un programme d'une certaine taille que vous avez écrit dans un fichier et que vous vouliez lire ce fichier. Dans ce cas, il y a deux options. Vous pouvez conserver les fonctions que vous utilisez le plus souvent dans le fichier
Matrices en GEL
Genius prend en charge les vecteurs et les matrices et possède une importante bibliothèque de fonctions pour la manipulation des matrices et l'algèbre linéaire.
Saisie de matrices
[1,2,3;4,5,6;7,8,9]
[1, 2, 3
 4, 5, 6
 7, 8, 9]
Pour saisir des matrices, vous pouvez utiliser l'une des deux syntaxes suivantes. Soit vous saisissez la matrice sur une seule ligne, en séparant les valeurs par des virgules et les lignes par des point-virgules soit vous saisissez chaque rangée sur une ligne en séparant les valeurs par des virgules. Vous pouvez également combiner les deux méthodes. Ainsi pour saisir une matrice 3x3 contenant les nombres 1 à 9, vous pouvez saisir
a = [ 1, 2, 3
 4, 5, 6
 7, 8, 9]
b = [ a, 10
 11, 12]
[1, 2, 3, 10
 4, 5, 6, 10
 7, 8, 9, 10
 11, 11, 11, 12]
Vous pouvez aussi utiliser les fonctionnalités de complétion pour saisir des matrices. Par exemple, vous pouvez saisir :
[1, 2, 3
 4, 5
 6]
[1, 2, 3
 4, 5, 0
 6, 0, 0]
Notez que les éléments non spécifiés sont initialisés à 0, donc
Lorsque les matrices sont évaluées, elles sont parcourues dans le sens des lignes, exactement de la même façon que l'opérateur
Faites attention lorsque vous utilisez des retours à la ligne à l'intérieur des crochets
Opérateur de transposition conjuguée et de transposition
[1,2,3]*[4,5,6]'
[1,2,3]*[4,5,6i].'
Vous pouvez obtenir la matrice transposée conjuguée grâce à l'opérateur
Remarquez que la transposée normale, c'est-à-dire l'opérateur
Algèbre linéaire
Genius implémente beaucoup de routines utiles d'algèbre linéraire et de manipulation de matrice. Consultez les sections
Les routines d'algèbre linéaire implémentées en GEL ne proviennent pas actuellement d'un paquet numérique bien testé et ne doivent donc pas être utilisées pour des calculs numériques critiques. D'un autre côté, Genius implémente très bien les nombreuses opérations d'algèbre linéaire avec des coefficients rationnels et entiers. Elles sont par nature exactes et en fait vous donnent de bien meilleurs résultats que les routines en double précision usuelles pour l'algèbre linéaire.
Par exemple, il est vain de calculer le rang et le noyau d'une matrice réelle puisque dans tous les cas pratiques, il faut considérer que la matrice contienne de légères erreurs. Il est possible que vous obteniez un résultat différent de ce que vous attendiez. Le problème est qu'en faisant une légère perturbation toute matrice est de rang complet et inversible. Cependant si la matrice est composée de nombres rationnels alors le rang et le noyau sont toujours exactes.
En général, lorsque Genius calcule la base d'un espace vectoriel (par exemple avec la fonction
Notez que Genius peut se souvenir d'un certaine nombre de propriétés d'une matrice. Par exemple, il se souvient qu'une matrice est sous une forme réduite. Si beaucoup d'appels à des fonctions qui utilisent en interne une forme réduite, sont effectués, vous pouvez réduire la matrice une fois pour toute auparavant. Les appels successifs à la fonction
Polynômes en GEL
Actuellement Genius peut prendre en charge des polynômes à une variable écrits sous la forme de vecteurs et réaliser des opérations élémentaires avec eux. Il est prévu d'étendre cette prise en charge.
Utilisation des polynômes
[1,2,3]
1 + 2*x + 3*x^2
Actuellement les polynômes à une variable sont juste des vecteurs lignes dont les valeurs sont les coefficients. La puissance du terme est la position dans le vecteur, la première étant 0. Ainsi,
PolyToString([1,2,3],"y")
3*y^2 + 2*y + 1
f = PolyToFunction([0,1,1])
f(2)
Vous pouvez ajouter, soustraire et multiplier des polynômes en utilisant respectivement les fonctions
Il est aussi possible de trouver les racines des polynômes de degré 1 à 4 en utilisant la fonction
Consultez
Théorie des ensembles en GEL
Genius possède des fonctionnalités intégrées basiques concernant la théorie des ensembles. Actuellement un ensemble est juste un vecteur (ou une matrice). Chaque objet distinct est traité comme un élément différent.
Utilisation des ensembles
Tout comme les vecteurs, les objets dans les ensembles peuvent comprendre des nombres, des chaînes de caractères,
Pour construire un ensemble à partir d'un vecteur, utilisez la fonction
De manière similaire, il existe des fonctions
Pour tester l'appartenance, il existe les fonctions
Liste des fonctions GEL
help NomDeLaFonction
Pour obtenir de l'aide sur une fonction spécifique à partir de la console, saisissez :
Commandes
help
help NomDeLaFonction
Affiche l'aide (ou l'aide d'une fonction/commande).
load "fichier.gel"
Charge un fichier dans l'interpréteur. Le contenu du fichier s'exécute comme s'il était saisi en ligne de commande.
cd /nom/de/repertoire
Change le répertoire de travail en
pwd
Affiche le répertoire de travail.
ls
Affiche les fichiers dans le répertoire.
plugin nom_du_greffon
Charge un greffon. Le greffon portant ce nom doit être installé sur votre système dans le répertoire correct.
Basique
AskButtons (requête)
AskButtons (requête, bouton1, ...)
Pose une question et présente une liste de boutons à l'utilisateur (ou un menu d'options en mode texte). Renvoie l'indice du bouton enfoncé, commençant à 1, c'est-à-dire renvoie 1 si le premier bouton est enfoncé, 2 si le second bouton est enfoncé, etc. Si l'utilisateur ferme la fenêtre (ou appui sur Entrée en mode texte) alors
AskString (requête)
AskString (requête, défaut)
Pose une question et permet à l'utilisateur de saisir une chaîne de caractères qui est ensuite renvoyée. Si l'utilisateur annule ou ferme la fenêtre alors
Compose (f,g)
Compose deux fonctions et renvoie une fonction qui est la composition de
ComposePower (f,n,x)
Compose et exécute une fonction avec elle-même
Evaluate (chaîne)
Analyse et évalue une chaîne.
GetCurrentModulo
Obtient le modulo actuel à partir du contexte extérieur à la fonction. C'est-à-dire, si l'extérieur de la fonction a été exécuté en mode modulo (en utilisant
Identity (x)
Fonction identité, renvoie son argument.
IntegerFromBoolean (val_bool)
Crée un entier (0 pour
IsBoolean (param)
Vérifie que l'argument est un booléen (et pas un nombre).
IsDefined (id)
Vérifie qu'un identifiant est défini. Vous devez transmettre une chaîne de caractères ou un identifiant. Si vous transmettez une matrice, chaque entrée est évaluée séparément et la matrice doit contenir des chaînes ou des identifiants.
Tolérance pour la fonction
IsFunction (param)
Vérifie que l'argument est une fonction.
IsFunctionOrIdentifier (param)
Vérifie que l'argument est une fonction ou un identificateur.
IsFunctionRef (param)
Vérifie que l'argument est une référence de fonction. Cela inclut les références de variable.
IsMatrix (param)
Vérifie que l'argument est une matrice. Même si
IsNull (param)
Vérifie que l'argument est
IsString (param)
Vérifie que l'argument est une chaîne de caractères.
IsValue (param)
Vérifie que l'argument est un nombre.
Parse (chaîne)
Analyse mais n'évalue pas une chaîne de caractères. Notez que certains pré-calculs sont effectués pendant l'étape d'évaluation.
SetFunctionFlags (id,drapeau...)
Définit des drapeaux pour une fonction, actuellement
SetHelp (id,categorie,desc)
Définit une catégorie et une ligne de description d'aide pour une fonction.
SetHelpAlias (id,alias)
Met en place un pseudonyme pour l'aide.
chdir (rep)
Change le répertoire actuel, tout comme la commande
CurrentTime
Renvoie l'heure UNIX courante avec une précision de l'ordre de la microseconde sous forme d'un nombre à virgule flottante, c'est-à-dire le nombre de secondes écoulées depuis le 1er janvier 1970.
display (chaîne,expr)
Affiche une chaîne de caractères et une expression séparées par deux points.
UserVariables ()
error (chaîne)
Affiche une chaîne vers la sortie erreur (dans la console).
exit
Alias :
Quitte le programme.
false
Alias :
La valeur booléenne
manual
Affiche le manuel utilisateur.
print (chaîne)
Affiche une expression suivie d'un retour à la ligne. L'argument
printn (chaîne)
Affiche une expression non suivie d'un retour à la ligne. L'argument
IsDifferentiable (f,x0)
protect (id)
Protège une variable de la modification. C'est utilisé dans les fonctions internes de GEL pour leur éviter d'être accidentellement écrasées.
ProtectAll ()
Protège toutes les variables, paramètres et fonctions actuellement définis de la modification. C'est utilisé dans les fonctions internes de GEL pour leur éviter d'être accidentellement écrasées. Normalement l'
set (id,val)
set(`x,1)
 
Définit une variable globale. L'
string (s)
Crée une chaîne de caractères à partir de n'importe quel argument.
true
Alias :
La valeur booléenne
undefine (id)
Alias :
Annule la définition d'une variable, y compris les variables locales et globales, toutes les valeurs dans tous les contextes sont effacées. Vous ne devriez vraiment pas utiliser cette fonction pour des variables locales. Un vecteur d'identifiants peut également être transmis pour annuler la définition de plusieurs variables.
UndefineAll ()
Annule la définition de toutes les variables globales non protégées (y compris les fonctions et les paramètres). Normalement l'
unprotect (id)
Annule la protection d'une variable contre sa modification.
UserVariables ()
Renvoie un vecteur d'identifiants des variables globales définies par l'utilisateur (non protégées).
wait (secs)
Attend un nombre spécifié de secondes.
version
Renvoie la version de Genius sous la forme d'un vecteur horizontal à 3 valeurs : en premier la version majeure, puis la version mineure et enfin le niveau de correction.
warranty
Renvoie les informations sur la garantie.
Paramètres
ChopTolerance = nombre
Tolérance pour la fonction
ContinuousNumberOfTries = nombre
Nombre d'itérations à essayer pour rechercher la continuité et les limites d'une fonction.
ContinuousSFS = nombre
Nombre d'étapes successives pour atteindre la tolérance pour le calcul de la continuité.
ContinuousTolerance = nombre
Tolérance pour la continuité d'une fonction et pour le calcul de la limite.
DerivativeNumberOfTries = nombre
Nombre d'itérations à essayer pour trouver la limite pour la dérivée.
DerivativeSFS = nombre
Nombre d'étapes successives pour atteindre la tolérance pour le calcul de la dérivée.
DerivativeTolerance = nombre
Tolérance pour le calcul de la dérivée des fonctions.
ErrorFunctionTolerance = nombre
Efface les solutions dessinées par la fonction
FloatPrecision = nombre
Précision en virgule flottante.
FullExpressions = booléen
Affiche les expressions complètes, même celles de plus d'une ligne.
GaussDistributionTolerance = nombre
Efface les solutions dessinées par la fonction
IntegerOutputBase = nombre
Base de sortie pour les entiers.
IsPrimeMillerRabinReps = nombre
Nombre de tests supplémentaires de Miller-Rabin à lancer sur un nombre avant de le déclarer comme premier dans
LinePlotDrawLegends = true
Indique à genius de tracer les légendes pour les
LinePlotDrawAxisLabels = true
Indique à genius de tracer les légendes pour les
LinePlotVariableNames = ["x","y","z","t"]
Indique à Genius les noms des variables utilisés pour les
LinePlotWindow = [x1,x2,y1,y2]
Définit les limites pour les
MaxDigits = nombre
Nombre maximum de chiffres à afficher.
MaxErrors = nombre
Nombre maximum d'erreurs à afficher.
MixedFractions = booléen
Si vrai, les fractions mixtes sont affichées.
Fonction utilisée pour l'intégration numérique dans la fonction
NumericalIntegralFunction = fonction
Fonction utilisée pour l'intégration numérique dans la fonction
NumericalIntegralSteps = nombre
Définit les limites pour les tracés de surface (consultez
Définit quand la sortie est tronquée. Consultez
OutputChopExponent = nombre
Lorsqu'un autre nombre dans l'objet qui est affiché (une matrice ou une valeur) est plus grand que 10
La sortie n'est jamais tronquée si
Si vous voulez toujours que la sortie soit tronquée selon
Définit quand la sortie est tronquée. Consultez
OutputChopWhenExponent = nombre
Définit quand la sortie est tronquée. Consultez
OutputStyle = chaîne
Style des affichages, cela peut être
OutputStyle = "latex"
Cela affecte principalement la façon dont les matrices et les fractions sont affichées et est utile pour le copier/coller vers des documents. Par exemple, vous pouvez définir ce paramètre à « latex » par :
ResultsAsFloats = booléen
Convertit tous les résultats en nombres flottants avant de les afficher.
ScientificNotation = booléen
Utilise la notation scientifique.
SlopefieldTicks = [verticale,horizontale]
Définit le nombre de petits traits verticaux et horizontaux dans un graphique de champ de tangente (consultez
SumProductNumberOfTries = nombre
Définit les limites pour les
SumProductSFS = nombre
Nombre d'étapes successives pour atteindre la tolérance pour les fonctions
SumProductTolerance = nombre
Définit les limites pour les
SurfacePlotDrawLegends = true
Indique à genius de tracer les légendes pour les
SurfacePlotVariableNames = ["x","y","z"]
Indique à Genius les noms de variables à utiliser comme noms par défaut pour les
SurfacePlotWindow = [x1,x2,y1,y2,z1,z2]
Définit les limites pour les tracés de surface (consultez
VectorfieldNormalized = true
Indique si les longueurs de flèches du tracé de champ de vecteurs doivent être normalisées. Si true (vrai), les tracés de champ de vecteurs n'affichent que la direction et pas l'amplitude (consultez
Consultez
VectorfieldTicks = [verticale,horizontale]
Définit le nombre de petits traits verticaux et horizontaux dans un graphique de champ de vecteurs (consultez
Constantes
CatalanConstant
Constante de Catalan, approximativement 0,915..., elle est définie comme la série des termes
Consultez
EulerConstant
Alias :
Constante d'Euler gamma, parfois appelée la constante d'Euler-Mascheroni.
Consultez
GoldenRatio
Le nombre d'or.
Consultez
Gravity
Accélération de la chute libre au niveau de la mer.
Consultez
e
La base du logarithme naturel.
Consultez
pi
Le nombre pi, c'est-à-dire le rapport de la circonférence d'un cercle sur son diamètre. Il vaut approximativement 3.14159265359...
Consultez
Nombres
AbsoluteValue (x)
Alias :
Valeur absolue d'un nombre et, si
Consultez
Chop (x)
Remplace les très petits nombres par zéro.
ComplexConjugate (z)
Alias :
Calcule le conjugué du nombre complexe
Consultez
Denominator (x)
Renvoie le dénominateur d'un nombre rationnel.
Consultez
FractionalPart (x)
Renvoie la partie fractionnelle d'un nombre.
Consultez
Im (z)
Alias :
Renvoie la partie imaginaire d'un nombre complexe.
Consultez
IntegerQuotient (m,n)
Division sans reste.
IsComplex (nbre)
Vérifie si l'argument est un nombre complexe (non réel).
IsComplexRational (nbre)
Vérifie si l'argument est potentiellement un nombre rationnel complexe. C'est-à-dire si la partie réelle et la partie imaginaire sont fournies sous la forme de nombres rationnels. Bien sûr, rationnel signifie simplement « non enregistré comme un nombre à virgule flottante ».
IsFloat (nbre)
Vérifie si l'argument est un nombre flottant (non complexe).
IsGaussInteger (nbre)
Alias :
Vérifie si l'argument peut être un entier complexe.
IsInteger (nbre)
Vérifie si l'argument est un entier (non complexe).
IsNonNegativeInteger (nbre)
Vérifie si l'argument est un entier réel non négatif.
IsPositiveInteger (nbre)
Alias :
Vérifie si l'argument est un entier réel positif. Notez que par convention 0 n'est pas un nombre naturel.
IsRational (nbre)
Vérifie si l'argument est un nombre rationnel (non complexe). Bien sûr, rationnel signifie simplement « non enregistré comme un nombre à virgule flottante ».
IsReal (nbre)
Vérifie si l'argument est un nombre réel.
Numerator (x)
Renvoie le numérateur d'un nombre rationnel.
Consultez
Re (z)
Alias :
Renvoie la partie réelle d'un nombre complexe.
Consultez
Sign (x)
Alias :
Renvoie le signe d'un nombre. C'est-à-dire renvoie
ceil (x)
Alias :
Exemples :
exp (x)
La fonction exponentielle. C'est la fonction
Consultez
float (x)
Transforme le nombre en nombre à virgule flottante. C'est-à-dire la représentation à virgule flottante du nombre
floor (x)
Alias :
Renvoie le plus grand entier inférieur ou égal à
ln (x)
Le logarithme naturel, le logarithme de base
log (x)
log (x,b)
Logarithme de
log10 (x)
Logarithme base 10 de
log2 (x)
Alias :
Logarithme base 2 de
max (a,params...)
Alias :
Renvoie le maximum des arguments ou de la matrice.
min (a,params...)
Alias :
Renvoie le minimum des arguments ou de la matrice.
rand (taille...)
Génère aléatoirement des nombres flottants dans l'intervalle
randint (max,taille...)
Génère aléatoirement des entiers dans l'intervalle
round (x)
Alias :
Arrondit un nombre.
sqrt (x)
Alias :
La racine carrée. Au cours de calculs en mode modulaire, certains entiers renvoient soit
Consultez
trunc (x)
Alias :
Tronque le nombre à un entier (renvoie la partie entière).
Trigonométrie
acos (x)
Alias :
Fonction arccos (arc cosinus).
acosh (x)
Alias :
Fonction arccosh (cosinus hyperbolique inverse).
acot (x)
Alias :
Fonction arccot (cotangente inverse).
acoth (x)
Alias :
Fonction arccoth (cotangente hyperbolique inverse).
acsc (x)
Alias :
Inverse de la fonction cosécante.
acsch (x)
Alias :
Inverse de la fonction cosécante hyperbolique.
asec (x)
Alias :
Inverse de la fonction sécante.
asech (x)
Alias :
Inverse de la fontion sécante hyperbolique.
asin (x)
Alias :
La fonction arcsin (sinus inverse).
asinh (x)
Alias :
Fonction arcsinh (sinus hyperbolique inverse).
atan (x)
Alias :
Calcule la fonction arctangente (tangente inverse).
Consultez
atanh (x)
Alias :
Fonction arctanh (tangente hyperbolique inverse).
atan2 (y, x)
Alias :
Calcule la fonction arctan2. Si
Consultez
cos (x)
Calcule la fonction cosinus.
Consultez
cosh (x)
Calcule la fonction cosinus hyperbolique.
Consultez
cot (x)
Fonction cotangente.
coth (x)
Fonction cotangente hyperbolique.
csc (x)
Fonction cosécante.
csch (x)
Fonction cosécante hyperbolique.
sec (x)
Fonction sécante.
sech (x)
Fonction sécante hyperbolique.
sin (x)
Calcule la fonction sinus.
sinh (x)
Calcule la fonction sinus hyperbolique.
tan (x)
Calcule la fonction tangente.
tanh (x)
Fonction tangente hyperbolique.
Théorie des nombres
AreRelativelyPrime (a,b)
Si les entiers
Consultez
BernoulliNumber (n)
Renvoie le
Consultez
ChineseRemainder (a,m)
Alias :
Recherche
Consultez
Consultez
CombineFactorizations (a,b)
Étant donné deux factorisations, donne la factorisation du produit.
Consultez
ConvertFromBase (v,b)
Convertit un vecteur de valeurs indiquant les puissances de b en un nombre.
ConvertToBase (n,b)
Convertit un nombre en un vecteur contenant les puissances des éléments dans la base
DiscreteLog (n,b,q)
Calcule le logarithme discret de
Consultez
Divides (m,n)
Vérifie la divisibilité (si
EulerPhi (n)
Calcule la fonction d'Euler phi, c'est-à-dire le nombre d'entiers compris entre 1 et
Consultez
ExactDivision (n,d)
Renvoie
Consultez
Factorize (n)
Renvoie la factorisation d'un nombre sous la forme d'une matrice. La première ligne contient les nombres premiers dans la factorisation (y compris 1) et la seconde ligne sont les puissances. Par exemple :
Consultez
Consultez
Factors (n)
for n=1 to 1000 do (
 if MatrixSum (Factors(n)) == 2*n then
 print(n)
)
Renvoie tous les facteurs de
Consultez
FermatFactorization (n,tentatives)
Essaie la factorisation de Fermat de
C'est une assez bonne factorisation si votre nombre est le produit de deux facteurs très proches l'un de l'autre.
Consultez
FindPrimitiveElementMod (q)
Cherche le premier élément primitif dans F
FindRandomPrimitiveElementMod (q)
Cherche un élément primitif au hasard dans F
IndexCalculus (n,b,q,S)
Calcule le logarithme discret de n base
IndexCalculusPrecalculation (b,q,S)
Lance l'étape de calcul préliminaire de
IsEven (n)
Teste si un entier est pair.
IsMersennePrimeExponent (p)
Teste si un nombre entier positif
Consultez
IsNthPower (m,n)
Vérifie si un nombre rationnel
IsOdd (n)
Teste si un entier est impair.
IsPerfectPower (n)
Vérifie qu'un entier est une puissance parfaite, a
IsPerfectSquare (n)
Vérifie qu'un entier est un carré parfait d'un entier. Le nombre doit être un vrai entier. Les entiers négatifs ne peuvent bien sûr jamais être des carrés de vrais entiers.
IsPrime (n)
Teste la primalité des entiers ; pour les nombres inférieurs à 2,5e10 la réponse est déterministe (si l'hypothèse de Riemann est vérifiée). Pour des nombres plus grands, la probabilité d'une erreur de détermination dépend du paramètre
Si
Consultez
IsPrimitiveMod (g,q)
Vérifie que
IsPrimitiveModWithPrimeFactors (g,q,f)
Vérifie que
IsPseudoprime (n,b)
Teste si
IsStrongPseudoprime (n,b)
Teste si
Consultez
Jacobi (a,b)
Alias :
Calcule le symbole de Jacobi (a/b) (b doit être impair).
JacobiKronecker (a,b)
Alias :
Calcule le symbole de Jacobi (a/b) avec l'extension de Kronecker (a/2)=(2/a) si impair, ou (a/2)=0 si pair.
LeastAbsoluteResidue (a,n)
Renvoie le résidu de
Legendre (a,p)
Alias :
Calcule le symbole de Legendre (a/p).
Consultez
LucasLehmer (p)
Teste si 2
Consultez
LucasNumber (n)
Renvoie le
Consultez
MaximalPrimePowerFactors (n)
Renvoie les puissances premières d'un nombre.
MersennePrimeExponents
Renvoie un vecteur de nombres premiers de Mersenne qui est une liste d'entiers positifs
MillerRabinTest (n,reps)
Utilise le test de primalité de Miller-Rabin sur
Consultez
MillerRabinTestSure (n)
Utilise le test de primalité de Miller-Rabin sur
ModInvert (n,m)
Renvoie l'inverse de n mod m.
Consultez
MoebiusMu (n)
Renvoie la fonction mu de Moebius évaluée dans
Consultez
NextPrime (n)
Renvoie le plus petit nombre premier supérieur à
La fonction utilise la fonction
PadicValuation (n,p)
Renvoie la valuation p-adic (nombre de zéros après la virgule en base
Consultez
PowerMod (a,b,m)
Calcule
Prime (n)
Alias :
Renvoie le
Consultez
PrimeFactors (n)
Renvoie tous les facteurs premiers d'un nombre sous la forme d'un vecteur.
Consultez
PseudoprimeTest (n,b)
Test de pseudoprimalité, renvoie
Consultez
Consultez
RemoveFactor (n,m)
Supprime toutes les instances du facteur
Consultez
SilverPohligHellmanWithFactorization (n,b,q,f)
Calcule le logarithme discret de
SqrtModPrime (n,p)
Cherche la racine carrée de
Consultez
StrongPseudoprimeTest (n,b)
Lance le test de pseudo-primarité forte en base
Consultez
gcd (a,params...)
Alias :
Plus grand commun diviseur d'entiers (PGCD, en anglais « Greatest Common Divisor »). Vous pouvez fournir autant d'entiers que vous voulez dans la liste d'arguments ou vous pouvez fournir un vecteur ou une matrice d'entiers. Si vous fournissez plus d'une matrice de la même taille alors le PGCD est recherché élément par élément.
Consultez
lcm (a,params...)
Alias :
Plus petit commun multiple d'entiers (PPCM, en anglais « Least Common Multiplier »). Vous pouvez fournir autant d'entiers que vous voulez dans la liste d'arguments ou vous pouvez fournir un vecteur ou une matrice d'entiers. Si vous fournissez plus d'une matrice de la même taille alors le PPCM est recherché élément par élément.
Consultez
Manipulation de matrices
ApplyOverMatrix (a,fonc)
Applique une fonction sur tous les éléments d'une matrice et renvoie une matrice de résultats.
ApplyOverMatrix2 (a,b,fonc)
Applique une fonction sur tous les éléments de 2 matrices (ou 1 valeur et 1 matrice) et renvoie une matrice de résultats.
ColumnsOf (M)
Extrait les colonnes de la matrice comme un vecteur horizontal.
ComplementSubmatrix (m,r,c)
Supprime certaines lignes et colonnes d'une matrice.
CompoundMatrix (k,A)
Calcule la k-ième matrice composée de A.
CountZeroColumns (M)
Compte le nombre de colonnes nulles d'une matrice. Par exemple, après avoir réduit une matrice suivant les colonnes, vous pouvez utiliser cette fonction pour obtenir la dimension du noyau. Consultez
DeleteColumn (M,col)
Supprime une colonne d'une matrice.
DeleteRow (M,row)
Supprime une ligne d'une matrice.
DiagonalOf (M)
Extrait la diagonale de la matrice comme un vecteur colonne.
Consultez
DotProduct (u,v)
Renvoie le produit scalaire de deux vecteurs. Les vecteurs doivent être de même taille. Aucune conjugaison n'est faite donc c'est une forme bilinéaire même dans le cas de nombres complexes.
Consultez
ExpandMatrix (M)
Développe une matrice exactement comme cela est fait lors de la saisie d'une matrice non précédée d'une apostrophe. Cela signifie que toute matrice interne est développée sous la forme de blocs. C'est une façon de construire des matrices à partir de matrices plus petites et c'est ce qui est effectué normalement de manière automatique lors d'une saisie à moins que la matrice ne soit précédée d'une apostrophe.
HermitianProduct (u,v)
Alias :
Renvoie le produit hermitienne de deux vecteurs. Les vecteurs doivent avoir la même taille. C'est une forme sesquilinéaire utilisant la matrice identité.
Consultez
I (n)
Alias :
Renvoie une matrice identité de la taille indiquée, soit une matrice de
Consultez
IndexComplement (vec,mtaille)
Renvoie le complémentaire d'un vecteur d'indices. Le premier indice est toujours 1. Par exemple pour le vecteur
IsDiagonal (M)
Indique si la matrice est diagonale.
Consultez
IsIdentity (x)
Vérifie qu'une matrice est la matrice identité. Renvoie automatiquement
IsLowerTriangular (M)
Indique si une matrice est triangulaire inférieure, c'est-à-dire que toutes les valeurs au dessus de la diagonale sont nulles.
IsMatrixInteger (M)
Vérifie si une matrice est constituée de nombres entiers (non complexe).
IsMatrixNonnegative (M)
Vérifie si une matrice est non négative, c'est-à-dire que chaque élément n'est pas négatif. Ne pas confondre les matrices positives avec les matrices définies positives.
Consultez
IsMatrixPositive (M)
Vérifie si une matrice est positive, c'est-à-dire que chaque élément est positif (et par conséquent réel), et en particulier qu'aucun élément n'est nul. Ne pas confondre les matrices positives avec les matrices définies positives
IsMatrixRational (M)
Vérifie si une matrice est constituée de nombres rationnels (non complexes).
IsMatrixReal (M)
Vérifie si une matrice est constituée de nombres réels (non complexes).
IsMatrixSquare (M)
Vérifie si une matrice est carrée, c'est-à-dire que sa largeur est égale à sa hauteur.
IsUpperTriangular (M)
Indique si une matrice est triangulaire supérieure, c'est-à-dire que toutes les valeurs en dessous de la diagonale sont nulles.
IsValueOnly (M)
Vérifie si une matrice est une matrice de nombres seulement. Beaucoup de fonctions internes contrôlent cela. Les valeurs peuvent être n'importe quels nombres y compris des complexes.
IsVector (v)
Si l'argument est un vecteur horizontal ou vertical. Genius ne fait pas de distinction entre une matrice et un vecteur, un vecteur est juste une matrice 1 par
IsZero (x)
Vérifie si une matrice est composée uniquement de zéros. Fonctionne également avec les nombres et dans ce cas, c'est équivalent à
LowerTriangular (M)
Renvoie une copie de la matrice
MakeDiagonal (v,param...)
Alias :
MakeVector (A)
Construit un vecteur colonne à partir d'une matrice en mettant les colonnes les unes au dessus des autres. Renvoie
MatrixProduct (A)
Calcule et renvoie le produit de tous les éléments d'une matrice ou d'un vecteur.
MatrixSum (A)
Calcule et renvoie la somme de tous les éléments d'une matrice ou d'un vecteur.
MatrixSumSquares (A)
Calcule la somme du carré de tous les éléments d'une matrice ou d'un vecteur.
CountZeroColumns (M)
Convertit un nombre en un vecteur contenant les puissances des éléments dans la base
elements (M)
Convertit un nombre en un vecteur contenant les puissances des éléments dans la base
OuterProduct (u,v)
Retourne le produit tensoriel de deux vecteurs, c'est-à-dire que si on suppose que
ReverseVector (v)
Inverse l'ordre des éléments d'un vecteur. Renvoie
RowSum (m)
Calcule la somme pour chaque ligne d'une matrice et renvoie un vecteur colonne contenant le résultat.
RowSumSquares (m)
Calcule la somme pour chaque ligne d'une matrice et renvoie un vecteur colonne contenant le résultat.
RowsOf (M)
Renvoie les lignes d'une matrice dans un vecteur vertical. Chaque élément du vecteur est un vecteur horizontal qui correspond à chaque ligne de
SetMatrixSize (M,lignes,colonnes)
Fabrique une nouvelle matrice de la taille spécifiée à partir de l'ancienne. C'est-à-dire crée une nouvelle matrice dans laquelle est recopiée l'ancienne. Les entrées qui ne rentrent pas sont retirées et l'espace supplémentaire est complété par des zéros. Si
ShuffleVector (v)
Mélange les éléments d'un vecteur. Renvoie
SortVector (v)
Trie les éléments d'un vecteur en ordre croissant.
StripZeroColumns (M)
Élimine toutes les colonnes entièrement nulles de
StripZeroRows (M)
Élimine toutes les lignes entièrement nulles de
Submatrix (m,r,c)
Renvoie certaines colonnes et lignes d'une matrice. C'est équivalent à
SwapRows (m,ligne1,ligne2)
Échange deux lignes dans une matrice.
UpperTriangular (M)
Renvoie une copie de la matrice
columns (M)
Renvoie le nombre de colonnes d'une matrice.
elements (M)
Renvoie le nombre total d'éléments d'une matrice. C'est le nombre de colonnes multiplié par le nombre de lignes.
ones (lignes,colonnes...)
Crée une matrice de 1 (ou un vecteur colonne si un seul argument est donné). Renvoie
rows (M)
Renvoie le nombre de lignes d'une matrice.
zeros (lignes,colonnes...)
Crée une matrice de 0 (ou un vecteur colonne si un seul argument est donné). Renvoie
AuxiliaryUnitMatrix (n)
Renvoie la matrice unitaire auxiliaire de taille
Consultez
BilinearForm (v,A,w)
Évalue (v,w) par rapport à la forme bilinéaire donnée par la matrice A.
BilinearFormFunction (A)
Renvoie une fonction qui évalue deux vecteurs par rapport à la forme bilinéaire donnée par A.
CharacteristicPolynomial (M)
Alias :
Renvoie le polynôme caractéristique d'un vecteur. C'est-à-dire renvoie les coefficients du polynôme en commençant par le terme constant. Ce polynôme est défini par
Consultez
CharacteristicPolynomialFunction (M)
Renvoie le polynôme caractéristique d'un vecteur sous la forme d'une fonction. Ce polynôme est défini par
(consultez
ColumnSpace (M)
Renvoie une matrice de base pour le sous-espace vectoriel d'une matrice. C'est-à-dire renvoie une matrice dont les colonnes forment une base pour le sous-espace vectoriel de
CommutationMatrix (m, n)
Renvoie la matrice de permutation K(m,n) qui est l'unique matrice m*n par m*n telle que K(m,n) * MakeVector(A) = MakeVector(A.') pour toutes matrices A de taille m par n.
CompanionMatrix (p)
Matrice compagnon d'un polynôme (comme vecteur).
ConjugateTranspose (M)
Transposée conjuguée d'une matrice (matrice adjointe). Identique à l'opérateur
Consultez
Convolution (a,b)
Alias :
Calcule la convolution de deux vecteurs horizontaux.
ConvolutionVector (a,b)
Calcule la convolution de deux vecteurs horizontaux. Renvoie le résultat sous la forme d'un vecteur dont les composants ne sont pas additionnées ensemble.
CrossProduct (v,w)
Produit vectoriel de deux vecteurs dans R
DeterminantalDivisorsInteger (M)
Renvoie les « determinantal divisors » d'une matrice d'entiers (et non pas son polynôme caractéristique).
DirectSum (M,N...)
Somme directe de matrices.
DirectSumMatrixVector (v)
Somme directe d'un vecteur de matrices.
Eigenvalues (M)
Alias :
Renvoie les valeurs propres d'une matrice carrée. Ne fonctionne actuellement que pour les matrices de taille inférieure ou égale à 4 par 4 ou pour les matrices triangulaires (pour lesquelles les valeurs propres sont sur la diagonale).
Consultez
Eigenvectors (M)
Eigenvectors (M, &valeurspropres)
Eigenvectors (M, &valeurpropres, &multiplicités)
Renvoie les vecteurs propres d'une matrice carrée. Il est possible en option d'obtenir les valeurs propres ainsi que leur multiplicité algébrique. Ne fonctionne actuellement que pour les matrices 2x2.
Consultez
GramSchmidt (v,B...)
Applique le procédé de Gram-Schmidt (aux colonnes) par rapport au produit scalaire donné par
Consultez
HankelMatrix (c,r)
Matrice de Hankel.
HilbertMatrix (n)
Matrice de Hilbert d'ordre
Consultez
Image (T)
Renvoie l'image (espace vectoriel engendré par les colonnes) d'une transformation linéaire.
InfNorm (v)
Renvoie la norme « infini », appelée aussi norme sup, ou encore norme de la convergence uniforme.
InvariantFactorsInteger (M)
Renvoie les facteurs invariants d'une matrice carrée (pas sa caractéristique).
InverseHilbertMatrix (n)
Matrice inverse de Hilbert d'ordre
IsHermitian (M)
Indique si une matrice est hermitienne. C'est-à-dire si elle est égale à sa transposée conjuguée.
Consultez
IsInSubspace (v,W)
Teste si un vecteur appartient à un sous-espace.
IsInvertible (n)
Indique si une matrice (ou un nombre) est inversible (une matrice entière est inversible si et seulement si elle est inversible sur les entiers).
IsInvertibleField (n)
Indique si une matrice (ou un nombre) est inversible sur un corps.
IsNormal (M)
Indique si
Consultez
IsPositiveDefinite (M)
Indique si
Notez que certains auteurs (par exemple Mathworld) n'exigent pas que
Consultez
IsPositiveSemidefinite (M)
Indique si
Notez que certains auteurs n'exigent pas que
Consultez
IsSkewHermitian (M)
Indique si une matrice est anti-hermitienne. C'est-à-dire si sa transposée conjuguée est égale à l'opposée de la matrice.
Consultez
IsUnitary (M)
Indique si une matrice est unitaire. C'est-à-dire si
Consultez
JordanBlock (n,lambda)
Alias :
Renvoie le bloc de Jordan correspondant à la valeur propre
Consultez
Kernel (T)
Renvoie le noyau d'une transformation linéaire.
(consultez
OuterProduct (u,v)
Alias :
Consultez
LUDecomposition (A, L, U)
Calcule la décomposition LU de
C'est la décomposition LU d'une matrice appelée aussi réduction de Crout ou de Cholesky (ISBN 0-201-11577-8 pp.99-103). La matrice triangulaire supérieure est composée d'une diagonale de 1. Ce n'est pas la méthode de Doolittle pour laquelle la diagonale de 1 est dans la matrice inférieure.
Toutes les matrices ne possèdent pas de décomposition LU, par exemple
Consultez
Minor (M,i,j)
Renvoie le mineur
Consultez
NonPivotColumns (M)
Renvoie les colonnes qui ne sont pas les colonnes pivot d'une matrice.
Norm (v,p...)
Alias :
Renvoie la norme-p d'un vecteur (ou norme-2 si p n'est pas fourni).
(consultez
NullSpace (T)
Renvoie le noyau d'une matrice. C'est-à-dire le noyau de l'application linéaire que la matrice représente sous la forme d'une matrice dont l'espace des colonnes est le noyau de
Consultez
(consultez
Nullity (M)
Alias :
Renvoie la dimension du noyau de la matrice
Consultez
OrthogonalComplement (M)
Renvoie le complément orthogonal de l'espace des colonnes.
PivotColumns (M)
Renvoie les numéros des colonnes pivot d'une matrice, c'est-à-dire quelles sont les colonnes d'une matrice réduite qui contiennent 1 en première position. Renvoie également dans quelles lignes se trouvent ces pivots.
Projection (v,W,B...)
Projection du vecteur
QRDecomposition (A, Q)
Calcule la décomposition QR d'une matrice carrée
Consultez
RayleighQuotient (A,x)
Renvoie le quotient de Rayleigh (aussi appelé le quotient ou rapport de Rayleigh-Ritz) d'une matrice et d'un vecteur.
Consultez
RayleighQuotientIteration (A,x,epsilon,maxiter,vecref)
Cherche les valeurs propres de
Consultez
Rank (M)
Alias :
Renvoie le rang d'une matrice.
Consultez
RosserMatrix ()
Matrice de Rosser, un problème classique de test de valeurs propres symétriques.
Rotation2D (angle)
Alias :
Renvoie la matrice correspondant à la rotation centrée sur l'origine dans R
Rotation3DX (angle)
Renvoie la matrice correspondant à la rotation centrée sur l'origine dans R
Rotation3DY (angle)
Renvoie la matrice correspondant à la rotation centrée sur l'origine dans R
Rotation3DZ (angle)
Renvoie la matrice correspondant à la rotation centrée sur l'origine dans R
(consultez
RowSpace (M)
Renvoie une matrice de base pour l'espace vectoriel engendré par les lignes d'une matrice.
SesquilinearForm (v,A,w)
Évalue (v, w) par rapport à la forme sesquilinéaire donnée par la matrice A.
SesquilinearFormFunction (A)
Renvoie une fonction qui évalue deux vecteurs par rapport à la forme sesquilinéaire donnée par A.
SmithNormalFormField (A)
Forme normale de Smith pour les corps (se terminera par des 1 sur la diagonale).
Consultez
SmithNormalFormInteger (M)
Forme normale de Smith pour les matrices entières carrées (pas sa caractéristique).
SolveLinearSystem (M,V,params...)
Résout le système linéaire Mx=V, renvoie V s'il y a une solution unique ou
ToeplitzMatrix (c, r...)
Renvoie la matrice de Toeplitz construite à partir de la première colonne c et (éventuellement) de la première ligne r. Si seule la colonne c est fournie alors elle est conjuguée et la version non conjuguée est utilisée pour la première ligne pour fournir une matrice hermitienne (si le premier élément est réel bien sûr).
Consultez
Trace (M)
Alias :
Calcule la trace d'une matrice, c'est-à-dire la somme des éléments diagonaux.
Consultez
Transpose (M)
Matrice transposée. C'est identique à l'opérateur
Consultez
VandermondeMatrix (v)
Alias :
Renvoie la matrice de Vandermonde.
Consultez
VectorAngle (v,w,B...)
L'angle entre deux vecteurs par rapport au produit scalaire donné par
VectorSpaceDirectSum (M,N)
Somme directe des espaces vectoriels M et N.
VectorSubspaceIntersection (M,N)
Intersection des sous-espaces donnés par M et N.
VectorSubspaceSum (M,N)
Somme des espaces vectoriels M et N, c'est-à-dire {w | w=m+n, m dans M, n dans N}.
adj (m)
Alias :
Renvoie la matrice adjointe d'une matrice.
cref (M)
Alias :
Calcule la forme échelonnée réduite en colonnes.
det (M)
Alias :
Renvoie le déterminant d'une matrice.
Consultez
ref (M)
Alias :
Renvoie la matrice échelonnée en lignes (row echelon) d'une matrice. C'est-à-dire effectue une élimination de Gauss de
Consultez
rref (M)
Alias :
Renvoie la matrice échelonnée réduite en lignes (reduced row echelon) d'une matrice. C'est-à-dire effectue une élimination de Gauss-Jordan de
Consultez
Combinatoire
Catalan (n)
Renvoie le
Consultez
Combinations (k,n)
Renvoie toutes les combinaisons de k nombres de 1 à n comme un vecteur de vecteurs (consultez aussi
Consultez
DoubleFactorial (n)
Double factorielle :
Consultez
Consultez
Factorial (n)
Factorielle :
Consultez
Consultez
FallingFactorial (n,k)
Factorielle décroissante :
Consultez
Fibonacci (x)
Alias :
Calcule le
Consultez
FrobeniusNumber (v,param...)
Calcule le nombre de Frobenius. C'est-à-dire calcule le plus petit nombre qui ne peut pas être obtenu comme une combinaison linéaire d'entiers non négatifs d'un vecteur donné d'entiers non négatifs. Le vecteur peut être fourni sous la forme de nombre séparés ou d'un seul vecteur. Tous les nombres fournis doivent avoir un PGCD de 1.
Consultez
GaloisMatrix (règle_de_combinaison)
Matrice de Galois étant donnée la règle de combinaison linéaire (a_1*x_+...+a_n*x_n=x_(n+1)).
FrobeniusNumber (n,v)
Trouve le vecteur
Consultez
HarmonicNumber (n,r)
Alias :
Nombre harmonique, le
Hofstadter (n)
Fonction de Hofstadter q(n) définie par q(1)=1, q(2)=1, q(n)=q(n-q(n-1))+q(n-q(n-2)).
LinearRecursiveSequence (valeurs_ensemencement,règle_de_combinaison,n)
Calcule la relation de récurrence linéaire en utilisant l'algorithme de Galois.
Multinomial (v,param...)
Calcule les coefficients multinomiaux. Prend un vecteur de
(a+b+c)! / (a!b!c!)
La formule pour
Consultez
NextCombination (v,n)
Calcule la combinaison qui apparaîtrait après v dans un appel à la fonction combinations, la première combinaison devrait être
Par exemple, avec la fonction Combinations, vous devriez normalement écrire une boucle du style :
Pascal (i)
Calcule le triangle de Pascal sous la forme d'une matrice. Cela renvoie une matrice
Consultez
Permutations (k,n)
Renvoie toutes les permutations de
Consultez
Consultez
RisingFactorial (n,k)
Alias :
Factorielle croissante (Pochhammer) : (n)_k = n(n+1)...(n+(k-1)).
Consultez
StirlingNumberFirst (n,m)
Alias :
Nombre de Stirling du premier type.
Consultez
StirlingNumberSecond (n,m)
Alias :
Nombre de Stirling du second type.
Consultez
Consultez
Subfactorial (n)
Sous-factorielle : n! multiplié par sum_{k=1}^n (-1)^k/k!.
Triangular (nième)
Calcule le
Consultez
nCr (n,r)
Alias :
Calcule le nombre de combinaisons, c'est-à-dire le coefficient binomial.
Consultez
nPr (n,r)
Calcule le nombre de permutations de taille
Analyse
CompositeSimpsonsRule (f,a,b,n)
Intégration de f par la méthode de Simpson composée sur l'intervalle [a,b] avec n sous-intervalles avec une erreur de l'ordre max(f'''')*h^4*(b-a)/180, notez que n doit être pair.
Consultez
CompositeSimpsonsRuleTolerance (f,a,b,FourthDerivativeBound,Tolerance)
Intégration de f par la méthode de Simpson composée sur l'intervalle [a,b] avec un nombre d'étapes calculé à l'aide de la borne de la dérivée quatrième et la tolérance souhaitée.
Derivative (f,x0)
Tente de calculer la dérivée en essayant d'abord une approche symbolique puis numérique.
EvenPeriodicExtension (f,L)
Renvoie une fonction qui est l'extension périodique paire de
Consultez aussi
FourierSeriesFunction (a,b,L)
Renvoie une fonction qui est la série de Fourier de coefficients donnés par les vecteurs
Consultez
InfiniteProduct (fonc,début,inc)
Essaie de calculer un produit infini pour une fonction à un seul argument.
InfiniteProduct2 (fonc,param,début,inc)
Essaie de calculer un produit infini pour une fonction à double arguments avec func(arg,n).
InfiniteSum (fonc,début,inc)
Essaie de calculer une somme infinie pour une fonction à un seul argument.
InfiniteSum2 (fonc,param,début,inc)
Essaie de calculer une somme infinie pour une fonction à double arguments avec func(arg,n).
IsContinuous (f,x0)
Essaie de voir si une fonction à valeur réelle est continue en x0 en calculant la limite en ce point.
IsDifferentiable (f,x0)
Teste de différentiabilité en approchant les limites gauche et droite et en les comparant.
LeftLimit (f,x0)
Calcule la limite gauche d'une fonction à valeurs réelles en x0.
Limit (f,x0)
Calcule la limite d'une fonction à valeur réelle en x0. Essaie de calculer les deux limites à gauche et à droite.
MidpointRule (f,a,b,n)
Intégration par la méthode des rectangles.
NumericalDerivative (f,x0)
Alias :
Essaie de calculer la dérivée par méthode numérique.
NumericalFourierSeriesCoefficients (f,L,N)
Renvoie un vecteur de vecteurs
NumericalFourierSeriesFunction (f,L,N)
Renvoie une fonction, qui est la série de Fourier de la fonction
NumericalFourierCosineSeriesCoefficients (f,L,N)
Renvoie un vecteur des coefficients de la série de Fourier en cosinus de
Consultez
NumericalFourierCosineSeriesFunction (f,L,N)
Renvoie une fonction qui est la série de Fourier en cosinus de
NumericalFourierSineSeriesCoefficients (f,L,N)
Renvoie un vecteur des coefficients de la série de Fourier en sinus de
Consultez
NumericalFourierSineSeriesFunction (f,L,N)
Renvoie une fonction qui est la série de Fourier en sinus de
NumericalIntegral (f,a,b)
Intégration de f entre a et b, en suivant la règle définie par
NumericalLeftDerivative (f,x0)
Essaie de calculer la dérivée à gauche par méthode numérique.
NumericalLimitAtInfinity (_f,step_fun,tolerance,successive_for_success,N)
Essaie de calculer la limite de f (step_fun(i)) lorsque i va de 1 à N.
NumericalRightDerivative (f,x0)
Essaie de calculer la dérivée à droite par méthode numérique.
OddPeriodicExtension (f,L)
Renvoie une fonction qui est l'extension périodique impaire de
Consultez aussi
OneSidedFivePointFormula (f,x0,h)
Calcule la dérivée d'un côté en utilisant une formule à cinq points.
OneSidedThreePointFormula (f,x0,h)
Calcule la dérivée d'un côté en utilisant une formule à trois points.
PeriodicExtension (f,a,b)
Renvoie une fonction qui est l'extension périodique de
Consultez également
RightLimit (f,x0)
Calcule la limite à droite d'une fonction à valeurs réelles en x0.
TwoSidedFivePointFormula (f,x0,h)
Calcule la dérivée des deux côtés en utilisant une formule à cinq points.
TwoSidedThreePointFormula (f,x0,h)
Calcule la dérivée des deux côtés en utilisant une formule à trois points.
Fonctions
Argument (z)
Alias :
Renvoie l'argument (angle) d'un nombre complexe.
sec (x)
La fonction Gamma. Seules les valeurs réelles sont actuellement implémentées.
Consultez
sec (x)
La fonction Gamma. Seules les valeurs réelles sont actuellement implémentées.
sec (x)
La fonction Gamma. Seules les valeurs réelles sont actuellement implémentées.
sec (x)
La fonction Gamma. Seules les valeurs réelles sont actuellement implémentées.
DirichletKernel (n,t)
Calcul le noyau de Dirichlet d'ordre n.
DiscreteDelta (v)
Renvoie 1 si et seulement si tous les éléments sont nuls.
Tolérance pour la fonction
ErrorFunction (x)
Alias :
Fonction erreur, 2/sqrt(pi) * int_0^x e^(-t^2) dt.
Consultez
FejerKernel (n,t)
Noyau Fejer d'ordre
Consultez
GammaFunction (x)
Alias :
La fonction Gamma. Seules les valeurs réelles sont actuellement implémentées.
Consultez
KroneckerDelta (v)
Renvoie 1 si et seulement si tous les éléments sont égaux.
LucasNumber (n)
Consultez
LucasNumber (n)
MinimizeFunction (fonc,x,incr)
Cherche la première valeur pour laquelle f(x)=0.
MoebiusDiskMapping (a,z)
Transformation de Möbius du disque vers lui-même en faisant correspondre a à 0.
Consultez
MoebiusMapping (z,z2,z3,z4)
Transformation de Möbius utilisant le rapport croisé en prenant z2, z3, z4 à 1, 0 et l'infini respectivement.
MoebiusMappingInftyToInfty (z,z2,z3)
Transformation de Möbius utilisant le rapport croisé en prenant l'infini à l'infini et z2, z3 à 1 et 0 respectivement.
MoebiusMappingInftyToOne (z,z3,z4)
Transformation de Möbius utilisant le rapport croisé en prenant l'infini à 1 et z3, z4 à 0 et l'infini respectivement.
MoebiusMappingInftyToZero (z,z2,z4)
Transformation de Möbius utilisant le rapport croisé en prenant l'infini à 0 et z2, z4 à 1 et l'infini respectivement.
PoissonKernel (r,sigma)
Le noyau de Poisson sur D(0,1) (non normalisé à 1, donc son intégrale vaut 2 pi).
PoissonKernelRadius (r,sigma)
Le noyau de Poisson sur D(0,R) (non normalisé à 1).
RiemannZeta (x)
Alias :
Fonction zeta de Riemann (seules les valeurs réelles sont actuellement implémentées).
Consultez
UnitStep (x)
La fonction échelon vaut 0 pour xlt;0, 1 sinon. C'est l'intégrale de la fonction delta de Dirac. Elle est aussi appelée fonction d'Heaviside.
Consultez
cis (x)
La fonction
deg2rad (x)
Convertit les degrés en radians.
rad2deg (x)
Convertit les radians en degrés.
sin (x)
Consultez
Résolution d'équations
CubicFormula (p)
Calcule les racines d'un polynôme cubique (de degré 3) en utilisant la formule cubique. Le polynôme doit être fourni sous la forme d'un vecteur de coefficients. Par exemple
Consultez
EulersMethod (f,x0,y0,x1,n)
Utilise la méthode classique d'Euler pour résoudre numériquement y'=f(x,y) avec les valeurs initiales
Les systèmes peuvent être résolus en ayant uniquement
Consultez
EulersMethodFull (f,x0,y0,x1,n)
Utilise la méthode classique d'Euler pour résoudre numériquement y'=f(x,y) avec les valeurs initiales
FindRootBisection (f,a,b,TOL,N)
Cherche la racine d'une fonction en utilisant la méthode de la fausse position.
FindRootFalsePosition (f,a,b,TOL,N)
Cherche la racine d'une fonction en utilisant la méthode de la fausse position.
FindRootMullersMethod (f,x1,x2,x3,TOL,N)
Cherche la racine d'une fonction en utilisant la méthode de Muller.
FindRootSecant (f,a,b,TOL,N)
Cherche la racine d'une fonction en utilisant la méthode de la fausse position.
NewtonsMethodPoly (poly,valeurinitiale,epsilon,maxn)
Consultez aussi
Exemples :
Consultez
NewtonsMethodPoly (poly,valeurinitiale,epsilon,maxn)
Consultez aussi
Exemples :
Consultez
PolynomialRoots (p)
Calcule les racines d'un polynôme (de degré 1 à 4) en utilisant une des formules adaptée à ce type de polynôme. Le polynôme doit être fourni sous la forme d'un vecteur de coefficients. Par exemple
La fonction appelle
QuadraticFormula (p)
Calcule les racines d'un polynôme quadratique (de degré 2) en utilisant la formule quadratique. Le polynôme doit être fourni sous la forme d'un vecteur de coefficients.
Consultez
QuarticFormula (p)
Calcule les racines d'un polynôme quartique (de degré 4) en utilisant la formule quartique. Le polynôme doit être fourni sous la forme d'un vecteur de coefficients.
Consultez
RungeKutta (f,x0,y0,x1,n)
Utilise la méthode classique non adaptative de Runge-Kutta du quatrième ordre pour résoudre numériquement y'=f(x,y) avec les valeurs initiales
Consultez
RungeKuttaFull (f,x0,y0,x1,n)
Utilise la méthode classique non adaptative de Runge-Kutta du quatrième ordre pour résoudre numériquement y'=f(x,y) avec les valeurs initiales
Statistiques
Average (m)
Alias :
Calcule la moyenne de toute une matrice.
Consultez
Tolérance pour la fonction
GaussDistribution (x,sigma)
Intégrale de la fonction de Gauss de 0 à
Consultez
GaussFunction (x,sigma)
Fonction distribution de Gauss normalisée (courbe normale).
Median (m)
Alias :
Calcule la médiane de toute une matrice.
Consultez
PopulationStandardDeviation (m)
Alias :
Calcule l'écart type de la population de toute une matrice.
RowAverage (m)
Alias :
Calcule la moyenne de chaque ligne d'une matrice.
RowMedian (m)
Calcule la médiane de chaque ligne d'une matrice et renvoie un vecteur colonne.
RowPopulationStandardDeviation (m)
Alias :
Calcule l'écart type de la population des lignes d'une matrice et renvoie un vecteur colonne.
RowStandardDeviation (m)
Alias :
Calcule l'écart type des lignes d'une matrice et renvoie un vecteur colonne.
StandardDeviation (m)
Alias :
Calcule l'écart type de toute une matrice.
Polynômes
AddPoly (p1,p2)
Ajoute deux polynômes (vecteurs).
DividePoly (p,q,amp;r)
Divise deux polynômes (en tant que vecteurs) en utilisant la division longue. Renvoie le quotient des deux polynômes. L'argument optionnel
Consultez
IsPoly (p)
Vérifie qu'un vecteur est utilisable en tant que polynôme.
MultiplyPoly (p1,p2)
Multiplie deux polynômes (comme vecteurs).
NewtonsMethodPoly (poly,valeurinitiale,epsilon,maxn)
Définit quand la sortie est tronquée. Consultez
Exemples :
Poly2ndDerivative (p)
Renvoie la dérivée seconde du polynôme (comme vecteur).
PolyDerivative (p)
Prend la dérivée du polynôme (comme vecteur).
PolyToFunction (p)
Fabrique une fonction à partir d'un polynôme (comme vecteur).
PolyToString (p,var...)
Fabrique une chaîne à partir d'un polynôme (comme vecteur).
SubtractPoly (p1,p2)
Soustrait deux polynômes (comme vecteur).
TrimPoly (p)
Tronque les zéros d'un polynôme (défini comme vecteur).
Théorie des ensembles
Intersection (X,Y)
Renvoie l'intersection, selon la théorie des ensembles, de X et Y (X et Y sont des vecteurs supposés être des ensembles).
IsIn (x,X)
Renvoie
IsSubset (X, Y)
Renvoie
MakeSet (X)
Renvoie un vecteur où chaque élément de X n'apparaît qu'une seule fois.
SetMinus (X,Y)
Renvoie la différence X-Y selon la théorie des ensembles (X et Y sont des vecteurs supposés être des ensembles).
Union (X,Y)
Renvoie l'union, selon la théorie des ensembles, de X et Y (X et Y sont des vecteurs supposés être des ensembles).
Algèbre linéaire
Divers
ASCIIToString (vec)
Convertit un vecteur de valeurs ASCII en chaîne.
AlphabetToString (vec,alphabet)
Convertit un vecteur d'indices en chaîne de caractères. Les indices correspondent à la position dans la chaîne
StringToASCII (chaîne)
Convertit une chaîne en vecteur de valeurs ASCII.
StringToAlphabet (chaîne,alphabet)
Convertit une
Calcul symbolique
SymbolicDerivative (f)
Essaie de dériver symboliquement la fonction f, où f est une fonction à une variable.
Exemples :
SymbolicDerivativeTry (f)
Essaie de dériver symboliquement la fonction f, où f est une fonction à une variable, renvoie
SymbolicNthDerivative (f,n)
Essaie de dériver symboliquement une fonction n fois (consultez
SymbolicNthDerivativeTry (f,n)
Essaie de dériver symboliquement une fonction n fois silencieusement et renvoie
SymbolicTaylorApproximationFunction (f,x0,n)
Essaie de construire la fonction approximation de Taylor autour de x0 au nième degré (consultez
Exemples :
LinePlot (fonc1,fonc2,fonc3,...)
LinePlot (fonc1,fonc2,fonc3,x1,x2,y1,y2)
LinePlot (fonc1,fonc2,fonc3,x1,x2,y1,y2)
LinePlot (fonc1,fonc2,fonc3,x1,x2,y1,y2)
LinePlot (fonc1,fonc2,fonc3,x1,x2,y1,y2)
Trace la courbe de une à dix fonctions cartésiennes. Les premiers arguments, jusqu'à dix au plus, sont les fonctions à tracer. Vous pouvez ensuite rajouter quatre paramètres
Le paramètre
Exemples :
LinePlotClear ()
Affiche la fenêtre d'affichage du tracé et efface les courbes déjà tracées.
LinePlotDrawLine (x1,y1,x2,y2,...)
LinePlotDrawLine (v,...)
Trace une ligne du point
Exemples :
LinePlotParametric (xfonc,yfonc,...)
LinePlotParametric (xfonc,yfonc,t1,t2,tinc)
LinePlotParametric (xfonc,yfonc,t1,t2,tinc,x1,x2,y1,y2)
LinePlotParametric (xfonc,yfonc,t1,t2,tinc,x1,x2,y1,y2)
LinePlotParametric (xfonc,yfonc,t1,t2,tinc)
Trace la courbe d'une fonction paramétrique. En premier viennent les fonctions de
Si les limites de la fenêtre de tracé ne sont pas indiquées alors les limites définies par
LinePlotCParametric (fonc,...)
LinePlotCParametric (fonc,t1,t2,tinc)
LinePlotCParametric (fonc,t1,t2,tinc,x1,x2,y1,y2)
Trace la courbe d'une fonction paramétrique à valeurs complexes. En premier vient la fonction qui renvoie
Si les limites de la fenêtre de tracé ne sont pas indiquées alors les limites définies par
SlopefieldClearSolutions ()
Efface les solutions tracées par la fonction
Efface les solutions tracées par la fonction
SlopefieldDrawSolution (x, y, dx)
Lorsqu'un tracé de champ de directions est actif, dessine une solution avec les conditions initiales spécifiées. La méthode standard de Runge-Kutta est utilisée avec l'incrément
SlopefieldPlot (fonc)
SlopefieldPlot (fonc,x1,x2,y1,y2)
Trace un champ de directions. La fonction
Exemples :
SurfacePlot (fonc)
SurfacePlot (fonc,x1,x2,y1,y2,z1,z2)
SurfacePlot (fonc,x1,x2,y1,y2,z1,z2)
SurfacePlot (func,[x1,x2,y1,y2,z1,z2])
SurfacePlot (func,[x1,x2,y1,y2,z1,z2])
Trace une surface, dont la fonction prend comme arguments deux nombres ou bien un nombre complexe. En premier vient la fonction puis en option les limites sous la forme
Exemples :
SurfacePlotData (data)
SurfacePlotData (data,label)
SurfacePlotData (data,x1,x2,y1,y2,z1,z2)
SurfacePlotData (data,label,x1,x2,y1,y2,z1,z2)
SurfacePlotData (data,[x1,x2,y1,y2,z1,z2])
SurfacePlotData (data,label,[x1,x2,y1,y2,z1,z2])
Exemples :
SurfacePlotDataGrid (data,[x1,x2,y1,y2])
SurfacePlotDataGrid (data,[x1,x2,y1,y2,z1,z2])
SurfacePlotDataGrid (data,[x1,x2,y1,y2],label)
SurfacePlotDataGrid (data,[x1,x2,y1,y2,z1,z2],label)
Exemples :
VectorfieldClearSolutions ()
Efface les solutions dessinées par la fonction
Efface les solutions dessinées par la fonction
VectorfieldDrawSolution (x, y, dt, tlong)
Lorsqu'un tracé de champ de vecteurs est actif, dessine une solution avec les conditions initiales spécifiées. La méthode standard de Runge-Kutta est utilisée avec l'incrément
VectorfieldPlot (foncx, foncy)
VectorfieldPlot (foncx, foncy, x1, x2, y1, y2)
Trace un champ de vecteurs à deux dimensions. La fonction
Vous pouvez spécifier, en option, les limites de la fenêtre de tracé sous la forme
Exemples :
Exemple de programmes en GEL
Voici une fonction qui calcule des factorielles :
Avec des indentations, cela devient :
C'est un portage direct de la fonction factorielle de la page de manuel de
function f(x) = prod k=1 to x do k
La façon, de loin la plus facile, de définir une fonction factorielle serait d'utiliser la boucle de produit de la manière suivante. Ce n'est pas seulement la plus courte et la plus rapide mais aussi probablement la version la plus lisible.
Voici un exemple plus conséquent qui redéfinit essentiellement la fonction interne
Pour configurer l'
Modifications des paramètres avec GEL
Beaucoup de paramètres dans Genius ne sont simplement que des variables globales qui peuvent être évaluées et auxquelles on peut attribuer des valeurs de la même manière que pour des variables normales. Consultez
MaxDigits = 12
Par exemple, vous pouvez paramétrer le nombre maximum de chiffres pour l'affichage d'un résultat à 12 en saisissant :
Sortie
Nombre maximum de chiffres à afficher
Le nombre maximum de chiffres dans un résultat (
Résultats en nombres flottants
Si les résultats doivent être toujours affichés sous la forme de nombres flottants (
Nombres flottants en notation scientifique
Si les nombres flottants doivent être affichés en notation scientifique (
Toujours afficher les expressions complètes
Si l'expression complète doit être affichée pour les valeurs renvoyées non numériques (plus longues qu'une ligne) (
Utiliser les fractions mixtes
Si les fractions doivent être affichées comme des fractions mixtes telles que « 1 1/3 » plutôt que « 4/3 ». (
Afficher 0.0 lorsqu'un nombre flottant est inférieur à 10^-x (0=ne jamais arrondir)
Comment arrondir la sortie. Mais seulement lorsque d'autres nombres autour sont grands. Consultez la documentation du paramètre
Arrondir les nombres uniquement si un autre nombre est plus grand que 10^-x
Quand arrondir la sortie. C'est configuré par le paramètre
Se souvenir des paramètres de sortie d'une session à l'autre
Si les réglages concernant la sortie dans le cadre
Si ce n'est pas coché, les réglages précédemment enregistrés ou ceux par défaut sont utilisés à chaque lancement de Genius. Notez que les paramètres sont enregistrés à la fin de la session donc si vous souhaitez modifier la valeur par défaut, cochez cette case, redémarrez Genius puis décochez-la à nouveau.
Afficher les erreurs dans une boîte de dialogue
Si coché, les erreurs s'affichent dans une boîte de dialogue séparée, sinon elles s'affichent dans la console.
Afficher les messages d'informations dans une boîte de dialogue
Si coché, les messages d'informations s'affichent dans une boîte de dialogue séparée, sinon elles s'affichent dans la console.
Nombre maximum d'erreurs à afficher
Le nombre maximum d'erreurs à afficher pour une évaluation (
En plus de ces préférences, il existe d'autres préférences qui ne peuvent être modifiées qu'en les paramétrant dans l'espace de la console. Pour celles qui peuvent affecter la sortie, consultez
IntegerOutputBase
La base utilisée pour afficher les entiers.
OutputStyle
Une chaîne, qui peut être
Précision
Précision des nombres en virgule flottante
La précision des nombres en virgule flottante en bits (
Se souvenir de la précision choisie d'une session à l'autre
Si le réglage de la précision doit être conservé pour la prochaine session. Si ce n'est pas coché, le paramétrage précédemment enregistré ou celui par défaut est utilisé à chaque lancement de Genius. Notez que les paramètres sont enregistrés à la fin de la session donc si vous souhaitez modifier la valeur par défaut, cochez cette case, redémarrez genius puis décochez-la à nouveau.
Terminal
Le terminal se réfère à la console dans la zone de travail.
Lignes d'historique
Nombre de lignes d'historique dans le terminal.
Police
La police à utiliser dans le terminal.
Noir sur blanc
Si vous utilisez du noir sur blanc dans le terminal.
Curseur clignotant
Si le curseur dans le terminal doit clignoter lorsque le terminal possède le focus. Cela peut être parfois ennuyant et génère du trafic inutile si vous utilisez Genius à distance.
Mémoire
Nombre maximum de nœuds à allouer
De manière interne, toutes les données sont placées dans des nœuds en mémoire. Ce paramètre fournit une limite sur le nombre maximum de nœuds à allouer pour les calculs. Cela évite le problème d'une saturation de mémoire si vous faites quelque chose par erreur qui utilise trop de mémoire, telle qu'un calcul récursif sans fin. Cela pourrait ralentir votre ordinateur et rendre difficile même l'interruption du programme.
Une fois que la limite est atteinte, l'
Régler la limite à zéro signifie qu'il n'y a aucune limite sur la quantité de mémoire utilisable par Genius.
À propos de l'
L'
Pour rapporter une anomalie ou émettre une suggestion concernant cette application ou ce manuel, envoyez un courriel à l'auteur ou à la liste de discussion (voir site Web).
Ce programme est distribué au titre des clauses de la Licence Publique Générale GNU (GPL), telle que publiée par la Free Software Foundation ; soit la version 2 de la licence, ou (à votre discrétion) une version ultérieure quelconque. Une copie de cette licence peut être trouvée à ce
Jiří Lebl a été partiellement soutenu pendant diverses parties du développement pour ce travail par la bourse DMS 0900885 de NSF et l'université de l'Illinois à Urbana-Champaign. Le logiciel a été utilisé à la fois pour l'éducation et la recherche.
Bruno Brouard <annoa\.b\@gmail\.com>, 2010-11
Luc Pionchon <pionchon\.luc\@gmail\.com>, 2011
Université de Wisconsin-Madison
load
cd
plugin
AskButtons
AskString
Compose
ComposePower
Evaluate
Identity
IntegerFromBoolean
IsBoolean
IsDefined
IsFunction
IsFunctionOrIdentifier
IsFunctionRef
IsMatrix
IsNull
IsString
IsValue
Parse
SetFunctionFlags
SetHelp
SetHelpAlias
chdir
display
error
print
printn
protect
ProtectAll
set
string
undefine
UndefineAll
unprotect
UserVariables
wait
ChopTolerance
ContinuousNumberOfTries
ContinuousSFS
ContinuousTolerance
DerivativeNumberOfTries
DerivativeSFS
DerivativeTolerance
ErrorFunctionTolerance
FloatPrecision
FullExpressions
GaussDistributionTolerance
IsPrimeMillerRabinReps
LinePlotDrawLegends
LinePlotDrawAxisLabels
LinePlotVariableNames
LinePlotWindow
MaxDigits
MaxErrors
MixedFractions
NumericalIntegralFunction
NumericalIntegralSteps
Nombre d'étapes à réaliser pour la fonction
OutputChopExponent
OutputChopWhenExponent
ResultsAsFloats
ScientificNotation
SlopefieldTicks
SumProductNumberOfTries
Nombre d'itérations à essayer pour les fonctions
SumProductSFS
SumProductTolerance
Tolérance pour les fonctions
SurfacePlotDrawLegends
SurfacePlotVariableNames
SurfacePlotWindow
VectorfieldNormalized
VectorfieldTicks
AbsoluteValue
Chop
ComplexConjugate
Denominator
FractionalPart
Im
IntegerQuotient
IsComplex
IsComplexRational
IsFloat
IsGaussInteger
IsInteger
IsNonNegativeInteger
IsPositiveInteger
IsRational
IsReal
Numerator
Re
Sign
ceil
exp
float
floor
ln
log
log10
log2
max
min
rand
randint
round
sqrt
trunc
acos
acosh
acot
acoth
acsc
acsch
asec
asech
asin
asinh
atan
atanh
atan2
cos
cosh
cot
coth
csc
csch
sec
sech
sin
sinh
tan
tanh
AreRelativelyPrime
BernoulliNumber
ChineseRemainder
CombineFactorizations
ConvertFromBase
ConvertToBase
DiscreteLog
Divides
EulerPhi
ExactDivision
Factorize
Factors
FermatFactorization
FindPrimitiveElementMod
FindRandomPrimitiveElementMod
IndexCalculus
IndexCalculusPrecalculation
IsEven
IsMersennePrimeExponent
IsNthPower
IsOdd
IsPerfectPower
IsPerfectSquare
IsPrime
IsPrimitiveMod
IsPrimitiveModWithPrimeFactors
IsPseudoprime
IsStrongPseudoprime
Jacobi
JacobiKronecker
LeastAbsoluteResidue
Legendre
LucasLehmer
LucasNumber
MaximalPrimePowerFactors
MillerRabinTest
MillerRabinTestSure
ModInvert
MoebiusMu
NextPrime
PadicValuation
PowerMod
Prime
PrimeFactors
PseudoprimeTest
RemoveFactor
SilverPohligHellmanWithFactorization
SqrtModPrime
StrongPseudoprimeTest
gcd
lcm
ApplyOverMatrix
ApplyOverMatrix2
ColumnsOf
ComplementSubmatrix
CompoundMatrix
CountZeroColumns
DeleteColumn
DeleteRow
DiagonalOf
DotProduct
ExpandMatrix
HermitianProduct
I
IndexComplement
IsDiagonal
IsIdentity
IsLowerTriangular
IsMatrixInteger
IsMatrixNonnegative
IsMatrixPositive
IsMatrixRational
IsMatrixReal
IsMatrixSquare
IsUpperTriangular
IsValueOnly
IsVector
IsZero
LowerTriangular
MakeDiagonal
MakeVector
MatrixProduct
MatrixSum
MatrixSumSquares
OuterProduct
ReverseVector
RowSum
RowSumSquares
RowsOf
SetMatrixSize
ShuffleVector
SortVector
StripZeroColumns
StripZeroRows
Submatrix
SwapRows
UpperTriangular
columns
elements
ones
rows
zeros
AuxiliaryUnitMatrix
BilinearForm
BilinearFormFunction
CharacteristicPolynomial
CharacteristicPolynomialFunction
ColumnSpace
CommutationMatrix
CompanionMatrix
ConjugateTranspose
Convolution
ConvolutionVector
CrossProduct
DeterminantalDivisorsInteger
DirectSum
DirectSumMatrixVector
Eigenvalues
Eigenvectors
GramSchmidt
HankelMatrix
HilbertMatrix
Image
InfNorm
InvariantFactorsInteger
InverseHilbertMatrix
IsHermitian
IsInSubspace
IsInvertible
IsInvertibleField
IsNormal
IsPositiveDefinite
IsPositiveSemidefinite
IsSkewHermitian
IsUnitary
JordanBlock
Kernel
LUDecomposition
Consultez
Minor
NonPivotColumns
Norm
NullSpace
Nullity
OrthogonalComplement
PivotColumns
Projection
QRDecomposition
Consultez
RayleighQuotient
RayleighQuotientIteration
Rank
RosserMatrix
Rotation2D
Rotation3DX
Rotation3DY
Rotation3DZ
RowSpace
SesquilinearForm
SesquilinearFormFunction
SmithNormalFormField
SmithNormalFormInteger
SolveLinearSystem
ToeplitzMatrix
Consultez
Trace
Consultez
Transpose
Consultez
VandermondeMatrix
VectorAngle
VectorSpaceDirectSum
VectorSubspaceIntersection
VectorSubspaceSum
adj
cref
det
ref
rref
Catalan
Combinaisons
DoubleFactorial
Factorial
FallingFactorial
Fibonacci
FrobeniusNumber
GaloisMatrix
GreedyAlgorithm
HarmonicNumber
Hofstadter
LinearRecursiveSequence
Multinomial
NextCombination
Pascal
Permutations
RisingFactorial
StirlingNumberFirst
StirlingNumberSecond
Subfactorial
Triangular
nCr
nPr
CompositeSimpsonsRule
CompositeSimpsonsRuleTolerance
Derivative
EvenPeriodicExtension
FourierSeriesFunction
InfiniteProduct
InfiniteProduct2
InfiniteSum
InfiniteSum2
IsContinuous
IsDifferentiable
LeftLimit
Limit
MidpointRule
NumericalDerivative
NumericalFourierSeriesCoefficients
NumericalFourierSeriesFunction
NumericalFourierCosineSeriesCoefficients
NumericalFourierCosineSeriesFunction
NumericalFourierSineSeriesCoefficients
NumericalFourierSineSeriesFunction
NumericalIntegral
NumericalLeftDerivative
NumericalLimitAtInfinity
NumericalRightDerivative
OddPeriodicExtension
OneSidedFivePointFormula
OneSidedThreePointFormula
PeriodicExtension
RightLimit
TwoSidedFivePointFormula
TwoSidedThreePointFormula
Argument
DirichletKernel
DiscreteDelta
ErrorFunction
FejerKernel
GammaFunction
Consultez
KroneckerDelta
MinimizeFunction
MoebiusDiskMapping
MoebiusMapping
MoebiusMappingInftyToInfty
MoebiusMappingInftyToOne
MoebiusMappingInftyToZero
PoissonKernel
PoissonKernelRadius
RiemannZeta
Consultez
UnitStep
cis
deg2rad
rad2deg
CubicFormula
EulersMethod
EulersMethodFull
FindRootBisection
Cherche la racine d'une fonction en utilisant la méthode de dichotomie.
FindRootFalsePosition
FindRootMullersMethod
FindRootSecant
Cherche la racine d'une fonction en utilisant la méthode de la sécante.
PolynomialRoots
QuadraticFormula
QuarticFormula
RungeKutta
RungeKuttaFull
Average
GaussDistribution
GaussFunction
Median
PopulationStandardDeviation
RowAverage
RowMedian
RowPopulationStandardDeviation
RowStandardDeviation
StandardDeviation
AddPoly
DividePoly
IsPoly
MultiplyPoly
NewtonsMethodPoly
Utilise la méthode de Newton sur un polynôme pour essayer de trouver une racine, s'arrête après deux valeurs successives égales, à epsilon près, ou après maxn essais (renvoie alors
Poly2ndDerivative
PolyDerivative
PolyToFunction
PolyToString
SubtractPoly
TrimPoly
Intersection
IsIn
IsSubset
MakeSet
SetMinus
Union
ASCIIToString
AlphabetToString
StringToASCII
StringToAlphabet
SymbolicDerivative
SymbolicDerivativeTry
SymbolicNthDerivative
SymbolicNthDerivativeTry
SymbolicTaylorApproximationFunction
LinePlot
LinePlotClear
LinePlotDrawLine
Des paramètres supplémentaires peuvent être ajoutés pour spécifier la couleur de la ligne, des flèches et la zone de tracé. Vous pouvez faire cela en ajoutant une chaîne
LinePlotParametric
LinePlotCParametric
SlopefieldClearSolutions
SlopefieldDrawSolution
SlopefieldPlot
SurfacePlot
SurfacePlotData
SurfacePlotDataGrid
VectorfieldClearSolutions
VectorfieldDrawSolution
VectorfieldPlot
@@image: 'figures/genius_window.eps'; md5=b2fe72c0dea70343a11a7bbc2225f985
@@image: 'figures/line_plot.eps'; md5=1977b7181c5d8ecb7d4348e1de79919b
@@image: 'figures/line_plot_graph.eps'; md5=201bfa54ba0797171d8910eb946354c1
@@image: 'figures/parametric.eps'; md5=52274a10d3e58dc8f883fdf3a48d5ad3
@@image: 'figures/parametric_graph.eps'; md5=223659107c58320edd6030193c89524c
@@image: 'figures/surface_graph.eps'; md5=b505c811ddf51b109722ccc53f176dd2
Juillet 2011
Division.
Division élément par élément.
Opérateur égalité (renvoie
Et logique (and).
Ou logique (or).
Ou exclusif logique (xor).
Non logique (not).
Opérateur négation.
Référencement de variable (pour transmettre une référence à quelque chose). Consultez
Matrice transposée conjuguée.
Matrice transposée, ne conjugue pas les entrées.
Renvoie le plus petit entier supérieur ou égal à n.
Construit une matrice diagonale à partir d'un vecteur.
Calcule la somme des carrés pour chaque ligne d'une matrice.