# language_name_wals:	Spanish
# language_name_glotto:	Spanish
# iso639_3:	spa
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/es.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

La potencia de HTML5 y la web en su aplicación
WebKit
WebKit es un potente motor HTML multiplataforma usado en software libre y en productos comerciales. WebKitGTK+ es una versión de WebKit construida en
WebKitGTK+ hace que sea fácil añadir funcionalidad web a su aplicación, o usar HTML5 y tecnologías asociadas para crear interfaces de usuario dinámicas rápidamente.
Tutorial de demostración de WebKitGTK+
Manual de referencia de WebKitGTK+
La página web de WebKitGTK+
Servicio de comunicación en tiempo real unificado e integrado
Telepathy
Telepathy proporciona un entorno de trabajo potente para interactuar con los contactos de mensajería instantánea del usuario. con Telepathy, todas las cuentas y las conexiones se manejan con un servicio de sesión de D-Bus, que está plenamente integrado con el escritorio GNOME. Las aplicaciones se puede conectar a este servicio para comunicarse con los contactos.
Con la API de «Telepathy Tubes» puede incluso usar un túnel para un protocolo arbitrario sobre los protocolos modernos de mensajería instantánea como Jabber para crear aplicaciones interactivas. Cree juegos multi-jugador o editores colaborativos que se integren con los servicios de mensajería instantánea del escritorio.
Manual del desarrollador de Telepathy
La página web de Telepathy
Disposición de texto completamente internacionalizado y renderizado
Pango
Pango es la biblioteca principal de gestión de texto y tipografías en la plataforma GNOME. Es responsable de mostrar y renderizar texto y se usa a través de GTK+.
El motor de dibujo Pango se puede usar con diferentes backends de tipografías y dibujado. En la mayoría de sistemas GNOME, Pango usará FreeType, fontconfig y Cairo para acceder a las tipografías y renderizar texto. En otros sistemas, Pango usará la tipografía nativa de los sistemas, tales como Uniscribe en Microsoft Windows y ATSUI en MacOs.
Pango tiene un soporte extensivo para los variados sistemas de escritura usados en todo el mundo. Muchos de los sistemas de escritura usados en los idiomas tienen complejas reglas de dibujado de glifos y composición de caracteres. Con Pango, casi todos los idomas pueden escribirse y mostrarse correctamente, permitiendo a los usuarios en cualquier parte ver texto en sus idiomas maternos. El soporte de Pango para múltiples sistemas de escritura es automático; los desarrolladores de aplicaciones no tienen que escribir ningún código especial para soportar otros idiomas.
Pango soporta el estilo de texto usado en los típicos documentos e interfaces, incluyendo cursivas, tamaños de tipografía y subrayado. Pango usa un vocabulario simple parecido a XML llamado PangoMarkup que le permite establecer el tamaño de la tipografía, el color, los estilos y otros atributos del texto. Al usar PangoMarkup podrá especificar estilos en línea sin tener que iterar manualmente con los bloques de texto. Se puede usar PangoMarkup desde GTK+ directamente, permitiéndole dar estilo a textos en sus interfaces gráficas fácilmente.
Debería usar directamente Pango cuando necesite mostrar texto en la pantalla o en un medio diferente. Usar Pango permitirá a la disposición de su texto trabajar de forma parecida con GTK+ y el resto de la plataforma GNOME. le ayudará a crear código portable y, lo más importable, le asegurará que su aplicación pueda renderizar texto correctamente en cientos de idiomas diferentes.
Manual de referencia de Pango
La página web de Pango
Notificaciones activas en la bandeja de mensajes
Notificaciones
La biblioteca «libnotify» proporciona una API adecuada para presentar notificaciones al usuario. Las notificaciones puede ser simplemente un mensaje o pueden permitir que el usuario responda. Las notificaciones hechas con «libnotify» usarán la interfaz apropiada en el entorno en que se esté ejecutando la aplicación. En GNOME 3, las notificaciones se muestran en la parte inferior de la pantalla y se colocan en la bandeja de mensajes.
Manual de referencia de Libnotify
Almacenamiento seguro para contraseñas y otros datos
Depósito de claves
GNOME proporciona un gestor del depósito de claves moderno y seguro para almacenar las contraseñas y otros datos sensibles del usuario. Las aplicaciones pueden usar la biblioteca del gestor del depósito de claves para almacenar y acceder a las contraseñas, mientras que los usuarios pueden gestionar sus contraseñas usando la aplicación
El gestor del depósito de claves proporciona cualquier número de depósitos donde cada depósito puede contener cualquier número de elementos. Los elementos en un depósito almacenan una información, generalmente una contraseña. Cada depósito está bloqueado individualmente y los usuarios deben proporcionar una clave para desbloquear el depósito. Una vez que el depósito está desbloqueado, el usuario tiene acceso a todos los elementos de ese depósito.
El gestor del depósito de claves proporciona una lista de control para cada elemento del depósito, controlando a qué aplicaciones se permite el acceso a ese elemento. Si una aplicación desconocida trata de acceder a un elemento del depósito, el gestor del depósito preguntará al usuario si quiere permitir o denegar el acceso de esa aplicación. Esto ayuda a prevenir que programas maliciosos o pobremente escritos accedan a información sensible del usuario.
Los datos del depósito de claves almacenados en el sistema de archivos están cifrados con el cifrado de bloques AES, mientras que el SHA1 se usa para el «hash» de los atributos del elemento. Usando atributos «hash», el gestor del depósito de claves es capaz de mirar elementos que piden las aplicaciones sin necesidad de desbloquear el depósito. El depósito se desbloquea cuando se encuentra un elemento coincidente y se accede a él.
El gestor del depósito de claves también proporciona un depósito de claves para la sesión. Los elementos en el depósito de la sesión nunca se almacenan en el disco y se pierden cuando termina la sesión del usuario. El depósito de la sesión se puede usar para almacenar contraseñas que sólo van a usarse en la sesión actual.
Si usa GIO para acceder a servidores remotos, automáticamente obtiene los beneficios del gestor del depósito de claves. Siempre que GVFS necesite autenticar al usuario, proporciona la opción para almacenar la contraseña, ya sea en el depósito de claves predeterminado o en el depósito de claves de la sesión.
Debería usar el gestor del depósito de claves siempre que su aplicación necesite almacenar contraseñas u otros datos sensibles de los usuarios. Al usar el gestor del depósito de claves se proporciona una mejor experiencia al usuario a la vez que se mantienen seguros los datos del mismo.
Manual de referencia de gnome-keyring
Manual de referencia de libseahorse
Resumen de las potentes tecnologías dentro de la plataforma GNOME.
Shaun McCance
shaunm@gnome.org
Germán Póo-Caamaño
gpoo@gnome.org
Fundación GNOME
http://foundation.gnome.org/
GNOME
Resumen de la plataforma GNOME
GNOME es un poderoso pero simple ambiente de escritorio con un fuerte enfoque en usabilidad, accesibilidad, e internacionalización. GNOME esta diseñado para ser usable por todos, sin importar su pericia técnica, discapacidades, o lenguaje nativo. GNOME hace sencillo el uso de las computadoras para la gente.
La plataforma GNOME proporciona un entorno comprensible para el desarrollo de aplicaciones gráficas y otro software. GNOME proporciona una plataforma de desarrollo comprensible que permite a los desarrolladores crear software profesional fácil de usar y agradable estéticamente. Usando las tecnologías de GNOME puede crear software de alta calidad y para satisfacer las expectativas de sus usuarios. Este documento proporciona una visión general de alto nivel de la plataforma GNOME, con enlaces a documentación detallada de cada parte de la plataforma.
Gráficos y multimedia
Soporte al núcleo de la aplicación
Tecnologías de la aplicación
Bajo la cubierta
Sistema de ayuda orientado a temas
Ayuda
A veces, los usuarios necesitan un poco de ayuda, incluso con las aplicaciones mejor diseñadas. GNOME proporciona un sistema de ayuda orientada a temas integrado que usa el lenguaje de marcado
Cunando no necesita manuales lineales, GNOME también soporta el formato estándar industrial
El tour de un minuto para Mallard
La página web de Mallard
La página web de DocBook
Un marco de trabajo UPnP fácil de usar, eficiente y flexible
GUPnP
GUPnP es un marco de trabajo orientado a objetos de código abierto para crear dispositivos y puntos de control UPnP, escrito en C usando GObject y libsoup. La API de GUPnP está pensada para ser fácil de usar, eficiente y flexible.
El marco de trabajo GUPnP consta de los siguientes componentes/paquetes:
GSSDP: la biblioteca de bajo nivel que implementa el descubrimiento de recursos y el anuncio en la red mediante el protocolo SSDP.
GUPnP: el núcleo de la biblioteca que implementa la especificación UPnP: anuncio de recursos y descubrimiento, descripción, control, notificación de eventos y presentación (GUPnP incluye funcionalidad de servidor muy básica mediante libsoup). GUPnP no incluye auxiliares para construcción o control de recursos estandarizados específicos (ej. servidor multimedia): esto se deja para bibliotecas de nivel superior que usen el marco de trabajo GUPnP.
GUPnP A/V: una pequeña biblioteca que pretende simplificar el manejo y la implementación de perfiles UPnP A/V.
GUPnP DLNA: una pequeña biblioteca que pretende simplificar las tareas relacionadas con DLNA tales como adivinar el perfil de un medio, transcodificar a un perfil dado, etc.
GUPnP IGD: una biblioteca para manejar mapeos de puertos de dispositivos UPnP de puerta de enlace de Internet.
GUPnP Vala: bindings de Vala para las bibliotecas de GUPnP.
Herramientas de GUPnP: alternativa libre a las herramientas UPnP de Intel, que usan GUPnP. Proporcionan herramientas para el cliente y el servidor que permiten probar y depurar fácilmente dispositivos UPnP y puntos de control:
Universal Control Point: una herramienta que permite descubrir dispositivos y servicios UPnP, obtener información sobre ellos, suscribirse a eventos e invocar acciones.
Network Light: una bombilla virtual que controla puntos de control para encenderlos o apagarlos, cambiar su nivel de regulación y consultar su estado actual. También proporciona una sencilla IU para controlar todas las luces de red disponibles en la red.
AV Control Point: una sencilla IU de reproductor multimedia que permite descubrir y reproducir contenido multimedia disponible en una red. Es, estrictamente, un punto de control y, por lo tanto, no tiene capacidades de reproducción por sí mismo, así que se apoya en dispositivos de renderizado multimedia UPnP para reproducir.
Upload: una sencilla utilidad de línea de comandos que sube archivos a servidores multimedia conocidos, Use «Universal Control Point» para descubrir los servidores multimedia.
El marco de trabajo GUPnP nació de la frustración con libupnp y su lío de hilos. GUPnP es totalmente mono-hilo (aunque asíncrono), se integra con el bucle principal de GLib y proporciona el mismo conjunto de características que libupnp al tiempo que oculta la mayor parte de la implementación de UPnP mediante una elegante diseño orientado a objetos.
GUPnP es software libre. Todas las bibliotecas se publican bajo la licencia LGPL de GNU, y las herramientas de GUPnP se publican bajo la licencia GPL de GNU.
Debe usar GUPnP siempre que quiera que su código se comunique con dispositivos UPnP o DLNA. Por ejemplo, estos dispositivos se incluyen la Playstation 3 y los modelos de televisor Bravia de Sony, televisores y teléfonos Samsung, XBox de Microsoft, routers modernos, etc. La lista de dispositivos es enorme y sigue creciendo.
Aparte de tratar con los dispositivos UPnP, GUPnP se puede usar para crear fácilmente soluciones personalizadas de red doméstica en dispositivos/servicios capaces de descubrir e interactuar unos con otros sin ningún tipo de configuración por parte del usuario.
Para más información acerca de GUPnP, visite la
Kit de herramientas con muchas características para crear interfaces gráficas de usuario
GTK+
GTK+ es la principal biblioteca usada para construir interfaces de usuario en GNOME. Proporciona todos los controles de interfaz de usuario, o widgets, usados en una aplicación gráfica común. Es una API moderna, orientada a objetos que permite construir interfaces de usuario atractivas y sofisticadas sin tratar con los detalles de bajo nivel como el pintado o la interacción con el dispositivo.
Además de los widgets básicos, como botones, casillas, y entradas de texto, GTK+ también proporciona potentes API según el modelo Vista-Controlador (MVC) para vistas de árbol, campos de texto multilínea, y acciones de menú y barra de herramientas.
Los widgets en GTK+ se emplazan en las ventanas usando un modelo de paquetes de cajas. Los programadores sólo especifican cómo empaquetar los widgets juntos en cajas contenedoras, en lugar de su posición en coordenadas absolutas. GTK+ se asegura de que las ventanas se dimensionan correctamente para ajustarse a su contenido y maneja automáticamente las redimensiones de ventanas.
Debido a que GTK+ ofrece una API flexible, desarrollar widgets adicionales para su uso en aplicaciones GTK+ es sencillo. Existen cierto número de bibliotecas de terceras partes que proporcionan widgets adicionales y muchos desarrolladores han creado widgets personalizados para propósitos especiales en sus aplicaciones.
GTK+ maneja los detalles difíciles de los interfaces de usuario e interacción del usuario y proporciona una API simple y potente que le permite centrarse en los detalles de su aplicación. Las aplicaciones desarrolladas con GTK+ se adaptarán inmediatamente al los ajustes del tema y tipografía del usuario, interactuarán debidamente con las tecnologías de asistencia y se comportarán como el usuario espera que se comporten.
Tutorial de demostración de GTK+
Manual de referencia de GTK+
La página web de GTK+
Reproducir, crear y manipular sonidos, vídeos y otros medios
GStreamer
GStreamer es una biblioteca multimedia muy potente para reproducir, crear y manipular sonido, vídeo y otros tipos de media. Puede usar GStreamer para proporcionar reproducción de sonido y vídeo, grabar una entrada de múltiples fuentes y editar contenido multimedia. GStreamer soporta de forma predeterminada codificación y decodificación en numerosos formatos, además puede soportar formatos adicionales a través de complementos.
GStreamer proporciona una arquitectura flexible en la que se procesa el contenido multimedia a través de una «pipeline» de elementos. Cada elemento puede aplicar filtros al contenido, tales como codificación o decodificación, combinar múltiples fuentes o transformar el contenido multimedia. Esta arquitectura se permite para un grupo arbitrario de elementos, de tal forma que virtualmente pueda llevar a cabo cualquier efecto al usar GStreamer. Además, GStreamer está diseñado para no requerir exceso computacional, de tal forma que puede usarse en aplicaciones con altas latencias.
A la vez que GStreamer proporciona una potente API para manipular contenido multimedia, también proporciona rutinas convenientes para una simple reproducción. GStreamer puede construir automáticamente una «pipeline» para leer y reproducir archivos en cualquiera de los formatos soportados, permitiéndole usar fácilmente sonido y vídeo en su aplicación.
La arquitectura de GStreamer permite que los complementos añadan codificadores, decodificadores y todo tipo de filtro de contenidos. Los desarrolladores de terceras partes pueden proporcionar complementos para GStreamer que estarán disponibles automáticamente para todas las aplicaciones que usen GStreamer. Los complementos pueden proporcionar soporte para otros formatos multimedia o proporcionar funcionalidades y efectos adicionales.
Debería usar GStreamer siempre que necesite leer o reproducir contenido multimedia en su aplicación, o si su aplicación necesita manipular sonido o vídeo. Usar GStreamer hará más sencillo el desarrollo de su aplicación y proporcionará elementos fiables para muchas de sus necesidades.
El manual del desarrollador de aplicaciones de GStreamer
El manual de referencia del núcleo de GStreamer 0.10
La página de documentación de GStreamer
La página web de GStreamer
Archivo asíncrono y manejo de URI con acceso al archivo y a la información del volumen
Archivos GIO
GIO proporciona varias API para leer y escribir archivos y otros flujos de manera asíncrona. Los archivos se referencian con URI, y los «backend» locales pueden proporcionar acceso a más cosas que sólo a archivos locales. Cuando se ejecuta bajo el escritorio GNOME, GIO usa GVFS para permitir el acceso a archivos sobre SFTP, FTP, WebDAV, SMB y otros protocolos populares. Este acceso transparente a archivos en red es libre para todas las aplicaciones que usan GIO.
Las API de archivo de GIO se diseñaron para usarse en interfaces gráficas controladas por eventos. El diseño asíncrono, no bloqueante, significa que su interfaz de usuario no se bloquea esperando un archivo. También hay disponibles algunas versiones síncronas de las API, que a veces son más convenientes para trabajar con hilos o con procesos.
GIO también proporciona rutinas para gestionar dispositivos y volúmenes, consultar tipos de archivos e iconos y encontrar aplicaciones para abrir archivos.
Manual de referencia de GIO
API de red potente construida sobre las clases de flujo de GIO
Redes GIO
Construida en la parte superior del flujo de API usadas por archivos, GIO proporciona API de red de alto nivel para comunicarse sobre sockets de dominio TCP/IP y UNIX. Puede usar la API de red GIO para conectarse a un servidor, detectar eventos, y leer los recursos. El diseño asíncrono de la API significa que su aplicación no se bloquea esperando una respuesta.
Soporte de red de bajo nivel
Funcionalidad de red de alto nivel
Ventanas subyacentes y manejo de eventos
GDK
GDK es la biblioteca de bajo nivel que usa GTK+ para interactuar con el sistema para los dispositivos gráficos y de entrada. Aunque rara vez usará GDK directamente en el código de la aplicación, contiene toda la funcionalidad necesaria para dibujar objetos y texto en la pantalla e interactuar con el usuario con varios dispositivos de entrada.
GDK le permite acceder a eventos del teclado, ratones y otros dispositivos de entrada, en lugar de conectarse con las señales de alto nivel que se usan en GTK+. GDK también proporciona rutinas de bajo nivel para acceder a los datos de arrastrar y soltar y del portapapeles del sistema. Cuando implemente controles personalizados, quizá deba acceder a estas características para implementar un comportamiento adecuado de la interacción con el usuario.
GDK proporciona otra funcionalidad necesaria para implementar un toolkit gráfico completo como GTK+. Ya que GDK actúa como una plataforma de abstracción, permitiendo que GTK+ se ejecute en múltiples entornos, proporciona una API para todas las funcionalidades del sistema que necesita GTK+. Esto incluye información acerca configuraciones multimonitor, resolución y profundidad de color, mapas de colores y cursores.
Debería usar GDK siempre que necesite acceso de bajo nivel al sistema de ventanas, incluyendo acceso a bajo nivel para eventos, ventanas y al portapapeles. Usar GDK para estas tareas asegura que su código es portable y se integra con el resto de su código GTK+. Generalmente no deberían usarse las rutinas de dibujado simple en GDK. En su lugar, debería usar la extensa funcionalidad que proporciona Cairo.
Manual de referencia de GDK
Acceso común a bases de datos relacionales
GDA
GDA ofrece un envoltorio sobre base bases de datos relacionales, permitiéndole almacenar y recuperar fácilmente datos de diferentes sistemas de bases de datos comunes.
Manual de acceso a datos de GNOME
Integración con la libreta de direcciones del escritorio y el calendario
Evolution Data Server
El servidor de datos de Evolution (Evolution Data Server) proporciona una única libreta de direcciones y un calendario que todas las aplicaciones pueden usar para almacenar y recuperar información. Usar el servidor de datos de Evolution significa que los usuarios no tendrán que mantener listas de contactos separadas para cada aplicación o copiar manualmente acontecimientos entre los calendarios.
La gente cada vez utiliza más los equipos para interactuar con sus amigos y colegas. Las aplicaciones tales como clientes de correo electrónico, mensajería instantánea y las aplicaciones de telefonía y videoconferencia se usan para comunicarse unos con otros. Estas aplicaciones a menudo proporcionan listas de contactos para ayudar a los usuarios. Al usar el servidor de datos de Evolution, las aplicaciones pueden almacenar la información de los contactos en una sola ubicación, permitiendo a todas las aplicaciones ver todos los datos pertinentes acerca de los contactos del usuario.
Las aplicaciones también pueden usar el servidor de datos de Evolution para almacenar y recuperar citas del calendario del usuario. Por ejemplo, el reloj del panel muestra un calendario simple cuando se pulsa sobre él. Si el usuario tiene una cita planificada se mostrará en éste calendario. Esto hace más fácil ver las citas próximas sin tener que abrir una completa aplicación de calendario.
Referencia de la API de Evolution: libebook
Referencia de la API de Evolution: libecal
Bus estándar de comunicaciones entre procesos
D-Bus
D-Bus es un bus de mensajes multiescritorio para enviar eventos entre diversas aplicaciones, el escritorio y componentes de bajo nivel del sistema. D-Bus proporciona una API simple para enviar mensajes a servicios en particular y para enviar mensajes de difusión a todos los servicios interesados. D-Bus permite que diferentes tipos de aplicaciones se comuniquen e integren entre ellas y el escritorio, proporcionando una mejor interacción y una experiencia enriquecedora para el usuario.
D-Bus proporciona un bus de sesión y un bus de sistema. El bus de sesión lo usan las aplicaciones en una sesión de un solo usuario, permitiéndolas compartir datos y notificaciones de eventos e integrándolos con el escritorio del usuario. Por ejemplo, los reproductores de películas pueden enviar un mensaje por D-Bus para evitar que se active el salvapantallas cuando el usuario está viendo una película.
El bus del sistema es un bus de un solo mensaje que se ejecuta independientemente de cualquier sesión de usuario. Se puede comunicar con las aplicaciones de cualquier sesión, permitiendo a esas aplicaciones interactuar con los componentes del sistema sin tener que tratar con detalles de bajo nivel del sistema. El bus del sistema se usa para proporcionar una funcionalidad importante que los usuarios esperan que funcione en sus sistemas. Por ejemplo, el bus del sistema se usa para monitorizar cuando los interfaces de red se conectan o desconectan, cuando se conectan unidades externas y cuando la batería del sistema está baja.
D-Bus se desarrolla conjuntamente en
GNOME proporciona soporte completo para D-Bus usando las API GBus y GDBus en
Tutorial de D-Bus
Especificación de D-Bus
Gráficos y animaciones impresionantes con una API gráfica
Clutter
Clutter es una biblioteca que permite crear interfaces de usuario rápidas, portables, dinámicas e irresistibles.
Clutter usa las API industriales estándar de
Clutter no especifica ningún estilo visual, y no proporciona un control predefinido de la interfaz de usuario complicado; permite al desarrollador definir qué se necesita, usando una API gráfica flexible, con libertad para ubicar los elementos de la escena (o «actores») en la vista principal (o «escenario»).
Clutter viene con actores predefinidos para mostrar colores sólidos, datos de imágenes, texto y dibujos 2D personalizados de alta precisión usando la API de
Clutter proporciona un entorno de trabajo de animaciones y efectos gráficos ampliable. Una animación se asocia con una línea de tiempo, y cambia una o más de sus propiedades para uno o más actores en el tiempo, por ejemplo, su rotación en una dimensión concreta, su escala, tamaño, opacidad, etc.
Varias bibliotecas de terceras partes permiten la integración con otras tecnologías, como: Clutter-GTK, para empotrar un escenario de Clutter en una aplicación GTK+; Clutter-GStreamer, para empotrar vídeo de GStreamer y tuberías de sonido.
El libro de cocina de Clutter
Manual de referencia de Clutter
La página web de Clutter
API simple de sonido para notificaciones y eventos
Canberra
Canberra es una biblioteca para reproducir eventos sonoros y notificaciones, como cuando un usuario recibe un mensaje u ocurre un error. Además de proporcionar una API cómoda, Canberra también puede trabajar con características de accesibilidad del escritorio o proporcionar notificaciones alternativas para usuarios con deficiencias auditivas.
Referencia de Canberra
Lienzo para dibujar modernos vectores en 2D
Cairo
Cairo es una biblioteca gráfica 2D que cuenta con una API sofisticada para dibujar vectores gráficos, imágenes compuestas y renderizar texto con antialias. Cairo proporciona soporte para muchos dispositivos de salida, incluyendo el sistema X Window, Microsoft Windows y búferes de imagen, permitiéndole escribir código para dibujar gráficos en diferentes medios independiente de la plataforma.
El modelo de dibujado de Cairo es similar al que proporcionan PostScript y PDF. La API de Cairo proporciona operaciones de dibujado tales como pincelar y rellenar splines cúbicos de Bézier, componer imágenes y realizar transformaciones afines. Estas operaciones con vectores permiten a ricos gráficos con antialias sin tener que usar el caro dibujo basado en píxel en el código de su aplicación.
El rico modelo de Cairo permite renderizado de alta calidad en múltiples dispositivos. La misma API se puede usar para crear impresionantes gráficos y textos en la pantalla, para renderizar imágenes o crear salidas modificadas adecuadas para una impresión.
Debería usar Cairo siempre que necesite dibujar gráficos en su aplicación más allá de los widgets proporcionados por GTK+. Gran parte del dibujado realizado por GTK+ se lleva a cabo usando Cairo. Usar Cairo para su dibujado personalizado permitirá a su aplicación tener gráficos de alta calidad, con antialias e independientes de la resolución.
Manual de Cairo
La página web de Cairo
Soporte para lectores de pantalla y otras herramientas de accesibilidad
ATK
La accesibilidad es el proceso de asegurarse de que su aplicación se puede usar por personas con alguna o varias discapacidades. Las discapacidades pueden ser de muchos tipos: visuales, de coordinación, movimientos descoordinados, impedimentos auditivos, impedimentos cognitivos y del lenguaje y desordenes de apoplejías. Muchas personas tienen algún tipo de discapacidad y hacer su aplicación accesible permitirá que más gente pueda usarla de forma efectiva.
GNOME proporciona soporte para dispositivos de accesibilidad usando el entorno de trabajo ATK. Este entorno de trabajo define un conjunto de interfaces a las que los componentes del interfaz gráfico se deberán adherir. Esto permite a, por ejemplo, los lectores de pantalla leer el texto de un interfaz e interactuar con sus controles. El soporte de ATK está construido dentro de GTK+ y el resto de la plataforma GNOME, de tal forma que cualquier aplicación que use GTK+ tendrá cierto soporte accesibilidad razonable debido a este hecho.
Sin embargo, debería ser consciente de las cuestiones de accesibilidad cuando desarrolle sus aplicaciones. Aunque los interfaces GTK+ proporcionan una accesibilidad razonable de forma predeterminada, a menudo puede mejorar el comportamiento de su programa con las herramientas de accesibilidad proporcionando información adicional a ATK. Si desarrolla widgets personalizados, debería asegurarse que exponen sus propiedades a ATK. También debería evitar el uso de sonidos, gráficos o colores como única vía de enviarle información al usuario.
El escritorio GNOME posee cierto número de herramientas de accesibilidad que permiten a los usuarios con discapacidades usar plenamente el escritorio y sus aplicaciones. Las aplicaciones que implementan completamente ATK serán capaces de trabajar con las herramientas de accesibilidad. Las herramientas de accesibilidad de GNOME incluyen un lector de pantalla, un magnificador de pantalla, un teclado en pantalla y
Accesibilidad de GNOME para desarrolladores
Referencia de ATK
Daniel Mustieles <daniel\.mustieles\@gmail\.com>, 2011-2012
Jorge González <jorgegonz\@svn\.gnome\.org>, 2007-2010
Mario Carrión <mario\@monouml\.org>, 2006
Para referencias de la API consulte
Soporte para interfaces gráficas y para el núcleo de la aplicación
Creación y entrega multimedia rica basada en complementos
Para obtener información más extensa sobre GStreamer, consulte
@@image: 'test_comm1.png'; md5=47677860b23d89d6f428f1dc454bdb08
Documentación
Más…
Tracker
Telepathy-Glib
Lectura complementaria
Biblioteca HTTP asíncrona con cookies, SSL y XML-RPC
Soup
Phil Bull
philbull@gmail.com
2012
Ver una lista completa de las bibliotecas de desarrollo de GNOME.
Bibliotecas de la plataforma
La plataforma GNOME es una amplia colección de bibliotecas.
GSettings
GObject
glib
GLib
Cliente de mensajería instantánea Empathy
import telepathy
status = telepathy.get_im_status_or_whatever()
Tecnología
Avahi
Pequeños fragmentos de código de ejemplo para implementar características específicas y patrones de la IU.
Esta biblioteca de fragmentos de código proporciona demostraciones de todos los tipos de funcionalidades que puede añadir a su aplicación con las API de GNOME.
Descubrir impresoras en la red local con mDNS
Puede buscar impresoras en la red local usando Avahi y mDNS/zeroconf.
Avahi busca impresoras.
import avahi
do_something()
Multimedia
Cómo empezar
Asegúrese de que está ejecutando un sistema operativo que soporte las versiones de las bibliotecas de GNOME que necesita. Las distribuciones de Linux principales suelen tener el soporte actualizado.
Instalar las herramientas de desarrollo
Conocer la plataforma
Empezar a programar
Obtener soporte y documentación
Soporte para mensajería instantánea, redes, redes sociales, correo-e y calendario.
Comunicación y redes sociales
Use
Obtener un contacto desde la libreta de direcciones de Gmail
@@image: 'equation.png'; md5=3f9de1175d8de332977ee67890e2cb6d
Fundación GNOME
Resumen de las tecnologías de GNOME
Herramientas para desarrolladores
Ejemplos y documentación
@@image: 'media/ubuntu.png'; md5=40845e4a40b335b1958da1403f01c13f
@@image: 'media/fedora.png'; md5=19add55f4349fd9e90f3a50b344ba626
@@image: 'media/opensuse.png'; md5=a852a94199328e2f978c7f6a55bf8b54
Instalar las herramientas de desarrollo de GNOME
Proyecto de Documentación GNOME
gnome-doc-list@gnome.org
Prepárese para desarrollar en GNOME
Instalar las herramientas necesarias
Antes de empezar a programar, deberá instalar las herramientas de desarrollo de GNOME requeridas en su equipo. Esto no debería llevarle más de 10 minutos.
Instalación automática
Un una distribución actualizada, debería ser capaz de instalar los paquetes simplemente pulsando en
Instalación manual
Si prefiere la instalación manual, puede encontrar instrucciones para las diversas distribuciones en el
Ubuntu
Fedora
OpenSuSE
Otras
Versiones necesarias
Las guías asumen que tiene instaladas, al menos, las siguientes versiones de las herramientas.
Anjuta - 3.0
Devhelp - 3.0
Glade - 3.10
Por supuesto, cualquier versión más moderna también funcionará. Ahora, le deseamos que disfrute con las
Herramientas para ayudarle a internacionalizar sus aplicaciones.
Traducción y localización
Andre Klapper
Primer paso...
Segundo paso...
Tercer paso...
Herramientas de ayuda y de accesibilidad
Nemiver
GDB
Anjuta
Lenguajes
C
JavaScript
Python
Las bibliotecas
Vala
Equipo de documentación GNOME
2010, 2011
2010
Johannes Schmid
jhs@gnome.org
2011
Cómo empezar
C++
@@image: 'media/record-collection.png'; md5=2d645997687ed5aacd36aafafc16e072
Cree una pequeña aplicación con una base de datos para ordenar su colección de música
Colección de música
En este tutorial aprenderá:
Cómo conectar con una base de datos usando libgda
Cómo insertar y examinar registros en una tabla de una base de datos
Introducción
Esta demostración usa el lenguaje Javascript. Se va a demostrar cómo conectar y usar una base de datos desde un programa GTK+, usando la biblioteca GDA («GNOME Data Access», Acceso a datos de GNOME). Por lo tanto, es necesario tener instalada también esta biblioteca.
Acceso a Datos de GNOME (GDA) es una biblioteca cuyo propósito es proporcionar acceso universal a diferentes tipos de fuentes de datos. Esto abarca desde los tradicionales sistemas de bases da datos relacionales hasta cualquier fuente de datos imaginable como un servidor de correo-e, un directorio LDAP, etc. Para obtener más información y una documentación completa de la API, visite la
Aunque una gran parte del código se refiere a la interfaz de usuario (IU), el tutorial se enfocará a las partes de las bases de datos (aunque se puede hacer mención a otras partes que se consideren relevantes). Para aprender más sobre los programas en Javascript en GNOME, consulte el tutorial del programa
Crear un proyecto en Anjuta
Antes de empezar a programar, deberá configurar un proyecto nuevo en Anjuta. Esto creará todos los archivos que necesite para construir y ejecutar el código más adelante. También es útil para mantener todo ordenado.
Inicie Anjuta y pulse
Elija
Pulse
Estructura del programa
Esta demostración es una aplicación GTK+ sencilla (con una única ventana) capaz de insertar registros en la tabla de una base de datos, así como de explorar todos los registros de la tabla. La tabla tiene dos campos:
Empezar la diversión
Empezar examinando el esqueleto del programa:
Líneas 1‒4: importaciones iniciales. Preste especial atención a la línea 3, que indica a Javascript que importe la biblioteca GDA, nuestro objetivo en este tutorial.
Líneas 6‒17: definir la clase
Líneas 19‒23: iniciar la aplicación.
Diseñar la aplicación
Eche un vistazo al método
Líneas 22 y 27: crear las dos entradas (para los dos campos) en las que el usuario escribirá algo para insertarlo en la base de datos.
Líneas 31‒34: crear el botón «Insertar». Se conecta su señal
Línea 39: crear el widget (
Línea 44: crear la etiqueta donde se mostrará el número de registros de la tabla. Inicialmente está vacía, se actualizará más tarde.
Conectar e inicializar la base de datos
El código que hace la conexión con la base de datos está en método
Líneas 2‒3: crear el objeto de GDA


Si GDA no soporta el proveedor, o si falta algún elemento en la cadena de conexión, la línea 2 elevará una excepción. Por esto, en la vida real hay que manejarlo con la sentencia
Línea 4: abrir la conexión. En el proveedor de SQLite, si la base de datos no existe, se creará en este paso.
Líneas 6‒10: intentar hacer una selección simple para comprobar si la tabla existe. Si no existe (porque la base de datos se acaba de crear), este comando elevará una excepción, que se maneja en el bloque
Para ejecutar los comandos SQL anteriores se usan las funcionas globales de GDA
En este punto, ya está configurada la base de datos y lista para usarse.
Seleccionar
Después de conectar a la base de datos, el constructor de la demostración llama al método
Línea 2: el comando
Línea 3: crear un objeto
Línea 7: recorrer todos los registros, recuperándolos con la ayuda del objeto
Líneas 8‒9: se hacen dos cosas en cada línea:
Use el método
El método
Línea 11: concatenar los dos registros para formar una línea de texto, separados por
Línea 14: cuando termine el bucle, se tendrán todos los registros formateados en la variable
Línea 15: mostrar el número de registros en la tabla, usando el método
Insertar
Bien, ahora ya sabe cómo conectarse a la base de datos y cómo seleccionar filas de una tabla. Ahora es el momento de hacer un
Se ha aprendido a usar las funciones de conveniencia de GDA
Líneas 2‒3: comprobar si el usuario ha rellenado todos los campos. El código del método privado
Línea 5: la manera más rápida de hacer el
Línea 7: crear el objeto
Línea 8: establecer el nombre de la base de datos en la que operará la sentencia construida (generará
Líneas 9‒10: establecer los campos que formarán parte de la sentencia y sus valores. El primer argumento es el nombre del campo (como aparece en la tabla). El segundo es el valor de este campo.
Línea 11: obtener el objeto
Línea 12: finalmente, ejecutar la sentencia SQL (
Línea 14: limpiar los campos «id» y «name» en la pantalla. El código del método privado
Línea 15: actualizar la vista en la pantalla haciendo otro
También puede usar parámetros mientras construye la sentencia. Usando objetos y parámetros
Ejecutar la aplicación
Todo el código que necesita debe estar en su lugar, así que trate de ejecutar el código. Ahora tiene una base de datos para su colección de música.
Implementación de referencia
Si tiene problemas con este tutorial, compare su código con este
@@image: 'media/photo-wall.png'; md5=f19590d97e8ec029cda3c44b769c11cd
@@image: 'media/photo-wall-focused.png'; md5=9f1ceecf3a28c1e468597b093a10cbae
Un visor de imágenes Clutter
Chris Kühl
chrisk@openismus.com
Mural de fotos
Para este ejemplo se construirá un sencillo visor de imágenes usando Clutter. Aprenderá:
Cómo dimensionar y posicionar varios
Cómo poner una imagen en un
Cómo hacer transiciones sencillas usando el entorno de trabajo de animaciones de Clutter
Cómo hacer que un
Cómo obtener nombres de archivos de una carpeta
Clutter es una biblioteca para crear interfaces de usuarios dinámicas usando OpenGL para la aceleración gráfica. Este ejemplo demuestra una pequeña, pero importante parte de la biblioteca Clutter para crear un sencillo pero atractivo programa para ver imágenes.
Para ayudarle a conseguir su objetivo, también se utilizarán algunos fragmentos comunes de GLib. Más importante es que se usará una
Seleccione
Asegúrese de que
Active
Pulse
Un vistazo al mural de fotos
El visor de imágenes muestra al usuario un mural de imágenes.
Cuando se pulsa una imagen, esta se anima para que rellene el área de visualización. Cuando se pulsa la imagen que tiene el foco, vuelve a su tamaño original usando una animación que dura 500 milisegundos.
Configuración inicial
El siguiente fragmento de código contiene muchas definiciones y variables que se usarán en las siguientes secciones. Úselo como referencia para las próximas secciones. Copie este código al principio de
Saltar dentro del código
Se empezará echando un vistazo a la función
Línea 4:
Línea 7: debe inicializar Clutter. Si olvida hacerlo, obtendrá mensajes muy extraños. Queda advertido.
Líneas 9‒11: aquí es donde se obtiene el
Un
Línea 12: aquí se llama a la función para obtener las rutas de las imágenes. Esto se verá en breve.
Líneas 14‒26: aquí es donde se configuran los
Línea 29: mostrar el escenario y
Línea 32: iniciar el bucle principal de Clutter.
Configurar los actores de imagen
En Clutter, un actor es el elemento visual más simple. Básicamente, todo lo que ve es un actor.
En esta sección, se va a mirar más detenidamente el bucle usado para configurar los
Línea 5: aquí se quiere obtener la ruta a la ubicación
Línea 6: aquí es donde actualmente se crea el
Línea 7: está función se verá en una sección posterior.
Línea 8: esto añade el
Línea 9: esto añade el
Es interesante tener en cuenta que se prefiere anteponer los
Cargar las imágenes
Tómese un pequeño descanso de Clutter para ver cómo se pueden obtener los nombres de archivos desde la carpeta de imágenes.
Líneas 5 y 12: esto abre la carpeta o, si ocurre un error, termina después de mostrar un mensaje de error.
Líneas 14‒23: la primera línea obtiene otro nombre de archivo del
Configurar los actores
Eche un vistazo al tamaño y al posicionamiento de los
Línea 7: configurar un actor como «reactivo» significa que reacciona a los eventos tales como
Líneas 9‒12: ahora se conecta el evento
En este punto tiene un mural de fotos que está listo para verse.
Reaccionar a las pulsaciones
Líneas 1‒4: hay que asegurarse de que la función de retorno de llamada coincide con la firma requerida para la señal
Unas pocas palabras sobre los argumentos que no se están usando en este ejemplo. El
El
Línea 7: se establece un indicador estático para seguir el estado en el que se está: modo mural o modo de foco. Se inicia en modo mural, por lo que ninguna imagen tiene el foco. Por ello, el indicador se establece inicialmente a
Línea 9: esta línea de código ejecuta una función personalizada,
Líneas 13‒19: llegar a este código significa que actualmente sólo una imagen tiene el foco, y se quiere volver al modo mural. La función
La dirección del
El modo de animación que usar. Aquí se ha usado
La duración de la animación, en milisegundos. Se ha escogido 500 ms para este ejemplo.
El resto de argumentos son parejas propiedad/valor. Aquí se quiere establecer el valor
El último argumento debe ser siempre
La propiedad
La profundidad también determina qué
Línea 24: llegar a esta línea de código significa que actualmente se está en el modo mural y se va a dar el foco a un
Línea 25: establecer la propiedad
Líneas 27‒33: esto es similar al bloque de código anterior. Tenga en cuenta que se está estableciendo la profundidad para elevarlo por encima del resto de imágenes.
Línea 37: aquí se cambia la opción
Como se ha mencionado anteriormente, los
Recuerde, sin embargo, que para que los
Lo siguiente es la función de conveniencia pasada a
Líneas 2‒5: la firma de esta función requiere dos
Línea 7: dependiendo de qué valor booleano se pasa, el
Construir y ejecutar la aplicación
Todo el código debería estar listo para ejecutarse. Todo lo que necesita son algunas imágenes para cargar. De manera predeterminada, las imágenes se cargan desde la carpeta
Cuando lo haya hecho, pulse
Si todavía no lo ha hecho, elija la aplicación
Si tiene problemas con este tutorial, compare su código con este
@@image: 'media/message-board.ogv'; md5=beb80c4538776dc2cdd26c95abea5027
Un programa sencillo usando WebKitGTK+ y el DOM.
Cuadro de mensajes
Cómo mostrar una página web con WebKit.
Como manipular el contenido de una página web usando las funciones del DOM del WebKit.
En este tutorial se asume que está familiarizado con el lenguaje de programación C y que tiene un conocimiento básico de GTK+, incluyendo cómo crear y colocar widgets y cómo conectar funciones de retorno de llamadas a señales. Consulte la
La plataforma GNOME incluye WebKitGTK+, construido sobre el potente marco de trabajo WebKit. WebKitGTK se usa en todo GNOME, no sólo para ver páginas web en Internet, sino también para crear interfaces de usuario enriquecidas a las que se pueden añadir estilos fácilmente con CSS.
En este tutorial, se creará un cuadro de mensajes sencillo usando WebKit. El cuadro de mensajes le permitirá introducir algún texto y añadirlo a una lista de mensajes en HTML. Antes de empezar, deberá configurar un proyecto en Anjuta.
En Anjuta, pulse
Seleccione
Rellene sus detalles en la página
Desactive la opción
Deberá indicar a Anjuta que va a usar WebKitGTK+ en este proyecto. En la página
Cuando termine el asistente de creación de un nuevo proyecto, abra el archivo
#include &lt;webkit/webkit.hgt;
Verifique que todo funciona construyendo lo que tiene hasta ahora. Pulse
Ahora debería poder ejecutar el programa. Pulse
La disposición de la ventana y la vista web
Ahora que puede mostrar una ventana, es el momento de empezar a trabajar con WebKit. Para este tutorial, se creará una entrada de texto y una vista web y ambas se empaquetarán en una ventana. Busque la función
Primero cree un objeto
Ahora cree una caja vertical y añádala a la ventana. Una ventana sólo puede contener un widget hijo, por lo que necesitará una caja para añadir varios widgets. El segundo argumento de
Después, cree un objeto
Antes de añadir la vista web debe crear una ventana desplazada para ponerla dentro. La ventana desplazada contendrá barras de desplazamiento a la derecha y abajo cuando sea necesario, y evitará que la vista web abarque la pantalla entera. En este momento, se pasa
Finalmente, cree una
WEBKIT_WEB_VIEW (view)
La vista en sí. Ya que
"lt;htmlgt;lt;bodygt;lt;/bodygt;lt;/htmlgt;"
El archivo HTML más simple que pueda escribir.
"text/html"
El tipo MIME del contenido que ha proporcionado. En este caso, está usando HTML plano.
"UTF-8"
La codificación de caracteres del contenido que ha proporcionado. Aunque sólo use caracteres ASCII, es una buena idea especificar UTF-8, ya que es la codificación que se usa de manera predeterminada en toda la plataforma GNOME.
NULL
El URI base. En este ejemplo no se necesita, pero puede querer proporcionar un URI
Cada vez que añade un widget, debe llamar a la función
Finalmente, debe llamar a la función
Construya y ejecute el cuadro de mensajes de nuevo. Debería ver una ventana con una entrada de texto y una vista web. Todavía no hace nada porque la entrada de texto y la vista web no saben nada la una acerca de la otra.
Conectar señales
Ahora se quiere hacer que el cuadro
Entonces se debe definir
Lo primero que hacer es obtener un objeto
Una vez que tenga el documento, querrá obtener el elemento
shaunm
Ahora, cree un elemento
Finalmente, añada el nuevo elemento
Mejorar el aspecto con CSS
En este punto, su programa es completamente funcional, pero no es muy atractivo. Puede añadir estilos a la visualización de los mensajes con CSS, igual que puede hacer con una página web. Hay muchas maneras de incluir un CSS en la página: puede añadirlo al documento HTML inicial, añadirlo en línea usando el atributo
Todo lo que tiene en este ejemplo son elementos
Para aplicar el CSS, configure la
g_base64_encode tiene argumentos no válidos
Asegúrese de añadir declaraciones de variables para
gchar *tmp, *css;
Un URI de datos empieza por
Construya y ejecute el programa de nuevo. Debería funcionar exactamente igual que al final de la última sección, excepto que los mensajes tendrán estilos con un borde y un degradado de fondo sutil.
Aprender más
Este tutorial le ha mostrado cómo crear una aplicación sencilla usando GTK+ y WebKit, incluyendo cómo mostrar un documento y manipular su contenido. Para crear una aplicación real, probablemente quiera hacer algo más. Pruebe a añadir características usted mismo. Aquí hay algunas ideas:
Si se siente cómodo usando CSS, pruebe a cambiar el estilo de la visualización del mensaje. Es fácil iniciarse en CSS, pero cada vez es más potente. Hay una gran cantidad de tutoriales de CSS en Internet, y casi todo lo que se puede hacer en una página web, se puede hacer en esta aplicación.
Ahora mismo, todos los mensajes se pierden al cerrar el cuadro de mensajes. Pruebe a guardar el contenido HTML después de cada envío, y a cargar el archivo guardado (si existe) al inicio.
Si guarda sus mensajes durante mucho tiempo, empezará a preguntarse dónde los escribió. Añada una marca de tiempo a cada mensaje cuando se envía. Probablemente quiera crear algún elemento
@@image: 'media/magic-mirror.png'; md5=8171faea6ed3b6ddac0da084c29e4e22
Usar su cámara web como un espejo usando el entorno de trabajo GStreamer y GTK+
Daniel G. Siegel
dgsiegel@gnome.org
Espejo mágico
Su espejo se ha caído al suelo y se ha roto en miles de pedazos; pero necesita un espejo para afeitarse o para maquillarse. ¿Qué puede hacer?
En este tutorial se va a hacer un programa que le permite usar su cámara web como un espejo. Aprenderá a:
Crear una aplicación GTK+
Acceder a su cámara web usando GStreamer y empotrar el resultado en una ventana
Obtener las fotos de su cámara web
Necesitará lo siguiente para poder seguir este tutorial:
Una copia instalada del
Copias instaladas de GTK+, GStreamer y de un compilador de Vala
Conocimientos básico de un lenguaje de programación orientado a objetos
Elija
Desactive la opción
Asegúrese de que
Pulse
Construir el código por primera vez
El código carga una ventana (vacía) y la muestra.Se ofrecen más detalles a continuación; omita esta lista si entiende los conceptos básicos:
Las dos líneas
El constructor de la clase
La función estática
Este código está listo para usarse, por lo que puede compilarlo pulsando
Cambie la
Acceder al flujo de vídeo de la cámara web con GStreamer
El entorno multimedia de trabajo GStreamer es capaz de manejar vídeo desde cámaras web. Añada GStreamer a su aplicación y podrá acceder al flujo de vídeo.
Primero se quita la ventana creada anteriormente, ya que GStreamer se encargará de mostrar la imagen en la pantalla.
Ahora se va a crear un elemento de GStreamer que accede a la cámara web. Se va a usar el elemento «Camerabin», que es un elemento de cámara todo en uno capaz de hacer fotos, vídeos, aplicar efectos y mucho más. Perfecto para nuestro caso de uso. Con
Por supuesto, también es posible integrar el vídeo más ajustadamente en otras ventanas, pero esto es un tema avanzado que incluye algunos detalles sobre el sistema «X-Window» que aquí se omiten.
Compile y ejecute de nuevo. Acabará teniendo dos ventanas. En el siguiente paso, se integrará el vídeo en una ventana de GTK+.
Si tiene problemas con este tutorial, compare su código con este
Para obtener más información sobre el lenguaje de programación Vala, puede querer revisar el
Conclusión
@@image: 'media/image-viewer.png'; md5=7720360611243b14283b83527be968c2
Philip Chimento
philip.chimento@gmail.com
Tiffany Antopolski
tiffany.antopolski@gmail.com
Visor de imágenes
Cómo configurar un proyecto básico usando el
Cómo escribir una
Conocimiento básico del lenguaje de programación
Una copia instalada de
Inicie
Seleccione
Aprenderá a usar el constructor de interfaces en el tutorial del
Pulse
Las dos líneas
Conectar señales es como se define lo que pasa cuando pulsa un botón, o cuando ocurre algún otro evento. Aquí, se llama a la función
La función
Crear la interfaz de usuario
Ahora se dará vida a la ventana vacía. GTK+ organiza la interfaz de usuario con varios
Ahora reemplace el constructor actual con el siguiente:
Las dos primeras líneas son partes de la IGU a las que se debe acceder desde más de un método. Se declaran aquí, por lo que son accesibles mediante la clase en vez de serlo solamente en el método en el que se crearon.
Mostrar la imagen
En la última línea de este método se destruye el diálogo
Si todavía no lo ha hecho, elija la aplicación
Si tiene problemas con este tutorial, compare su código con este
Siguientes pasos
Jonh Wendell
jwendell@gnome.org
Cargar y mostrar archivos de imagen
Conocimiento básico del lenguaje de programación Python
Seleccione
Pulse
Una primera aplicación en GTK+
Vea como queda una aplicación GTK+ muy básica en Python:
Eche un vistazo a lo que está pasando:
Señales
Las señales son un concepto clave en la programación en GTK. Cuando pasa algo en un objeto, emite una señal; por ejemplo, cuando se pulsa un botón, emite la señal
Contenedores: diseñar la interfaz de usuario
Añada la caja y los widgets a la ventana. Inserte el siguiente código en el método
Empaquetado: añadir widgets al contenedor
Ahora inserte estas dos líneas, justo debajo de las dos que acaba de añadir.
Cargar la imagen: conectar con la señal
Cargar la imagen: escribir la llamada de retorno de la señal

Si tiene problemas con este tutorial, compare su código con este
Escribir una interfaz GTK+ de usuario básica usando JavaScript
Una copia instalada del intérprete
Elija
Pulse
JavaScript básico: hola mundo
Antes de empezar a escribir el visor de imágenes, averigüe algo más sobre cómo se usa JavaScript en GNOME. Por supuesto que su primer contacto con un lenguaje de programación debe ser el programa «Hola mundo», que se puede encontrar en el archivo
Clases en JavaScript

_init: function ()
Ahora que «MyClass» se ha definido, se puede jugar con ella:
Vea como queda una aplicación GTK+ muy básica en JavaScript:
Finalmente,
Añadir clases
Puede encontrar definiciones de señales para cualquier objeto en la
Cerrar la ventana
Añada la caja y los widgets a la ventana. Inserte el siguiente código en el método
Por último, se debe cambiar la línea
this.window.show_all ();
const Lang = imports.lang;

Si tiene problemas con este tutorial, compare su código con este
Cómo escribir una aplicación GTK+ en C++
Elija
Asegúrese de que
Pulse
Esto es una configuración muy básica de código C++ usando gtkmm. Se ofrecen más detalles a continuación; omita esta lista si entiende los conceptos básicos:
Ahora se dará vida a la ventana vacía. gtkmm organiza la interfaz de usuario con varios

Si todavía no lo ha hecho, elija la aplicación
Si tiene problemas con este tutorial, compare su código con este
Algunos conceptos básicos de programación en C/GObject
Cómo escribir una aplicación GTK+ en C
Seleccione
Asegúrese de que
La función
Al final de la línea de este método, se destruye el diálogo
Si tiene problemas con este tutorial, compare su código con este
@@image: 'media/guitar-tuner.png'; md5=f0b7ed4cdc2729d2d0f4d38b829db61e
@@image: 'media/guitar-tuner-glade.png'; md5=f6606525443ab2160f53a87a454364d0
@@image: 'media/guitar-tuner-pipeline.png'; md5=5adc952909d92af5dae6954781b4ad5f
Usar
Afinador de guitarra
En este tutorial se va a hacer una aplicación que reproduce tonos que puede usar para afinar su guitarra. Aprenderá a:
Configurar un proyecto básico usando el
Crear un proyecto en
Asegúrese de que
Pulse
El código carga una ventana (vacía) desde el archivo de descripción de interfaz de usuario y la muestra. Se ofrecen más detalles a continuación; omita esta lista si entiende los conceptos básicos:
Conectar señales es como se define lo que pasa cuando pulsa un botón, o cuando ocurre algún otro evento. Aquí, se llama a la función
Este código está listo para usarse, por lo que puede compilarlo pulsando
Crear la interfaz de usuario
En la pestaña
Guarde el diseño de la IU (pulsando
Tuberías de Gstreamer
Configurar la tubería
Crear el manejador de señales
Definir el manejador de señales
Si todavía no lo ha hecho, elija la aplicación
Si tiene problemas con este tutorial, compare su código con este
Analizar automáticamente las notas que toca el usuario.
Configurar un proyecto básico en Anjuta
Crear una IGU sencilla con el diseñador de IU de Anjuta
Usar GStreamer para reproducir sonidos
Conocimiento básico del lenguaje de programación Python
Seleccione
Pulse
Ejecutar el código por primera vez
Conectar señales es como se define lo que pasa cuando pulsa un botón, o cuando ocurre algún otro evento. Aquí, se llama a la función
Este código está listo para usarse, por lo que puede ejecutarlo pulsando
El archivo de GtkBuilder contiene una descripción de la interfaz de usuario (IU). Para editar la interfaz de usuario, abra
Escribir el manejador de señales
Cambie la línea de importación en
Detener la reproducción
Ahora se escribirá el código de la función
La llamada a
Definir los tonos
El botón que se ha pulsado se pasa como argumento (
Si tiene problemas con este tutorial, compare su código con este
Usar gtkmm y GStreamermm para construir un sencillo afinador de guitarra para GNOME. Muestra cómo usar el diseñador de interfaces.
Conocimiento básico del lenguaje de programación C++
Elija
Asegúrese de que
Pulse
El constructor de la clase
Después llama a algunas funciones que configuran y después ejecutan la aplicación. La función
Repita los pasos anteriores para el resto de botones, añadiendo las 5 cuerdas restantes con las etiquetas
Guarde el diseño de la IU (pulsando
Usar GStreamermm
Para usar GStreamermm, se debe inicializar. Esto se hace añadiendo la siguiente línea de código junto a la línea
 Gst::init (argc, argv);
Mientras está con esto, asegúrese de que
El código tiene el propósito siguiente:
Conectar las señales
Se quiere reproducir el sonido correcto cuando el usuario pulsa un botón. Lo que significa que hay que conectar la señal disparada cuando el usuario pulsa el botón. También se quiere proporcionar información a la función llamada dependiendo del tono que reproducir. gtkmm hace que esto sea fácil ya que se puede vincular información con la biblioteca
Si tiene problemas con este tutorial, compare su código con este
Lectura complementaria
La mayor parte de lo que se ha visto anteriormente se explica detalladamente en el
Conocimiento básico del lenguaje de programación C
Seleccione
Asegúrese de que
El constructor de la clase
Inserte la siguiente línea en
Esto incluye la biblioteca GStreamer. También necesita añadir una línea para inicializar GStreamer; ponga la siguiente línea de código antes de la llamada
Después, copie la siguiente función en
Ahora, se escribe el código de la función
La llamada a
Se quiere reproducir el sonido correcto cuando un usuario pulsa un botón. En primer lugar, se necesita conocer las frecuencias de las seis cuerdas de la guitarra, que están definidas (al principio de
Si tiene problemas con este tutorial, compare su código con este
Reproductor de sonido
Usar el poder del lenguaje de marcado número uno
XML y XSLT
Desde su introducción formal en 1998, XML (eXtensible Markup Language) cada vez se ha usado en más aplicaciones. Se usa para una gran variedad de propósitos, desde formatos de documentación como XHTML y DocBook a protocolos de internet como SOAP y Jabber. XML proporciona una sintaxis de base limpia y simple, permitiendo a las aplicaciones centrarse en sus necesidades particulares.
Procesamiento de XML
GNOME posee la biblioteca libxml2 y la usa extensivamente en todo el escritorio. La biblioteca libxml2 es una biblioteca de procesado XML rápida y que cumple con los estándares, proporcionando todo lo que puede necesitar para usar XML en su aplicación.
La biblioteca libxml2 proporciona un número variado de diferentes API para trabajar con XML de tal forma que puede usar la que mejor se ajuste a las necesidades de desarrollo de su aplicación. Además del árbol API nativo, libxml2 también proporciona el API SAX2 basado en retro llamadas , lector de contenido XML transmisible y escritor de interfaces además de soporte completo para XPath.
Además del soporte DTD, libxml2 también proporciona soporte completo para validar documentos usando RELAX NG, que permite un modelo de validación más flexible mientras que mantiene una facilidad de uso. También existe soporte parcial para XML Schema, el nuevo lenguaje de esquemas producido por el W3C.
Debería usar libxml2 siempre que necesite trabajar directamente con XML en su aplicación. Usar libxml2 asegura que tendrá análisis, procesado y salida XML que cumple completamente con los estándares. Para los desarrolladores significa que no deben preocuparse sobre incompatibilidades entre aplicaciones.
Para obtener más información acerca de libxml2, consulte
Transformar XML con XSLT
XSLT es un lenguaje basado en XML para transformar XML en otros formatos. XSLT es un lenguaje basado en plantillas que le permite coincidir con particulares tipos de elementos XML y crear una salida acorde con ello. Basado en XML y XPath, XSLT permite a los desarrolladores crear plantillas limpias y modulares para convertir un «dialecto» XML en otro formato más adecuado para la aplicación.
GNOME posee la biblioteca libxslt, una implementación completa de XSLT. La biblioteca libxslt está construida encima del soporte XML y XPath en libxml2, permitiendo que sea rápida y cumpla con los estándares.
Debería usar libxslt si necesita transformar documentos XML. Aunque XSLT no siempre es la solución correcta para procesar XML, a menudo puede simplificar el desarrollo. Ya que libxslt le permite añadir elementos y funciones de extensión, puede personalizarlas para que se ajusten a su aplicación.
Para obtener más información acerca de libxslt, consulte
Resumen de la plataforma
La plataforma GNOME proporciona un entorno de desarrollo comprensible para aplicaciones gráficas y otro software. Al usar las tecnologías en GNOME, puede crear software de alta calidad para alcanzar y superar las expectativas de los usuarios. Este capítulo proporciona un breve resumen de los componentes tratados en este documento.
GNOME proporciona un número de bibliotecas para construir atractivos interfaces gráficos. Proporciona bibliotecas para mostrar y manipular los controles comunes de interfaz , para mostrar y renderizar el texto de los sistemas de escritura de todo el mundo, así como para dibujar sofisticados gráficos vectoriales en la pantalla. Las tecnologías gráficas de GNOME se describen en la
La biblioteca GIO en GLib, junto con el «backend» GVFS proporcionan una abstracción del sistema de archivos que permite a los usuarios trabajar de forma remota contra servidores así como contra el sistema de archivos local. GIO proporciona una API de alto nivel para las operaciones con los archivos, haciendo que el desarrollo sea rápido y fácil. Usar GIO le permite a su aplicación soportar carpetas remotas automáticamente. GIO y GVFS están descritos en la
GNOME proporciona la biblioteca y el demonio de GConf para almacenar y obtener las preferencias de los usuarios. GConf tiene una API simple que hace sencillo proporcionar preferencias que aplicables instantáneamente en su aplicación. Usar GConf también permite a los administradores proporcionar ajustes predeterminados y obligatorios para las aplicaciones de sus usuarios. Gconf está descrito en la
GNOME proporciona facilidades para la internacionalización y la accesibilidad, ayudándole a llegar al mayor número de usuarios potenciales. Gran parte de la internacionalización y accesibilidad están construidos dentro de las propias aplicaciones, pero hay muchos temas de los que debe ser consciente cuando desarrolle aplicaciones. La internacionalización está descrita en la
GNOME se entrega con GStreamer, un «framework» multimedia extremadamente potente para crear, editar y reproducir contenido de audio y vídeo. GStreamer está descrito en la
GNOME también proporciona un «framework» completo de impresión que reemplaza CUPS siempre que sea posible. El «framework» de impresión de GNOME le permite proporcionar un interfaz consistente de alta calidad par ala impresión. El «framework» de impresión está descrito en la
El escritorio GNOME tiene soporte completo para transferir datos usando el portapapeles o arrastrando y soltando. Las API en GTK+ pueden ayudarle a crear aplicaciones cuya interoperabilidad con el resto del escritorio sea buena. Las funcionalidades del portapapeles y de arrastrar y soltar están descritas en la
Con
GNOME tiene la característica del sistema de componentes Bonobo, construido encima de CORBA. Bonobo permite a los programadores crear complejos componentes empotrables que pueden volver a usarse en otros programas. Nótese que Bonobo está obsoleto. En su lugar, el nuevo código escrito debe usar D-Bus y otras tecnologías. Bonobo está descrito en la
Para hacer que las redes sean más manejables para los usuarios, GNOME soporta el servicio DNS Discovery. El servicio de descubrimiento de DNS permite a las aplicaciones encontrar servicios automáticamente en una red local, en lugar de requerir que el usuario proporcione las direcciones de red. El servicio de descubrimiento de DNS está descrito en la
Finalmente GNOME proporciona un número de bibliotecas para trabajar con XML y servicios web. Estas tecnologías cada vez están siendo más importantes para los desarrolladores de aplicaciones. XML y los servicios web están descritos en la
El escritorio GNOME tiene numerosos lugares donde las aplicaciones pueden proporcionar una mejor integración, así pues proporciona las miniaplicaciones del panel o complementos para la gestión de archivos. Muchas de estas características están descritas en la
GNOME proporcione unas Guías de Interfaz Humana (GIU) comprensivas para ayudarle a crear aplicaciones más usables. Los estándares de usabilidad de GNOME fueron de los primeros entre los escritorios libres y continúan mejorando GNOME para una mejor experiencia del usuario. La usabilidad está descrita en la
GNOME también proporciona una completa ayuda del sistema, así como una guía de estilo para escribir la documentación. Aunque muchas veces está infravalorada, una buena ayuda al usuario puede mejorar su software significativamente. La documentación está descrita en la
Este trabajo está licenciado bajo una
Como excepción especial, los poseedores de los derechos de autor le dan permiso para copiar, modificar y distribuir el código de ejemplo contenido en este documento bajo los términos que usted elija, sin restricción.
Conectar sus aplicaciones al mundo
IPC y red
Mensajes por D-BUS
Para obtener más información acerca de D-Bus, consulte
Pila de red
La biblioteca GIO, parte de GLib, proporciona soporte de red integrado, incluyendo Sockets, autenticación TLS/SSL y resolución de DNS. Por ello, el soporte de red es una parte integral de la plataforma GNOME y no se necesitan dependencias adicionales.
GIO también proporciona una capa de acceso conveniente para acceder a D-Bus de una forma orientada a objetos.
Para obtener más información acerca de GIO, consulte
Servicio de descubrimiento
El servicio de descubrimiento de DNS o Zeroconf es una tecnología para localizar automáticamente los servicios disponibles en una red. Zeroconf permite a los usuarios acceder a los recursos de red sin tener que proporcionar una dirección explícita o configurar sus aplicaciones manualmente.
El servicio de descubrimiento de DNS ya se usa en varios lugares a traes de GNOME y se añadirá aún más soporte en el futuro. Por ejemplo,
La biblioteca Avahi proporciona soporte completo para el servicio de descubrimiento de DNS. Para obtener más información sobre Avahi, consulte
Servicios web
En nuestro mundo altamente interconectado, más y más aplicaciones necesitan proporcionar soporte para diversos servicios web. A veces los servicios web simplemente proporcionan una funcionalidad añadida, mientras que otras veces son el núcleo de la aplicación. Incluso las aplicaciones que han proporcionado una experiencia individual al usuario durante años están incorporando nuevos usos con servicios web.
La plataforma GNOME proporciona soporte para usar servicios web desde su aplicación, así como completas
SOAP
Con la biblioteca libsoup, GNOME proporciona soporte para SOAP, un protocolo ampliamente usado para analizar mensajes XML a través de HTTP. SOAP permite a los desarrolladores exponer un interfaz a través de la web que pueden usar aplicaciones para obtener información, enviar datos, realizar transacciones o usar cualquier otro número de los servicios proporcionados.
SOAP se puede usar para buscar y obtener información, para interactuar con una tienda en línea, para gestionar las cuentas de los usuarios en otros sistemas o para muchos otros propósitos. Los servicios web cada vez se usan más y más para proporcionar funcionalidades esenciales a los usuarios y las aplicaciones que usan SOAP pueden proporcionar una experiencia más integrada y llena de características al usuario.
La biblioteca libsoup contiene una implementación de HTTP y un juego API para construir y consumir mensajes SOAP. También permite autenticación segura, de tal forma que podrá usar los servicios web para acceder a cuentas privadas a través de una conexión segura. Al usar libsoup se hace fácil usar los servicios web sin necesidad de analizar e interpretar los mensajes enviados a través de SOAP.
Para obtener más información acerca de libsoup, consulte
Introducción a la plataforma de GNOME
GNOME provee una plataforma de desarrollo comprensivo que permite a los desarrolladores crear software profesional fácil de usar y agradable estéticamente. Este documento provee un resumen de alto nivel de la plataforma GNOME a través de enlaces a documentación detallada en cada parte de la plataforma.
Quién debe leer este documento
Debe leer este documento si quiere crear software usando la plataforma GNOME. Desarrollando con la plataforma GNOME le ayudará a crear aplicaciones consistentes que se integran bien en el escritorio del usuario. Esta guía le presentará varios componentes de la plataforma, para que sepa las librerías con las que se pueden cumplir que tareas. Esta guía enlaza a a documentación detallada adicional, de esta forma puede explorar cada componente de la plataforma más profundamente.
Esta guía puede también ser útil si esta seleccionando una plataforma de desarrollo para su proyecto de software. Esta proveerá un resumen de como puede usar la plataforma GNOME para construir software útil.
Esta guía también describe las formas de extender el escritorio GNOME con añadidos, apliques de panel, y otras herramientas útiles. Si quiere desarrollar funcionalidad adicional para conectar dentro del escritorio GNOME, debe leer esta guía, particularmente
Si tiene software existente que quiere portar a la plataforma GNOME, debe mirar la
La familia GNOME
GNOME es un esfuerzo global, con muchos contribuidores alrededor del mundo. GNOME es exitoso por sus contribuidores y usuarios. Esta sección lista los sitios web y conferencias donde puede aprender acerca de GNOME, así como de otras organizaciones para trabajar con GNOME.
www.gnome.org
El sitio web primario para usuarios GNOME. Contiene información de liberaciones, descargas, y documentación.
library.gnome.org
La fuente completa de toda la documentación de GNOME. Contiene toda la documentación de usuario y desarrollador producida por GNOME, automáticamente construida y actualizada para cada lanzamiento.
foundation.gnome.org
El sitio web para la fundación GNOME, la fundación no-lucrativa que supervisa el desarrollo de GNOME.
bugzilla.gnome.org
El rastreo de errores de GNOME. Use este sitio para enviar reportes de errores o solicitudes de funcionalidades, o para rastrear el estado de un reporte.
live.gnome.org
El wiki de GNOME. Muchos proyectos dentro de GNOME ahora usan el wiki como su espacio web primario. En adición, el wiki es usado a menudo para bosquejar el desarrollo futuro.
La antigua pagina web para la documentación del desarrollador. Una vez tuvo la documentación e información del desarrollador acerca de la usabilidad, documentación y equipos de traducción. El contenido de esta pagina se ha sustituido por
mail.gnome.org
Información en listas de correo de GNOME. Este sitio contiene archivos totales de todas las listas de correo.
El repositorio Git de GNOME, rastrea todos los código fuente de GNOME al principio del proyecto.
Listas de correo
gnome-list
La lista de correo primaria para usuarios GNOME.
gnome-devel-list
Información y preguntas acerca de desarrollo usando la plataforma GNOME.
gnome-love
El primer lugar a ir para involucrarse con GNOME.
Información en accesibilidad en aplicaciones GNOME.
Información en escritura de documentación para aplicaciones GNOME.
gnome-i18n
Información acerca de internacionalización y localización de aplicaciones GNOME.
usability
Información en usabilidad para aplicaciones GNOME.
La GUADEC
La conferencia principal para usuarios y desarrolladores de GNOME. La GUADEC tiene lugar anualmente en mayo o junio. Cada año, se presenta en una ciudad Europea diferente, haciéndolo una excelente excusa para ver más de Europa. Las charlas presentadas en la GUADEC están orientadas a usuarios, desarrolladores, y vendedores.
La GNOME Summit
La reunión hacker. La Summit se ajustado principalmente para desarrolladores existentes de GNOME, aunque a menudo hay información útil para nuevos desarrolladores. El Summit se presenta en Boston.
GNOME.conf.au
Una reunión casual presentada anualmente en linux.conf.au.
Otras organizaciones
freedesktop.org
El esfuerzo colaborativo para interoperabilidad y tecnología compartida entre ambientes de escritorio. A través de freedesktop.org, GNOME trabaja con proyectos como KDE y XFCE para hacer lo fácil para desarrolladores de aplicación para proveer mejor experiencia para sus usuarios.
Mozilla
El motor web libre, y muchas cosas más. GNOME mantiene lazos cercanos al equipo de desarrollo Mozilla para proveer en general una mejor interface de usuario.
OpenOffice.org
La suite de oficina libre. GNOME trabaja con el equipo de desarrollo de OpenOffice.org para ayudar a proveer una interfaz más unificada cuando se use la suite de oficina libre de GNOME.
Fundación de Software Libre
Libertad. Establecido en 1985, la Fundación de Software Libre ha trabajado para crear sistemas operativos libres completos, dando a sus usuarios la libertad para usar, modificar, y redistribuir su software. Como parte del proyecto GNU. GNOME apunta a proveer un ambiente de escritorio totalmente libre.
Registros de aplicación y tipos de archivo
Para que las aplicaciones sean útiles, los usuarios deben ser capaces de encontrarlas y ejecutarlas. Los usuarios del Escritorio GNOME pueden ejecutar aplicaciones usando el menú de aplicaciones o pueden ejecutarlas accediendo a los archivos en el gestor de archivos. El Escritorio GNOME le permite añadir aplicaciones y tipos de archivo al instalar su aplicación. El mecanismo para ello está especificado por
Añadir su aplicación es tan simple como proporcionar un archivo de entrada de escritorio con la información necesaria. Los archivos de entrada de escritorio usan una sintaxis de clave-valor simple, con elementos adicionales para proporcionar un contenido traducido para valores particulares. El archivo de entrada de escritorio de su aplicación deberá contener la siguiente información:
Un nombre y un comentario, ambos traducidos a tantos idiomas como soporte su aplicación,
Una lista de categorías desde una lista fija, que se usan para ubicar su aplicación en el menú de aplicaciones,
Un icono, pudiendo ser una ruta completa o simplemente un nombre para el tema de iconos del sistema,
Una lista de tipos de archivo que soportan sus aplicaciones, y
Si su aplicación maneja tipos de archivo personalizados que el sistema no conoce, deberá añadir ese tipo de archivos al registro de tipos de archivo. A todos los tipos de archivo se accede a través de los tipos MIME. Por ejemplo, los archivos de sonido Ogg Vorbis tienen un tipo MIME
Para obtener más información acerca de las aplicaciones, consulte
Miniaplicaciones del panel
El Escritorio GNOME posee paneles potentes y flexibles en los que los usuarios pueden añadir cualquier número de pequeñas aplicaciones, llamadas miniaplicaciones del panel. Las miniaplicaciones pueden proporcionar todo tipo de accesos rápidos a cualquier tipo de información útil y funcional. Por ejemplo, el Escritorio GNOME posee miniaplicaciones del panel para cambiar entre ventanas y áreas de trabajo, mostrar las condiciones climáticas actuales y la actividad de la red entre otras muchas.
Puede proporcionar una miniaplicación del panel para aumentar la funcionalidad de su aplicación o simplemente puede proporcionar una miniaplicación del panel individual. Si simplemente necesita mostrar notificaciones rápidas, debería considerar usar el área de notificación en su lugar, que también se muestra en el panel del usuario. Las miniaplicaciones del panel se deberían usar cuando se necesita proporcionar más funcionalidad de la que proporcionan los iconos de notificación.
Las miniaplicaciones del panel son procesos independientes que usan Bonobo para comunicarse con el panel. Bonobo permite a las miniaplicaciones integrarse con el panel para proporcionar una experiencia de usuario consistente. Por ejemplo, el menú contextual para cada miniaplicación del panel contiene elementos estándar para quitar, mover y bloquear la miniaplicación. Cada miniaplicación del panel puede añadir elementos al menú contextual para realizar otras acciones. La miniaplicación del panel
Nótese que Bonobo está obsoleto y en su lugar se usan D-Bus y otras tecnologías.
Para obtener más información acerca de las miniaplicaciones del panel, consulte
Área de notificación
Además de los lanzadores y las miniaplicaciones del panel, el panel de GNOME también dispone de un área de notificación que las aplicaciones pueden usar para notificar eventos a los usuarios. Las notificaciones se pueden usar para alertar al usuario de nuevos correos electrónicos, actualizaciones disponibles, próximas reuniones o cualquier otro acontecimiento.
Las notificaciones son iconos simples que su aplicación puede ubicar en el área de notificación del panel del usuario. Su aplicación puede realizar alguna acción si el usuario pulsa sobre el icono. Actualmente, el sistema de notificaciones está implementado en la biblioteca experimental Egg; no obstante, la nueva versión de GTK+ tendrá soporte para los iconos de notificación.
El área de notificación es una especificación de
Gestor de archivos
GNOME posee

Los complementos de
Los complementos también pueden añadir columnas a la vista de lista y emplazar emblemas en archivos automáticamente. Esto se puede usar para proporcionar información pertinente al usuario. Por ejemplo, un complemento de

Además de la arquitectura de complementos flexible,
Gestor de ventanas
El gestor de ventanas es un programa especial responsable de dibujar los bordes y títulos de las ventanas. El gestor de ventanas también es el responsable de manejar todas las operaciones realizadas sobre las ventanas, tales como mover, redimensionar, minimizar y mover entre áreas de trabajo. Las ventanas se gestionan de forma consistente con poco o ningún trabajo por parte de los desarrolladores de aplicaciones. Cuando las aplicaciones necesitan influenciar al gestor de ventanas, puede proporcionar sugerencias sobre sus ventanas usando llamadas a funciones en GTK+.
No obstante, los programas externos pueden interactuar directamente con el gestor de ventanas e incluso controlar su comportamiento. Al usar la biblioteca de GNOME libwnck, las aplicaciones pueden obtener información acerca de la ubicación y estado de todas las ventanas y instruir al gestor de ventanas para realizar diversas acciones sobre esas ventanas.
La biblioteca libwnck no es específica del gestor de ventanas de GNOME. Todas sus funcionalidades usan los consejos extendidos sobre gestores de ventanas (Extended Window Manager Hints, EWMH por sus siglas). EWMH se desarrolló de forma conjunta con
La interacción del gestor de ventanas con la biblioteca libwnck se puede usar para tareas simples, tales como mostrar áreas de trabajo y las miniaplicaciones de listas de ventanas en el panel del usuario, así como para aplicaciones complejas tales como realizar acciones automáticas sobre nuevas ventanas basándose en ciertas propiedades de las ventanas.
Centro de control
El Escritorio GNOME proporciona un sólo menú para todas las preferencias del escritorio así como para los ajustes de administración del sistema. Los diálogos de preferencias y ajustes se pueden emplazar en este menú para hacerlos más fácilmente accesibles. Los diálogos se pueden emplazar en el menú de preferencias añadiéndolos al registro de aplicaciones con la categoría
Si proporciona un diálogo que permite a los administradores configurar los sistemas del escritorio, entonces debería añadir su diálogo al menú de administración. Si proporciona un diálogo que permite a los usuarios ajustar las preferencias que afectan a cierto número de aplicaciones, entonces debería añadir su diálogo al menú de preferencias. No debería usar estos menús globales para las preferencias de una aplicación individual.
Almacenar contraseñas
Gestión de sesiones
GNOME proporciona herramientas para permitir a su aplicación ejecutarse suavemente entre una sesión y otra. Los usuarios pueden salir de la sesión mientras se ejecutan aplicaciones y tener esas aplicaciones completamente restauradas al iniciar de nuevo una sesión. Para proporcionar esta funcionalidad, su aplicación debe conectarse con el gestor de sesiones y guardar su estado cuando el usuario cierra la sesión.
Nótese que esta sección está obsoleta ya que GnomeClient y Libgnomeui también están obsoletos. En su lugar el nuevo código escrito debe usar
GNOME proporciona una API simple para la gestión de sesiones en la biblioteca del Interfaz de Usuario de GNOME. Para obtener más información acerca de cómo trabajar con el gestor de sesiones de GNOME, consulte la sección
Libreta de direcciones y calendario
Para obtener más información acerca de la libreta de direcciones, consulte
Usabilidad
El Escritorio GNOME está diseñado alrededor de la usabilidad y procura proporcionar una experiencia al usuario simple y consistente. Las personas usan los equipos para realizar algún trabajo (o para jugar) no para imaginarse cómo interactuar con interfaces de usuario complicados. Cuando diseñe su aplicación, debería considerar con qué facilidad reconocerán los usuarios los comunes paradigmas de los interfaces de usuario, con qué rapidez aprenderán los elementos únicos de su aplicación y con qué eficiencia ejecutarán tareas una vez que hayan aprendido a usarlos.
GNOME proporciona unas directrices de interfaz humano extensas (HIG) para ayudarle a escribir aplicaciones que sean atractivas y usables. Mientras que no hay directrices que puedan proporcionar una respuesta única para todo lo relacionado con la usabilidad, entender las directrices de interfaz humano puede hacer más fácil crear una aplicación usable. Para obtener más información, consulte
Toda aplicación debería proporcionar documentación para ayudar a los usuarios a entender la aplicación así como problemas de uso que puedan surgir. Mientras que una aplicación bien diseñada no debería necesitar de la lectura de una documentación antes de su uso, la documentación no deja de ser una herramienta importante para los usuarios, particularmente para aplicaciones complejas.
GNOME proporciona un entorno de trabajo unificado para proporcionar la documentación del usuario. Puede proporcionar la documentación usando el formato estándar de la industria DocBook. Usar DocBook significa que no tendrá que preocuparse por los detalles de formateo. En su lugar, su documentación se formateará automáticamente con la misma convención y consistencia que el resto de la documentación del sistema.
El visor de ayuda de GNOME,
Para obtener más información acerca de escribir documentación para su documentación, consulte
@@image: 'figures/graphics.png'; md5=d7ab482cbaaf268b4c439c57b2624826
@@image: 'figures/pango.png'; md5=e308eb839e5e70aea097a4cfe744e44c
@@image: 'figures/i18n.png'; md5=75f5d47d566817d32f1ed76e4c761ffb
Interfaces gráficas
Muchas aplicaciones necesitarán proporcionar una interfaz gráfica para interactuar con usuarios. Las interfaces gráficas pueden crear un medio intuitivo y descubrible para que las personas interactúen con el software, y usuarios esperan que las aplicaciones proporcionen interfaces de usuario fáciles de usar y atractivas.
La Plataforma GNOME proporciona tecnología sofisticada de gráficos e interfaces de usuario, desde controles de interfaz de usuario estándar en una API de dibujo a pantalla de gráficos de alta calidad. El uso de las tecnologías de gráficos en GNOME le permite crear aplicaciones que son consistentes, intuitivas, y estéticamente placenteras.
Vistazo por las capas de las bibliotecas gráficas
Para obtener más información acerca de GTK+, consulte
Libglade
Nótese que Libglade está obsoleto y en su lugar se usar
Libglade es una biblioteca para construir dinámicamente interfaces de usuario desde descripciones XML. Puede usar un constructor de interfaces gráficos como
Libglade permite a los programadores centrar su código en la lógica de sus aplicaciones, manteniendo el orden con la construcción actual del interfaz. Los constructores de interfaces gráficos también facilitan a las personas dedicadas a diseñar el interfaz, la construcción de interfaces sin tener que saber programar.
Para obtener más información acerca de libglade, consulte
Mostrar múltiples idiomas con Pango
Captura de pantalla del editor de textos
Para obtener más información acerca de Pango, consulte
GDK se puede ejecutar sobre varias plataformas, incluyendo el sistema X Window, Microsoft Windows, DirectFB y Quartz. Sobre cualquier plataforma, GDK proporciona el mismo API consistente, permitiendo a las aplicaciones GTK+ ejecutarse sin modificaciones.
GDK posee características de contexto gráfico y primitivas de dibujado que son adecuadas para dibujar objetos simples y renderizar imágenes en la pantalla. Ya que se proporciona un sistema de dibujado más extenso con Cairo, GDK proporciona ganchos para usar contextos Cairo dentro de GDK.
Para obtener más información acerca de Cairo, consulte
Sistema de archivos virtual
GIO, parte de GLib, es la biblioteca núcleo que se usa para las operaciones sobre archivos y carpetas en GNOME. GIO proporciona una capa de abstracción del sistema de archivos unificada con complementos para «backend». En GNOME, la biblioteca GVFS proporciona un «backend» de GIO implementando múltiples protocolos de red y locales. Al usar GIO junto con GVFS permite a su aplicación que trabaje con archivos en máquinas remotas tan fácilmente como con archivos locales.
GIO puede proporcionar información detallada acerca de carpetas y archivos, incluyendo el tipo MIME de un archivo y las aplicaciones que pueden usarse para abrir el archivo. Ya que GIO usa el estándar de
GIO se usa en muchas partes del escritorio GNOME. El gestor de archivos,
En anteriores versiones de GNOME se usaba la biblioteca GnomeVFS para acceder a archivos y carpetas. Aunque GnomeVFS proporcionaba muchas de las mismas características, incluyendo acceso transparente a carpetas remotas, tenía un número de limitaciones que han llevado a GIO. GnomeVFS está obsoleto y no se debería usar en código nuevo, aunque aún estará soportado durante todo el ciclo de vida de GNOME 2. Para obtener más información acerca de GnomeVFS, consulte
Configuración y bloqueo
GConf es el sistema de almacenamiento y recuperación de los ajustes de la configuración en GNOME. GConf consiste de dos partes: una biblioteca cliente para acceder a los ajustes y un demonio de sesión que es responsable de los detalles de almacenar y recuperar esos ajustes. Usar un demonio permite a GConf usar diferentes backends de almacenamiento, validar las entradas y proporcionar acceso simultáneo a diferentes aplicaciones.
Los ajustes almacenados en GConf se almacenan y recuperan usando una única clave o identificador de cadena. Las claves usan un espacio de nombre jerárquico para evitar colisiones entre los ajustes de las aplicaciones y el escritorio. Puede proporcionar un archivo de esquema para detallar sus claves de configuración. Esto permite a GConf validar el tipo de la entrada y mostrar documentación localizada acerca de la clave. Esto ayuda a los administradores del sistema, quienes pueden establecer múltiples ajustes de una vez sin tener que navegar por diálogos de preferencias.
GConf puede buscar ajustes de diferentes fuentes a la vez, generalmente desde diferentes ubicaciones en el sistema de archivos. Teniendo las apropiadas fuentes del sistema configuradas, GConf permite a los administradores del sistema proporcionar tanto ajustes obligatorios como predeterminados para todos los usuarios. Herramientas de GNOME como el
La biblioteca cliente de GConf proporciona notificaciones de los cambios en los ajustes, haciendo más fácil proporcionar ajustes aplicables instantáneamente en su aplicación, independientemente de si los ajustes se cambian desde su aplicación o usando otra herramienta. Establecer el valor de una clave se notificará a todas las aplicaciones interesadas, permitiendo que los ajustes generales del escritorio y de otras aplicaciones multiplataforma trabajen conjuntamente y sin esfuerzo.
GConf facilita el bloqueo de sistemas a través del establecimiento claves particulares de sólo lectura, evitando que los usuarios cambien esos valores. Además, GNOME proporciona cierto número de claves de alta seguridad que pueden usarse para desactivar acciones tales como guardar al disco y cambiar la distribución del panel. Herramientas como
Debería usar GConf para almacenar todas las preferencias del usuario en su aplicación. Usar GConf facilitará el proporcionar preferencias de aplicación instantánea y hará que sus ajustes sean accesibles a los administradores del sistema así como a las herramientas de configuración y respaldo.
Para obtener más información acerca de GConf, consulte
El Escritorio GNOME y la Plataforma de Desarrollo proporcionan soporte completo para la internacionalización y localización de aplicaciones. La internacionalización es el proceso de asegurarse que su aplicación puede ser localizada, incluyendo el marcado de todas las cadenas para su traducción, usando números y un formato de cadenas correcto y ajustando las variaciones de las convenciones para fechas y horas, unidades y formateo.
GNOME usa el estándar gettext y las rutinas relacionadas para acceder a las localizaciones. El soporte para la localización usando gettext está incluido en cada componente de la plataforma GNOME. Herramientas automáticas pueden explorar su código fuente para buscar cadenas especialmente marcadas. Al usar gettext, puede acceder fácil y eficientemente a versiones traducidas para todas las cadenas, que sean visibles al usuario, en su aplicación desde dominios de traducción instalados con su aplicación.
Estos dominios de traducción se pueden crear usando archivos PO, que pueden usar los traductores para seguir los cambios en las cadenas y actualizar sus traducciones convenientemente. GNOME proporciona intltool, una herramienta para gestionar las traducciones en los archivos PO. Al usar intltool, los traductores pueden usar los archivos PO para traducir no sólo las cadenas en su aplicación, sino también otros tipos de archivos que use, tales como los archivos de esquema de GConf, archivos de entrada de escritorio y archivos XML.
GNOME también proporciona la herramienta xml2po como parte del paquete gnome-doc-utils. Esta herramienta permite a los traductores usar archivos PO para crear versiones traducidas de la documentación escrita en varios formatos XML, incluyendo XHTML y DocBook.
La internacionalización involucra más que la simple posibilidad de traducir las cadenas, GNOME soporta el desarrollo de su aplicación en todos los pasos del proceso. GTK+ ajustará automáticamente su presentación para los idiomas que se leen de derecha a izquierda y Pango tiene soporte completo para renderizar texto bidireccional y texto en varios sistemas de escritura diferentes. GTK+ soporta múltiples métodos de entrada, permitiendo a los usuarios de cualquier idioma introducir texto con sus teclados de forma eficiente. De forma nativa, la plataforma GNOME al completo usa la codificación de texto UTF-8 de Unicode, proporcionando acceso a los caracteres y sistemas de escritura de todo el mundo.

Capturas de pantalla de la aplicación de hoja de cálculo
Internacionalizar su aplicación ayuda a hacerla disponible a más usuarios a través del mundo. Mientras que los traductores experimentados deben proporcionar las traducciones para cualquier idioma, los programadores deben asegurarse de que la aplicación está adecuadamente internacionalizada antes de que se pueda localizar completamente.
Para obtener más información acerca de la internacionalización en GNOME, consulte
Accesibilidad
Para recomendaciones extensas sobre accesibilidad, consulte
Impresión
La mayoría de las aplicaciones necesitan proporcionar soporte para la impresión. Los usuarios esperan ser capaces de imprimir el contenido que ven en la pantalla. La plataforma GNOME proporciona bibliotecas para ayudarle a añadir soporte para obtener una impresión de alta calidad con su aplicación.
Nótese que esta sección está obsoleta y que
El entorno de trabajo de impresión de GNOME consiste en dos bibliotecas que le ayudan a proporcionar una impresión de alta calidad con un interfaz consistente en su aplicación. En el núcleo del entorno de trabajo de impresión está libgnomeprint, una biblioteca para crear salidas PostScript para enviar a las impresoras. En la parte superior de ella está libgnomeprintui, que proporciona controles de impresión estándar para el interfaz de usuario de su aplicación.
La biblioteca libgnomeprint implementa el modelo de imagen de PostScript que usan por la mayoría de las impresoras. Las impresoras que no soportan PostScript pueden usarse a través de CUPS, como se describe más abajo. Además del estándar de impresión PostScript, libgnomeprint también soporta canal alfa y antialias.
La biblioteca libgnomeprintui proporciona diálogos de impresión estándar, un diálogo de vista previa y otros varios controles y funcionalidades requeridas para construir la impresión dentro de un interfaz de usuario intuitivo. El entorno de trabajo de impresión de GNOME maneja los detalles de localización de las impresoras y purgado de los trabajos de impresión así como permite exportar directamente a PostScript y PDF desde el diálogo de impresión.
Debería usar libgnomeprint siempre que necesite renderizar el contenido para una impresión en PostScript. Debería usar libgnomeprintui para construir su interfaz de impresión, incluso si la salida renderizada proviene de otra fuente. Al usar el interfaz de trabajo de impresión de GNOME se proporciona a los usuarios un interfaz de usuario consistente con las características que esperan para las aplicaciones de impresión.
CUPS
En la mayoría de sistemas GNOME, CUPS (Common UNIX Printing System) actúa como el sistema de impresión de bajo nivel. CUPS proporciona un moderna arquitectura rica en características para descubrir impresoras, opciones de acceso de la impresora, y reparto de tareas a diferentes tipos de impresoras.
CUPS proporciona un conjunto de herramientas para descubrir automáticamente las impresoras locales y de red. Esto no sólo permite a los usuarios ver todas las impresoras disponibles sino también usar diferentes tipos de impresoras sin ninguna configuración manual.
CUPS proporciona un interfaz unificado para la impresión independientemente de la ubicación o del tipo de impresora. De forma similar, CUPS gestiona automáticamente múltiples protocolos de impresión aplicando filtros al contenido enviado por las impresoras. Las aplicaciones pueden simplemente proporcionar una salida PostScript y CUPS la convertirá automáticamente para las impresoras que no soporten PostScript de forma nativa.
CUPS también proporciona opciones para la configuración de la impresora en forma de archivos PPD (PostScript Printer Description). Las configuraciones PPD permiten a las aplicaciones exponer al usuario las posibilidades de cada impresora con un interfaz de usuario consistente. Por ejemplo, PPD le permite detectar si una impresora puede recopilar y grapar los trabajos imprimidos así como proporcionar la opción en el interfaz del usuario.
En la mayoría de los casos no necesitará un interfaz directo con CUPS en sus aplicaciones. Usando el entorno de trabajo de impresión de GNOME tendrá acceso automáticamente a la potencia y flexibilidad de CUPS. Tener CUPS por debajo de su aplicación significa una mejor experiencia de usuario con menor programación.
Bindings de lenguajes
Aunque la plataforma GNOME está escrita principalmente en C, está escrita intencionalmente para que sea sencillo usar otros lenguajes de programación. Usando bindings de lenguajes, se puede desarrollar con la plataforma GNOME nativamente en el lenguaje de programación de su elección.
Existen bindings para muchos lenguajes de programación, y la plataforma GNOME oficialmente soporta bindings para C++, Java, Perl y Python.
Los bindings de C++ proporcionan cobertura completa de la plataforma GNOME, incluyendo GTK+, Libglade y GConf. Los bindings de C++ envuelven todos los objetos con objetos nativos de C++ y permiten a los programadores proporcionar widgets a medida con herencia normal de C++. Proporcionan una API totalmente nativa, con manejadores de señal de tipo seguro, uso total de la biblioteca estándar de C++, y una administración completa de memoria de C++.
Java
Las bindings de Java proporcionan una cobertura completa de la plataforma GNOME, incluyendo GTK+, Cairo, y GConf. Los bindings de Java envuelven todos los objetos con objetos nativos de Java y permiten a los programadores proporcionar widgets a medida con herencia normal de Java. Proporcionan una API totalmente nativa, utilizando bibliotecas de clases e interfaces de Java donde sea apropiado.
Para más información acerca de los bindings de Java para GNOME, visite
Perl
Los bindings de Perl proporcionan interfaces nativas Perl para la plataforma GNOME, incluyendo GTK+, GnomeVFS, y GConf. Los bindings de Perl envuelven todos los objetos con objetos de Perl y permiten a los programadores usar las practicas estándar de Perl para manipularlos. Proporcionan una API totalmente nativa, utilizando tipos de datos nativos de Perl donde sea apropiado.
Para más información acerca de los bindings de Perl para GNOME, visite
Los bindings de Python proporcionan interfaces nativas con Python para la plataforma GNOME, incluyendo GTK+, GnomeVFS, y GConf. Los bindings de Python envuelven todos los objetos con objetos nativos de Python y permiten a los programadores proporcionar widgets a medida con herencia normal de Python. Proporcionan un API nativa de Python la cual automáticamente maneja detalles como conversión de tipos y gestión de memoria.
Para más información acerca de los bindings de Python en GNOME, visite
Existen bindings totales o parciales para muchos otros lenguajes de programación, como C#, Eiffel, JavaScript, Ruby, y Scheme. A pesar de no estar actualmente oficialmente soportados por GNOME, muchos de esos bindings son de la misma alta calidad que los bindings oficiales de GNOME, y algunos de ellos quizás puedan incluirse como bindings oficiales de GNOME en futuros lanzamientos.
Para una lista de bindings de lenguajes, visite
Resumen rápido de módulos
Este apéndice proporciona un resumen rápido de las bibliotecas incluidas en la plataforma de escritorio y desarrollo GNOME. Las bibliotecas están listadas por módulo con una breve descripción y un enlace para más información en este documento, donde sea posible.
Los módulos en la plataforma de desarrollo GNOME establecen garantías estrictas acerca de la estabilidad del API y ABI. Se garantiza que las aplicaciones desarrolladas sobre los módulos de plataforma podrán ejecutarse sin modificarse durante el ciclo de vida de GNOME 2.
GConf
GConf proporciona el servicio y las bibliotecas para almacenar y obtener datos de configuración. Se trata sobre GConf en el
ORBit
ORBit es un servidor CORBA obsoleto. La arquitectura de componentes obsoleta de GNOME, Bonobo, está construida sobre CORBA. Se trata sobre CORBA en el
atk
ATK proporciona el conjunto de interfaces de accesibilidad que se implementan por otros grupos de herramientas y aplicaciones. Con el uso de las interfaces de ATK, las herramientas de accesibilidad tienen acceso total para ver y controlar aplicaciones en ejecución. Se trata sobre ATK en el
gail
GAIL proporciona una implementación de las interfaces ATK para GTK+ y las bibliotecas de GNOME, permitiendo a las herramientas de accesibilidad interactuar con aplicaciones escritas utilizando esas bibliotecas. En 2009 GAIL se integró dentro de GTK+. La accesibilidad se trata en el
gio
Parte de GLib, la biblioteca GIO proporciona una API de alto nivel para acceder a archivos y carpetas. Junto con la biblioteca GVFS, proporciona una abstracción del sistema de archivos que permite a las aplicaciones acceder a archivos remotos y locales. GIO está comentada en la
GLib proporciona los bloques básicos para construir aplicaciones y bibliotecas escritas en C. Proporciona el sistema de objetos básico usado en GNOME, la implementación del bucle principal, y un gran conjunto de funciones de utilidad para cadenas y estructuras de datos comunes.
gnome-vfs
Gnome-VFS es una biblioteca obsoleta para acceder a archivos y carpetas. GIO y GVFS la reemplazan. El nuevo código debería usar GIO en su lugar.
gtk+
Gtk+ es la principal biblioteca empleada para construir interfaces de usuario en las aplicaciones GNOME. Proporciona controles de interfaz de usuario y retrollamadas de señales para controlar interfaces de usuario. Se trata sobre GTK+en la
gvfs
GVFS proporciona una implementación de «backend» para GIO, permitiendo acceso a numerosos protocolos con la API GIO. Los desarrolladores no acceden a GVFS directamente. En su lugar, las aplicaciones escritas con GIO usarán automáticamente GVFS en sistemas donde esté activado.
libIDL
libIDL es una biblioteca obsoleta para analizar sintácticamente los archivos IDL (Interface Definition Language), los cuales son necesarios para los interfaces CORBA. Orbit, la implementación de CORBA de GNOME, usa libIDL. Se trata sobre CORBA en la
libart_lgpl
libart es una biblioteca gráfica obsoleta que puede renderizar rutas vectoriales. Se usa en el widget GnomeCanvas. El nuevo código escrito no debe usar libart_lgpl sino Cairo y/o otras tecnologías en su lugar.
libbonobo
Bonobo es un marco de trabajo obsoleto para crear componentes reutilizables para usarlos en aplicaciones GNOME, construidas sobre CORBA. Bonobo se trata en la
libbonoboui
La biblioteca obsoleta Bonobo UI proporciona un número de controles de interfaz de usuario usando el marco de trabajo de componentes Bonobo. Bonobo se trata en la
libglade
Libglade es una biblioteca obsoleta para construir interfaces de usuario dinámicamente desde descripciones XML. Libglade está obsoleta y ha sido reemplazada por
libgnome
La biblioteca obsoleta libgnome proporciona un número de rutinas útiles para construir aplicaciones modernas, incluyendo gestión de sesión, activación de archivos y URI, y mostrar ayuda.
libgnomecanvas
El widget GnomeCanvas proporciona un widget flexible para crear gráficos estructurados interactivos.
libgnomeui
La biblioteca obsoleta libgnomeui proporciona widgets adicionales para aplicaciones. Muchos de los widgets de libgnomeui ya han sido trasladados a GTK+.
libxml2
La biblioteca libxml2 proporciona un número de API para trabajar con XML en una forma que cumpla con los estándares. La biblioteca libxml2 se trata en
libxslt
La biblioteca libxslt proporciona una implementación rápida y completa de XSLT, un lenguaje para transformar XML. La biblioteca libxslt se trata en
pango
Pango es la biblioteca básica de texto y manipulación de tipografías usada en aplicaciones GNOME. Tiene un soporte extensivo para diferentes sistemas de escritura usados en todo el mundo. Pango se trata en
Módulos de escritorio
No se requiere que los módulos en el escritorio GNOME mantengan las mismas garantías de estabilidad de API y ABI como los módulos en la plataforma, aunque, se intenta mantenerlos relativamente estables. A menudo, los módulos se introducen en el lanzamiento del escritorio para madurar, y luego se trasladan a la plataforma cuando se han estabilizado.
eel
La biblioteca eel proporciona un número adicional de widgets para usarlos principalmente en
El servidor de datos de Evolution proporciona una ubicación unificada para libretas direcciones e información de calendario, permitiendo que varias aplicaciones compartan los mismos datos. El servidor de Evolution se trata en la
gnome-panel
En adición al panel actual, el paquete gnome-panel proporciona las bibliotecas usadas para construir miniaplicaciones de panel para ejecutarse en el panel del usuario. Las miniaplicaciones del Panel se tratan en la
El depósito de claves de GNOME, proporciona una forma moderna y segura de almacenar contraseñas de usuario y otros datos sensibles. Las claves se cifran y únicamente se puede acceder a ellas con permiso explícito del usuario. El depósito de claves GNOME se trata en la
GStreamer es el potente sistema multimedia que se usa en todo GNOME para reproducir, crear y manipular sonido y vídeo. Se habla de GStreamer en la
gtkhtml
La biblioteca gtkhtml proporciona un renderizador HTML ligero con soporte completo para edición de texto enriquecido. Se usa dentro del cliente de correo
gtksourceview
La biblioteca gtksourceview proporciona un extensión para el widget GtkTextView que soporta el resaltado automático de sintaxis y otras funciones que son útiles para editores de código fuente. Usado en el editor de texto
libgail-gnome
GAIL proporciona una implementación de las interfaces ATK para GTK+ y las bibliotecas de GNOME, permitiendo a las herramientas de accesibilidad interactuar con aplicaciones escritas utilizando esas bibliotecas. La accesibilidad se trata en el
libgnomeprint
libgnomeprint es una biblioteca obsoleta que proporciona una implementación del modelo de imagen PostScript. Ha sido sustituida por
libgnomeprintui
libgnomeprintui es una biblioteca obsoleta que proporciona un diálogo de impresión estándar, un diálogo de previsualización, y otros controles diversos requeridos para impresión. Ha sido sustituida por
libgtop
La biblioteca libgtop proporciona una API portable para obtener información acerca de procesos en ejecución. Se usa en la aplicación
librsvg
La biblioteca librsvg proporciona una implementación de SVG (Scalable Vector Graphics). Se usa en todo el escritorio para renderizar gráficos vectoriales independientemente de la resolución.
libsoup
La biblioteca libsoup proporciona una implementación del protocolo SOAP (Simple Object Access Protocol), así como una implementación HTTP. SOAP se puede usar para construir servicios web dentro de aplicaciones. La biblioteca libsoup se trata en la
libwnck
La biblioteca libwnck proporciona medios para controlar cualquier gestor de ventanas compatible con EWMH, incluyendo
libxklavier
La biblioteca libxklavier proporciona una API de alto nivel para acceder y establecer distribuciones del teclado. Se usa en las
vte
VTE es un widget emulador de terminal para uso en aplicaciones GTK+. Proporciona una API consistente y usa Pango para dibujar el texto, permitiendo mostrar todo el texto internacionalizado. VTE se usa en la aplicación
¿Qué es la plataforma de GNOME?
Para comenzar con el desarrollo de GNOME o para usar la plataforma de GNOME, consulte nuestras
Involucrarse
Plataforma de GNOME
Portapapeles y arrastrar y soltar
Ya que los usuarios trabajan con más y más tipos de datos en diferentes aplicaciones, tienen una necesidad de compartir objetos y datos entre sus aplicaciones. GNOME soporta dos métodos relacionados para transferencia de datos entre aplicaciones: usar operaciones de arrastrar y soltar, y copiar y pegar desde un portapapeles global del sistema. Ambas, el portapapeles y arrastrar y soltar, trabajan sobre múltiples aplicaciones, incluyendo aquellas no desarrolladas con GNOME.
El portapapeles se usa cuando un usuario copia datos explícitamente en una aplicación. La aplicación entonces reclama la propiedad del portapapeles. Cuando el usuario pega los datos en otra aplicación, la aplicación pide al portapapeles los datos de la primera aplicación. Las operaciones con el portapapeles están completamente soportadas en GTK+.
Las operaciones de arrastrar y soltar son similares pero requieren que el se siga al puntero y se actualice según el usuario se mueve a lo largo de objetivos potenciales para «soltar». Cuando a una aplicación se la notifica que el puntero se está moviendo sobre ella durante una operación activa de arrastrar, debe actualizar el cursor para indicar so acepta o no la operación de soltar. GTK+ proporciona soporte para arrastrar y soltar con una API sofisticada que hace fácil gestionar los objetivos potenciales para «soltar» en sus aplicaciones.
Tanto las operaciones con el portapapeles como las de arrastrar y soltar contienen negociación. Cuando una aplicación tiene datos que ofrecer, advierte qué formatos están disponibles para los datos. Las operaciones de recepción pueden requerir los formatos más apropiados. Por ejemplo, si un usuario copia texto de un navegador web, un procesador de textos puede mantener el formato pidiendo los datos en HTML, mientras que un editor de texto plano puede recibir el texto sin ningún formato.
Debería proporcionar funcionalidades para las operaciones con el portapapeles y arrastrar y soltar para cualquier dato sobre el que su aplicación pueda operar. Las operaciones con el portapapeles y arrastrar y soltar son útiles para más que simple texto: archivos, gráficos y archivos de sonido son ejemplos de datos que se pueden transferir entre aplicaciones. Cuando use GTK+, automáticamente obtendrá soporte para operaciones con el portapapeles y arrastrar y soltar para áreas de texto, botones de color, selectores de archivos y otros interfaces de control integrados. Debería usar las API en GTk+ para proporcionar soporte para cualquier otro tipo de dato en su aplicación.
Para obtener más información, consulte
Bonobo y CORBA
Nótese que Bonobo, libIDL y ORBit están obsoletas, en su lugar se usan D-Bus y otras tecnologías. Vea más información encima.
Bonobo es un «framework» para crear componentes reusables para su uso en aplicaciones. Construido sobre el estándar de la industria Common Object Request Broker Architecture (CORBA), Bonobo proporciona todos los interfaces comunes requeridos para crear y usar componentes con un comportamiento apropiado para las aplicaciones de GNOME.
Los componentes Bonobo se puede usar en una variedad de situaciones, y pueden ayudar a crear software flexible y extensible. Por ejemplo, un componente para mostrar contenido multimedia podría empotrarse en un procesador de textos, añadiendo soporte multimedia efectivo al procesador de textos sin que el procesador de textos trabaje directamente con él. Los componentes Bonobo también se usan para empotrar las miniaplicaciones en el panel de GNOME. Usar Bonobo permite a las miniaplicaciones comunicarse de una forma efectiva con el panel, proporcionando a los usuarios un interfaz consistente.
Los componentes Bonobo no se limitan a controles gráficos. Evolution, la suite de correo y groupware de GNOME usaba Bonobo para proporcionar acceso a los usuarios a la libreta de direcciones y al calendario. Esto permite a los usuarios mantener toda su información en un sitio mientras que todas las aplicaciones pueden acceder a ella.
Bonobo está construido sobre CORBA, permitiendo que los componentes se ejecuten en procesos separados. Los componentes se pueden escribir en diferentes lenguajes y ejecutarse sobre diferentes tiempos de ejecución; sólo necesitan implementar un interfaz especificado con IDL (Interface Definition Language). El diseño flexible de CORBA incluso permite que los componentes se ejecuten en distintos equipos de una red.
GNOME proporciona con ORBit su propia implementación ligera y rápida de CORBA. Las herramientas y bibliotecas proporcionadas con GNOME permiten que los componentes estén escritos en C, un lenguaje habitualmente excluido por otras implementaciones de CORBA. ORBit es una implementación de CORBA increíblemente rápida.
Bonobo ayuda a rellenar los huecos en CORBA proporcionando los interfaces adicionales y especificaciones necesarias para soportar componentes consistentes. Aunque rara vez necesitará usar CORBA sin Bonobo, se puede usar directamente. Por ejemplo, la la infraestructura de accesibilidad de GNOME usa CORBA para permitir a las tecnologías de asistencia inspeccionar e interactuar con las aplicaciones en ejecución.
Puede querer usar Bonobo para proporcionar componentes gráficos complejos que puedan ser empotrados en aplicaciones. No obstante, para necesidades CEP, las tecnologías de GNOME se están moviendo a D-Bus, ya que integrar D-Bus en las aplicaciones es considerablemente más fácil.
Para obtener más información acerca de Bonobo, consulte
XML y servicios web
Se concede autorización para copiar, distribuir o modificar este documento según los términos de la GFDL (GNU Free Documentation License), Versión 1.1, o cualquier otra versión posterior publicada por Free Software Foundation sin secciones invariables, textos de portada ni textos de contraportada. Podrá encontrar una copia de la GFDL en este
Este manual es parte de la colección de manuales GNOME distribuidos bajo el GFDL. Si quiere distribuir este manual separadamente de la colección, puede hacerlo añadiendo una copia de la licencia al manual, como está descrito en la sección 6 de la licencia.
Muchos de los nombres usados por empresas para distinguir sus productos y servicios se mencionan como marcas comerciales. Donde aparezcan dichos nombres en cualquier documentación GNOME,y para que los miembros del proyecto de documentación reconozcan dichas marcas comerciales, dichos nombres se imprimen en mayúsculas o iniciales mayúsculas.
EL DOCUMENTO SE PROPORCIONA "TAL CUAL", SIN GARANTÍAS DE NINGÚN TIPO, NI EXPRESAS NI IMPLÍCITAS, INCLUYENDO, SIN LIMITACIÓN, CUALQUIER GARANTÍA DE QUE EL DOCUMENTO O UNA VERSIÓN MODIFICADA DEL MISMO CAREZCAN DE DEFECTOS, SEA COMERCIALIZABLE, ADECUADO PARA UNA FINALIDAD DETERMINADA O QUE NO CONSTITUYA NINGUNA INFRACCIÓN. TODO EL RIESGO EN CUANTO A LA CALIDAD, PRECISIÓN Y UTILIDAD DEL DOCUMENTO O DE CUALQUIER VERSIÓN MODIFICADA DEL MISMO LE CORRESPONDE A USTED. EN CASO DE QUE CUALQUIER DOCUMENTO O VERSIÓN MODIFICADA RESULTARA DEFECTUOSO EN CUALQUIER SENTIDO, SERÁ USTED (Y NO EL REDACTOR INICIAL, NI EL AUTOR NI CUALQUIER PERSONA QUE HAYA CONTRIBUIDO) QUIEN ASUMIRÁ EL COSTE DE CUALQUIER SERVICIO TÉCNICO, REPARACIÓN O CORRECCIÓN NECESARIOS. ESTA LIMITACIÓN DE LAS GARANTÍAS CONSTITUYE UNA PARTE ESENCIAL DE ESTA LICENCIA. NO SE AUTORIZA NINGÚN USO DE CUALQUIER DOCUMENTO O VERSIÓN MODIFICADA DEL MISMO SI NO ES CON SUJECIÓN A ESTA LIMITACIÓN DE LAS GARANTÍAS; Y
EN NINGUNA CIRCUNSTANCIA NI SEGÚN NINGÚN ARGUMENTO LEGAL, SEA POR MOTIVOS CULPOSOS (INCLUIDA LA NEGLIGENCIA), CONTRACTUALES O DE OTRO TIPO, NI EL AUTOR, NI EL REDACTOR INICIAL, NI CUALQUIER COLABORADOR, NI CUALQUIER DISTRIBUIDOR DEL DOCUMENTO O VERSIÓN MODIFICADA DEL MISMO, NI CUALQUIER PROVEEDOR DE CUALQUIERA DE DICHAS PARTES, SERÁN RESPONSABLES, ANTE NINGÚN TERCERO, DE NINGÚN DAÑO O PERJUICIO DIRECTO, INDIRECTO, ESPECIAL, INCIDENTAL O CONSIGUIENTE DE NINGÚN TIPO, INCLUIDOS, SIN LIMITACIÓN, LOS DAÑOS POR PÉRDIDA DE FONDO DE COMERCIO, INTERRUPCIÓN DEL TRABAJO, FALLO O MAL FUNCIONAMIENTO INFORMÁTICO, NI CUALQUIER OTRO DAÑO O PÉRDIDA DERIVADOS DEL USO DEL DOCUMENTO Y LAS VERSIONES MODIFICADAS DEL MISMO, O RELACIONADO CON ELLO, INCLUSO SI SE HABÍA COMUNICADO A AQUELLA PARTE LA POSIBILIDAD DE TALES DAÑOS.
EL DOCUMENTO Y VERSIONES MODIFICADAS SE PROPORCIONAN BAJO LOS TÉRMINOS DE LA LICENCIA LIBRE DE DOCUMENTACIÓN DE GNU Y TENIENDO EN CUENTA QUE:
2005
2006
2.20
McCance