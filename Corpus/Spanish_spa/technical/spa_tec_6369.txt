# language_name_wals:	Spanish
# language_name_glotto:	Spanish
# iso639_3:	spa
# year_composed:	NA
# year_published:	2014
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	GNOME
# source:	https://object.pouta.csc.fi/OPUS-GNOME/v1/raw/es.zip
# copyright_short:	http://opus.nlpl.eu/GNOME.php
# copyright_long:	http://opus.nlpl.eu/GNOME.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

@@image: 'figures/genius_window.png'; md5=726c4fc51539c5898333fa28720f94b3
@@image: 'figures/line_plot.png'; md5=0ce9e28d32f414d68a0958a1c38918fc
@@image: 'figures/line_plot_graph.png'; md5=284ee1a4302f7ce163b72b7d5ce7fb91
@@image: 'figures/parametric.png'; md5=d6be229108fb50a16e8bdbbfde822ba8
@@image: 'figures/parametric_graph.png'; md5=74cbbc455c4fd79de6d0e60d0b54aa4c
@@image: 'figures/surface_graph.png'; md5=45b10d405b4cd88ad07413452e5f68ac
Manual de la herramienta matemática Genius.
Manual de Genius
1997-2013
Jiří (George) Lebl
2004
Kai Willadsen
Se concede permiso para copiar, distribuir o modificar este documento según las condiciones de la GNU Free Documentation License (GFDL), Versión 1.1 o cualquier versión posterior publicada por la Free Software Foundation sin Secciones invariantes, Textos de portada y Textos de contraportada. Encontrará una copia de la GFDL en este
Este manual es parte de la colección de manuales GNOME distribuidos bajo la GFDL. Si quiere distribuir este manual separadamente de la colección, puede hacerlo añadiendo una copia de la licencia al manual, tal como se describe en la sección 6 de la licencia.
Muchos de los nombres usados por empresas para distinguir sus productos y servicios se mencionan como marcas comerciales. Donde aparezcan dichos nombres en cualquier documentación GNOME, y para que los miembros del proyecto de documentación reconozcan dichas marcas comerciales, dichos nombres se imprimen en mayúsculas o iniciales mayúsculas.
EL DOCUMENTO SE ENTREGA "TAL CUAL", SIN GARANTÍA DE NINGÚN TIPO, NI EXPLÍCITA NI IMPLÍCITA INCLUYENDO, SIN LIMITACIÓN, GARANTÍA DE QUE EL DOCUMENTO O VERSIÓN MODIFICADA DE ÉSTE CAREZCA DE DEFECTOS EN EL MOMENTO DE SU VENTA, SEA ADECUADO A UN FIN CONCRETO O INCUMPLA ALGUNA NORMATIVA. TODO EL RIESGO RELATIVO A LA CALIDAD, PRECISIÓN Y UTILIDAD DEL DOCUMENTO O SU VERSIÓN MODIFICADA RECAE EN USTED. SI CUALQUIER DOCUMENTO O VERSIÓN MODIFICADA DE AQUÉL RESULTARA DEFECTUOSO EN CUALQUIER ASPECTO, USTED (Y NO EL REDACTOR INICIAL, AUTOR O AUTOR DE APORTACIONES) ASUMIRÁ LOS COSTES DE TODA REPARACIÓN, MANTENIMIENTO O CORRECCIÓN NECESARIOS. ESTA EXENCIÓN DE RESPONSABILIDAD SOBRE LA GARANTÍA ES UNA PARTE ESENCIAL DE ESTA LICENCIA. NO SE AUTORIZA EL USO DE NINGÚN DOCUMENTO NI VERSIÓN MODIFICADA DE ÉSTE POR EL PRESENTE, SALVO DENTRO DEL CUMPLIMIENTO DE LA EXENCIÓN DE RESPONSABILIDAD;Y
BAJO NINGUNA CIRCUNSTANCIA NI BAJO NINGUNA TEORÍA LEGAL, SEA POR ERROR (INCLUYENDO NEGLIGENCIA), CONTRATO O DE ALGÚN OTRO MODO, EL AUTOR, EL ESCRITOR INICIAL, CUALQUIER CONTRIBUIDOR, O CUALQUIER DISTRIBUIDOR DEL DOCUMENTO O VERSIÓN MODIFICADA DEL DOCUMENTO, O CUALQUIER PROVEEDOR DE CUALQUIERA DE ESAS PARTES, SERÁ RESPONSABLE ANTE NINGUNA PERSONA POR NINGÚN DAÑO DIRECTO, INDIRECTO, ESPECIAL, INCIDENTAL O DERIVADO DE NINGÚN TIPO, INCLUYENDO, SIN LIMITACIÓN DAÑOS POR PÉRDIDA DE MERCANCÍAS, PARO TÉCNICO, FALLO INFORMÁTICO O MAL FUNCIONAMIENTO O CUALQUIER OTRO POSIBLE DAÑO O PÉRDIDAS DERIVADAS O RELACIONADAS CON EL USO DEL DOCUMENTO O SUS VERSIONES MODIFICADAS, AUNQUE DICHA PARTE HAYA SIDO INFORMADA DE LA POSIBILIDAD DE QUE SE PRODUJESEN DICHOS DAÑOS.
EL DOCUMENTO Y LAS VERSIONES MODIFICADAS DEL MISMO SE PROPORCIONAN CON SUJECIÓN A LOS TÉRMINOS DE LA GFDL, QUEDANDO BIEN ENTENDIDO, ADEMÁS, QUE:
Jiří
Lebl
Universidad del estado de Oklahoma
jirka@5z.com
Kai
Willadsen
Universidad de Queensland, Australia
kaiw@itee.uq.edu.au
0.2
Marzo de 2014
Jiri (George) Lebl
Este manual describe la versión 1.0.18 de Genius.
Comentarios
Para informar de un fallo, o hacer alguna sugerencia sobre la aplicación
Introducción
La
Hay dos versiones de la
Este manual describe principalmente la versión gráfica de la calculadora pero, por supuesto, el lenguaje es el mismo. La línea de comandos carece de las capacidades de dibujo y de otras capacidades que necesitan la interfaz gráfica de usuario.
Primeros pasos
Para iniciar la
Puede iniciar la
Menú
Dependiendo de su sistema operativo y de su versión, el elemento de menú de la
Diálogo
Dependiendo de la instalación de su sistema, el elemento del menú puede no estar disponible. si no lo está, puede abrir el diálogo «Ejecutar» y ejecutar
Línea de comandos
Para iniciar la versión de GNOME de la
Para iniciar sólo la versión de línea de comandos, ejecute el siguiente comando:
Al iniciar Genius
Cuando inicia la versión de la
Ventana de la
Herramienta matemática Genius
Archivo
Editar
Calculadora
Configuración
Ayuda
Muestra la ventana principal
La ventana de la
Barra de menú.
Los menús de la barra de menús contienen todos los comandos que necesita para trabajar con archivos en la
El menú
Los otros menús tienen funciones similares a las de otras aplicaciones.
Barra de herramientas.
La barra de herramientas contiene un subconjunto de comandos a los que puede acceder desde la barra de menús.
Área de trabajo
El área de trabajo es el método primario para interactuar con la aplicación.
Inicialmente, el área de trabajo sólo tenía la pestaña
Alternativamente, puede escribir programas más largos y éstos pueden aparecer en pestañas separadas y se pueden guardar en archivos para su posterior recuperación.
Uso básico
Usar el área de trabajo
Normalmente, interactúa con la calculadora en la pestaña
Escriba su expresión en el área de trabajo de la
Para obtener una lista de todas las funciones y los comandos, escriba:
Suponga que ha guardado algún comando GEL previamente como un programa en un archivo y quiere ejecutarlo. Para cargar este programa desde el archivo
Crear un programa nuevo
Para escribir un programa nuevo, eliga
Para guardar el programa que ha escrito, elija
Abrir y ejecutar un programa
Para abrir un archivo, elija
Para ejecutar un programa desde un archivo, elija
Dibujar
El soporte de dibujo solo está disponible para la versión gráfica de GNOME. Todo el dibujo disponible desde la interfaz gráfica está disponible en la ventana
Trazado de líneas
Para crear gráficas de funciones de valores reales de una variable, abra la ventana
Una vez que pulse el botón
Crear una ventana de dibujo
Muestra la ventana de trazado de líneas
En los cuadros de texto escriba sólo las expresiones donde
Ventana de dibujo
El gráfico producido.
Desde aquí puede imprimir el dibujo, crear un PostScript encapsulado o un PNG del dibujo, o cambiar la escala. Si el eje dependiente no se ha establecido correctamente, puede hacer que Genius lo ajuste buscando los extremos de las funciones representadas.
Para dibujar usando la línea de comandos, consulte la documentación de la función
Gráficos paramétricos
En la ventana de crear dibujo, también puede elegir la pestaña
Pestaña dibujo paramétrico
Crear dibujo
Pestaña dibujo paramétrico en la ventana
Puede ver un ejemplo de una gráfica de una función paramétrica en la
Gráfico paramétrico
Gráfico paramétrico producido
Dibujos de campos de inclinación
En la ventana de crear dibujo, también puede elegir la pestaña
Cuando un campo de inclinación está activo, hay un menú adicional disponible
El solucionador usa el método Runge-Kutta estándar. Los gráficos se quedarán en la pantalla hasta que los borre. El solucionador se detendrá cuando alcance el límite de la ventana de dibujo. La ampliación no cambia los límites o los parámetros de la solución, tendrá que borrar y redibujar con los parámetros apropiados. También puede usar la función
Gráficos de campos de vectores
En la ventana de crear dibujo, también puede elegir la pestaña
De manera predeterminada se muestra la dirección y la magnitud del campo vectorial. Para mostrar únicamente la dirección y no la magnitud, normalice la longitud de las flechas habilitando la opción pertinente.
Cuando un campo vectorial está activo, hay un menú
El resolutor usa el método estándar de Runge-Kutta. Los gráficos resultantes permanecerán en la pantalla hasta que se limpie. Aumentar el gráfico no cambia los límites o parámetros de las soluciones, tendrá que limpiar y redibujarlos con los parametros adecuados. También puede usar la función
Gráficos de superficie
Genius también puede dibujar superficies. Seleccione la pestaña
El rango
Gráfico de superficie
Valor absoluto de la función coseno complejo.
Conceptos de GEL
GEL significa Lenguaje de Extensión de Genius. Éste es el lenguaje que se utiliza para escribir programas para Genius. Un programa en GEL es simplemente una expresión que se evalúa como un número, una matriz, o cualquier objeto en GEL. Por lo tanto, la
Valores
Los valores en GEL pueden ser
Números
1234
0x123ABC
01234
23\\1234ABCD
Los enteros son el primer tipo numérico en GEL. Los enteros se escriben de forma estándar.
3/4
1 3/10
El segundo tipo numérico de GEL son los racionales. Los números racionales se obtienen dividiendo dos enteros. De modo que se puede escribir:
1.315
7.887e77
7.887e-77
.3
0.3
77e5
El siguiente tipo numérico es el de coma flotante. Estos se especifican de un modo muy similar a la notación en C. Puedes usar
1+2i
8.01i
77*e^(1.3i)
El último tipo de números en GEL son los números complejos. Puede escribir un número complejo como la suma de su parte real y su parte imaginaria. Para agregar la parte imaginaria, escriba una
Al introducir números imaginarios, deba haber un número delante de la
Para usar notación de fracciones mixtas con números imaginarios debe colocar las fracciones mixtas entre paréntesis (ej.
Booleanos
Genius también soporta valores booleanos nativos. Las dos constantes booleanas están definidas como
Puede usar un valor booleano o cualquier expresión que produzca un número o valor booleano en cualquier lugar donde se espera una expresión Booleana. Si Genius necesita evaluar un valor numérico como un valor booleano interpretará «0» como
( (1 + true) - false ) * true
( (true or true) or not false ) and true
1 == true
Además, puede efectuar operaciones con valores booleanos. Por ejemplo:
Cadenas
a=2+3;«El resultado es: »+a
El resultado es: 5
"Barra: \\\\ Comillas: \\" Tabulaciones: \ 1\ 2\ 3"
Barra: \\ Comillas: " Tabulaciones: 1 2 3
Al igual que los números y los booleanos, las cadenas en GEL se pueden almacenar como valores dentro de variables y pasárselas a funciones. Puede concatenar una cadena con otra cadena mediante el operador «+». Por ejemplo:
string(22)
"22"
Además, puede usar la función
Nulo
Existe un valor especial llamado
x=5;.
x=5;
Ejemplo:
Algunas funciones devuelven
Usar variables
NombreVariable
Sintaxis:
Para evaluar una variable por sí misma, simplemente introduzca el nombre de la variable. Esto devolverá el valor de la variable. Puede usar una variable en cualquier lugar donde pueda utilizar un número o cadena. Además, las variables son necesarias al definir funciones que toman argumentos (consulte la
Usar completado con el tabulador
Puede usar el completado con el tabulador para que Genius complete nombres de las variables. Intente escribir las primeras letras del nombre de la variable y pulse
Los nombres de variables son sensibles a la capitalización
Los nombres de variables son sensibles a la capitalización. Esto significa que las variables
Configurar variables
x = 3
x := 3
Sintaxis:
a = b = 5
Para asignar un valor a una variable, use los operadores
Los operadores
Para temas relacionados con el ámbito de las variables, consulte la
Variables integradas
GEL tiene un número de «variables» predeterminadas, tales como
Resultado de la variable anterior
Ans+389
Las variables
Usar funciones
NombreFuncion(argumento1, argumento2, ...)
Factorial(5)
cos(2*pi)
gcd(921,317)
Sintaxis:
Hay muchas funciones integradas, como
Puede usar completado con el tabulador para que Genius complete nombres de funciones. Pruebe a escribir las primeras letras del nombre y pulse
Los nombres de las funciones son sensibles a mayúsculas.
Los nombres de las funciones son sensibles a la capitalización. Esto significa que las funciones
Definir funciones
Sintaxis:
function addup(a,b,c) = a+b+c
Una función toma cero o más argumentos separados por comas y devuelve el resultado del cuerpo de dicha función. Definir funciones propias es primordialmente una cuestión de conveniencia; un posible uso es tener un conjunto de funciones definidas en archivos GEL que Genius pueda cargar para tenerlas disponibles. Ejemplo:
Listas de argumentos de variables
function f(a,b...) = b
Si se incluye
Pasar funciones a funciones
En Genius es posible pasar una función como argumento de otra función. Esto se puede hacer usando «nodos de funciones» o funciones anónimas.
function f(a,b) = a(b)+1;
function b(x) = x*x;
f(b,2)
Si no se escriben los paréntesis después del nombre de la función, en lugar de evaluarse, la función se devolverá como un «nodo función». El nodo función se puede pasar a como argumento a otra función. Ejemplo:
function f(a,b) = a(b)+1;
f(`(x) = x*x,2)
Para pasar funciones que no están definidas se puede hacer uso de la función anónima (consulte la
Operaciones con funciones
exp(sin*cos+4)
`(x) = exp(sin(x)*cos(x)+4)
f = exp(sin*cos+4)
LinePlot(sin^2)
Algunas funciones permiten operaciones aritméticas y algunos argumentos de función tales como
No todas las funciones se pueden usar de este modo. Por ejemplo, cuando usa una función binaria las funciones deben aceptar el mismo número de argumentos.
Valor absoluto / módulo
|a-b|
Puede calcular el valor absoluto de algo encerrándolo entre
En el caso de que la expresión sea un número complejo el resultado será su módulo (distancia desde el origen). Por ejemplo:
Separador
3 ; 5
En GEL, si quiere escribir más de un comando debe usar el operador
Esto requiere poner algunos paréntesis para evitar ambigüedades, especialmente si el carácter
Comentarios
# Esto es un comentario
# cada línea debe empezar por una almohadilla
# en la siguiente línea se establece el valor de x a 123
x=123;
GEL es similar a otros lenguajes de scripts en el sentido de que
Evaluación modular
2^(5!) * 3^(6!) mod 5
Genius implementa aritmética modular. Para usarla, simplemente añada «mod &lt;enterogt;» después de la expresión. Ejemplo:
10^-1 mod 101
1/10 mod 101
A = [1,2;3,4]
B = A^-1 mod 5
A*B mod 5dar nombres
Dados dos números enteros a y b, puede calcular el inverso multiplicativo de a módulo b usando números racionales (desde luego, el inverso debe existir). Ejemplos:
geniusgt; sqrt(4) mod 7
=
[2, 5]
geniusgt; 2*2 mod 7
= 4
Algunas funciones como
No concatene operadores mod, solo colóquelos al final del cálculo, todos los cálculos en la expresión que está a la izquierda se llevarán a cabo bajo aritmética mod. Si coloca un operador mod dentro de un mod seguramente obtendrá resultados inesperados. Si solo quiere aplicar mod a un único número y controlar cuándo se toma el resto, es mejor utilizar el operador
Lista de operadores GEL
Todo en GEL es en realidad una expresión. Las expresiones se encadenan unas tras otras mediante diferentes operadores. Como hemos visto, incluso el separador es un operador binario en GEL. A continuación se muestra una lista de los operadores en GEL.
a;b
El separador evalúa
a=b
El operador asignación. Asigna
a:=b
El operador asignación. Asigna
|a|
Valor absoluto o módulo (si
Consulte
a^b
Exponenciación, eleva
a.^b
Potencia elemento a elemento. Eleva cada elemento de una matriz
a+b
Adición. Suma dos números, matrices, funciones o cadenas. Si suma una cadena a cualquier valor el resultado es una cadena. Si uno de ellos es una matriz cuadrada y el otro un número, el número se multiplica por la identidad de la matriz.
a-b
Sustracción. Resta dos números, matrices o funciones.
a*b
Multiplicación. Es la multiplicación normal de matrices.
a.*b
Multiplicación elemento a elemento si
a/b
División. Cuando
a./b
División elemento por elemento. Igual que
a\\b
División hacia atrás. Es lo mismo que
a.\\b
División hacia atrás elemento por elemento.
a%b
El operador mod. No activa el
a.%b
Operador mod elemento por elemento. Devuelve el resto de
a mod b
Operación de evaluación modular. La expresión
a!
Operador factorial. Esto es
a!!
Operador doble factorial. Esto es
a==b
Operador de igualdad, devuelve
a!=b
Operador de desigualdad, devuelve
alt;gt;b
Operador distinto alternativo devuelve
alt;=b
Operador menor o igual, devuelve
agt;=b
Operador mayor o igual, devuelve
alt;b
Operador menor que, devuelve
agt;b
Operador mayor que, devuelve
alt;=gt;b
Operador de comparación. Si
a and b
AND lógico. Devuelve cierto si
a or b
OR lógico. Devuelve cierto si
a xor b
X-OR lógico. Devuelve cierto si
not a
NOT lódico. Devuelve la negación lógica de
-a
Operador de negación. Devuelve el negativo de un número o una matriz (en una matriz, funciona de acuerdo al elemento)
&a
Referencia de variables (pasar una referencia a una variable). Consulte
*a
Desreferenciar una variable (para acceder a una variable referenciada). Consulte la
a'
Transpuesta conjugada de una matriz. Significa que las filas y columnas se intercambian y se toman la conjugada compleja de todas las entradas. Esto es, si el elemento i,j de
a.'
Transpuesta de matriz, no conjuga las entradas. Esto significa, el elemento i,j de
a@(b,c)
Devuelve el elemento en la fila
a@(b,)
Devuelve la fila de la matriz (o múltiples filas si
a@(b,:)
Igual que el anterior
a@(,c)
Devuelve la columna de la matriz (o columnas si
a@(:,c)
a@(b)
Obtiene un elemento de una matriz tratándola como vector. Recorre la matriz por filas.
a:b
A@(2:4,)
 
Crea un vector con valores de
a:b:c
geniusgt; 1:2:9
=
`[1, 3, 5, 7, 9]
Crea un vector con valores desde
(a)i
(a)*1i
 
Crea un número imaginario (multiplicando
`a
Escapa un identificador de modo que no sea evaluado. O escapa una matriz de modo que no sea expandida.
a swapwith b
Intercambia el valor de
increment a
Incrementa la variable
increment a by b
Incrementa la variable
El operador @() hace el operador «:» más útil. Con éste puede especificar regiones dentro de una matriz. De modo que a@(2:4,6) representa las filas 2, 3 y 4 de la columna 6. O @(,1:2) devuelve las dos primeras columnas de una matriz. Puede asignar al operador @() siempre que el valor sea una matriz cuyo tamaño coincida con el tamaño de la región asignada o cualquier otro tipo de valor.
Los operadores de comparación (excepto el operador &lt;=gt; que se comporta de un modo normal), no son estrictamente operadores binarios, de hecho pueden agruparse de una forma matemática estándar, por ejemplo: (1lt;xlt;=ylt;5) es una expresión booleana válida y significa lo que debería, es decir, (1lt;x and x≤y and ylt;5)
El operador unario «menos» opera de un modo distinto dependiendo del lugar donde aparece. Si lo hace antes de un número su prioridad es muy alta. Si aparece delante de una expresión tendrá menos prioridad que los operadores potencia y factorial. De este modo, por ejemplo,
Programar con GEL
Condicionales
Sintaxis:
if a=5 then a=a-1
if a==5 then a:=a-1
Ejemplos:
Bucles
Bucles «while»
Sintaxis:
Bucles «for»
for i = 1 to 20 by 2 do print(i)
Sintaxis:
for x = 0 to 1 by 0.1 do print(x)
for x = 0 to 1 by 1/10 do print(x)
Cuando uno de los valores es un número de coma flotante, la verificación final se realiza con un paso de de 2 ^ -20. Es decir, incluso si se sobrestima 2 ^ -20 veces el «por» por encima, todavía se ejecuta la última iteración. De este modo
Bucles «foreach»
for n in [1,2:3,4] do print(n)
for n in RowsOf ([1,2:3,4]) do print(n)
Sintaxis:
Parar y continuar
También puede utilizar los comandos
Sumas y productos
Sintaxis:
Si no se ejecuta ningún comando (por ejemplo
Para los números en coma flotante el redondeo de protección de errores se realiza como en el bucle for. Consulte la
Operadores de comparación
Los siguientes operadores de comparación comunes están soportados en GEL, y tienen el significado obvio:
if a=b then c
if a==b then c
Generalmente
No todos los operadores de comparación (salvo el operador
Para construir expresiones lógicas utilice las palabras
Variables globales y ámbito de variables
GEL es un
function f() = (a:=5; g());
function g() = print(a);
f();
Al igual que la mayoría de los lenguajes de programación, GEL tiene diferentes tipos de variables. Normalmente, cuando se define una variable en una función ésta es visible desde esa función y desde todas las funciones que se llamen (todos los contextos superiores). Por ejemplo, suponga que una función
function f() = (a:=5; g());
function g() = print(a);
a:=10;
f();
Si define una variable dentro de una función, ésta anulará toda variable definida al llamar a funciones. Por ejemplo, si modifica el código anterior y escribe:
Los argumentos de funciones son exactamente como variables definidas dentro de la función, salvo que éstas se inicializan con el valor que se introduce en la función. Además de esto, se les trata como a cualquier otra variable definida dentro de la función.
Las funciones se tratan exactamente como variables. Por lo tanto, puede redefinir funciones. Normalmente, (en el nivel superior) no puede redefinir variables y funciones protegidas. Pero localmente si lo puede hacer. Considere la siguiente sesión:
a=6;
function f() = (a:=5);
f();
set(`a,3)
set("a",3)
Las funciones definidas en el nivel superior se consideran globales. Éstas son visibles desde cualquier parte. Como se dijo, la función
La función
Para recapitular en un lenguaje más técnico: Genius opera con diferentes contextos numerados. El nivel más alto es el contexto 0 (cero). Siempre que se introduce una función , el contexto aumenta, y cuando la función devuelve su resultado el contexto disminuye. Siempre se puede ver una función o una variable desde los contextos mayores. Cuando una variable se define en un contexto menor, al fijar esta variable se crea una nueva variable local en el contexto actual y esta variable sera visible desde los contextos mayores.
También existen variables locales, que sólo pueden ser vistas desde el contexto actual. Cuando se devuelven funciones por un valor se pueden referenciar variables que no son visibles desde un contexto mas alto y esto puede ser problemático. Consulte las secciones
Variables de parámetros
Como se dijo, existen variables especiales llamadas parámetros. Éstas existen en todos los ámbitos. Para declarar un parámetro llamado
Cuando define un parámetro utilizando la función
Algunos parámetros están integrados de manera predeterminada y modifican el comportamiento de genius.
Retorno
Normalmente, una función se compone de una o varias expresiones separadas con punto y coma, y se devuelve el valor de la última expresión. Esto resulta útil en funciones sencillas, pero algunas veces no querrá que una función devuelva el resultado del último cálculo. Podría, por ejemplo, preferir que ésta devolviera algún valor obtenido a la mitad de la función. En este caso, puede utilizar la palabra
Referencias
Para algunas funciones puede ser necesario devolver más de un valor. Esto se puede lograr al devolver un vector de valores, pero muchas veces resulta conveniente pasar una referencia a una variable. Puede pasar una referencia a una variable a una función, y la función fijará el valor, eliminando una referencia. Aunque éste es el principal uso de las referencias, no es el único.
Cuando se utilizan funciones que devuelven valores a través de referencias en la lista de argumentos, pase solo el nombre de la variable con un ampersand (amp;). Por ejemplo, el siguiente código calcula el valor propio de una matriz
La manera como funcionan las referencias y la sintaxis que utilizan son similares al lenguaje C. El operador
Las referencias se pueden explicar mejor utilizando un ejemplo:
Lvalues
a
Identificador. Aquí se asignará la variable de nombre
Eliminar la referencia a un identificador. Esto fijará lo que a lo que apunta la variable
a@(lt;regiongt;)
Región de una matriz. Aquí, la región normalmente se especifica como con el operador regular @(), y puede ser un sola entrada, o una región completa de una matriz.
Un lvalue es el lado izquierdo the una asignación. En otras palabras, un lvalor es lo que se le asigna a algo. Algunos lvalues válidos son:
a:=4
*tmp := 89
a@(1,1) := 5
a@(4:8,3) := [1,2,3,4,5]'
Ejemplos:
Programación avanzada con GEL
Control de errores
Si detecta un error en su función, puede salir de ella. Para errores normales, como argumentos del tipo equivocado, puede impedir que se calcule el resultado de la función al agregar la frase
function f(M) = (
 if not IsMatrix (M) then (
 error ("M no es una matriz");
 bailout
 );
 ...
)
Por ejemplo, si quiere verificar argumentos en una función. Podría utilizar el siguiente código:
Sintaxis de nivel superior
Cuando se indroduce una sentencia en el nivel más alto, la sintaxis es distinta a la que se utiliza cuando se introduce entre paréntesis o dentro de una función. En el nivel más alto la tecla «Intro» tiene el mismo efecto que al pulsarla en la línea de comandos. Piense en un programa como una secuencia de líneas introducidas en la línea de comandos. En particular, no necesita introducir el separador al final de la línea (salvo que sea parte de varias sentencias dentro de paréntesis).
if Algo() then
 HacerAlgo()
else
 HacerOtraCosa()
El siguiente código, aunque funcione bien en la función, puede producir un error al introducirlo en el nivel más alto de un programa.
if Algo() then (
 HacerAlgo()
) else (
 HacerOtraCosa()
)
El problema es que, después que la
Devolver funciones
function f() = (
 k = 5;
 `(x) = (x+k)
)
g = f();
g(5)
Es posible devolver funciones como un valor. De esta manera puede construir funciones que construyan otras funciones con propósitos específicos de acuerdo a ciertos parámetros. La parte complicada es determinar qué variables ve la función. La manera en que esto funciona en GEL es la siguiente: cuando una función devuelve otra función, todos los identificadores que referencia el cuerpo de la función que sale del ámbito son antepuestos al diccionario privado de la función devuelta. Por lo tanto, la función verá todas las variables que estaban en el ámbito cuando fue definida. Por ejemplo, la siguiente función devuelve una función que agrega 5 al valor de su argumento:
function f() = (
 k := 5;
 function r(x) = (x+k);
 k := 10;
 r
)
Algo que conviene tener en cuenta es que el valor de
function f() = (
 k := 5;
 function r(x) [k] = (x+k);
 k := 10;
 r
)
Algunas veces es mejor tener más control sobre cómo las variables se copian al diccionario privado. Desde la versión 1.0.7 puede especificar qué variables se copian al diccionario privado colocando corchetes adicionales después de los argumentos con la lista de variables que se desean copiar separadas con comas. Si hace esto, las variables se copiarán al diccionario privado en el momento que se define la función, y no se tocará el diccionario privado después de esto. Por ejemplo,
function f() = (
 k := 5;
 function r(x) [] = (x+k);
 r
);
k := 10;
g = f();
g(10)
Cuando quiera que la función no tenga un diccionario privado escriba un par de corchetes vacíos después de la lista de argumentos. Con esto no se creará ningún diccionario privado. Hacer esto es útil para incrementar la eficiencia cuando no se necesita un diccionario privado o cuando quiere que la función busque todas las variables cuando las ve al momento que se la llama. Por ejemplo, suponga que quiere que la función que devuelve
Variables locales verdaderas
k := 10;
function r(x) = (x+k);
function f(g,x) = (
 k := 5;
 g(x)
);
f(r,1)
Cuando se pasa una función a otras funciones, la manera predeterminada en que se determinan los ámbitos de las variables puede no ser la que quiere. Por ejemplo:
function f(g,x) = (
 local g,x,k;
 k := 5;
 g(x)
);
Pero hay otra solución. Desde la versión 1.0.7 existen variables locales verdaderas. Éstas son variables que son visibles sólo desde el contexto actual y no desde ninguna función que se llame. Se podría definir
function f(g,x) = (
 local *;
 k := 5;
 g(x)
);
Si todas las variables se crean localmente, puede pasar un asterisco en lugar de una lista de variables. En este caso las variables no se inicializarán hasta que se fijen, desde luego. Entonces, la siguiente definición de
Es bueno que todas las funciones que toman otras funciones como argumentos utilicen variables locales. De esta manera las funciones que pasan no ven los detalles de la implementación y luego no se confunden.
Procedimiento de inicio de GEL
Primero, el programa busca el archivo de la biblioteca instalada (la versión compilada
Si alguna vez cambia el lugar donde está instalada la biblioteca, primero deberá compilarla con el comando
Cargar programas
load programa1.gel programa2.gel
load "Nombre raro de archivo con ESPACIOS.gel"
cd «carpeta_con_programas_gel»
ls *.gel
Algunas veces tiene un programa más largo que escribió en un archivo y quiere leer dicho archivo. En estas situaciones tiene dos opciones. Puede conservar las funciones que más usa en el archivo
Matrices en GEL
Genius tiene soporte para vectores y matrices y una biblioteca dimensionable para manipulación de matrices y funciones de álgebra lineal.
Introducir matrices
[1,2,3;4,5,6;7,8,9]
[1, 2, 3
 4, 5, 6
 7, 8, 9]
Para introducir matrices, puede utilizar cualquiera de las dos sintaxis que siguen. Puede introducir la matriz en una línea, separando los valores con comas y las filas con un punto y coma. También puede introducir cada fila en una línea, separando los valores con comas. También puede combinar los dos métodos. Para introducir una matriz de 3x3 con los números 1 a 9 podría hacer lo siguiente:
a = [ 1, 2, 3
 4, 5, 6
 7, 8, 9]
b = [ a, 10
 11, 12]
[1, 2, 3, 10
 4, 5, 6, 10
 7, 8, 9, 10
 11, 11, 11, 12]
También puede utilizar la funcionalidad de expandir matrices para introducir una matriz. Por ejemplo puede hacer lo siguiente:
[1, 2, 3
 4, 5
 6]
[1, 2, 3
 4, 5, 0
 6, 0, 0]
Otra cosa es que se los puntos no especificados se inicialicen a 0, por lo que
Cuando las matrices se evalúan y se recorre fila por fila, justo como el operador
Tenga cuidado al utilizar «return» en expresiones dentro de corchetes
Conjugada de la traspuesta y operador de trasposición
[1,2,3]*[4,5,6]'
[1,2,3]*[4,5,6i].'
Puede calcular la matriz traspuesta conjugada de una matriz utilizando el operador
Observe que la matriz traspuesta, esto es la que se calcula utilizando el operador
Álgebra lineal
Genius implementa varias rutinas útiles para manipular álgebra lineal y matrices. Consulte las secciones
Las rutinas de álgebra lineal implementadas en GEL no ofrecen actualmente un paquete numérico bien probado, por lo que no se deberían utilizar para cálculos numéricos críticos. Por otro lado, Genius implementa muy bien muchas operaciones de álgebra lineal con coeficientes racionales y enteros. Éstas son intrínsecamente exactas y, de hecho, dan resultados mucho mejores que las rutinas comunes de doble precisión para álgebra lineal.
Por ejemplo, no tiene sentido calcular el rango y el espacio nulo de una matriz en coma flotante, ya que para todos los fines prácticos, se debe tener en cuenta que la matriz puede tener algunos errores pequeños. Es posible que se obtenga un resultado diferente al esperado. El problema es que con una perturbación pequeña cualquier matriz es de rango completo e invertible. Sin embargo, si la matriz se compone de números racionales, entonces el rango y el espacio nulo serán siempre exactos.
En general, cuando Genius calcula la base de un espacio vectorial determinado (por ejemplo con la función
Cabe señalar que Genius puede recordar ciertas propiedades de una matriz. Por ejemplo, se recordará si una matriz está en su forma reducida por filas. Si se hacen muchas llamadas a funciones que utilizan internamente la forma reducida por filas de una matriz, se puede reducir por filas la matriz previamente una sola vez. Las llamadas sucesivas a la función
Polinomios en GEL
Actualmente, Genius puede manipular polinomios de una variable escritos como vectores y realizar algunas operaciones básicas con ellos. Se prevé ampliar este soporte adicional.
Usar polinomios
[1,2,3]
1 + 2*x + 3*x^2
Actualmente, los polinomios de una variable son vectores horizontales con valores como nodos. La potencia del término es la posición en el vector, con la primera posición siendo 0. Por lo tanto,
PolyToString([1,2,3],"y")
3*y^2 + 2*y + 1
f = PolyToFunction([0,1,1])
f(2)
Se pueden sumar, restar y multiplicar polinomios utilizando las funciones
También es posible encontrar raíces de los polinomios de grado 1 a 4 mediante el uso de la función
Consulte la
Teoría de conjuntos en GEL
Genius incorpora un juego básico de funcionalidades teoréticas. En la actualidad, un conjunto es sólo un vector (o una matriz). Cada objeto distinto se trata como un elemento diferente.
Usar conjuntos
Al igual que los vectores, los objetos en conjuntos pueden incluir números, cadenas,
Para construir un conjunto fuera de un vector, use la función
Del mismo modo hay funciones que se explican por si mismas como
Para los miembros del equipo de pruebas, hay funciones
Lista de funciones GEL
help NombreFuncion
Para obtener ayuda sobre una función específica desde la consola, escriba:
Comandos

help
ayuda NombreFunción
Imprimir ayuda (o ayuda en una función/comando).

load «archivo.gel»
Cargar un archivo en el intérprete. El archivo se ejecutará como si se hubiera escrito en la línea de comandos.

cd /carpeta/nombre
Cambiar la carpeta de trabajo a

pwd
Imprimir la carpeta de trabajo actual.

ls
Listar archivos en la carpeta actual.

plugin nombre_del_complemento
Cargar un complemento. El complemento debe estar instalado en el sistema en la carpeta adecuada.
Básico

AskButtons (consulta)
AskButtons (consulta, botón1, ...)
Hace una pregunta y presenta una lista de botones para el usuario o un menú de opciones en modo texto). Devuelve el índice en base a 1 de la tecla pulsada. Esto es, devuelve 1 si se presiona la primera tecla, 2 si es la segunda, y así sucesivamente. Si el usuario cierra la ventana (o simplemente entra en modo texto), entonces devuelve la constante

AskString (consulta)
AskString (consulta, predeterminado)
Hace una pregunta y deja al usuario que introduzca una cadena que luego devuelve. Si el usuario cancela o cierra la ventana, entonces se devuelve la constante

Compose (f,g)
Componer dos funciones y devolver una función, que es la composición de

ComposePower (f,n,x)
Compone y ejecuta una funcion con ella misma

Evaluate (cadena)
Analiza y evalúa una cadena.

GetCurrentModulo
Obtener el módulo actual desde fuera del contexto de la función. Esto significa que, si fuera de la función se ejecutó en módulo (utilizando

Identity (x)
Función identidad, devuelve su argumento.

IntegerFromBoolean (bval)
Hacer entero (0 para

IsBoolean (arg)
Comprobar si el argumento es un booleano (y no un número).

IsDefined (id)
Comprobar si un identificador está declarado. Pase una cadena o un identificador. Si pasa una matriz, cada entrada se evaluará por separado y la matriz contendrá cadenas o identificadores.

IsFunction (arg)
Comprobar si el argumento es una función.

IsFunctionOrIdentifier (arg)
Comprobar si el argumento es una función o un identificador.

IsFunctionRef (arg)
Comprobar si el argumento es una referencia a la función. Esto incluye las referencias a variables.

IsMatrix (arg)
Comprobar si el argumento es una matriz. Si bien

IsNull (arg)
Comprobar si el argumento es

IsString (arg)
Comprobar si el argumento es una cadena de texto.

IsValue (arg)
Comprobar si el argumento es un número.

Parse (cadena)
Comprobar pero no evaluar una cadena. Tenga en cuenta que algunos cálculos internos se realizan durante el análisis.

SetFunctionFlags (id,opciones...)
Establece opciones para una función, actualmente

SetHelp (id,categoria,desc)
Establece la categoría y la línea de descripción de la ayuda para una función.

SetHelpAlias (id,alias)
Establece un alias de ayuda.

chdir (carpeta)
Cambia la carpeta actual, igual que

CurrentTime
Devuelve la hora UNIX actual con una precisión de microsegundos, como un número en coma flotante. Esto es, devuelve el número de segundos desde el 1 de enero de 1970.

display (cadena,expresión)
Muestra una cadena y una expresión separadas por dos puntos.

DisplayVariables (var1,var2,...)
DisplayVariables(`x,`y,`z)
 
Muestra la configuración de variables. Las variables pueden ser cadenas o identificadores. Por ejemplo: <placeholder\-1>
DisplayVariables()
 
Si se llama sin argumentos (debería suministrar una lista vacía de argumentos) como <placeholder\-1> entonces todas las variables se imprimirán incluyendo una lista de llamadas similar a

error (cadena)
Imprime un error en el flujo de error (en la consola).

exit
Aliases:
Sale el programa.

false
Alias:
El valor booleano

manual
Muestra el manual de usuario.

print (cadena)
Imprime una expresión y luego una nueva línea. El argumento

printn (cad)
Imprime una expresión sin un carácter de nueva línea. El argumento

PrintTable (f,v)
PrintTable (f,[0:10])
 
Imprime una tabla de valores para una función. Los valores están en el vector

protect (id)
Puede proteger una variable de ser modificada. Esto se usa en las funciones de GEL internas para evitar que se sobreescriban accidentalmente.

ProtectAll ()
Protege todas la variables actuales definidas, parámetros y funciones desde que se modificaron. Se utiliza por las funciones GEL para impedir accidentalmente que se sobrescriba. Normalmente la

set (id,val)
set(`x,1)
 
Establecer una variable global. La variable

string (s)
Crear una cadena. Esto creará una cadena desde cualquier argumento.

true
Alias:
El valor booleano

undefine (id)
Alias:
Elimina la definición de una variable. Esto incluye variables locales y globales, cada valor se limpia en toda su dimensión. Esta función no se usa en variables locales. Se puede usar un vector de identificadores para eliminar la definición de varias variables a la vez.

UndefineAll ()
Elimina la definición de todas las variables desprotegidas globales (incluyendo funciones y parámetros). La

unprotect (id)
Desproteger una variable de ser modificada.

UserVariables ()
Devolver un vector con todos los nombres de variables globales definidas por el usuario (sin proteger).

wait (secs)
Esperar un número específico de segundos.

version
Devuelve la versión de Genius como un vector horizontal de tres argumentos en el que el primero es la versión mayor, le sigue menor versión y la revisión en último lugar.

warranty
Da la información de garantía.
Parámetros

ChopTolerance = número
Tolerancia de la función

ContinuousNumberOfTries = número
Iteraciones para tratar de obtener el límite de continuidad y sus límites.

ContinuousSFS = número
Número de pasos sucesivos dentro de la tolerancia para el cálculo de la continuidad.

ContinuousTolerance = número
Tolerancia para la continuidad de las funciones y para el cálculo del límite.

DerivativeNumberOfTries = número
Número de iteraciones para tratar de obtener el límite para la derivada.

DerivativeSFS = número
Número de pasos sucesivos dentro de la tolerancia para el cálculo de la derivada.

DerivativeTolerance = número
Tolerancia para calcular las derivadas de las funciones.

ErrorFunctionTolerance = número
Tolerancia de

FloatPrecision = número
Precisión en coma flotante.

FullExpressions = booleano
Imprimir expresiones completas, incluso si son de más de una línea.

GaussDistributionTolerance = número
Tolerancia de la función

IntegerOutputBase = número
Base de salida de enteros.

IsPrimeMillerRabinReps = número
Número de tests de Miller-Rabin adicionales que ejecutar sobre un número antes de declararlo primo en

LinePlotDrawLegends = true
Le dice a Genius cómo dibujar las leyendas para las

LinePlotDrawAxisLabels = true
Le dice a Genius que dibuje las etiquetas de los ejes cuando se utilizan

LinePlotVariableNames = ["x","y","z","t"]
Le dice a Genius qué nombres de variable se usan como nombres predeterminados para

LinePlotWindow = [x1,x2,y1,y2]
Establece los límites para las

MaxDigits = número
Máximo de cifras que mostrar.

MaxErrors = número
Máximo de errores que mostrar.

MixedFractions = booleano
Si es cierto, las fracciones mixtas se imprimen.

NumericalIntegralFunction = función
La función usada para la integración en

NumericalIntegralSteps = número
Pasos que realizar en

OutputChopExponent = número
Cuando otro número que se imprime en el objeto (una matriz o un valor) es mayor que 10
La salida nunca se corta si
Si quiere que la salida siempre se corte según

OutputChopWhenExponent = número
Cuando recortar la salida. Consulte

OutputStyle = cadena
Estilo de salida, puede ser
OutputStyle = "latex"
Esto afecta principalmente a cómo las matrices y fracciones se imprimen y es útil para pegar en los documentos. Por ejemplo, puede configurarlo en LaTeX usando:

ResultsAsFloats = booleano
Convertir todos los resultados a flotantes antes de imprimir.

ScientificNotation = booleano
Usar notación científica.

SlopefieldTicks = [vertical,horizontal]
Establece el número de pasos verticales y horizontales en un diagrama de pendientes. (Consulte

SumProductNumberOfTries = número
Cuántas iteraciones probar para

SumProductSFS = número
La cantidad de pasos consecutivos para estar dentro de los límites para

SumProductTolerance = número
Tolerancia para

SurfacePlotDrawLegends = true
Le dice a Genius cómo dibujar las leyendas para las

SurfacePlotVariableNames = ["x","y","z"]
Indica a Genius los nombres de variables que se usan como nombres predeterminados para las

SurfacePlotWindow = [x1,x2,y1,y2,z1,z2]
Establece los límites de la superficie de dibujado (consulte

VectorfieldNormalized = true
Indica si la longitud de las flechas tendrá un tamaño normalizado en el trazado dentro del campo vectorial. Si es cierto, en el campo vectorial solo aparecerá la dirección y no la magnitud. (Consulte

VectorfieldTicks = [vertical,horizontal]
Establece el número de pasos verticales y horizontales en un gráfico de campo de vectores. (Observe
Constantes

CatalanConstant
Constante de Catalan, aproximadamente 0,915... Se define para las series donde los términos son
Consulte la

EulerConstant
Alias:
Constante gamma de Euler. También llamada constante de Euler-Mascheroni,
Consulte la

GoldenRatio
El número áureo.
Consulte la

Gravedad
Aceleración en caída libre a nivel del mar.
Consulte la

e
La base del logaritmo natural.
Consulte la

pi
El número pi, que es la relación de la circunferencia de un círculo con su diámetro. Esto es aproximadamente 3,14159265359...
Consulte la
Numérico

AbsoluteValue (x)
Alias:
Valor absoluto de un número y, si
Consulte la

Chop (x)
Reemplazar números muy pequeños por cero.

ComplexConjugate (z)
Alias:
Calcula el conjugado complejo del número complejo
Consulte la

Denominator (x)
Obtener el denominador de un número racional.
Consulte la

FractionalPart (x)
Devolver la parte fraccional de un número.
Consulte la

Im (z)
Alias:
Obtener la parte imaginaria de un número complejo.
Consulte la

IntegerQuotient (m,n)
División sin resto.

IsComplex (num)
Comprobar si el argumento es un número complejo (no real).

IsComplexRational (num)
Comprobar si el argumento es, posiblemente, un número racional complejo. Esto es, si tanto la parte real como la imaginaria se dan como números racionales. Por supuesto, racional significa simplemente que «no se almacena como un número en coma flotante».

IsFloat (num)
Comprobar si el argumento es un número en coma flotante (no complejo).

IsGaussInteger (num)
Alias:
Comprobar si el argumento es un posible entero complejo.

IsInteger (num)
Comprobar si el argumento es un entero (no complejo).

IsNonNegativeInteger (num)
Comprobar si el argumento es un entero real no negativo.

IsPositiveInteger (num)
Alias:
Comprueba si el argumento es un entero real positivo. Tenga en cuenta que se acepta el convenio de que 0 no es un número natural.

IsRational (num)
Comprobar si el argumento es un número racional (no complejo). Por supuesto, racional significa «no almacenado como un número en coma flotante».

IsReal (num)
Comprobar si el argumento es un número real

Numerator (x)
Obtener el numerador de un número racional.
Consulte la

Re (z)
Alias:
Obtener la parte real de un número complejo.
Consulte la

Sign (x)
Alias:
Devolver el signo de un número. Devuelve

ceil (x)
Alias:
Obtener el menor número entero mayor o igual a
Tenga en cuenta que los números en coma flotante se almacenan en binario y que puede que el resultado no sea lo que espera. Por ejemplo

exp (x)
La función exponencial. Esto es la función
Consulte la

float (x)
Convertir un número en un valor en coma flotante. Esto devuelve la representación en coma flotante del número

floor (x)
Alias:
Obtener el entero más alto menor o igual que

ln (x)
El logaritmo natural, logaritmo en base

log (x)
log (x,b)
Logaritmo de

log10 (x)
Logaritmo de

log2 (x)
Alias:
Logaritmo de

max (a,args...)
Alias:
Devuelve el máximo de los argumentos o las matrices.

min (a,args...)
Alias:
Devuelve el mínimo de los argumentos o las matrices.

rand (tamaño...)
Generar valores en coma flotante aleatorios en el rango

randint (máx,tamaño...)
Generar número enteros aleatorios en el rango

round (x)
Alias:
Redondear un número.

sqrt (x)
Alias:
La raíz cuadrada. Cuando se opera con «módulo», algunos enteros devolverán un valor
Consulte

trunc (x)
Alias:
Truncar el número a un entero (devolver la parte entera)
Trigonometría

acos (x)
Alias:
La función arccos (inversa del cos).

acosh (x)
Alias:
La función arccosh (inversa del cosh).

acot (x)
Alias:
La función arccot (inversa de la cot)

acoth (x)
Alias:
La función arccoth (inversa de la coth).

acsc (x)
Alias:
La inversa de la función cosecante.

acsch (x)
Alias:
La inversa de la función cosecante hiperbólica.

asec (x)
Alias:
La inversa de la función secante.

asech (x)
Alias:
La inversa de la función secante hiperbólica.

asin (x)
Alias:
La función arcsen (inversa del sen).

asinh (x)
Alias:
La función arcsenh (inversa del senh).

atan (x)
Alias:
Calcula la función «arctan» (inversa de «tan»).
Consulte la

atanh (x)
Alias:
La función arctanh (inversa de la tanh).

atan2 (y, x)
Alias:
Calcula la función «arctan2». Si
Consulte la

cos (x)
Calcula la función coseno.
Consulte

cosh (x)
Calcula la función coseno hiperbólico.
Consulte

cot (x)
La función cotangente.

coth (x)
La función cotangente hiperbólica.

csc (x)
La función cosecante.

csch (x)
La función cosecante hiperbólica.

sec (x)
La función secante.

sech (x)
La función secante hiperbólica.

sin (x)
Calcula la función seno.

sinh (x)
Calcula la función seno hiperbólico.

tan (x)
Calcula la función tangente.

tanh (x)
La función tangente hiperbólica.
Teoría de números

AreRelativelyPrime (a,b)
¿Son los números reales
Consulte

BernoulliNumber (n)
Devolver el
Consulte la

ChineseRemainder (a,m)
Alias:
Encontrar la
Consulte la

CombineFactorizations (a,b)
Dadas dos factorizaciones, dar la factorización del producto.
Consulte la sección

ConvertFromBase (v,b)
Convertir un vector de valores mostrando potencias de b a un número.

ConvertToBase (n,b)
Convertir un número en un vector de potencias para elementos en base

DiscreteLog (n,b,q)
Encontrar el logaritmo discreto de
Consulte la

Divides (m,n)
Comprueba la divisibilidad (si

EulerPhi (n)
Calcular la función phi de Euler para
Consulte la

ExactDivision (n,d)
Devuelve

Factorize (n)
Devuelve la factorización de un número como una matriz. La primera fila son los números primos en la factorización (incluido el 1) y la segunda fila son las potencias. Por ejemplo:
Consulte la

Factors (n)
for n=1 to 1000 do (
 if MatrixSum (Factors(n)) == 2*n then
 print(n)
)
Devuelve todos los factores de

FermatFactorization (n,tries)
Probar la factorización de Fermat de
Es una buena factorización si su número es el producto de dos factores que están muy cerca.
Consulte la

FindPrimitiveElementMod (q)
Encontrar el primer elemento primitivo en F

FindRandomPrimitiveElementMod (q)
Encontrar un elemento primitivo aleatorio en F

IndexCalculus (n,b,q,S)
Calcula la base del logaritmo discreto

IndexCalculusPrecalculation (b,q,S)
Ejecuta los pasos para los cálculos previos de

IsEven (n)
Comprueba si un entero es par.

IsMersennePrimeExponent (p)
Comprueba si un entero positivo
Consulte la

IsNthPower (m,n)
Comprueba si un número racional

IsOdd (n)
Comprueba su un entero es impar.

IsPerfectPower (n)
Comprobar si un entero es una potencia perfecta, a

IsPerfectSquare (n)
Comprobar si un entero es un cuadrado perfecto de un entero. El número será un entero real. Los enteros negativos, por supuesto, no son perfectos cuadrados de enteros reales.

IsPrime (n)
Comprueba si dos números enteros son primos, para números menores que 2.5e10 la respuesta es determinista (si la hipótesis de Riemann es verdadera). Para números más grandes, la probabilidad de un falso positivo depende de
Si se devuelve
Consulte

IsPrimitiveMod (g,q)
Comprobar si

IsPrimitiveModWithPrimeFactors (g,q,f)
Comprobar si

IsPseudoprime (n,b)
Si

IsStrongPseudoprime (n,b)
Compruebe si

Jacobi (a,b)
Alias:
Calcular el símbolo de Jacobi (a/b) (b debe ser impar).

JacobiKronecker (a,b)
Alias:
Calcular el símbolo de Jacobi (a/b) con extensión de Kronecker (a/2)=(2/a) cuando sea impar, o (a/2)=0 cuando sea par.

LeastAbsoluteResidue (a,n)
Devuelve el resto de

Legendre (a,p)
Alias:
Calcular el símbolo de Legendre (a/p).
Consulte

LucasLehmer (p)
Compruebe si 2
Consulte la

LucasNumber (n)
Devuelve el
Consulte la

MaximalPrimePowerFactors (n)
Devuelve todos los factores primos de un número.

MersennePrimeExponents
Un vector de Mersenne de exponentes primos conocidos, esto es una lista de enteros positivos

MillerRabinTest (n,reps)
Utiliza la prueba de números primarios Miller-Rabin de
Consulte la

MillerRabinTestSure (n)
Utiliza la prueba Miller-Rabin de números primos de

ModInvert (n,m)
Devuelve el inverso de n módulo m.
Consulte

MoebiusMu (n)
Devuelve la función de Moebius «mu» de
Consulte

NextPrime (n)
Devuelve el primo menor más grande que
Esta función utiliza las GMP

PadicValuation (n,p)
Devuelve la evaluación del número «p-adic» (número de ceros que va dejando en base
Consulte

PowerMod (a,b,m)
Calcula

Prime (n)
Alias:
Devuelve el

PrimeFactors (n)
Devuelve todos los factores primos de un número como un vector.
Consulte

PseudoprimeTest (n,b)
Prueba de pseudo-primo, devuelve
Consulte

RemoveFactor (n,m)
Elimina todas las instancias del factor
Consulte

SilverPohligHellmanWithFactorization (n,b,q,f)
Buscar el logaritmo sencillo de

SqrtModPrime (n,p)
Buscar la raíz cuadrada de
Consulte

StrongPseudoprimeTest (n,b)
Ejecutar la prueba del pseudo-primo fuerte en base
Consulte

gcd (a,args...)
Alias:
Máximo común divisor de enteros. Puede introducir tantos enteros en la lista de argumentos, o puede introducir un vector o una matriz de enteros. Si introduce más de una matriz del mismo tamaño, entonces el máximo común divisor se realiza elemento a elemento.
Consulte

lcm (a,args...)
Alias:
Mínimo común múltiplo de enteros. Puede introducir tantos enteros en la lista de argumentos, o introducir un vector o matriz de enteros. Si introduce mas de una matriz del mismo tamaño, entonces el mínimo común múltiplo se realiza elemento a elemento.
Consulte
Manipulación de matrices

ApplyOverMatrix (a,func)
Aplicar una función sobre todos los elementos de una matriz y devolver una matriz con los resultados.

ApplyOverMatrix2 (a,b,func)
Aplicar una función sobre todos los elementos de dos matrices (o un valor y una matriz) y devolver una matriz con los resultados.

ColumnsOf (M)
Obtener las columnas de una matriz como un vector horizontal.

ComplementSubmatrix (m,r,c)
Eliminar filas y columnas de una matriz.

CompoundMatrix (k,A)
Calcular la k-ésima matriz compuesta de A.

CountZeroColumns (M)
Contar el número de cero columnas en una matriz. Por ejemplo una vez que su columna reduce una matriz puede usar esto para encontrar la nulidad. Consulte

DeleteColumn (M,col)
Eliminar una columna de una matriz.

DeleteRow (M,row)
Eliminar una fila de una matriz.

DiagonalOf (M)
Obtener las entradas diagonales de una matriz como un vector columna.
Consulte la

DotProduct (u,v)
Obtener el producto escalar de dos vectores. Los vectores serán del mismo tamaño. Se toman no conjugados por lo que tendrá forma bilineal incluso si se trabaja con números complejos.
Consulte

ExpandMatrix (M)
Expandir una matriz de la misma manera que hacemos con la entrada sin comillas de la matriz. Esto es, se expande cualquier matriz interna como bloques. Esto es una manera de construir matrices fuera de las mas pequeñas y se hace de manera automática en la entrada a menos que la matriz se entrecomille.

HermitianProduct (u,v)
Alias:
Obtener el producto de Hermitian de dos vectores. Los vectores serán del mismo tamaño. Esto es una forma «sesquilinear» para utilizar la identidad de la matriz.
Consulte

I (n)
Alias:
Devolver una matriz identidad del tamaño dado, es decir, de
Consulte

IndexComplement (vec,msize)
Devuelve el complemento índice de un vector de índices. Todo en base a uno. Por ejemplo para el vector

IsDiagonal (M)
Es una matriz diagonal.
Consulte la

IsIdentity (x)
Comprobar si una matriz es la matriz de identidad. Automáticamente devuelve

IsLowerTriangular (M)
Es una matriz triangular inferior. Esto es, todas las entradas están por encima de la diagonal cero.

IsMatrixInteger (M)
Comprobar si una matriz es una matriz de enteros (no compleja).

IsMatrixNonnegative (M)
Comprobar si una matriz no es negativa, es decir, si cada elemento no es negativo. No confunda matrices positivas con matrices semidefinidas positivas.
Consulte la

IsMatrixPositive (M)
Comprobar si una matriz es positiva, es decir, si cada elemento es positivo (y por lo tanto real). Individualmente, ningún elemento es 0. No confunda matrices positivas con matrices definidas positivas.

IsMatrixRational (M)
Comprobar si el argumento es una matriz de números racionales (no complejos)

IsMatrixReal (M)
Comprobar si el argumento es una matriz de números reales (no complejos).

IsMatrixSquare (M)
Comprobar si una matriz es cuadrada, es decir, si su altura es igual a su anchura.

IsUpperTriangular (M)
¿Es una matriz triangular superior?. Esto se cumple si todas las entradas por debajo de la diagonal son cero.

IsValueOnly (M)
Comprobar si una matriz es una matriz de sólo números. Muchas funciones internas hacen esta comprobación. Los valores pueden ser cualquier número, incluyendo números complejos.

IsVector (v)
Indica si el argumento de un vector es horizontal o vertical. Genius no distingue entre una matriz y un vector, y un vector es justo una matriz 1 por

IsZero (x)
Comprobar si una matriz está compuesta toda por ceros. También trabaja con números, en cualquier caso esto es equivalente a

LowerTriangular (M)
Devuelve una copia de la matriz

MakeDiagonal (v,arg...)
Alias:
Hacer una matriz diagonal desde un vector. Alternativamente puede pasarle los valores como argumentos para la diagonal. Así

MakeVector (A)
Hacer un vector columna fuera de la matriz colocando columnas una encima de la otra. Devuelve

MatrixProduct (A)
Calcular el producto de todos los elementos en una matriz o vector. Es decir, multiplicar todos los elementos y devolver un número que es el producto de todos los elementos.

MatrixSum (A)
Calcular la suma de todos los elementos en una matriz o vector. Es decir, sumar todos los elementos y devolver un número que es el resultado de la suma de todos los elementos.

MatrixSumSquares (A)
Calcular la suma de los cuadrados de todos los elementos en una matriz o vector.

NonzeroColumns (M)
Devuelve una fila vector de índices de columnas distintas de cero en la matriz

NonzeroElements (v)
Devuelve una fila vector de índices de elementos distintos de cero en el vector

OuterProduct (u,v)
Obtener el producto externo de dos vectores. Esto es, suponga que

ReverseVector (v)
Invierte el orden de los elementos de un vector (devuelve

RowSum (m)
Calcula la suma de cada fila de una matriz y devuelve el resultado en un vector vertical con el resultado

RowSumSquares (m)
Calcular la suma de los cuadrados de cada fila de una matriz y devolver una matriz columna con los resultados.

RowsOf (M)
Obtiene las filas de una matriz como un vector vertical. Cada elemento del vector es un vector horizontal que se corresponde con la fila de

SetMatrixSize (M,filas,columnas)
Hacer una nueva matriz del mismo tamaño que otra. Es decir, devolverá una nueva matriz con la copia de otra. Las entradas que no caben, se recortan y el espacio adicional se rellena con ceros. Si

ShuffleVector (v)
Mezcla los elementos de un vector (devuelve

SortVector (v)
Ordenar los elementos del vector en orden ascendente.

StripZeroColumns (M)
Quita todas las columnas de ceros de

StripZeroRows (M)
Quita todas las filas de ceros de

Submatrix (m,r,c)
Devolver columnas y filas desde una matriz. Esto es equivalente a

SwapRows (m,fila1,fila2)
Intercambiar dos columnas de una matriz.

UpperTriangular (M)
Devuelve una copia de la matriz

columns (M)
Obtener el número de columnas de una matriz.

elements (M)
Obtener el número total de elementos de una matriz. Es decir, el número de columnas por el número de filas.

ones (filas,columnas...)
Hacer una matriz rellena de unos (o un vector fila si sólo se introduce un argumento). Devuelve

rows (M)
Obtener el número de filas de una matriz.

zeros (filas,columnas...)
Hacer una matriz llena de ceros (o un vector fila si se introduce sólo un argumento). Devuelve

AuxiliaryUnitMatrix (n)
Obtener la matriz auxiliar de tamaño
Consulte

BilinearForm (v,A,w)
Evaluar (v,w) con respecto a la forma bilineal dada por la matriz A.

BilinearFormFunction (A)
Devolver una función que evalúa dos vectores con respecto a la forma bilineal dada por A.

CharacteristicPolynomial (M)
Alias:
Obtener el polinomio característico como un vector. Es decir, devuelve los coeficientes del polinomio empezando por el término constante. Este polinomio se define por
Consulte

CharacteristicPolynomialFunction (M)
Obtener el polinomio característico como una función. Es decir, el polinomio se define por

ColumnSpace (M)
Obtener una matriz base para el espacio de la columna de una matriz. Es decir, devuelve una matriz la cual las columnas son las bases para el espacio de la columna

CommutationMatrix (m, n)
Devolver la matriz de conmutación

CompanionMatrix (p)
Matriz acompañante de un polinomio (como vector).

ConjugateTranspose (M)
Conjugada traspuesta de una matriz (adjunta). Es lo mismo que el operador
Consulte

Convolution (a,b)
Alias:
Calcular la convolución de dos vectores horizontales.

ConvolutionVector (a,b)
Calcular la convolución de dos vectores horizontales. Devuelve el resultado como un vector y no se suman.

CrossProduct (v,w)
Producto cruzado de dos vectores en R

DeterminantalDivisorsInteger (M)
Obtiene determinantes divisores de una matriz de enteros (no su característica).

DirectSum (M,N...)
Suma directa de matrices.

DirectSumMatrixVector (v)
Suma directa de un vector de matrices.

Eigenvalues (M)
Alias:
Obtener los valores propios de una matriz cuadrada. En la actualidad solo funciona con matrices de tamaño 4 por 4 como máximo, o para matrices triangulares (cuyo valores propios están en la diagonal).
Consulte la

Eigenvectors (M)
Eigenvectors (M, &eigenvalues)
Eigenvectors (M, &eigenvalues, &multiplicities)
Obtener los autovectores de una matriz cuadrada. Opcionalmente, obtener los autovalores y su multiplicidad algebraica. Actualmente funciona sólo para matrices de hasta 2x2.
Consulte la

GramSchmidt (v,B...)
Aplicar el proceso de Gram-Schmidt (a las columnas) con respecto al propio producto dado por
Consulte

HankelMatrix (c,r)
Hankel matrix.

HilbertMatrix (n)
Matriz de Hilbert de orden
Consulte

Image (T)
Obtener la imagen (espacio columna) de una transformación lineal.

InfNorm (v)
Obtener el operador norma de un vector, a veces también se denomina norma suprema o norma máxima.

InvariantFactorsInteger (M)
Obtiene los factores invariantes de una matriz cuadrada de enteros (no su característica).

InverseHilbertMatrix (n)
Matriz inversa de Hilbert de orden

IsHermitian (M)
Es una matriz Hermitian. Es decir, es igual a su traspuesta conjugada.
Consulte

IsInSubspace (v,W)
Comprueba si un vector está en un subespacio.

IsInvertible (n)
Es una matriz (o número) invertible (La matriz de enteros es invertible si, y sólo si esta es invertible sobre los enteros).

IsInvertibleField (n)
Es una matriz (o un número) inversible sobre un campo.

IsNormal (M)
Indica que
Consulte

IsPositiveDefinite (M)
Indica que
Tenga en cuenta que algunos autores (por ejemplo Mathworld) no requieren que
Consulte

IsPositiveSemidefinite (M)
Indica si
Tenga en cuenta que algunos autores no requieren que
Consulte

IsSkewHermitian (M)
Es matriz antihermítica. Esto es, la transposición conjugada es igual al negativo de la matriz.
Consulte

IsUnitary (M)
¿Es una matriz unitaria?. Esto es, hacer
Consulte

JordanBlock (n,lambda)
Alias:
Obtener el bloque de Jordan correspondiente al valor propio
Consulte

Kernel (T)
Obtener el núcleo (espacio nulo) de una trasformación lineal.
(Consulte

KroneckerProduct (M, N)
Alias:
Calcula el producto de Kronecker (producto tensorial en base estándar) de dos matrices.
Consulte la

LUDecomposition (A, L, U)
Obtener la descomposición de LU de
Esto es la descomposición de LU de una matriz también conocido como Crout y/o reducción de Cholesky. (ISBN 0-201-11577-8 pp.99-103) La matriz triangular superior cuenta con una diagonal de valores 1 (uno). Esto no es el método de Doolittle en las que los unos de la diagonal están sobre la matriz inferior.
No todas las matrices tienen la descomposición de LU, por ejemplo
Consulte la

Minor (M,i,j)
Obtener el menor
Consulte

NonPivotColumns (M)
Devolver las columnas que no son las columnas pivotes de una matriz.

Norm (v,p...)
Alias:
Obtener la norma p (o 2 normas si no se suministra p) de un vector.

NullSpace (T)
Obtener el espacio nulo de una matriz. Ese es el núcleo de la aplicación lineal que representa la matriz. Esto se devuelve como una matriz cuyo espacio de columna es el espacio nulo de
Consulte

Nullity (M)
Alias:
Obtener la nulidad de una matriz. Es decir, devuelve la dimensión del espacio nulo; la dimensión del núcleo de
Consulte

OrthogonalComplement (M)
Obtener el complemento ortogonal del espacio de columnas.

PivotColumns (M)
Devuelve las columnas pivote de una matriz, que son columnas que tienen un 1 en la fila forma reducida. También devuelve la fila en la que se producen.

Projection (v,W,B...)
Proyección del vector

QRDecomposition (A, Q)
Obtener la descomposición QR de una matriz cuadrada
Consulte la

RayleighQuotient (A,x)
Devuelve el cociente de Rayleigh (también llamado el cociente de Rayleigh-Ritz o ratio) de una matriz y un vector.
Consulte

RayleighQuotientIteration (A,x,epsilon,maxiter,vecref)
Buscar valores propios de
Conuslte

Rank (M)
Alias:
Obtener el rango de una matriz.
Consulte

RosserMatrix ()
Devolver la matriz de Rosser, que es un problemático y clásico test simétrico de valores propios.

Rotation2D (ángulo)
Alias:
Devolver la matriz correspondiente a la rotación alrededor del origen en R

Rotation3DX (ángulo)
Devuelve la matriz correspondiente a la rotación alrededor del origen en R

Rotation3DY (ángulo)
Devolver la matriz correspondiente a la rotación alrededor del origen en R

Rotation3DZ (ángulo)
Devolver la matriz correspondiente a la rotación alrededor del origen en R

RowSpace (M)
Obtener una matriz base para el espacio de filas de una matriz.

SesquilinearForm (v,A,w)
Evaluar (v,w) con respecto a la forma sesquilineal dada por la matriz A.

SesquilinearFormFunction (A)
Devolver una función que evalúa dos vectores con respecto a la forma sesquilineal dada por A.

SmithNormalFormField (A)
Devuelve la forma normal de Smith de una matriz sobre los campos (terminará con unos en la diagonal).
Consulte la

SmithNormalFormInteger (M)
Devuelve la forma normal de Smith para matrices cuadradas sobre enteros (no su característica).

SolveLinearSystem (M,V,args...)
Resuelve el sistema lineal Mx=V, devuelve la solución V si hay una única solución y

ToeplitzMatrix (c, r...)
Devuelve la matriz de Toeplitz que se construye con la primera columna «c» y (opcionalmente) la primera fila «r». Si sólo se da la columna «c», entonces esta es conjugada y la versión no conjugada la utiliza la primera fila para dar una matriz Hermitiana (si el primer elemento es real).
Consulte la

Trace (M)
Alias:
Calcular la traza de una matriz. Esto es la suma de sus elementos diagonales.
Consulte la

Transpose (M)
Traspuesta de una matriz. Es lo mismo que el operador
Consulte la

VandermondeMatrix (v)
Alias:
Devuelve la matriz de Vandermonde.
Consulte la

VectorAngle (v,w,B...)
El ángulo de dos vectores con respecto al propio producto viene dado por

VectorSpaceDirectSum (M,N)
Suma directa de los espacios vectoriales M y N.

VectorSubspaceIntersection (M,N)
Intersección de subespacios dados por M y N.

VectorSubspaceSum (M,N)
La suma de los espacios vectoriales M y N, esto es {w | w=m+n, m en M, n en N}.

adj (m)
Alias:
Obtener el adjunto clásico de una matriz.

cref (M)
Alias:
Calcular la forma en escalón reducida por columnas.

det (M)
Alias:
Obtener el determinante de una matriz.
Consulte la

ref (M)
Alias:
Obtener la matriz escalonada por fila. Es decir, aplicar la eliminación gausiana pero no hacer la reducción a
Consulte la

rref (M)
Alias:
Obtener la matriz escalonada reducida por filas. Es decir, aplicar la eliminación gausiana junto con la reducción a
Consulte la
Combinatoria

Catalan (n)
Obtener el
Consulte

Combinations (k,n)
Obtener todas las combinaciones de «k» números desde 1 a «n» como un vector de vectores. (Consulte

DoubleFactorial (n)
Doble factorial:
Consulte

Factorial (n)
Factorial:
Consulte

FallingFactorial (n,k)
Factorial descendente:
Consulte la

Fibonacci (x)
Alias:
Calcular el
Consulte la

FrobeniusNumber (v,arg...)
Calcular el número de Frobenius. Calcular en número más pequeño que no se puede dar como una combinación de entero lineal no negativo de un vector dado de enteros no negativos. El vector se puede dar como números separados o un simple vector. Todos los números tendrán un máximo común divisor de enteros «GCD» de 1.
Consulte la

GaloisMatrix (regla_de_combinación)
Matriz de Galois dada una regla de combinación lineal (a_1*x_+...+a_n*x_n=x_(n+1)).

FrobeniusNumber (n,v)
Buscar el vector
Consulte la

HarmonicNumber (n,r)
Alias:
Número harmónico, el

Hofstadter (n)
Función q(n) de Hofstadter definida por q(1)=1, q(2)=1, q(n)=q(n-q(n-1))+q(n-q(n-2)).

LinearRecursiveSequence (seed_values,combining_rule,n)
Calcular la sucesión lineal recursiva utilizando el escalamiento de Galois.

Multinomial (v,arg...)
Calcular los coeficientes multinomiales. Toma un vector de
(a+b+c)! / (a!b!c!)
La fórmula para
Consulte

NextCombination (v,n)
Obtener las combinaciones que v devolverá después de su ejecución. La primera combinación será
Por ejemplo, con Combination normalmente escribiría un bucle como sigue:

Pascal (i)
Obtener el triángulo de Pascal como una matriz. Esto devolverá una
Consulte

Permutations (k,n)
Obtener todas las permutaciones de
Consulte

RisingFactorial (n,k)
Alias:
(Puchhammer) factorial creciente: (n)_k = n(n+1)...(n+(k-1)).
Consulte

StirlingNumberFirst (n,m)
Alias:
Número de Stirling de primera clase.
Consulte

StirlingNumberSecond (n,m)
Alias:
Número de Stirling de segunda clase.
Consulte

Subfactorial (n)
Subfactorial: n! times sum_{k=1}^n (-1)^k/k!.

Triangular (nth)
Calcular el
Consulte

nCr (n,r)
Alias:
Calcular combinaciones, es decir, el coeficiente del binomio.
Consulte

nPr (n,r)
Calcular el número de permutaciones de tamaño
Cálculo

CompositeSimpsonsRule (f,a,b,n)
Integrar f usando la Regla Compuesta de Simpson en el intervalo [a,b] con n subintervalos y un error de max(f'''')*h^4*(b-a)/180, n debe ser entero.
Consulte

CompositeSimpsonsRuleTolerance (f,a,b,FourthDerivativeBound,Tolerance)
Integración de F por la Regla compuesta de Simpson en el intervalo [a,b] con el número de pasos calculado por la cuarta derivada y la tolerancia deseada.

Derivative (f,x0)
Intentar calcular la derivada, primero simbólicamente y después numéricamente.

EvenPeriodicExtension (f,L)
Devolver una función que es una extensión periódica par de
Consulte

FourierSeriesFunction (a,b,L)
Devuelve una función que es una serie de Fourier con coeficientes devueltos por los vectores
Consulte la

InfiniteProduct (func,inicio,inc)
Intenta calcular un producto infinito para una función de un sólo parámetro.

InfiniteProduct2 (func,arg,inicio,inc)
Intenta calcular un producto infinito para una función de dos parámetros con func(arg,n)

InfiniteSum (func,inicio,inc)
Intentar calcular una suma infinita para una función de un sólo parámetro.

InfiniteSum2 (func,arg,inicio,inc)
Intenta calcular una suma infinita para una función de dos parámetros con func(arg,n).

IsContinuous (f,x0)
Comprueba si una función real es continua en x0 calculando el límite en ese punto.

IsDifferentiable (f,x0)
Comprobar la diferenciabilidad aproximando los límites izquierdo y derecho y comparándolos.

LeftLimit (f,x0)
Calcular el límite por la izquierda de una función real en x0.

Limit (f,x0)
Calcular el límite de una función real en x0. Intenta calcular tanto el límite por la derecha como por la izquierda.

MidpointRule (f,a,b,n)
Integración por la regla del punto medio.

NumericalDerivative (f,x0)
Alias:
Intentar calcular la derivada numérica.

NumericalFourierSeriesCoefficients (f,L,N)
Devuelve un vector de vectores

NumericalFourierSeriesFunction (f,L,N)
Devuelve una función que es la serie de Fourier de

NumericalFourierCosineSeriesCoefficients (f,L,N)
Devuelve un vector de coeficientes de coseno de la serie de Fourier de
Consulte la

NumericalFourierCosineSeriesFunction (f,L,N)
Devuelve una función que es el coseno de la serie de Fourier de

NumericalFourierSineSeriesCoefficients (f,L,N)
Devuelve un vector de coeficientes de senos de la serie de Fourier de
Consulte la

NumericalFourierSineSeriesFunction (f,L,N)
Devuelve una función que es el seno de la serie de Fourier de

NumericalIntegral (f,a,b)
Integración por el conjunto de reglas en NumericalIntegralFunction de f desde «a» a «b» usando NumericalIntegralSteps pasos.

NumericalLeftDerivative (f,x0)
Intentar calcular la derivada numérica por la izquierda.

NumericalLimitAtInfinity (_f,step_fun,tolerance,successive_for_success,N)
Intentar calcular el límite de f(step_fun(i)), para i desde 1 hasta N.

NumericalRightDerivative (f,x0)
Intentar calcular la derivada numérica por la derecha.

OddPeriodicExtension (f,L)
Devuelve una función que es la extensión periódica impar de
Consulte también

OneSidedFivePointFormula (f,x0,h)
Calcular la derivada de un lado usando una fórmula de 5 puntos.

OneSidedThreePointFormula (f,x0,h)
Calcular la derivada de un lado usando una fórmula de tres puntos.

PeriodicExtension (f,a,b)
Devuelve una función que es la extensión periódica de
Consulte también

RightLimit (f,x0)
Calcular el límite por la derecha de una función real en x0.

TwoSidedFivePointFormula (f,x0,h)
Calcular la derivada de dos lados usando una fórmula de cinco puntos.

TwoSidedThreePointFormula (f,x0,h)
Calcular la derivada de dos lados usando una fórmula de tres puntos.
Funciones

Argument (z)
Alias:
argumento (ángulo) de un número complejo.

BesselJ0 (x)
Función de Bessel de primer tipo de orden 0. Implementada solo para números reales.
Consulte la

BesselJ1 (x)
Función de Bessel de primer tipo de orden 1. Implementada solo para números reales.

BesselJn (n,x)
Función de Bessel de primer tipo de orden

BesselY0 (x)
Función de Bessel de segundo tipo de orden 0. Implementada solo para números reales.

BesselY1 (x)
Función de Bessel de segunto tipo de orden 1. Implementada solo para números reales.

BesselYn (n,x)
Función de Bessel de segundo tipo de orden

DirichletKernel (n,t)
Núcleo de Dirichlet de orden n.

DiscreteDelta (v)
Devuelve 1 si y sólo si todos los elementos son cero.

ErrorFunction (x)
Alias:
La función de error, 2/sqrt(pi) * int_0^x e^(-t^2) dt.
Consulte

FejerKernel (n,t)
Núcleo de Fejer de orden
Consulte

GammaFunction (x)
Alias:
La función «Gamma». Actualmente sólo implementada para valores reales.
Consulte

KroneckerDelta (v)
Devuelve 1 si y sólo si todos los elementos son iguales.

LambertW (x)
La rama principal de la función de Lambert W calculada sólo para los valores reales más grandes o iguales que
Consulte la

LambertWm1 (x)
La rama menos uno «-1» de la función de Lambert W calculada sólo para valores reales más grandes o igual a

MinimizeFunction (func,x,incr)
Buscar el primer valor donde f(x)=0.

MoebiusDiskMapping (a,z)
Mapa de Moebius del disco a sí mismo mapeando a 0.
Consulte

MoebiusMapping (z,z2,z3,z4)
Mapa de Moebius usando el radio cruzado z2,z3,z4 a 1,0 e infinito respectivamente.

MoebiusMappingInftyToInfty (z,z2,z3)
Mapa de Moebius usando el radio cruzado tomando infinito a infinito y z2,z3 a 1 y 0 respectivamente.

MoebiusMappingInftyToOne (z,z3,z4)
Mapa de Moebius usando la relación cruzada tomando de infinito a 1 y z3,z4 a 0 e infinito respectivamente.

MoebiusMappingInftyToZero (z,z2,z4)
Mapa de Moebius usando la relación cruzada tomando de infinito a 0 y z2,z4 a 1 e infinito respectivamente.

PoissonKernel (r,sigma)
El núcleo de Poisson en D(0,1) (no normalizado a 1, esto es, su integral es 2pi).

PoissonKernelRadius (r,sigma)
El núcleo de Poisson en D(0,R) (no normalizado a 1).

RiemannZeta (x)
Alias:
La función «zeta de Riemann». Actualmente sólo implementada para valores reales.
Consulte

UnitStep (x)
La función escalón unitario es 0 para xlt;0, 1 si no. Es la integral de la función delta de Dirac. También llamada función de Heaviside.
Consulte la

cis (x)
La función

deg2rad (x)
Convertir grados a radianes.

rad2deg (x)
Convertir radianes a grados.

sinc (x)
Calcular la función sinc no normalizada, esto es
Consulte la
Resolución de ecuaciones

CubicFormula (p)
Calcular las raíces de un polinomio cúbico (de grado 3) utilizando la fórmula cúbica. El polinomio se dará como un vector de coeficientes. Esto es
Consulte

EulersMethod (f,x0,y0,x1,n)
Usar el método clásico de Euler para resolver numéricamente y'=f(x,y) para unas
Los sistemas se pueden resolver teniendo a
Consulte

EulersMethodFull (f,x0,y0,x1,n)
Utilizar el método clásico de Euler para resolver numéricamente y'=f(x,y) de forma inicial

FindRootBisection (f,a,b,TOL,N)
Buscar la raíz de una función utilizando el método de la bisección.

FindRootFalsePosition (f,a,b,TOL,N)
Buscar la raíz de una función utilizando el método de la posición falsa.

FindRootMullersMethod (f,x0,x1,x2,TOL,N)
Buscar la raíz de una función utilizando el método de Muller.

FindRootSecant (f,a,b,TOL,N)
Buscar la raíz de una función utilizando el método de la secante.

HalleysMethod (f,df,ddf,guess,epsilon,maxn)
Encontrar ceros utilizando el método de Halleys. Siendo
Consulte también
Ejemplo para encontrar la raíz cuadrada de 10:
Consulte la

NewtonsMethod (f,df,guess,epsilon,maxn)
Encontrar ceros utilizando el método de Newton. La variable
Consulte también
Ejemplo para encontrar la raíz cuadrade de 10:
Consulte la

PolynomialRoots (p)
Calcular las raíces de un polinomio (de grado 1 a 4) utilizando una de las fórmulas para cada polinomio. El polinomio entregará un vector de coeficientes. Esto es
La función llama a

QuadraticFormula (p)
Calcular las raíces de una polinomio cuadrático (de grado 2) utilizando la fórmula cuadrática. El polinomio será un vector de coeficientes. Es es
Consulte

QuarticFormula (p)
Calcular las raíces de un polinomio cuadrático (de grado 4) utilizando la fórmula cuadrática. El polinomio será un vector de coeficientes. Esto es
Consulte

RungeKutta (f,x0,y0,x1,n)
Utilizar el método clásico no adaptativo de cuarto orden Runge-Kutta para resolver numéricamente y'=f(x,y) que de forma inicial
Consulte

RungeKuttaFull (f,x0,y0,x1,n)
Utilizar el método clásico no adaptativo de cuarto orden Runge-Kutta para resolver numéricamente y'=f(x,y) que de forma inicial
Estadísticas

Average (m)
Alias:
Calcular la media de una matriz entera.
Consulte

GaussDistribution (x,sigma)
Integral de la función de Gauss desde 0 a
Consulte

GaussFunction (x,sigma)
La función de distribución Gausiana normalizada (la curva normal).

Median (m)
Alias:
Calcular la mediana de una matriz entera.
Consulte

PopulationStandardDeviation (m)
Alias:
Calcular la desviación de población típica de una matriz completa.

RowAverage (m)
Alias:
Calcular la media de cada columna de una matriz.

RowMedian (m)
Calcular la mediana de cada fila en una matriz y devolver una vector columna de las medianas.

RowPopulationStandardDeviation (m)
Alias:
Calcular la desviación típica de las columnas de una matriz y devuelve una matriz columna.

RowStandardDeviation (m)
Alias:
Calcular la desviación estándar de las filas de una matriz y devuelve una matriz columna.

StandardDeviation (m)
Alias:
Calcular la desviación estándar de una matriz entera.
Polinomios

AddPoly (p1,p2)
Suma dos polinomios (vectores).

DividePoly (p,q,amp;r)
Dividir dos polinomios (como vectores) utilizando la división larga. Devuelve el cociente de los dos polinomios. El argumento opcional
Consulte

IsPoly (p)
Comprobar si un vector se puede usar como un polinomio.

MultiplyPoly (p1,p2)
Multiplica dos polinomios (como vectores).

NewtonsMethodPoly (poly,guess,epsilon,maxn)
Encontrar una raíz de un polinomio utilizando el método de Newton. La variable
Consulte también
Ejemplo para encontrar la raíz cuadrada de 10:

Poly2ndDerivative (p)
Tomar la derivada segunda (como vector) polinómico.

PolyDerivative (p)
Tomar la derivada (como vector) polinómico.

PolyToFunction (p)
Extraer una función de un polinomio (como vector).

PolyToString (p,var...)
Extraer una cadena de un polinomio (como vector).

SubtractPoly (p1,p2)
Restar dos polinomios (como vectores).

TrimPoly (p)
Eliminar ceros de un polinomio (como vector).
Teoría de conjuntos

Intersection (X,Y)
Devuelve la intersección de X e Y (X e Y son vectores que se tratan como conjuntos).

IsIn (x,X)
Devuelve

IsSubset (X, Y)
Devuelve

MakeSet (X)
Devuelve un vector donde cada elemento de X aparece una sola vez.

SetMinus (X,Y)
Devuelve un conjunto teorético de diferencia X-Y (X e Y son vectores que pretender ser conjuntos).

Union (X,Y)
Devuelve la unión de X e Y (X e Y son vectores que se tratan como conjuntos).
Álgebra conmutativa

MacaulayBound (c,d)
Para una función de Hilbert que es c de grado d, dada la función de Macaulay obligado por la función de Hilbert de grado d+1 (el c^lt;dgt; operador de la prueba de Green).

MacaulayLowerOperator (c,d)
El operador c_lt;dgt; de la prueba de Green del teorema de Macaulay.

MacaulayRep (c,d)
Devolver la representación dth de Macaulay de un entero positivo c.
Miscelánea

ASCIIToString (vec)
Convertir un vector de valores ASCII en una cadena.

AlphabetToString (vec,alfabeto)
Convierte un vector de valores alfabéticos basados en 0 (posiciones en la cadena alfabeto) a una cadena.

StringToASCII (cad)
Convertir una cadena a un vector de valores ASCII.

StringToAlphabet (str,alfabeto)
Convertir una cadena en un vector de valores alfabéticos basados en 0 (posiciones en la cadena alfabeto), -1 para las letras desconocidas.
Operaciones simbólicas

SymbolicDerivative (f)
Intentar diferenciar simbólicamente la función «f», donde «f» es una función de una variable.
Ejemplos:

SymbolicDerivativeTry (f)
Intentar diferenciar simbólicamente la función f, donde f es una función de una variable, devuelve

SymbolicNthDerivative (f,n)
Intentar diferenciar simbólicamente una función n veces. (Consulte

SymbolicNthDerivativeTry (f,n)
Intentar diferenciar simbólicamente una función n veces de manera silenciosa y devolver

SymbolicTaylorApproximationFunction (f,x0,n)
Intenta construir la aproximación de Taylor alrededor de x0 hasta grado n. (Consulte

ExportPlot (archivo,tipo)
ExportPlot (archivo)
Exportar el contenido de la ventana de dibujado a un archivo. El tipo es una cadena que especifica el tipo de archivo que usar, «png», «eps» o «ps». Si no se especifica el tipo, se toma a partir de la extensión, en cuyo caso debe ser«.png», «.eps» o «.ps».
Tenga en cuneta que los archivos se sobreescriben sin preguntar.
Al exportar correctamente, se devuelve. Si falla algo, se muestra un error y se eleva una excepción.
Ejemplos:

LinePlot (func1,func2,func3,...)
LinePlot (func1,func2,func3,x1,x2)
LinePlot (func1,func2,func3,x1,x2,y1,y2)
LinePlot (func1,func2,func3,[x1,x2])
LinePlot (func1,func2,func3,[x1,x2,y1,y2])
Dibujar una función (o varias funciones) con una línea. Los 10 primeros argumentos son funciones, entonces opcionalmente puede especificar los límites de las gráficas como
El parámetro
Ejemplos:

LinePlotClear ()
Muestra la ventana de dibujo lineal y limpia las funciones y otras líneas que se hubiesen dibujado.

LinePlotDrawLine (x1,y1,x2,y2,...)
LinePlotDrawLine (v,...)a
Dibuja una línea desde
Se pueden añadir parámetros adicionales para especificar el color de la línea, ancho, flechas, ventanas de dibujado o leyendas. Puede modificarlo añadiendo un valor a
La denominación del color debe ser una cadena que identifique al color según el diccionario inglés que GTK reconocerá como
Los valores de entrada de la ventana deben ser del tipo
La especificación para la flecha debería ser
Finalmente, la leyenda debería ser una cadena que se pueda utilizar como leyenda en un gráfico. Es decir, si se imprimen las leyendas.
Ejemplos:

LinePlotParametric (xfunc,yfunc,...)
LinePlotParametric (xfunc,yfunc,t1,t2,tinc)
LinePlotParametric (xfunc,yfunc,t1,t2,tinc,x1,x2,y1,y2)
LinePlotParametric (xfunc,yfunc,t1,t2,tinc,[x1,x2,y1,y2])
LinePlotParametric (xfunc,yfunc,t1,t2,tinc,"fit")
Dibujar una función paramétrica con una línea. Primero vienen las funciones para
Si no se especifican los límites x e y, entonces se aplican las configuraciones actuales (Consulte

LinePlotCParametric (func,...)
LinePlotCParametric (func,t1,t2,tinc)
LinePlotCParametric (func,t1,t2,tinc,x1,x2,y1,y2)
Dibujar una función valorada paramétrica compleja con una línea. Primero vienen las funciones que devuelven
Si los límites no se especifican, entonces se aplican las configuraciones actuales (Consulte

PlotCanvasFreeze ()
Congela el dibujo en el lienzo de dibujado de forma temporal. Esto es útil si necesita dibujar un grupo de elementos y quiere demorar el dibujado para no permitir el parpadeo de una animación. Después de terminar con el dibujo debería descongelar el lienzo de dibujado llamando a la función
El lienzo está siempre desbloqueado hasta el final de cualquier proceso, así que nunca permanece bloqueado. El momento en que se muestra una nueva línea de comandos, por ejemplo, el lienzo de dibujado se descongela automáticamente. También tenga en cuenta que las llamadas a congelar y descongelar puede anidarse de manera segura.

PlotCanvasThaw ()
Descongela el lienzo de dibujado congelado por la función

SlopefieldClearSolutions ()
Borra las soluciones elaboradas por la función

SlopefieldDrawSolution (x, y, dx)
Cuando un campo de dibujo de gráficas está activo, dibuja una solución con las condiciones iniciales especificas. El método estándar de Runge-Kutta se usa con incremento

SlopefieldPlot (func)
SlopefieldPlot (func,x1,x2,y1,y2)
Dibujar un campo inclinado. La función
Ejemplos:

SurfacePlot (func)
SurfacePlot (func,x1,x2,y1,y2,z1,z2)
SurfacePlot (func,x1,x2,y1,y2)
SurfacePlot (func,[x1,x2,y1,y2,z1,z2])
SurfacePlot (func,[x1,x2,y1,y2])
Dibujar una función superficial que tome entre dos argumentos o un número complejo. Primero vienen las funciones que las limitan de forma opcional
Si no se especifican los límites de z, se usan los valores máximo y mínimo de la función.
Ejemplos:

SurfacePlotData (datos)
SurfacePlotData (datos,etiqueta)
SurfacePlotData (datos,x1,x2,y1,y2,z1,z2)
SurfacePlotData (datos,etiqueta,x1,x2,y1,y2,z1,z2)
SurfacePlotData (datos,[x1,x2,y1,y2,z1,z2])
SurfacePlotData (datos,etiqueta,[x1,x2,y1,y2,z1,z2])
Dibujar una superficie a partir de los datos. Los datos son una matriz de n x 3 cuyas filas son las coordenadas x, y, z. Los datos pueden ser un vector cuya longitud sea múltiplo de 3 y que contenga triplas de x, y z. Los datos deben contener al menos 3 puntos.
Opcionalmente, se pueden indicar una etiqueta y los límites. Si no se indican los límites, se calculan a partir de los datos, no se usa
Ejemplos:
Esto es un ejemplo de cómo dibujar con coordenadas polares, en particular, cómo dibujar la función

SurfacePlotDataGrid (datos,[x1,x2,y1,y2])
SurfacePlotDataGrid (datos,[x1,x2,y1,y2,z1,z2])
SurfacePlotDataGrid (datos,[x1,x2,y1,y2],etiqueta)
SurfacePlotDataGrid (datos,[x1,x2,y1,y2,z1,z2],etiqueta)
Dibujar una superficie a partir de datos rectangulares regulares. Los datos se dan en una matriz matriz de n x m donde las filas son la coordenada x y las columnas son la coordenada y. La coordenada x se divide en n-1 subintervalos iguales y la coordenada y se divide en m-1 subintervalos iguales. Los límites
Opcionalmente se puede indicar la etiqueta; si no se indica ninguna, se unas una etiqueta vacía.
Ejemplos:

VectorfieldClearSolutions ()
Limpia las soluciones realizadas por la función

VectorfieldDrawSolution (x, y, dt, tlen)
Cuando un campo de dibujo vectorial está activo, dibuja una solución con las condición específica inicial. El método estándar de Runge-Kutta se utiliza con incremento

VectorfieldPlot (funcx, funcy)
VectorfieldPlot (funcx, funcy, x1, x2, y1, y2)
Dibujar un vector bidimensional. La función
De manera opcional puede especificar los límites de la ventana de dibujo como
Ejemplos:
Programas de ejemplo en GEL
Esto es una función que calcula factoriales:
Con sangría se convierte:
Esto es un puerto directo de la función factorial desde la página principal
function f(x) = prod k=1 to x do k
Con mucho, la manera más fácil de definir una función factorial será usar el lazo del producto como sigue. No es sólo la manera más corta y más rápida, sino probablemente la versión mas legible.
He aquí un ejemplo más extenso, esto básicamente redefine la función interna
Para configurar la
Cambiar la configuración con GEL
Muchas de las configuraciones en Genius son simplemente variables globales, y que se pueden evaluar y asignar de la misma manera que las variables normales. Consulte la
MaxDigits = 12
Por ejemplo, puede establecer el número máximo de dígitos en un resultado a 12 escribiendo:
Salida
Número máximo de cifras que mostrar
El número máximo de dígitos en un resultado (
Resultados como números de coma flotante
Indica si los resultados se imprimirán siempre como números flotantes (
Números de coma flotante en notación científica
Indica si los números flotantes están en notación científica (
Imprimir siempre expresiones completas
Indica si se imprimen expresiones completas para valores de retorno no numéricos (más largos que una línea) (
Usar fracciones mixtas
Indica si se imprimen las fracciones como fracciones mixtas utilizando la forma «1 1/3» en vez de «4/3». (
Mostrar 0.0 cuando el número en coma flotante es menor que 10^-x (0=no truncar nunca)
Indica cómo cortar la salida. Pero sólo cuando otros números pueden ser muy grandes. Consulte la documentación del parámetro
Sólo truncar los números cuando otro número es mayor que 10^-x
Indica cuándo se corta la salida. Esto lo configura el parámetro
Recordar los ajustes de salida entre sesiones
Indica si la configuración de la salida en el campo
Si no está activada, se usará el valor predeterminado o cualquier configuración guardada anteriormente cada vez que se inicie Genius. Tenga en cuenta que las configuraciones se guardan al final de la sesión, así que si quiere cambiar los valores predeterminados, active esta casilla, reinicie
Mostrar los errores en una ventana de diálogo
Si se activan, los errores se mostrarán en un diálogo separado, si no se activan, los errores se imprimirán en la consola.
Mostrar los mensajes de información en un diálogo
Si se activan los mensajes de información se mostraran en un diálogo separado, si no se activan, los mensajes de información se imprimirán en la consola.
Máximo de errores que mostrar
El número máximo de errores que devolver por una prueba (
Además de estas preferencias, hay algunas preferencias que se pueden cambiar configurándolas en el área de trabajo de la consola. Para otras que puedan afectar a la salida consulte la
IntegerOutputBase
La base que se usará para mostrar enteros
OutputStyle
Una cadena, puede ser
Precisión
Precisión en coma flotante
Indica la precisión en bits de los números en coma flotante (
Recordar los ajustes de precisión entre sesiones
Indicar si la configuración de la precisión se recordará para la próxima sesión. Si no está activada, la configuración predeterminada o la configuración guardada anteriormente se utilizarán cada vez que Genius se inicie. Tenga en cuenta que las configuraciones se guardan al final de la sesión, así que si quiere cambiar la configuración por defecto, active esta casilla, reinicie Genius y luego vuelva a desactivarla.
Terminal
«Terminal» se refiere a la consola en el área de trabajo.
Líneas de desplazamiento hacia atrás
Líneas de desfile hacia atrás en la terminal.
Tipografía
La tipografía que usar en la terminal.
Negro sobre blanco
Si usar blanco sobre negro en la terminal.
Cursor parpadeante
Cuando la terminal tenga el foco, el cursor parpadeará en ella. Puede que a veces resulte molesto y genere tráfico innecesario si ejecuta Genius remotamente.
Memoria
Número máximo de nodos que asignar
Internamente, todos los datos se ponen en pequeños nodos en la memoria. Esto da un límite máximo de nodos reservados para el procesado. Esto evita que se quede sin memoria si comete algún error que haga consumir al programa más memoria de lo normal, como podría ser una recursión sin fin. Esto podría ralentizar su máquina y complicar incluso la interrupción del programa.
Una vez se ha alcanzado el límite, la
Establecer el límite a cero significa que no hay límite en la cantidad de memoria que usa Genius.
Acerca de la
Jiří (George) Lebl (
Para informar de un error o hacer una sugerencia sobre esta aplicación o sobre este manual, envíe un correo al autor o publique un mensaje en la lista de correo (consulte la página web).
Este programa se distribuye bajo los términos de la Licencia Pública General GNU (GPL) tal y como fue publicada por la Free Software Foundation, en la versión 3 ó (a su elección) cualquier versión posterior. Una copia de esta licencia puede encontrarse en
Jiří Lebl recibió apoyo parcial de la NSF grant DMS 0900885 y la Universidad de Illinois en Urbana-Champaign, la Universidad de California en San Diego y la Universidad de Wisconsin-Madison durante el desarrollo del proyecto. El software se ha utilizado tanto para docencia como para investigación.
Daniel Mustieles <daniel\.mustieles\@gmail\.com>, 2011
Nicolás Satragno <nsatragno\@gnome\.org>. 2013
Octubre de 2013
Consulte
Consulte
Ejecuta el método de Newton sobre un polinomio para tratar de encontrar una raíz, devuelve un resultado cuando encuentra dos valores sucesivos que estén dentro de los límites que marca
Universidad de Wisconsin-Madison
Junio de 2013
Consulte
Consulte
Consulte
Consulte
Consulte
Se pueden añadir parámetros adicionales para especificar el color de la línea, el grosor, las filas y la ventana de dibujo. Esto se hace añadiendo una cadena
Tolerancia de
Tolerancia de la función
Pasos que realizar en
Cuántas iteraciones probar para
Tolerancia de
Abril de 2013
load
cd
plugin
AskButtons
AskString
Compose
ComposePower
Evaluate
Identity
IntegerFromBoolean
IsBoolean
IsDefined
IsFunction
IsFunctionOrIdentifier
IsFunctionRef
IsMatrix
IsNull
IsString
IsValue
Parse
SetFunctionFlags
SetHelp
SetHelpAlias
chdir
display
error
print
printn
protect
ProtectAll
set
string
undefine
UndefineAll
unprotect
UserVariables
wait
ChopTolerance
ContinuousNumberOfTries
ContinuousSFS
ContinuousTolerance
DerivativeNumberOfTries
DerivativeSFS
DerivativeTolerance
ErrorFunctionTolerance
FloatPrecision
FullExpressions
GaussDistributionTolerance
IsPrimeMillerRabinReps
LinePlotDrawLegends
LinePlotDrawAxisLabels
LinePlotVariableNames
LinePlotWindow
MaxDigits
MaxErrors
MixedFractions
NumericalIntegralFunction
NumericalIntegralSteps
OutputChopExponent
OutputChopWhenExponent
ResultsAsFloats
ScientificNotation
SlopefieldTicks
SumProductNumberOfTries
SumProductSFS
SumProductTolerance
SurfacePlotDrawLegends
SurfacePlotVariableNames
SurfacePlotWindow
VectorfieldNormalized
VectorfieldTicks
AbsoluteValue
Chop
ComplexConjugate
Denominator
FractionalPart
Im
IntegerQuotient
IsComplex
IsComplexRational
IsFloat
IsGaussInteger
IsInteger
IsNonNegativeInteger
IsPositiveInteger
IsRational
IsReal
Numerator
Re
Sign
ceil
exp
float
floor
ln
log
log10
log2
max
min
rand
randint
round
sqrt
trunc
acos
acosh
acot
acoth
acsc
acsch
asec
asech
asin
asinh
atan
atanh
atan2
cos
cosh
cot
coth
csc
csch
sec
sech
sin
sinh
tan
tanh
AreRelativelyPrime
BernoulliNumber
ChineseRemainder
CombineFactorizations
ConvertFromBase
ConvertToBase
DiscreteLog
Divides
EulerPhi
ExactDivision
Factorize
Factors
FermatFactorization
FindPrimitiveElementMod
FindRandomPrimitiveElementMod
IndexCalculus
IndexCalculusPrecalculation
IsEven
IsMersennePrimeExponent
IsNthPower
IsOdd
IsPerfectPower
IsPerfectSquare
IsPrime
IsPrimitiveMod
IsPrimitiveModWithPrimeFactors
IsPseudoprime
IsStrongPseudoprime
Jacobi
JacobiKronecker
LeastAbsoluteResidue
Legendre
LucasLehmer
LucasNumber
MaximalPrimePowerFactors
MillerRabinTest
MillerRabinTestSure
ModInvert
MoebiusMu
NextPrime
PadicValuation
PowerMod
Prime
PrimeFactors
PseudoprimeTest
RemoveFactor
SilverPohligHellmanWithFactorization
SqrtModPrime
StrongPseudoprimeTest
gcd
lcm
ApplyOverMatrix
ApplyOverMatrix2
ColumnsOf
ComplementSubmatrix
CompoundMatrix
CountZeroColumns
DeleteColumn
DeleteRow
DiagonalOf
DotProduct
ExpandMatrix
HermitianProduct
I
IndexComplement
IsDiagonal
IsIdentity
IsLowerTriangular
IsMatrixInteger
IsMatrixNonnegative
IsMatrixPositive
IsMatrixRational
IsMatrixReal
IsMatrixSquare
IsUpperTriangular
IsValueOnly
IsVector
IsZero
LowerTriangular
MakeDiagonal
MakeVector
MatrixProduct
MatrixSum
MatrixSumSquares
OuterProduct
ReverseVector
RowSum
RowSumSquares
RowsOf
SetMatrixSize
ShuffleVector
SortVector
StripZeroColumns
StripZeroRows
Submatrix
SwapRows
UpperTriangular
columns
elements
ones
rows
zeros
AuxiliaryUnitMatrix
BilinearForm
BilinearFormFunction
CharacteristicPolynomial
CharacteristicPolynomialFunction
ColumnSpace
CommutationMatrix
CompanionMatrix
ConjugateTranspose
Convolution
ConvolutionVector
CrossProduct
DeterminantalDivisorsInteger
DirectSum
DirectSumMatrixVector
Eigenvalues
Eigenvectors
GramSchmidt
HankelMatrix
HilbertMatrix
Image
InfNorm
InvariantFactorsInteger
InverseHilbertMatrix
IsHermitian
IsInSubspace
IsInvertible
IsInvertibleField
IsNormal
IsPositiveDefinite
IsPositiveSemidefinite
IsSkewHermitian
IsUnitary
JordanBlock
Kernel
LUDecomposition
Minor
NonPivotColumns
Norm
NullSpace
Nullity
OrthogonalComplement
PivotColumns
Projection
QRDecomposition
RayleighQuotient
RayleighQuotientIteration
Rank
RosserMatrix
Rotation2D
Rotation3DX
Rotation3DY
Rotation3DZ
RowSpace
SesquilinearForm
SesquilinearFormFunction
SmithNormalFormField
SmithNormalFormInteger
SolveLinearSystem
ToeplitzMatrix
Trace
Transpose
VandermondeMatrix
VectorAngle
VectorSpaceDirectSum
VectorSubspaceIntersection
VectorSubspaceSum
adj
cref
det
ref
rref
Catalan
Combinations
DoubleFactorial
Factorial
FallingFactorial
Fibonacci
FrobeniusNumber
GaloisMatrix
GreedyAlgorithm
HarmonicNumber
Hofstadter
LinearRecursiveSequence
Multinomial
NextCombination
Pascal
Permutations
RisingFactorial
StirlingNumberFirst
StirlingNumberSecond
Subfactorial
Triangular
nCr
nPr
CompositeSimpsonsRule
CompositeSimpsonsRuleTolerance
Derivative
EvenPeriodicExtension
FourierSeriesFunction
InfiniteProduct
InfiniteProduct2
InfiniteSum
InfiniteSum2
IsContinuous
IsDifferentiable
LeftLimit
Limit
MidpointRule
NumericalDerivative
NumericalFourierSeriesCoefficients
NumericalFourierSeriesFunction
NumericalFourierCosineSeriesCoefficients
NumericalFourierCosineSeriesFunction
NumericalFourierSineSeriesCoefficients
NumericalFourierSineSeriesFunction
NumericalIntegral
NumericalLeftDerivative
NumericalLimitAtInfinity
NumericalRightDerivative
OddPeriodicExtension
OneSidedFivePointFormula
OneSidedThreePointFormula
PeriodicExtension
RightLimit
TwoSidedFivePointFormula
TwoSidedThreePointFormula
Argument
BesselJ0
BesselJ1
BesselJn
BesselY0
BesselY1
BesselYn
DirichletKernel
DiscreteDelta
ErrorFunction
FejerKernel
GammaFunction
KroneckerDelta
MinimizeFunction
MoebiusDiskMapping
MoebiusMapping
MoebiusMappingInftyToInfty
MoebiusMappingInftyToOne
MoebiusMappingInftyToZero
PoissonKernel
PoissonKernelRadius
RiemannZeta
UnitStep
cis
deg2rad
rad2deg
sinc
CubicFormula
EulersMethod
EulersMethodFull
FindRootBisection
FindRootFalsePosition
FindRootMullersMethod
FindRootSecant
PolynomialRoots
QuadraticFormula
QuarticFormula
RungeKutta
RungeKuttaFull
Average
GaussDistribution
GaussFunction
Median
PopulationStandardDeviation
RowAverage
RowMedian
RowPopulationStandardDeviation
RowStandardDeviation
StandardDeviation
AddPoly
DividePoly
IsPoly
MultiplyPoly
NewtonsMethodPoly
Poly2ndDerivative
PolyDerivative
PolyToFunction
PolyToString
SubtractPoly
TrimPoly
Intersection
IsIn
IsSubset
MakeSet
SetMinus
Union
MacaulayBound
MacaulayLowerOperator
MacaulayRep
ASCIIToString
AlphabetToString
StringToASCII
StringToAlphabet
SymbolicDerivative
SymbolicDerivativeTry
SymbolicNthDerivative
SymbolicNthDerivativeTry
SymbolicTaylorApproximationFunction
ExportPlot
LinePlot
LinePlotClear
LinePlotDrawLine
LinePlotParametric
LinePlotCParametric
SlopefieldClearSolutions
SlopefieldDrawSolution
SlopefieldPlot
SurfacePlot
SurfacePlotData
SurfacePlotDataGrid
VectorfieldClearSolutions
VectorfieldDrawSolution
VectorfieldPlot
Buscar raíces de una función utilizando el método de la bisección.
Buscar la raíz de una función utilizando el método de la secante.
Operador de negación.
Referenciar una variable (para pasar la referencia a algo). Consulte la
Matriz conjugada traspuesta.
Matriz traspuesta, no conjuga los elementos.
División.
División elemento por elemento.
Operador de igualdad (devuelve
AND lógico.
OR lógico.
XOR lógico.
NOT lógico.
@@image: 'figures/genius_window.eps'; md5=b2fe72c0dea70343a11a7bbc2225f985
@@image: 'figures/line_plot.eps'; md5=1977b7181c5d8ecb7d4348e1de79919b
@@image: 'figures/line_plot_graph.eps'; md5=201bfa54ba0797171d8910eb946354c1
@@image: 'figures/parametric.eps'; md5=52274a10d3e58dc8f883fdf3a48d5ad3
@@image: 'figures/parametric_graph.eps'; md5=223659107c58320edd6030193c89524c
@@image: 'figures/surface_graph.eps'; md5=b505c811ddf51b109722ccc53f176dd2
Obtener el entero más bajo mayor o igual que n.
Hacer una matriz diagonal de un vector.
Calcular la suma de los cuadrados de cada fila de una matriz.
Invertir los elementos de un vector.
Jiřiacute;