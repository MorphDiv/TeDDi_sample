# language_name_wals:	Spanish
# language_name_glotto:	Spanish
# ISO_6393:	spa
# year_composed:	NA
# year_published:	NA
# mode:	written
# genre_broad:	technical
# genre_narrow:	NA
# writing_system:	Latn
# special_characters:	NA
# short_description:	KDE4
# source:	https://object.pouta.csc.fi/OPUS-KDE4/v2/raw/es.zip
# copyright_short:	http://opus.nlpl.eu/KDE4.php
# copyright_long:	http://opus.nlpl.eu/KDE4.php J. Tiedemann, 2012, Parallel Data, Tools and Interfaces in OPUS. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)
# sample_type:	whole
# comments:	NA

& Anders. Lund; & Anders. Lund. mail;
& Dominik. Haumann; & Dominik. Haumann. mail;
Pablo de Vicente pablo. devicente@gmail. com Traductor Marcos Fouces Lago mfouces@yahoo. es Traductor Santiago Fernández Sancho santi@kde-es. org Traductor
Herramientas de edición avanzadas
Comentar/ descomentar
Las órdenes Comentar y Descomentar, disponibles en el menú Herramientas le permiten añadir o eliminar marcas de comentario de la selección, o en su defecto, de la línea actual. El formato de los comentarios depende del formato del texto que esté escribiendo.
Las reglas que determinan cómo deben ser los comentarios se establecen en las definiciones de sintaxis, así que si no se utiliza el resaltado de sintaxis, no será posible la realización automática de comentarios.
Algunos formatos definen marcas de comentarios de una sola línea, otros de varias líneas y otros utilizan ambas posibilidades. Si no están disponibles los comentarios de varias líneas, será imposible comentar una selección cuya última línea no esté incluida por completo.
Si está disponible una marca de comentario de una sola línea, es preferible comentar las líneas individualmente, ya que así se evitan problemas de comentarios anidados.
Al eliminar las marcas de comentario, se debe seleccionar el texto no comentado. Al eliminar marcas de comentario multilínea de una selección, se ignorará cualquier espacio en blanco que quede fuera de las marcas de comentario.
comentariost
Para colocar marcas de comentario, utilice Herramientas Comentar o el acceso directo de teclado correspondiente, que de forma predeterminada es Ctrl; #.
descomentar
Para eliminar marcas de comentario, utilice el elemento de menú Herramientas Descomentar o el acceso directo de teclado correspondiente, que de forma predeterminado es Ctrl; Shift; #.
El componente de la línea de órdenes del editor
El editor Kate tiene un componente que es una línea de órdenes interna, y le permitirá llevar a cabo diversas acciones desde un interfaz mínimo. La línea de órdenes es una entrada de texto en la parte inferior del área de edición, y para mostrarlo solo tendrá que seleccionar Ver Cambiar a línea de órdenes o utilizar el acceso rápido (de forma predeterminada es F7). El editor proporciona un conjunto de órdenes como las que se documentan a continuación, así como aquellos otros que se suministren a partir de extensiones.
Para ejecutar una orden, tecléela y pulse la tecla entrar. La línea de órdenes indicará si ha tenido éxito, posiblemente mostrando un mensaje. Si entra en la línea de órdenes pulsando F7 se ocultará automáticamente después de unos segundos. Para borrar el mensaje e introducir una nueva orden, pulse F7 de nuevo.
La línea de órdenes tiene un sistema de ayuda integrado, escriba la orden help para iniciarlo. Para ver una lista de todas las órdenes disponibles escriba help list, para ver ayuda especifica para una orden específica, escriba help orden.
La línea de órdenes tiene integrado un historial, por tanto podrá reutilizar las órdenes ya tecleadas. Para navegar a través del historial, utilice las teclas Arriba y Abajo. A la vez que se muestran las órdenes del historial, se seleccionará la parte del argumento, permitiendo cambiarlos fácilmente, sobreescribiendo los argumentos.
Órdenes estándar de la línea de órdenes
Órdenes para configurar el editor
Estas órdenes son las que proporciona el componente del editor, y le permite configurar únicamente el documento activo y la vista. Esto es especialmente práctico si desea utilizar una configuración diferente de la predeterminada, por ejemplo para el sangrado.
Tipos de argumentos
BOOLEAN
Se utilizan con órdenes que activan o desactivan opciones. Los valores aceptados son: on, off, true, false, 1 o 0
INTEGER
Un número entero
STRING
Una cadena
set-tab-width INTEGER ancho
Establece la tabulación con el valor de ancho
set-indent-width INTEGER ancho
Establece el sangrado con el valor de ancho. Solo se utiliza si se está sangrando con espacios.
set-word-wrap-column INTEGER ancho
Establece el ancho de línea para el ajuste de línea con el valor de ancho. Esto se utiliza si se tiene activado el ajuste de línea del documento.
set-icon-border BOOLEAN enable
Configura la visibilidad del borde de iconos.
set-folding-markers BOOLEANO activar
Configura la visibilidad del panel de marcas plegables.
set-line-numbers BOOLEAN activar
Configura la visibilidad de los números de línea del panel.
set-replace-tabs BOOLEAN enable
Si está activado, se sustituyen los espacios de tabulador por espacios normales a medida que escribe.
set-remove-trailing-space BOOLEAN enable
Si está activo, las espacios en blanco de marca se eliminan en el momento en el que el cursor salga de la línea.
set-show-tabs BOOLEAN activar
Si está activado, los caracteres de tabulación y espacios en blanco de marca se visualizarán como un puntito.
set-indent-spaces BOOLEAN activar
Si está activado, el editor hará un sangrado con indent-width espacios para cada nivel de sangrado, en lugar de con un caracter de tabulación.
set-mixed-indent BOOLEAN activar
Si está activado, kate utilizará una mezcla de tabuladores y espacios para el sangrado. Cada nivel de sangrado tendrá indent-width de ancho, y los diferentes niveles de sangrado se optimizarán utilizando los máximos caracteres de tabulación posibles.
Cuando se ejecuta, esta orden activará el sangrado con espacios, y si no se especifica el ancho se asignará una valor igual a la mitad de tab-width para el documento en tiempo de ejecución.
set-word-wrap BOOLEAN activar
Activa el ajuste de línea dinámico de acuerdo con el valor de activar
set-replace-tabs-save BOOLEAN enable
Cuando está activo, los tabuladores se reemplazan con espacios en blanco al guardar el documento.
set-remove-trailing-space-save BOOLEAN activar
Cuando está activo, se eliminan las marcas de los espacios de cada línea al guardar el documento.
set-indent-mode nombre
Asigna el modo de sangrado automático a nombre. si nombre es desconocido, el modo seleccionado es 'none '. Los modos válidos son 'cstyle', 'csands ', 'xml', 'python ', 'varindent' y 'none '.
set-highlight resaltado
Asigna el sistema de resaltado de sintaxis al documento. El argumento debe ser un nombre de resaltado válido, como aquellos que se pueden ver en el menú Herramientas Resaltado. Esta orden proporciona una lista de autocompletado para los argumentos.
Órdenes para la edición
Estas órdenes modifican el documento actual.
indent
Sangrado de texto en la línea actual.
unindent
Elimina el sangrado de las líneas seleccionadas o de la línea actual.
cleanindent
Borra el sangrado de las líneas seleccionadas o de la línea actual de acuerdo con la configuración del sangrado que tenga el documento.
comment
Inserta marcas de comentario haciendo que la selección, las líneas seleccionadas o la línea actual sean un comentario de acuerdo con el formato de texto que se haya definido en la sintaxis de resaltado para el documento.
uncomment
Elimina la etiqueta de comentario de la selección, de las líneas seleccionadas o de la línea actual, de acuerdo con las reglas sintácticas de resaltado del documento.
kill-line
Borra la línea actual.
replace patrón reemplazo
Reemplaza el texto que coincida con patrón con el valor de reemplazo. Si desea incluir espacios en blanco en el patrón, deberá entrecomillar tanto el patrón como el reemplazo con comillas simples o dobles. Si los argumentos no van entrecomillados, la primera palabra se utilizará como patrón y el resto como reemplazo. Si reemplazo está vacío, cada aparición de patrón se borra.
Puede asignar parámetros para configurar la búsqueda añadiendo dos puntos, seguidos de una o más letras cada una de las cuales representa una configuración, quedando de la forma replace: opciones patrón reemplazo. Las opciones disponibles son:
b
Buscar hacia atrás.
c
Buscar desde la posición del cursor.
e
Buscar sólo en el texto seleccionado.
r
Busca utilizando una expresión regular. Si está asignado, puede utilizar \\N donde N es un número que representa capturas en la cadena de reemplazo.
s
Búsqueda distinguiendo mayúsculas y minúsculas.
p
Pide permiso para reemplazar la siguiente aparición.
w
Encontrar sólo palabras completas.
date formato
Inserta una cadena de fecha/ hora definida de acuerdo a formato, o si éste no se especifica se utiliza el formato « aaaa-MM-dd hh: mm: ss ». La interpretación del formato será la siguiente:
d
El día como número sin ceros a la izquierda (1-31).
dd
El día como un número a dos dígitos (01-31).
ddd
La abreviatura del nombre del día según la localización (ejem: 'Lun '... 'Dom').
dddd
El nombre completo del día según la localización (ejem: 'Lunes '... 'Domingo').
M
El mes como un número sin ceros a la izquierda (1-12).
MM
El mes como un número a dos dígitos (01-12).
MMM
La abreviatura del nombre del mes según su localización (p. ej: 'Ene'.. 'Dic ').
yy
El año como un número de dos dígitos (00-99).
yyyy
Año a cuatro dígitos (1752-8000).
h
La hora sin ceros a la izquierda (0..23 o 1..12 si se muestra AM/ PM).
hh
La hora a dos dígitos (00..23 o 01..12 si se muestra AM/ PM).
m
Los minutos sin ceros a la izquierda (0..59).
mm
Los minutos a dos dígitos (00..59).
s
Los segundos sin ceros a la izquierda (0..59).
ss
Los segundos a dos dígitos (00..59).
z
Los milisegundos sin ceros a la izquierda (0..999).
zzz
Los milisegundos a tres dígitos (000..999).
AP
Se utiliza para mostrar AM/ PM. AP se reemplazará por « AM » o « PM ».
ap
Se utiliza para mostrar am/ pm. ap se reemplazará por « am » o « pm ».
char identificador
Esta órden le permite insertar caracteres literales por su identificador numérico, en formato decimal, octal o hexadecimal. Para utilizarlo inicie el diálogo de edición de órdenes y teclee char: [número] en la casilla de entrada, después pulse Aceptar.
Ejemplos de char
Entrada: char:234
Salida: #234;
Entrada: char:0x1234
Salida: #x1234;
reemplazo de cadenas al estilo de sed
Búsqueda al estilo de sed
s/ // [ig] %s/ // [ig]
Esta orden ejecuta una operación de búsqueda/ sustitución similar a las de sed en la línea actual o en todo el archivo (%s/ //).
Brevemente, se busca en el texto alguna cadena que coincida con el patrón de búsqueda, la expresión regular entre la primera y la segunda barra, y cuando se encuentra una coincidencia, la parte coincidente del texto es sustituida por la expresión contenida entre las barras central y última de la cadena. Los paréntesis en el patrón de búsquedas crean retroreferencias, es decir, que la orden recuerda qué parte de la coincidencia se encontraba entre los paréntesis; estas cadenas se pueden reutilizar en el patrón de sustitución, refiriendose a ellas como \\1 como el primer conjunto de paréntesis, \\2 como el segundo y así sucesivamente.
Para hacer una búsqueda literal de (o), debe escapar el carácter utilizando una barra inversa: \\(\\)
Si coloca una i al final de la expresión, las coincidencias son sensibles a mayúsculas y minúsculas. Si coloca una g al final, se reemplazarán todas las apariciones del patrón, en cualquier otro caso se reemplazará únicamente la primera aparición.
Sustitución de texto en la línea actual
Su buen amigo el ordenador se ha detenido, diciendo que la clase myClass, mencionada en la línea 3902 del archivo fuente no está definida.
« ¡Vaya por Dios! » pensará usted, es que se trataba de MyClass. Se desplaza a la línea 3902 y en vez de intentar buscar la palabra en el texto, abre el diálogo de la orden de edición, introduce s/ myclass/ MyClass/ i, pulsa el botón Aceptar, guarda el archivo y vuelve a compilar esta vez sin ningún error.
Sustitución de texto en todo el archivo
Imagine que tiene un archivo, en el que menciona a « Señorita Jensen » varias veces, cuando resulta que alguien viene y le dice que se acaba de casar con « Señora Jones ». Usted querrá, desde luego, sustituir cada aparición de « Señorita Jensen » por « Señora Jensen ».
Inicie la línea de órdenes y teclee la orden %s/ Señorita Jones/ Señora Jones/, y una vez que haya pulsado entrar habrá terminado.
Un ejemplo más avanzado
Este ejemplo hace uso de referencias anteriores así como de una clase de caracteres (si no sabe lo que es esto, por favor consulte la documentación citada más adelante).
Suponga que tiene la siguiente línea:
void MyClass: :DoStringOps( String & foo, String & bar String *p, int & a, int & b)
Pero usted se da cuenta de que ese código no está bien, y decide que quiere utilizar la palabra clave const en todos los argumentos « address of », que se caracterizan por tener un operador & delante del nombre del argumento. También desea simplificar el espacio en blanco, de forma que sólo haya uno entre cada palabra.
Abra el diálogo de edición de órdenes, e introduzca: s/ \\s+(\\w+)\\s+(amp; )/ const \\1 \\2/ g, después pulse el botón Aceptar. La g al final de la expresión hace que la expresión regular recompile cada coincidencia para guardar las retroreferencias.
Salida: void MyClass: :DoStringOps( const String & foo, const String & bar String *p, const int & a, const int & b)
Misión completada. Ahora, ¿qué ha ocurrido? Bien, hemos buscado algún espacio en blanco (\\s+) seguido de uno o más caracteres alfabéticos (\\w+) seguidos de más espacio en blanco (\\s+) seguido del símbolo « amp; », y en el proceso hemos guardado el bloque alfabético y el « amp; » para reutilizarlos en la operación de sustitución. Entonces hemos sustituido la parte coincidente de nuestra línea por un espacio en blanco seguido de « const » seguido de un espacio en blanco seguido de nuestro bloque alfabético (\\1) seguido de un espacio en blanco seguido de nuestro « amp; » almacenado (\\2)
En algunos casos el bloque alfabético era « String », en otros « int », así que la clase de caracteres \\w y el cuantificador + nos han servido de gran ayuda.
Opciones para navegar
goto INT línea
Esta orden va a la línea especificada.
find patrón
Esta orden navega hasta la primera aparición del patrón de acuerdo con la configuración. Las siguientes apariciones se pueden encontrar utilizando Editar Buscar siguiente (el acceso rápido predeterminado es F3).
La orden find puede configurarse añadiendo dos puntos seguidos de una o más opciones, el formato es find: opciones patrón. Están soportadas las siguientes opciones:
ifind patrón
Esta orden proporciona búsqueda « como-teclee ». Puede configurar el comportamiento o la búsqueda añadiendo dos puntos seguidos de una o más opciones, de forma similar a: ifind: opciones patrón. Las opciones permitidas son
Buscar mediante expresiones regulares.
Utilizar plegado de código
El plegado de código le permite ocultar partes de un documento en el editor, haciendo sencilla la visión general de los documentos. En & kate; las regiones plegables se calculan utilizando reglas definidas en las definiciones de resaltado de sintaxis, y por tanto solo está disponible en algunos formatos (suelen ser código fuente de programas, tales como XML). La mayor parte de las definiciones de resaltado soportan plegado de código y también le permiten definir manualmente regiones plegables, generalmente utilizando las palabras clave BEGIN y END.
Para utilizar la característica del plegado de código, active los marcadores de plegado, si no están visibles, mediante el elemento de menú Ver Plegado de código. El panel de marcadores de plegado a la izquierda de la pantalla muestra una vista gráfica de las regiones plegables, con los signos +/ - para indicar la posible operación en una región dada: un triángulo invertido indica que la región está expandida, pulsándolo se contraerá la región y se mostrará un triángulo derecho.
Se proporcionan cuatro órdenes para manipular el estado las regiones plegables, vea el la documentación del menú.
Si no desea utilizar el plegado de código, puede desactivar la opción Mostrar marcadores de plegado (si está disponible) en la página de aspecto del editor de configuración.
Extender & kate; mediante scripts
Desde & kate; 3.4 en KDE 4.4, el editor & kate; es fácilmente extensible a base de scripts. El lenguaje usado para ello es ECMAScript (más ampliamente conocido como JavaScript). & kate; soporta dos tipos de scripts: los de sangrado y los de línea de órdenes.
Scripts de sangrado
La cabecera del script de sangrado
& kate; lee todos los pares clave: valor hasta que no encuentra más caracteres dos puntos (':'). Esto permite que la cabecera incluya un texto arbitrario, como la licencia mostrada en el ejemplo.
En la instalación predeterminada de KDE, & kate; se distribuye con muchos sangrados. El código JavaScript correspondiente se puede encontrar en $KDRDIR/ share/ apps/ katepart/ script.
Si desarrolla algún script útil, considere la posiblidad de contribuir con el Proyecto & kate; escribiendo a la lista de correo.
Scripts de línea de órdenes
Cabecera del script de línea de órdenes
La cabecera de cada script de línea de órdenes se incluye en un comentario de la forma siguiente / * kate-script * author: Nombre de ejemplo & lt; nombre. ejemplo@una. direccion. orggt; * license: BSD * revision: 1 * kate-version: 3.4 * type: commands * functions: sort, format-paragraph * * Si una línea no tiene ':' se detiene la lectura de la cabecera, así que puede añadir * un texto opcional, como una licencia. */ A continuación se describe cada entrada:
type [required]: El tipo debe ser commands o & kate; ignorará el script.
functions [required]: Lista de órdenes del script, separadas por comas.
Código fuente del script
API de scripting
Cursores e intervalos
Ya que & kate; es un editor de texto, toda la API de scripting se basa en lo posible en cursores e intervalos. Un Cursor es una tupla (línea, columna) que representa una posición en el texto del documento. Un intervalo (Range) engloba el texto desde una posición inicial de cursor hasta una posición final. En las siguientes secciones se describe en detalle esta API.
El prototipo Cursor
Cursor();
Constructor. Devuelve un Cursor en la posición (0, 0).
Ejemplo: var cursor = new Cursor();
Cursor( int línea, int columna);
Constructor. Devuelve un Cursor en la posición (línea, columna).
Ejemplo: var cursor = new Cursor(3, 42);
Cursor( Cursor otro);
Constructor de copia. Devuelve una copia del cursor otro.
Ejemplo: var copia = new Cursor(otro);
Cursor Cursor. clone();
Devuelve una copia del cursor.
Ejemplo: var clon = cursor. clone();
bool Cursor. isValid();
Ejemplo: var valido = cursor. isValid();
Cursor Cursor. invalid();
Devuelve un nuevo cursor no válido situado en (-1, -1).
Ejemplo: var cursorNoValido = cursor. invalid();
int Cursor. compareTo( Cursor otro);
Compara este cursor con el cursor otro. Devuelve
-1 si este cursor está ubicado antes que el cursor otro,
0 si ambos son iguales y
+1 si este cursor está ubicado después del cursor otro.
bool Cursor. equals( Cursor otro);
String Cursor. toString();
El prototipo Range
Range();
Constructor. La invocación a new Range() devuelve un Range en (0, 0) - (0, 0).
Range( Cursor inicio, Cursor fin);
Constructor. La invocación a new Range( inicio, fin) devuelve el Range (inicio, fin).
Range( int primeraLínea, int primeraColumna, int últimaLínea, int últimaColumna);
Range( Range otro);
Constructor de copia. Devuelve una copia del Range otro.
Range Range. clone();
Devuelve una copia del intervalo.
Ejemplo: var clon = range. clone();
bool Range. isValid();
Ejemplo: var valido = range. isValid();
bool Range. invalid();
Devuelve el Range de (-1, -1) a (-1, -1).
bool Range. contains( Cursor cursor);
Devuelve true (verdadero) si el intervalo contiene la posición del cursor, si no, devuelve false (falso).
bool Range. contains( Range otro);
bool Range. containsColumn( int columna);
bool Range. containsLine( int línea);
bool Range. overlaps( Range otro);
bool Range. overlapsLine( int línea);
bool Range. overlapsColumn( int columna);
bool Range. equals( Range otro);
String Range. toString();
Funciones globales
void debug( String texto);
Imprime el texto a stdout en la consola desde la que se lanzó la aplicación.
Cursor view. cursorPosition()
Devuelve la posición actual del cursor en la vista.
void view. setCursorPosition( int línea, int columna) void view. setCursorPosition( Cursor cursor)
void view. setCursorPosition( int línea, int columna); void view. setCursorPosition( Cursor cursor);
Cursor view. virtualCursorPosition();
void view. setVirtualCursorPosition( int línea, int columna); void view. setVirtualCursorPosition( Cursor cursor);
String view. selectedText();
Devuelve el texto seleccionado o, si no se ha seleccionado ninguno, la cadena vacía.
bool view. hasSelection();
Devuelve true (verdadero) si la vista tiene texto seleccionado, si no, devuelve false (falso).
Range view. selection();
void view. setSelection( Range intervalo);
void view. removeSelectedText();
Elimina el texto seleccionado. Si la vista no tiene una selección, no hace nada.
void view. selectAll();
Selecciona todo el texto del documento.
void view. clearSelection();
Limpia la selección de texto sin eliminar este último.
String document. fileName();
String document. url();
String document. mimeType();
String document. encoding();
Devuelve la codificación actual en la que se guardó el archivo.
bool document. isModified();
Devuelve true (verdadero) si el documento tiene cambios sin guardar, y false (falso) en cualquier otro caso.
String document. text();
String document. line( int línea);
String document. wordAt( int línea, int columna); String document. wordAt( Cursor cursor);
Devuelve la palabra en la posición dada del cursor.
String document. charAt( int línea, int columna); String document. charAt( Cursor cursor);
Devuelve el carácter en la posición dada del cursor.
String document. firstChar( int línea);
String document. lastChar( int línea);
bool document. isSpace( int línea, int columna); bool document. isSpace( Cursor cursor);
bool document. startsWith( int línea, String texto, bool saltarEspacios);
bool document. endsWith( int línea, String texto, bool saltarEspacios);
bool document. setText( String texto);
Establece todo el texto del documento.
bool document. clear();
Elimina todo el texto del documento.
bool document. truncate( int línea, int columna); bool document. truncate( Cursor cursor);
bool document. insertLine( int línea, String texto);
bool document. removeLine( int línea);
void document. joinLines( int primeraLínea, int últimaLínea);
Une las líneas entre primeraLínea y últimaLínea. Dos líneas de texto se separan mediante un espacio.
int document. lines();
Devuelve el número de líneas del documento.
int document. length();
Devuelve el número de caracteres del documento.
int document. lineLength( int línea);
Devuelve la longitud de la línea.
void document. editBegin();
void document. editEnd();
int document. firstColumn( int línea);
int document. lastColumn( int línea);
int document. prevNonSpaceColumn( int línea, int columna); int document. prevNonSpaceColumn( Cursor cursor);
int document. nextNonSpaceColumn( int línea, int columna); int document. nextNonSpaceColumn( Cursor cursor);
int document. prevNonEmptyLine( int línea);
Devuelve la siguiente línea no vacía y que contiene caracteres que no son espacios, buscando hacia atrás.
int document. nextNonEmptyLine( int línea);
Devuelve la siguiente línea no vacía y que contiene caracteres que no son espacios, buscando hacia delante.
bool document. isInWord( String carácter, int atributo);
Devuelve true, si el carácter dado con el atributo también dado puede ser parte de una palabra, o false en caso contrario.
bool document. canBreakAt( String carácter, int atributo);
Devuelve true (verdadero) si la vista contiene texto seleccionado, en otro caso devuelve false (falso).
document. attribute( línea, columna); [función]
String document. commentMarker( int atributo);
String document. commentStart( int atributo);
String document. commentEnd( int atributo);
int document. attribute( int línea, int columna); int document. attribute( Cursor cursor);
Devuelve el atributo en la posición dada del cursor.
String document. attributeName( int línea, int columna); String document. attributeName( Cursor cursor);
String document. variable( String clave);
int document. firstVirtualColumn( int línea);
int document. lastVirtualColumn( int línea);
int document. toVirtualColumn( int línea, int columna); int document. toVirtualColumn( Cursor cursor);
int document. fromVirtualColumn( int línea, int columnaVirtual); int document. fromVirtualColumn( Cursor cursorVirtual);
Cursor document. anchor( int línea, int columna, Char carácter); Cursor document. anchor( Cursor cursor, Char carácter);
Cursor document. rfind( int línea, int columna, String texto, int atributo = -1); Cursor document. rfind( Cursor cursor, String texto, int atributo = -1);
int document. defStyleNum( int línea, int columna); int document. defStyleNum( Cursor cursor);
Devuelve el estilo por defecto usado en la posición actual del cursor.
bool document. isCode( int línea, int columna); bool document. isCode( Cursor cursor);
bool document. isComment( int línea, int columna); bool document. isComment( Cursor cursor);
bool document. isString( int línea, int columna); bool document. isString( Cursor cursor);
bool document. isRegionMarker( int línea, int columna); bool document. isRegionMarker( Cursor cursor);
bool document. isChar( int línea, int columna); bool document. isChar( Cursor cursor);
bool document. isOthers( int línea, int columna); bool document. isOthers( Cursor cursor);
Scripts en el componente de edición con Javascript
Introducción
Comenzando con la versión 2.5, el componente de edición de & kate; soporta la creación de scripts con ECMA, y también conoce JavaScript.
Los scripts se pueden utilizar únicamente a través de la línea de órdenes. Los requisitos son que el script se sitúen en la carpeta en la que & kate; pueda encontrarlos, junto con un archivo opcional. desktop que define la propiedades relacionadas. La carpeta válida se debe llamar katepart/ scripts y debe estar en las carpetas de datos de & kde;. Puede encontrar las carpetas de datos ejecutando la orden kde4-config --path data Como norma general tendrá disponibles una carpeta de sistema y otra de datos personales. Por supuesto, los scripts la carpeta de datos del sistema estará disponible para todos los usuarios del sistema, mientras que los de la carpeta personal solo estarán disponibles para usted.
Esta característica es experimental y tendrá cambios durante su futuro desarrollo.
Sabemos que muchos de ustedes estarán desilusionados porque no pueden añadir sus propios scripts en el menú o asignarles accesos rápidos. Lo sentimos, pero esperamos que en el futuro sea posible.
Todavía no es posible pasar argumentos a sus scripts. Tenga paciencia, y puede que se añadan en un futuro brillante;)
El API JavaScript de Kate
Aquí se lista el conjunto completo de funciones y propiedades disponibles en los objetos document y view. También puede utilizar todos los objetos estándar como Math, String Regex y así sucesivamente.
Cuando se ejecute un script, el objeto document es el documento actual, y el objeto view es la vista actual.
Por supuesto, los tipos de argumentos no se utilizan en JavaScript, sólo existen para indicar qué tipo de valores esperan las funciones.
parámetros
cadena es la cadena de salida
Hace que las salidas se dirijan a STDERR utilizando kDebug(). Se utiliza un área dedicada para la salida, y comenzará por Kate (KJS Scripts):
El API document
Parámetros
uint línea La línea de la posición para la que se buscará elatributo.
uint columna La columna de la posición para la que se buscará el atributo.
Devuelve el ID numérico del atributo para la posición del documento [línea, columna]. El atributo representa el aspecto visual o estilo del texto, y también puede utilizarse para calcular el resaltado de sintexis para una parte específica del texto, como en los formatos HTML o PHP.
document. canBreakAt( Char c, uint atributo); [función]
c El caracter a comprobar
atributo El atributo en la posción de c.
El valor devuelto indica si está permitido dividir la línea en un caracter c con un atributo atributo. El resultado se decide haciendo preguntando al atributo propietario del resaltado que caractes pueden dividir la línea.
document. canComment( uint atributo_inicio, uint atributo_fin); [función]
atributo_inicio El atributo al inicio del rango que se convertirá en un comentario.
atributo_fin El atributo al final del rango que se se convertirá en un comentario.
El valor devuelto indica si atributo_inicio y atributo_fin pertenecen al mismo sistema resaltado de sintaxis. Si lo son es correcto.
utilizando canComment
if (document. canComment( document. attribute(1,0), document. attribute(5,0))) {/ / 1,0 y 5,0 pertenecen al mismo sistema de resaltado de sintaxis}
atributo El atributo del texto para el que se obtendrá la cadena commentStart.
Devuelve la cadena requerida para iniciar un comentario multilínea para un texto con atributo, o una cadena vacía si el comentario multilínea no está soportado para este texto.
atributo El atributo del texto para el que se ha obtenido la cadena commentMarker
Devuelve la cadena utilizada para marcar el resto de la línea como un comentario para un texto con atributo o una cadena vacía sino están soportados los comentarios de una solo línea.
atributo El atributo del texto para el qeu se obtuvo la cadena commentEnd
Devuelve la cadena requerida al final de un comentario multilínea para un texto con atributo, o una cadena vacía si los comentarios multilínea no están soportados parar este texto.
Inicia un grupo de edición. Todas las acciones realizadas hasta que se llame a editEnd() se agruparán como una acción para deshacer.
Finaliza un grupo de edición.
document. highlightMode; [propiedad: sólo lectura]
El nombre del modo de resaltado del documento, tal como JavaScript o C++. Sino hay modo de resaltado de sintaxis seleccionado para el documento, el valor es None (ninguno). Tenga en cuenta que necesitará utilizar un nombre en inglés en aquellos casos en que difiera del traducido.
document. indentMode; [propiedad: sólo lectura]
El nombre del modo de sangrado del documento, como por ejemplo normal o cstyle. Recuerde que sino hay modo de sangrado seleccionado, el valor será none.
document. indentWidth; [propiedad: sólo lectura]
El ancho de sangrado asignado al documento. Se utiliza si el sangrado con espacios está activado.
document. insertLine( uint línea, string texto); [función]
línea número de línea del documento
texto texto a insertar
Inserta una línea nueva con el texto texto en la línea línea
document. insertText( uint línea, uint columna, string texto); [función]
línea el número de línea
columna la columna
texto el texto que se insertará
Inserta el texto texto en la línea línea y la columna columna.
Devuelve el tamaño del documento en bytes.
document. mixedIndent; [propiedad: sólo lectura]
Un propiedad booleana que indica que el sangrado mezclado está activado para el documento. Si es así, el sangrado está optimizado para contener una mezcla de tabuladores y espacios similares a los utilizados por el editor Emacs.
document. removeLine( uint línea); [función]
línea número de línea
Elimina la línea línea del documento.
document. removeText( uint líneaInicio, uint columnaInicio, uint líneaFin, uint columnaFin); [función]
líneaInicio especifica la línea de inicio
columnaInicio especifica la columna de inicio
líneaFin especifica la línea de fin
columnaFin especifica la columna de fin
Elimina el texto desde la línea líneaInicio y columna columnaFin hasta la línea líneaFin y columna columnaFin.
texto texto del documento
Asigna el contenido del documento completo a text. Asigna el contenido del documento completo a text.
document. spaceIndent; [propiedad: sólo lectura]
Es una propiedad booleana que indica si el sangrado con espacios está activado para el documento. De esta forma los niveles del documento se sangrarán con espacios, en caso contrario se utilizarán los tabuladores.
document. textFull(); [función]
Devuelve el texto del documento completo. Si el texto se ocupa varias líneas el caracter de salto de línea es\.
document. textLine( uint línea); [función]
línea la línea
Devuelve el texto de la línea línea.
Devuelve el texto del rango especificado. Si el rango ocupa varias líneas el caracter de salto de línea es\.
El API de view
Deseleccionar todo el texto.
view. cursorColumn(); [función]
Devuelve la columna del cursor actual (los caracteres TAB se expanden). Devuelve la columna del cursor actual (los caracteres TAB se expanden).
view. cursorColumnReal(); [función]
Devuelve la columna del cursor real actual (los caracteres TAB se cuentan como uno).
view. cursorLine(); [función]
Delecciona todo el texto.
Devuelve el texto seleccionado. Si la selección incluye varias líneas el caracter de salto de línea será\.
view. selectionEndColumn; [propiedad: sólo lectura]
Devuelve la columna final de la selección.
view. selectionEndLine; [propiedad: sólo lectura]
Devuelve el final de la línea de la selección.
view. selectionStartColumn; [propiedad: sólo lectura]
Devuelve la columna de inicio de la selección.
view. selectionStartLine; [propiedad: sólo lectura]
view. setCursorPosition( uint línea, uint columna); [función]
líea Especifica la línea para el cursor.
columna Especifica la columna para el cursor.
Asigna la posición de entrada del cursor en la vista a [línea, columna]. Asigna la posición del cursor de forma visual, esto es el caracter TAB se desplaza anchotabulador dependiendo de la posición dentro de la línea. La posición del cursor se ha hecho visible. Tanto la línea y la columna tienen base cero.
view. setCursorPositionReal( uint línea, uint columna); [función]
Asigna la posición de entrada del cursor a [línea, columna]. Ésto asigna la posición de la cadena, los caracteres TAB se cuentan como 1. La posición del cursor se hace visible. Tanto la línea como la columna tienen base cero.
view. setSelection( uint lineaInicio, uint columnaInicio, uint líneaFin, uint columnaFin); [función]
Asigna una selección desde la línea uint lineaInicio y columna columnaInicio hasta la línea líneaFin y columna columnaFin.
Un script de muestra
Como ejemplo crearemos un pequeño script que cambia a mayúsculas la selección. Lo primero que necesitaremos es comprobar que la selección existe, obtener el texto, cambiar las minúsculas y reemplazarlas con las mayúsculas. Una implementación podría parecerse a esto:
if (view. hasSelection()) {/ / selección para mayúsculas columna = view. selectionStartColumn; linea = view. selectionStartLine; seleccion = view. selection(). toUpperCase(); document. editBegin(); view. removeSelectedText(); document. insertText( linea, columna, seleccion); document. editEnd();}
Para agrupar esta acción y que se revierta con una simple activación de Deshacer deberá encapsular las líneas view. removeSelectedText() y document. insertText() con un document. editBegin() y un document. editEnd().
Un archivo. desktop de muestra
Veamos una archivo de muestra que acompaña al script anterior.
# Ejemplo de un archivo. desktop [Desktop Entry] Encoding=UTF-8 Name=Mayusculas JavaScript Kate Part Comment=Script para convertir a mayúsculas la selección X-Kate-Command=uppercase-selection X-Kate-Help=lt; pgt; Uso: & lt; codegt; uppercase-selectionlt; /codegt; lt; /pgt;
Como puede ver puede definir la codificación, asignar un nombre, un comentario, un texto de ayuda utilizando X-Kate-Help y la línea de órdenes a través de X-Kate-Command. Las entradas nombre, comentario y X-Kate-Help se traducen automáticamente a otros idiomas por parte de los equipos de traducción de KDE, si los archivos se encuentran en el repositorio SVN de KDE.
Juntar todo
& kate; buscará las carpetas de guiones (vea anteriores) para los archivos *. js. Para cada archivo comprueba si existe el correspondiente archivo. desktop, así por ejemplo para mayúsculas. js podría ser mayúsculas. desktop.
Si un archivo. desktop no puede encontrarse el script se registrará en la línea de órdenes de katepart con el nombre de archivo sin la finalización. js, por tanto en nuestro ejemplo podría ser mayusculas. si el nombre de la orden está afinada y no necesita las características extra que proporciona el archivo. desktop, no necesitará ningún archivo. desktop.
Si existe un archivo. desktop katepart leerá el nombre bajo el que el script se registrará desde el. desktop-entry X-Kate-Command, por ejemplo sería X-Kate-Command=uppercase-selection.